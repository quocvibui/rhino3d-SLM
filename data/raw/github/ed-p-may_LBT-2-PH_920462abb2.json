{
  "source_url": "https://github.com/ed-p-may/LBT-2-PH/blob/3c2bbdf0cb26deb92d36b870aeb920cbc31d8da2/scripts/LBT2PH/spaces.py",
  "repo": "ed-p-may/LBT-2-PH",
  "repo_stars": 12,
  "repo_description": "LBT2PH is a free toolkit for creating PHPP energy models from Ladybug Tools v1.0+ definitions.",
  "license": "GPL-3.0",
  "filepath": "scripts/LBT2PH/spaces.py",
  "instruction": "Spaces",
  "code": "import rhinoscriptsyntax as rs\nimport random\nimport ghpythonlib.components as ghc\nimport Grasshopper.Kernel as ghK\nimport Rhino\nfrom System import Object\nfrom ladybug_rhino.fromgeometry import from_face3d\n\n\ntry:  # import the core honeybee dependencies\n    from ladybug_rhino.togeometry import to_face3d\n    from ladybug_rhino.fromgeometry import from_face3d\n    from ladybug_geometry.geometry3d import Point3D, Face3D\nexcept ImportError as e:\n    raise ImportError('\\nFailed to import honeybee:\\n\\t{}'.format(e))\n\nimport LBT2PH\nimport LBT2PH.ventilation\n\nreload(LBT2PH)\nreload(LBT2PH.ventilation)\n\nclass TFA_Surface(Object):\n    ''' Represents an individual TFA Surface floor element '''\n    \n    def __init__(self, _surface=None, _host_room_name=None, \n                _params={}, _sub_surfaces=[]):\n        self._inset = 0.150\n        self._neighbors = None\n        self._area_gross = None\n        self._depth = None\n\n        self.id = random.randint(0,99999)\n        self.surface = _surface\n        self.host_room_name = _host_room_name\n        self.params = _params\n        self.sub_surfaces = _sub_surfaces\n\n    def __eq__(self, other):\n        return self.id == other.id\n\n    @property\n    def inset(self):\n        return self._inset\n\n    @inset.setter\n    def inset(self, _in):\n        try:\n            self._inset = float(_in)\n        except ValueError as e:\n            print(e)\n            print( 'Cannot set inset to {}'.format(_in) )\n\n    @property\n    def non_res_usage(self):\n        return self.get_surface_param('useType', '-')\n\n    @non_res_usage.setter\n    def non_res_usage(self, _val):\n        self.set_surface_param('useType', _val)\n\n    @property\n    def non_res_lighting(self):\n        return self.get_surface_param('lighting', '-')\n    \n    @non_res_lighting.setter\n    def non_res_lighting(self, _val):\n        self.set_surface_param('lighting', _val)\n\n    @property\n    def non_res_motion(self):\n        return self.get_surface_param('motion', '-')\n\n    @non_res_motion.setter\n    def non_res_motion(self, _val):\n        self.set_surface_param('motion', _val)\n\n    @property\n    def tfa_factor(self):\n        try:\n            return float( self.get_surface_param('TFA_Factor', 1) )\n        except Exception as e:\n            print('Error getting the TFA Factor as a number?')\n            print(e)\n\n    @tfa_factor.setter\n    def tfa_factor(self, _val):\n        try:\n            self.set_surface_param('TFA_Factor', float(_val) )\n        except Exception as e:\n            print('Please supply a number for the TFA-Factor on Surface {}'.format(self.space_name) )\n            print('Error setting \"{}\" as the TFA-Factot'.format( _val ) )\n            print(e)\n\n    @property\n    def space_number(self):\n        try:\n            return self.get_surface_param('Room_Number', None)\n        except Exception as e:\n            print('Error getting the Space Number?')\n            print(e)\n\n    @space_number.setter\n    def space_number(self, _val):\n        try:\n            self.set_surface_param('Room_Number', _val )\n        except Exception as e:\n            print('Error setting \"{}\" as the Space-Number on surface \"{}\"?'.format( _val, self.space_name ) )\n            print(e)\n\n    @property\n    def space_name(self):\n        try:\n            return self.get_surface_param('Object Name', None)\n        except Exception as e:\n            print('Error getting the Space Name?')\n            print(e)\n\n    @space_name.setter\n    def space_name(self, _val):\n        try:\n            self.set_surface_param('Object Name', _val )\n        except Exception as e:\n            print('Error setting \"{}\" as the Space-Name on surface \"{}\"?'.format( _val, self.space_name ) )\n            print(e)\n\n    @property\n    def area_tfa(self):\n        return self.area_gross * self.tfa_factor\n\n    @property\n    def area_gross(self):\n        if self._area_gross:\n            return self._area_gross\n        else:\n            # Compute the Gross Area\n            try:\n                return self.surface.GetArea()\n            except Exception as e:\n                print('Error calculating the Gross Area?')\n                print(e)\n                return None\n\n    @area_gross.setter\n    def area_gross(self, _val):\n        try:\n            self._area_gross = float(_val)\n        except Exception as e:\n            print('Error setting \"{}\" as the Gross-Area for surface \"{}\"?'.format( _val, self.space_name ) )\n            print(e)\n\n    @property\n    def surface_perimeter(self):\n        brep_edges = self.surface.Edges\n        brep_edges = [edg.DuplicateCurve() for edg in brep_edges]\n        srfc_perimeter = Rhino.Geometry.Curve.JoinCurves(brep_edges)\n\n        return srfc_perimeter[0]\n\n    @property\n    def neighbors(self):\n        if self._neighbors is None:\n            return set([self.id])\n        else:\n            return self._neighbors\n\n    def set_neighbors(self, _in):\n        self._neighbors = self.neighbors.union(_in)\n\n    def get_vent_flow_rate(self, _type='V_sup'):\n        ''' type = V_sup, V_eta or V_trans '''\n        try:\n            return float(self.params.get(_type, 0.0))\n        except Exception as e:\n            print(e)\n            print('Error getting {} ventilation flow rate?'.format(_type))\n\n    def set_vent_flow_rate(self, _type, _val):\n        if not self.params:\n            self.params = {}\n        \n        if _type not in ['V_sup', 'V_eta', 'V_trans']:\n            print(\"Error setting Vent Flow? Please input flow type:\\n\"\\\n                \"'V_sup', 'V_eta' or 'V_trans'\")\n            return None\n\n        self.params[_type] = float(_val)\n\n    def get_surface_param(self, _key, _default=None):\n        \"\"\" Gets a value from the 'params' dictionary \"\"\"\n        try:\n            return self.params.get(_key, _default)\n        except AttributeError as e:\n            print(e)\n            print('No \"{}\" parameter found in TFA Suface \"{}\" Params dict?'.format(_key, self.space_name))\n            return _default\n\n    def set_surface_param(self, _key, _val):\n        ''' Sets a value in the 'params' dictionary '''\n        try:\n            self.params[_key] = _val\n        except Exception as e:\n            print(e)\n            print('Error setting \"{}\" Parameter on TFA Surface \"{}\"?'.format(_key, _val))\n    \n    @staticmethod\n    def _find_hb_room_floor_surfaces( _hb_room, _ghenv ):\n        '''Looks at a single input Honeybee room, finds the floor surface(s) '''\n\n        floor_surfaces = [srfc for srfc in _hb_room.faces if str(srfc.type) == 'Floor']\n        if not floor_surfaces:\n            msg = 'Could not find any Floor surfacs in HB-Room: \"{}\"?\\n'\\\n            'Check the room surfaces and types to be sure there is at least one Floor.'.format(_hb_room.display_name)\n            _ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Remark, msg)\n\n        return floor_surfaces\n\n    @staticmethod\n    def _inset_floor_surfaces( _floor_surface, _inset_dist, _ghenv ):\n        '''Shrinks/Insets the surface by the specified amount '''\n\n        try:\n            rh_srfc = from_face3d(_floor_surface.geometry)\n        except Exception as e:\n            msg = 'Error. Can not convert floor surface: \"{}\" to Rhino geometry?'.format( _floor_surface )\n            _ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Remark, msg)\n            return None\n\n        if _inset_dist < 0.001:\n            return rh_srfc\n        \n        #-----------------------------------------------------------------------\n        srfcPerim = ghc.JoinCurves( ghc.BrepEdges(rh_srfc)[0], preserve=False )\n        \n        # Get the inset Curve\n        srfcCentroid = Rhino.Geometry.AreaMassProperties.Compute(rh_srfc).Centroid\n        plane = ghc.XYPlane(srfcCentroid)\n        plane = ghc.IsPlanar(rh_srfc, True).plane\n        srfcPerim_Inset_Pos = ghc.OffsetCurve(srfcPerim, _inset_dist, plane, 1)\n        srfcPerim_Inset_Neg = ghc.OffsetCurve(srfcPerim, _inset_dist*-1, srfcCentroid, 1)\n\n        # Choose the right Offset Curve. The one with the smaller area\n        # Check IsPlanar first to avoid ghc.BoundarySurfaces error\n        if srfcPerim_Inset_Pos:\n            if srfcPerim_Inset_Pos.IsPlanar:\n                srfcInset_Pos = ghc.BoundarySurfaces( srfcPerim_Inset_Pos )\n            else:\n                srfcInset_Pos = ghc.BoundarySurfaces( srfcPerim ) # Use the normal perim\n            area_Pos = ghc.Area(srfcInset_Pos).area\n        else: area_Pos = None\n\n        if srfcPerim_Inset_Neg:\n            if srfcPerim_Inset_Neg.IsPlanar():\n                srfcInset_Neg = ghc.BoundarySurfaces( srfcPerim_Inset_Neg )\n            else:\n                srfcInset_Neg = ghc.BoundarySurfaces( srfcPerim ) # Use the normal perim\n            area_neg = ghc.Area(srfcInset_Neg).area\n        else:\n            area_neg = None\n\n        #Guard clause in case any return Nones\n        if not area_Pos: return area_neg\n        if not area_neg: return area_Pos\n\n        #Else, choose the smaller of the two\n        if area_Pos < area_neg:\n            return srfcInset_Pos\n        else:\n            return srfcInset_Neg\n\n    @property\n    def depth(self):\n        '''Used for non-res lighting evaluation. The room depth(m) from the main window wall '''\n        \n        if self._depth:\n            return self._depth\n        \n        worldXplane = ghc.XYPlane( Rhino.Geometry.Point3d(0,0,0) )\n        \n        # Find the 'short' edge and the 'long' egde of the srfc geometry\n        srfcEdges = ghc.DeconstructBrep(self.surface).edges\n        segLengths = ghc.SegmentLengths(srfcEdges).longest_length\n        srfcEdges_sorted = ghc.SortList(segLengths, srfcEdges).values_a\n        endPoints = ghc.EndPoints(srfcEdges_sorted[-1])\n        longEdgeVector = ghc.Vector2Pt(endPoints.start, endPoints.end, False).vector\n        shortEdgeVector = ghc.Rotate(longEdgeVector, ghc.Radians(90), worldXplane).geometry\n        \n        # Use the edges to find the orientation and dimensions of the room\n        srfcAligedPlane = ghc.ConstructPlane(ghc.Area(self.surface).centroid, longEdgeVector, shortEdgeVector)\n        srfcAlignedWorld = ghc.Orient(self.surface, srfcAligedPlane, worldXplane).geometry\n        dims = ghc.BoxProperties( srfcAlignedWorld ).diagonal\n        dims = [dims.X, dims.Y]\n        width = min(dims)\n        depth = max(dims)\n        \n        return depth\n\n    @property\n    def dict_key(self):\n        if self.space_name and self.space_number:\n            tfa_dict_key = '{}-{}'.format(self.space_number, self.space_name)\n        else:\n            tfa_dict_key = '{}-NONAME'.format(self.id)\n        \n        return tfa_dict_key\n\n    def to_dict(self):\n        d = {}\n\n        d.update( {'id':self.id} )\n        d.update( {'space_number':self.space_number} )\n        d.update( {'space_name':self.space_name} )\n        d.update( {'host_room_name':self.host_room_name} )\n        d.update( {'params':self.params} )\n        d.update( {'area_gross':self.area_gross} )\n        d.update( {'depth':self.depth} )\n\n        if self.surface:\n            # Remeber, to_face3d returns a LIST of surfaces incase it triangulates\n            # so for now, just getitng the first one in that list to pass along\n            # Someday this'll break everything...\n\n            lbt_surface = to_face3d(self.surface)\n            \n            d.update( {'surface_list': lbt_surface[0].to_dict()  } )\n\n        return d\n\n    @classmethod\n    def from_dict(cls, _dict_tfa, _dict_sub_surfaces):\n        \n        sub_surfaces = []\n        for sub_surface in _dict_sub_surfaces.values():\n            new_sub_surface = cls.from_dict( sub_surface, {} )\n            sub_surfaces.append( new_sub_surface )\n\n        new_tfa_obj = cls()\n        new_tfa_obj.id = _dict_tfa.get('id')        \n        new_tfa_obj.host_room_name = _dict_tfa.get('host_room_name')\n        new_tfa_obj.params = _dict_tfa.get('params')\n        new_tfa_obj.sub_surfaces = sub_surfaces\n        new_tfa_obj._inset = 0.1\n        new_tfa_obj._neighbors = None\n        new_tfa_obj._area_gross = _dict_tfa.get('area_gross')\n        new_tfa_obj._depth = _dict_tfa.get('depth', None)\n\n        srfc_list = _dict_tfa.get('surface_list')\n        if srfc_list:\n            # Remeber, to_face3d returns a LIST of surfaces incase it triangulates\n            # so for now, just getitng the first one in that list to pass along\n            # Someday this'll break everything...\n\n            lbt_surface = Face3D.from_dict( srfc_list )\n            rh_surface = from_face3d( lbt_surface )\n            new_tfa_obj.surface = rh_surface\n\n        return new_tfa_obj\n\n    @classmethod\n    def from_hb_room(cls, _hb_room, _ghenv):\n        '''Creates a LIST of Tfa-Surface objects from a Honeybee Room '''\n        \n        new_objs = []\n        \n        floor_surfaces = cls._find_hb_room_floor_surfaces(_hb_room, _ghenv)\n\n        for srfc in floor_surfaces:\n            new_obj = cls()\n            \n            tfa_surface = new_obj._inset_floor_surfaces( srfc, new_obj.inset, _ghenv )\n            new_obj.tfa_factor = 1.0\n            new_obj.space_number = '0000'\n            new_obj.space_name = _hb_room.display_name\n            new_obj.surface = tfa_surface\n            new_obj.host_room_name = _hb_room.display_name\n\n            new_objs.append( new_obj )\n\n        return new_objs\n\n\n    def __unicode__(self):\n        return u'A PHPP Treated Floor Area (TFA) Object: < {} >'.format(self.id)\n    def __str__(self):\n        return unicode(self).encode('utf-8')\n    def __repr__(self):\n       return \"{}(_surface={!r}, _host_room_name={!r}, \"\\\n               \"params={!r}, _sub_surfaces={!r} )\".format(\n               self.__class__.__name__,\n               self.surface,\n               self.host_room_name,\n               self.params,\n               self.sub_surfaces)\n\n\nclass Volume:\n    ''' Represents an individual volume / part of a larger Space '''\n\n    def __init__(self, _tfa_surface=None, _space_geometry=None, _space_height=2.5):\n        self.id = random.randint(0,99999)\n        self.tfa_surface = _tfa_surface\n        self._space_geom = _space_geometry\n        self._space_height = _space_height\n        self._space_vn50 = None\n        self._offset_z = 0\n        self._phpp_vent_flow_rates = {'V_sup':0, 'V_eta':0, 'V_trans':0}\n\n    @property\n    def non_res_usage(self):\n        return self.tfa_surface.non_res_usage\n    \n    @property\n    def non_res_lighting(self):\n        return self.tfa_surface.non_res_lighting\n    \n    @property\n    def non_res_motion(self):\n        return self.tfa_surface.non_res_motion\n\n    @property\n    def dict_key(self):\n        return '{}-{}'.format(self.volume_number, self.volume_name)\n    \n    @property\n    def host_room_name(self):\n        return self.tfa_surface.host_room_name\n\n    @property\n    def volume_name(self):\n        return self.tfa_surface.space_name\n    \n    @property\n    def volume_number(self):\n        return self.tfa_surface.space_number\n\n    @property\n    def volume_height(self):\n        try:\n            # Try and get the height from the input geometry\n            z_positions = []\n            vol_brep = self.volume_brep\n            for brep in vol_brep:\n                vert_list = brep.Vertices\n                for vert in vert_list.Item:\n                    z_positions.append( vert.Location.Z )\n\n            highest =  max(z_positions)\n            lowest = min(z_positions)\n            vertical_distance = abs(highest - lowest)\n            \n            return float( vertical_distance )\n        except:\n            try:\n                return float(self._space_height)\n            except:\n                return 2.5\n\n    @property\n    def volume_brep(self):\n        try:\n            if self._space_geom:\n                return self._build_volume_brep_from_geom()\n            else:\n                return self._build_volume_brep_from_zone()\n        except Exception as e:\n            return None\n\n    @property\n    def area_tfa(self):\n        return float( self.tfa_surface.area_tfa )\n\n    @property\n    def vn50(self):\n        try:\n            volumes = []\n            breps = self.volume_brep\n            for brep in breps:\n                try:\n                    volumes.append( abs(float( brep.GetVolume() ) ) )\n                except:\n                    volumes.append( 0 )\n            \n            return sum(volumes)\n        except Exception as e:\n            try:\n                return float(self._space_vn50)\n            except:\n                return 5\n\n    @property\n    def depth(self):\n        return self.tfa_surface.depth\n\n    @property\n    def area_gross(self):\n        return self.tfa_surface.area_gross\n\n    def _build_volume_brep_from_geom(self):\n        results = ghc.BrepJoin( [self.tfa_surface.surface, self._space_geom.breps] )\n        #Un-pack the results\n        output = []\n        if results:\n            for brep, closed in zip(results.breps, results.closed):\n                if closed:\n                    output.append( brep )\n\n        return output  \n\n    def _build_volume_brep_from_zone(self):      \n        # Floor Surface\n        floor_surface = rs.coercebrep(self.tfa_surface.surface)\n        floor_surface = ghc.Move(floor_surface, ghc.UnitZ(self._offset_z) )[0]  # 0 is the new translated geometry\n\n        # Extrusion curve\n        surface_centroid = Rhino.Geometry.AreaMassProperties.Compute(floor_surface).Centroid\n        end_point = ghc.ConstructPoint(surface_centroid.X, surface_centroid.Y, surface_centroid.Z + self._space_height)\n        extrusion_curve = rs.AddLine(surface_centroid, end_point)\n\n        volume_brep = rs.ExtrudeSurface(surface=floor_surface, curve=extrusion_curve, cap=True)\n        volume_brep = rs.coercebrep(volume_brep)\n        \n        return [volume_brep]\n\n    def _get_vent_flow_rate(self, _type):\n        try:\n            return float(self.tfa_surface.get_vent_flow_rate(_type))\n        except:\n            return self._phpp_vent_flow_rates[_type]\n\n    def set_phpp_vent_rates(self, _dict):\n        self._phpp_vent_flow_rates = _dict\n        \n        self.tfa_surface.set_vent_flow_rate('V_sup', _dict['V_sup'])\n        self.tfa_surface.set_vent_flow_rate('V_eta', _dict['V_eta'])\n        self.tfa_surface.set_vent_flow_rate('V_trans', _dict['V_trans'])\n\n    def to_dict(self):\n        d = {}\n        d.update( {'id': self.id} )\n        d.update( {'volume_height': self.volume_height})\n        d.update( {'tfa_surface': self.tfa_surface.to_dict() } )\n        d.update( {'_space_vn50': self.vn50 } )\n\n        tfa_sub_surfaces = {}\n        for sub_surface in self.tfa_surface.sub_surfaces:\n            key = '{}_{}'.format(sub_surface.dict_key, str(sub_surface.id) )\n            tfa_sub_surfaces.update( { key:sub_surface.to_dict() } )\n        d.update( {'tfa_sub_surfaces': tfa_sub_surfaces } )\n    \n        vent_rates = {}\n        vent_rates.update( {'V_sup':self._get_vent_flow_rate('V_sup') })\n        vent_rates.update( {'V_eta':self._get_vent_flow_rate('V_eta') })\n        vent_rates.update( {'V_trans':self._get_vent_flow_rate('V_trans') })\n        d.update( {'_phpp_vent_flow_rates':vent_rates} )\n\n        return d\n\n    @classmethod\n    def from_dict(cls, _dict):\n        \n        new_volume = cls()\n        new_volume.tfa_surface = TFA_Surface.from_dict( _dict['tfa_surface'], _dict['tfa_sub_surfaces'] )\n        new_volume._space_geom = None\n        new_volume.volume_height = _dict['volume_height']\n        new_volume.id = _dict['id']\n        new_volume._space_vn50 = _dict['_space_vn50']\n        new_volume._phpp_vent_flow_rates = _dict['_phpp_vent_flow_rates']\n    \n        return new_volume\n\n    def __unicode__(self):\n        return u'A PHPP Space Volume Object: < {} >'.format(self.id)\n    def __str__(self):\n        return unicode(self).encode('utf-8')\n    def __repr__(self):\n       return \"{}(_tfa_surface={!r}, _space_geometry={!r}, \"\\\n               \"_space_height={!r})\".format(\n               self.__class__.__name__,\n               self.tfa_surface,\n               self._space_geom,\n               self._space_height)\n\n\nclass Space:\n    ''' A 'Space' or Room in a Zone. Made up of one or more Volumes/parts '''\n    \n    def __init__(self, _volumes=None, _vent_sched=LBT2PH.ventilation.PHPP_Sys_VentSchedule() ):\n        self.id = random.randint(0,99999)\n        self.volumes = _volumes\n        self.phpp_vent_system_id = 'default'\n        self._phpp_vent_flow_rates = {'V_sup':0, 'V_eta':0, 'V_trans':0}\n        self.vent_sched = _vent_sched\n        self._tfa = None\n    \n    @property\n    def non_res_usage(self):\n        output = [volume.non_res_usage for volume in self.volumes]\n        output = list(set(filter( None, output )))\n\n        if len(output) == 0:\n            print('Error: No Non-Res \"Usage\" found on room {}. Check your TFA surface assignments?'.format(self.space_name))\n            return '-'\n        elif len(output) > 1:\n            print('Error: More than one Non-Res \"Usage\" found on room {}. Check your TFA surface assignments?'.format(self.space_name))\n            return output[0]\n        else:\n            return output[0]\n\n    @property\n    def non_res_lighting(self):\n        output = [volume.non_res_lighting for volume in self.volumes]\n        output = list(set(filter( None, output )))\n\n        if len(output) == 0:\n            print('Error: No Non-Res \"Lighting\" found on room {}. Check your TFA surface assignments?'.format(self.space_name))\n            return '1-'\n        elif len(output) > 1:\n            print('Error: More than one Non-Res \"Lighting\" found on room {}. Check your TFA surface assignments?'.format(self.space_name))\n            return output[0]\n        else:\n            return output[0]\n\n    @property\n    def non_res_motion(self):\n        output = [volume.non_res_motion for volume in self.volumes]\n        output = list(set(filter( None, output )))\n\n        if len(output) == 0:\n            print('Error: No Non-Res \"Motion Detector\" found on room {}. Check your TFA surface assignments?'.format(self.space_name))\n            return '-'\n        elif len(output) > 1:\n            print('Error: More than one Non-Res \"Motion Detector\" found on room {}. Check your TFA surface assignments?'.format(self.space_name))\n            return output[0]\n        else:\n            return output[0]\n\n    @property\n    def space_vent_supply_air(self):\n        vent_rates = []\n        try:\n            for vol in self.volumes:\n                vent_rates.append( vol._get_vent_flow_rate('V_sup') )\n            return max(vent_rates)\n        except:\n            return self._phpp_vent_flow_rates['V_sup']\n        \n    @property\n    def space_vent_extract_air(self):\n        vent_rates = []\n        try:\n            for vol in self.volumes:\n                vent_rates.append( vol._get_vent_flow_rate('V_eta') )           \n            return max(vent_rates)\n        except:\n            return self._phpp_vent_flow_rates['V_eta']\n        \n    @property\n    def space_vent_transfer_air(self):\n        vent_rates = []\n        try:\n            for vol in self.volumes:\n                vent_rates.append( vol._get_vent_flow_rate('V_trans') )\n            return max(vent_rates)\n        except:\n            return self._phpp_vent_flow_rates['V_trans']\n\n    @property\n    def space_breps(self):\n        output = []\n        for volume in self.volumes:\n            volume_brep = volume.volume_brep\n        \n        \n            if volume_brep is None:\n                continue\n\n            if isinstance(volume.volume_brep, list):\n                for brep in volume.volume_brep:\n                    output.append(brep)\n            else:\n                output = volume.volume_brep\n\n        return output\n    \n    @property\n    def space_tfa_surfaces(self):\n        tfa_surface_breps = []\n        for volume in self.volumes:\n            tfa_surface_breps.append( volume.tfa_surface.surface )\n        \n        return tfa_surface_breps\n\n    @property\n    def center_point(self):\n        cps = [ ghc.Area(tfa_srfc).centroid for tfa_srfc in self.space_tfa_surfaces ]\n        cp = ghc.Average(cps)\n              \n        return rs.CreatePoint(*cp)\n\n    @property\n    def host_room_name(self):\n        host_room_names = set()\n        for volume in self.volumes:\n            host_room_names.add(volume.host_room_name)\n\n        if len(host_room_names) != 1:\n            print('Error. Multiple Host Zones found? Fix your room geometry')\n            return list(host_room_names)[0]\n        else:\n            return list(host_room_names)[0]\n\n    @property\n    def space_name(self):\n        space_names = set()\n        for volume in self.volumes:\n            space_names.add(volume.volume_name)\n        \n        if len(space_names) != 1:\n            print('Error. Multiple volume names found? Please fix your room parameters.')\n            return None\n        else:\n            return space_names.pop()\n\n    @property\n    def space_number(self):\n        space_nums= set()\n        for volume in self.volumes:\n            space_nums.add(volume.volume_number)\n        \n        if len(space_nums) != 1:\n            print('Error. Multiple volume numbers found? Please fix your room parameters')\n            return None\n        else:\n            return str(space_nums.pop())\n\n    @property\n    def dict_key(self):\n        return '{}_{}_{}'.format(self.space_number, self.space_name, self.id)\n\n    @property\n    def space_vn50(self):\n        return sum([volume.vn50 for volume in self.volumes])\n\n    @property\n    def space_tfa(self):\n        try:\n            return float(self._tfa)\n        except:\n            return sum(volume.area_tfa for volume in self.volumes)\n\n\n\n    #TODO: fix this.... area weighted....\n    #\n    #\n    #\n    #\n    @property\n    def space_tfa_factor(self):\n        return 1\n    #\n    #\n    #\n    #\n\n\n\n\n\n    @property\n    def depth(self):\n        \"\"\" Returns the largest of the Volume depths \"\"\"\n        \n        depth = [volume.depth for volume in self.volumes]\n        return max(depth)\n\n    @property\n    def area_gross(self):\n        return sum( volume.area_gross for volume in self.volumes )\n\n    @property\n    def space_avg_clear_ceiling_height(self):\n        return sum([volume.volume_height for volume in self.volumes])/len(self.volumes)\n\n    def set_phpp_vent_rates(self, _dict):\n        if 'V_sup' in _dict.keys() and 'V_eta' in _dict.keys() and 'V_trans' in _dict.keys():\n            self._phpp_vent_flow_rates = _dict\n\n        for vol in self.volumes:\n            vol.set_phpp_vent_rates( _dict )\n\n    def to_dict(self):\n\n        d = {}\n        d.update( {'id': self.id} )\n        d.update( {'_tfa':self.space_tfa} )\n        d.update( {'phpp_vent_system_id': self.phpp_vent_system_id} )\n        d.update( {'volumes' : {} } )\n\n        for volume in self.volumes:\n            key = '{}_{}'.format(volume.dict_key, volume.id)\n            d['volumes'].update( { key : volume.to_dict() } )\n        \n        vent_rates = {}\n        vent_rates.update( {'V_sup': self.space_vent_supply_air} )\n        vent_rates.update( {'V_eta': self.space_vent_extract_air} )\n        vent_rates.update( {'V_trans': self.space_vent_transfer_air} )\n        d.update( {'_phpp_vent_flow_rates': vent_rates} )\n        d.update( {'vent_sched': self.vent_sched.to_dict()} )\n\n        return d\n\n    @classmethod\n    def from_dict(cls, _dict):\n\n        dict_volumes = _dict['volumes']\n        volumes = []\n        for volume in dict_volumes.values():\n            new_volume = Volume.from_dict(volume)\n            volumes.append(new_volume)\n\n        new_space =  cls()\n        new_space._tfa = _dict.get('_tfa')\n        new_space.id = _dict.get('id')\n        new_space.phpp_vent_system_id = _dict.get('phpp_vent_system_id')\n        new_space._phpp_vent_flow_rates = _dict.get('_phpp_vent_flow_rates')\n        new_space.volumes = volumes\n        new_space.vent_sched = LBT2PH.ventilation.PHPP_Sys_VentSchedule.from_dict( _dict.get('vent_sched') )\n\n        return new_space\n\n    def __unicode__(self):\n        return u'A PHPP Space Object: < {} > {}-{}'.format(self.id, self.space_number, self.space_name)\n    def __str__(self):\n        return unicode(self).encode('utf-8')\n    def __repr__(self):\n       return \"{}(_volumes={!r}, _vent_sched={!r} )\".format(\n               self.__class__.__name__,\n               self.volumes, self.vent_sched)\n\ndef find_all_tfa_surfaces( _tfa_surfaces, _ghenv, _ghdoc ):\n    input_num = _TFA_surfaces_input_number(_ghenv)\n    \n    rhino_tfa_objects = []\n    for i, tfa_input in enumerate(_tfa_surfaces):\n        rhino_guid = _ghenv.Component.Params.Input[input_num].VolatileData[0][i].ReferenceID\n        rhino_obj = Rhino.RhinoDoc.ActiveDoc.Objects.Find( rhino_guid )\n        \n        if rhino_obj:\n            # Input is a Rhino surface\n            with LBT2PH.helpers.context_rh_doc(_ghdoc):\n                tfa_obj = get_tfa_surface_data_from_Rhino( rhino_guid )\n                rhino_tfa_objects.append( tfa_obj )\n        else:\n            # Input is a Grasshoppper-generated surface\n            geom = rs.coercegeometry( tfa_input )\n            \n            # Give each room a unique number so it won't try and\n            # join them together into a single room later\n            params = {}\n            #params['Object Name'] = 'Unnamed Room' #<--- make this 'turn on-able'\n            #params['Room_Number'] = i\n\n            tfa_obj = ( geom, params )\n            rhino_tfa_objects.append( tfa_obj )\n    \n    return rhino_tfa_objects\n\ndef _TFA_surfaces_input_number(_ghenv):\n    \"\"\"Searches the Component for the right input \"\"\"\n\n    for i, input in enumerate(_ghenv.Component.Params.Input):\n        if '_HB_rooms' == input.Name or '_TFA_surfaces' == input.NickName:\n            return i\n\ndef get_tfa_surface_data_from_Rhino(_guid):  \n   \n    geom = rs.coercegeometry(_guid)\n    nm = rs.ObjectName(_guid)\n\n    params = {}\n    param_keys = rs.GetUserText(_guid)\n    \n    for k in param_keys:\n        params[k] =rs.GetUserText(_guid, k)\n    \n    if 'Object Name' in params.keys():\n        params['Object Name'] = nm\n\n    return (geom, params)\n\ndef find_tfa_host_room(_tfa_srfc_geom, _hb_rooms):\n    \"\"\"Evaluates the Centoid of a TFA srf to see if it is inside an HB-Room \"\"\"\n    \n    srfc_centroid_a = Rhino.Geometry.AreaMassProperties.Compute(_tfa_srfc_geom).Centroid\n    \n    # Note: move the centroid 'up' just a tiny bit, otherwise 'is_point_inside'\n    # test will return False. Must not work if point is 'on' a surface...\n    move_distance = 0.1\n    srfc_centroid_b = Rhino.Geometry.Point3d(srfc_centroid_a.X, srfc_centroid_a.Y, srfc_centroid_a.Z + move_distance)\n\n    # Also, to use 'is_point_inside' need to convert the Point to a Ladybug Point3D\n    srfc_centroid_c = Point3D(srfc_centroid_b.X, srfc_centroid_b.Y, srfc_centroid_b.Z)\n    host_room = None\n    for room in _hb_rooms:\n        \n        if room.geometry.is_point_inside( srfc_centroid_c ):\n            \n            host_room = room.display_name\n            break\n        else:\n            \n            # Incase the Ladybug test doesn't work (seems to fail on some complex geom)\n            # Try doing a test using real Rhino Geometry as well...\n            \n            surfaces = []\n            for face in room.faces:\n                surfaces.append( from_face3d(face.geometry) )\n            \n            joined_breps = ghc.BrepJoin(surfaces).breps\n            if isinstance(joined_breps, list):\n                if ghc.PointInBreps(joined_breps, srfc_centroid_b, True):\n                    host_room = room.display_name\n                    break\n            else:\n                if ghc.PointInBrep(joined_breps, srfc_centroid_b, True):\n                    host_room = room.display_name\n                    break\n\n    return srfc_centroid_b, host_room\n\ndef get_hb_room_floor_surfaces(_room):\n    hb_floor_surfaces = []\n    for face in _room.faces:\n        if str(face.type) == 'Floor':\n            hb_floor_surfaces.append(face)\n\n    return hb_floor_surfaces\n\ndef find_neighbors(_dict_of_TFA_objs):\n    for tfa_a in _dict_of_TFA_objs.values():\n        for tfa_b in _dict_of_TFA_objs.values():\n            if ghc.BrepXBrep(tfa_a.surface, tfa_b.surface).curves:\n                tfa_a.set_neighbors(tfa_b.neighbors)\n                tfa_b.set_neighbors(tfa_a.neighbors)\n\n    return None\n\ndef bin_tfa_srfcs_by_neighbor(_dict_of_tfa_surfaces_by_room_id):\n    \"\"\" I honestly don't remember what this is doing. Gotta write better comments...\n    Args:\n        _dict_of_tfa_surfaces_by_room_id: (dict): Looks like ->\n                {'19-Kitchen': {5775: TFA_Surface...},\n                 '20-Bedroom': {5776: TFA_Surface...},\n                 ...\n                }\n    Returns:\n        srfcSets: (dict) :Looks like -->\n                {\n                    5775: [TFA_Surface, TFA_Surface, ...],\n                    5776: [TFA_Surface],\n                    ...\n                }\n    \"\"\"\n\n    srfcSets = {}\n    for _tfa_srfc_room_id, _tfa_srfc_dict in _dict_of_tfa_surfaces_by_room_id.items():\n        for tfa_id, tfa_surface_obj in _tfa_srfc_dict.items():\n\n            if len(tfa_surface_obj.neighbors) == 1:\n                srfcSets[tfa_surface_obj.id] = [ tfa_surface_obj ]\n            \n            else:\n                for id_num in tfa_surface_obj.neighbors:\n                    if id_num in srfcSets.keys():\n                        srfcSets[id_num].append( tfa_surface_obj )\n                        continue\n                else:\n                    srfcSets[tfa_surface_obj.id] = [ tfa_surface_obj ]\n\n    return srfcSets\n\ndef join_touching_tfa_groups(_tfa_surface_groups, _ghenv=None):\n    \"\"\" Do not really rememember how it works....\n\n        Args:\n            _tfa_surface_groups: (?)\n        Returns:\n            tfa_srfcs_joined: (?)\n    \"\"\"\n    \n    tfa_srfcs_joined = []\n    \n    for group in _tfa_surface_groups.values():\n        # if there is only a single element in the group, add it to the list\n        # otherwise, try and join together the elements in the group\n\n        if len(group) == 1:\n            tfa_srfcs_joined.append(group[0])\n        else:\n            # Need to do a weighted Join for the surfaces\n            ventFlowRates_Sup = []\n            ventFlowRates_Eta = []\n            ventFlowRates_Tran = []\n            areas_tfa = []\n            areas_gross = []\n            srfc_exterior_perimeters = []\n            sub_surfaces = []\n            usage = []\n            lighting = []\n            motion = []\n\n            for tfa_srfc in group:\n                #----- Get the ventilation flow rates\n                ventFlowRates_Sup.append( tfa_srfc.get_vent_flow_rate('V_sup') )\n                ventFlowRates_Eta.append( tfa_srfc.get_vent_flow_rate('V_eta') )\n                ventFlowRates_Tran.append( tfa_srfc.get_vent_flow_rate('V_trans') )\n\n                #----- Get the geometric information\n                areas_tfa.append(tfa_srfc.area_tfa)\n                areas_gross.append(tfa_srfc.area_gross)\n                srfc_exterior_perimeters.append(tfa_srfc.surface_perimeter)\n                sub_surfaces.append(tfa_srfc)\n\n                #----- Get the Non-Res params\n                usage.append(tfa_srfc.non_res_usage)\n                lighting.append(tfa_srfc.non_res_lighting)\n                motion.append(tfa_srfc.non_res_motion)\n\n            #----- Try to Build the new TFA surface\n            perim_curve = ghc.RegionUnion(srfc_exterior_perimeters)\n            if not perim_curve:\n                # If the Region Union fails, just return the TFA Surfaces without joining\n                tfa_srfcs_joined.append(group[0])\n                continue\n            \n            unioned_surface = Rhino.Geometry.Brep.CreatePlanarBreps(perim_curve, 0.01)\n            if len(unioned_surface) != 0:\n                unioned_surface = unioned_surface[0]\n            else:\n                break\n\n            host_room_name = group[0].host_room_name\n            params = group[0].params\n            unionedTFAObj = TFA_Surface(unioned_surface, host_room_name, params, sub_surfaces)\n\n            #---- Set the new TFA Surface's param properties\n            unionedTFAObj.area_gross = sum(areas_gross)\n            unionedTFAObj.tfa_factor = sum(areas_tfa) / sum(areas_gross)\n            unionedTFAObj.space_number = group[0].space_number\n            unionedTFAObj.space_name = group[0].space_name\n            unionedTFAObj.set_surface_param('V_sup', max(ventFlowRates_Sup) )\n            unionedTFAObj.set_surface_param('V_eta', max(ventFlowRates_Eta) )\n            unionedTFAObj.set_surface_param('V_trans', max(ventFlowRates_Tran) )\n\n            #---- Set the new TFA Surface's Non-Res params\n            usage = sorted(list(set(filter(None, usage))))\n            lighting = sorted(list(set(filter(None, lighting))))\n            motion = sorted(list(set(filter(None, motion))))\n            \n            unionedTFAObj.non_res_usage = usage[0]\n            unionedTFAObj.non_res_lighting = lighting[0]\n            unionedTFAObj.non_res_motion = motion[0]\n\n            # Give Warnings if needed\n            if len(usage) > 1:\n                msg = 'Warning: Found more than one Non-Res. \"Usage\" type on room \"{}\"?'.format( unionedTFAObj.space_name )\n                _ghenv.Component.AddRuntimeMessage( ghK.GH_RuntimeMessageLevel.Warning, msg )\n            if len(lighting) > 1:\n                msg = 'Warning: Found more than one Non-Res. \"Lighting\" type on room \"{}\"?'.format( unionedTFAObj.space_name )\n                _ghenv.Component.AddRuntimeMessage( ghK.GH_RuntimeMessageLevel.Warning, msg ) \n            if len(motion) > 1:\n                msg = 'Warning: Found more than one Non-Res. \"Motion Detector\" type on room \"{}\"?'.format( unionedTFAObj.space_name )\n                _ghenv.Component.AddRuntimeMessage( ghK.GH_RuntimeMessageLevel.Warning, msg ) \n\n            # Pass back the new Joined TFA surface\n            tfa_srfcs_joined.append(unionedTFAObj)\n\n    return tfa_srfcs_joined\n\ndef display_host_error(_tfa_obj, _ghenv):\n\n    try:\n        tfa_id = _tfa_obj.dict_key\n        msg = \"Couldn't figure out which room/zone the tfa surface '{}' should \"\\\n        \"go in?\\nMake sure the room is completely inside one or another zone.\".format(tfa_id)\n        _ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Warning, msg)\n\n    except:\n        msg = \"Couldn't figure out which room/zone the tfa surface 'Un-Named' should \"\\\n        \"go in?\\nMake sure to set the params for each surface and that they are inside \"\\\n        \"\\none or another zone\"\n        _ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Warning, msg)\n\n    return None\n\ndef get_model_tfa(_model):\n    tfa = 0\n    for room in _model.rooms:\n        for space in room.user_data.get('phpp', {}).get('spaces').values():\n            space_obj = Space.from_dict( space )\n            tfa += space_obj.space_tfa\n    \n    return tfa",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}