{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_BrepFace_retrim.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_BrepFace_retrim.py",
  "instruction": "This script retrims faces. This is often helpful in brep repair.\r\n\r\nSend any questions, comments, or script development service needs to\r\n@spb on the McNeel Forums, https://discourse.mcneel.com/",
  "code": "\"\"\"\r\nThis script retrims faces. This is often helpful in brep repair.\r\n\r\nSend any questions, comments, or script development service needs to\r\n@spb on the McNeel Forums, https://discourse.mcneel.com/\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line number less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n160629-30: Created.\r\n...\r\n200518-28, 0613,15: Refactored.  Simplified main function and removed option to create oppositely trimmed faces.\r\n200618: Added PerFaceColor support for V7.\r\n200619, 0729: Import-related update.\r\n210503: Import-related update.\r\n210630, 250324: Modified an option default value.\r\n\r\n\r\nWhen joined curves are used for splitting, edges traversing the joins will be \r\nmerged where possible.\r\n\r\nDuplicate naked edges.\r\n*Join all curves.  (Also used to order curves in loops.)\r\nif not closed: Feedback and return fail.\r\nif not allow merging of edges:\r\n    Explode (Curve.DuplicateSegments).\r\n    *Only join short curves with contiguous ones.\r\nSplit.\r\nif not all edges are at least min. allowed length:\r\n    Duplicate naked edges.\r\n    *Join only curves >= limit (Curve.JoinCurves(crvs))\r\n    if not closed: Feedback and return fail.\r\n    if not allow merging of edges:\r\n        Explode (Curve.DuplicateSegments).\r\n    Split.\r\n    if not all edges are at least min. allowed length: Feedback and return fail.\r\n\r\nTODO: Finish refactoring and replace some local code with imported modules.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\n\r\nimport xBrepFace\r\nimport xBrepObject\r\n\r\n\r\nclass Opts:\r\n    \r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    riAddOpts = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    def addOptionDouble(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionDouble(\r\n            getObj, englishName=names[key], numberValue=riOpts[key])\r\n\r\n\r\n    def addOptionInteger(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionInteger(\r\n            getObj, englishName=names[key], intValue=riOpts[key])\r\n\r\n    def addOptionList(key, names, listValues, values):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionList(\r\n            getObj,\r\n            englishOptionName=names[key],\r\n            listValues=listValues,\r\n            listCurrentIndex=values[key])\r\n\r\n\r\n    def addOptionToggle(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionToggle(\r\n            getObj, englishName=names[key], toggleValue=riOpts[key])\r\n\r\n\r\n    key = 'bTrimToSegs'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fEdgeLen_Min'; keys.append(key)\r\n    values[key] = 1.8 * sc.doc.ModelAbsoluteTolerance\r\n    names[key] = 'EdgeLengthMinTol'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    riAddOpts[key] = addOptionDouble(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'fSplitTol'; keys.append(key)\r\n    values[key] = sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    riAddOpts[key] = addOptionDouble(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bOutputSplitOnFail'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bOutputTrimmingCrvs'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDotFailures'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iDotFontHt'; keys.append(key)\r\n    values[key] = 33 if Rhino.RhinoApp.ExeVersion >= 6 else 11\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key], True, 3)\r\n    riAddOpts[key] = addOptionInteger(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bExtractNotAdd'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'Action'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Add', 'Extract')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def setValues(cls):\r\n        for key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n\r\n\r\n    @classmethod\r\n    def saveSticky(cls):\r\n        for key in cls.stickyKeys:\r\n            if key in cls.riOpts:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.riOpts[key].CurrentValue\r\n            else:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get single face breps with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select faces to retrim\")\r\n    go.SetCommandPromptDefault(\"All normal breps when none are selected\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Surface\r\n    #go.GeometryAttributeFilter = (\r\n    #        ri.Custom.GeometryAttributeFilter.OpenSurface)\r\n\r\n    go.AcceptNothing(True)\r\n\r\n    go.AlreadySelectedObjectSelect = True\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n\r\n    go.EnableClearObjectsOnEntry(False) # Keep objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False)\r\n    \r\n    go.AcceptNumber(enable=True, acceptZero=True)\r\n    \r\n    bPreselectedObjsChecked = False\r\n\r\n    idxs_Opts = {}\r\n    \r\n    while True:\r\n        for key in Opts.keys: idxs_Opts[key] = None\r\n        key = 'bTrimToSegs'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        key = 'fEdgeLen_Min'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'fSplitTol'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bOutputSplitOnFail'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bOutputTrimmingCrvs'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bDotFailures'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        if Opts.values['bDotFailures']:\r\n            key = 'iDotFontHt'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bExtractNotAdd'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bEcho'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bDebug'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n        \r\n        # Use bPreselectedObjsChecked so that only objects before the\r\n        # first call to go.GetMultiple is considered.\r\n        if not bPreselectedObjsChecked and go.ObjectsWerePreselected:\r\n            bPreselectedObjsChecked = True\r\n            go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n            continue\r\n        \r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Nothing:\r\n            oes = rd.ObjectEnumeratorSettings()\r\n            oes.LockedObjects = False\r\n            oes.ObjectTypeFilter = rd.ObjectType.Brep\r\n            rdBs = list(sc.doc.Objects.GetObjectList(oes))\r\n            go.Dispose()\r\n            if len(rdBs) == 0: return\r\n\r\n            return rdBs\r\n\r\n        # An option was selected or a number was entered.\r\n\r\n        key = 'fEdgeLen_Min'\r\n        if res == ri.GetResult.Number:\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n\r\n        for key in 'fEdgeLen_Min', 'fSplitTol':\r\n            if Opts.riOpts[key].CurrentValue <= 0.0:\r\n                Opts.riOpts[key].CurrentValue = Opts.riOpts[key].InitialValue\r\n\r\n        Opts.setValues()\r\n        Opts.saveSticky()\r\n        go.ClearCommandOptions()\r\n\r\n\r\ndef _getSortedBrepIdsAndFaces(rhObjs):\r\n    \"\"\"\r\n    Parameters:\r\n        list(objrefs and/or rd.BrepObjects)\r\n    Returns:\r\n        list(Brep GUIDs)\r\n        list(lists(integers of Face indices) per brep)\r\n    \"\"\"\r\n\r\n    gBreps_In = []\r\n    idxs_Faces_perBrep = []\r\n\r\n    for rhObj in rhObjs:\r\n\r\n        if isinstance(rhObj, rd.ObjRef):\r\n            objref = rhObj\r\n            gB_In = objref.ObjectId\r\n            rdBrep_In = objref.Object()\r\n            rgBrep_In = rdBrep_In.BrepGeometry\r\n            idx_CompIdx = objref.GeometryComponentIndex.Index\r\n        elif isinstance(rhObj, rd.BrepObject):\r\n            rdBrep_In = rhObj\r\n            gB_In = rdBrep_In.Id\r\n            rgBrep_In = rdBrep_In.BrepGeometry\r\n            idx_CompIdx = None\r\n        else:\r\n            raise Exception(\"{} passed to _getSortedBrepIdsAndFaces. Needs to be Objref or BrepObject.\".format(\r\n                rhObj.GetType().Name))\r\n\r\n        #            if not rgBrep_In.IsValid:\r\n        #                print(\"Brep {} is invalid.  Fix first.\".format(gB_In)\r\n        #                rgBrep_In.Dispose()\r\n        #                continue\r\n\r\n        if idx_CompIdx in (None, -1):\r\n            if gB_In in gBreps_In:\r\n                idxs_Faces_perBrep[gBreps_In.index(gB_In)] = range(rgBrep_In.Faces.Count)\r\n            else:\r\n                gBreps_In.append(gB_In)\r\n                idxs_Faces_perBrep.append(range(rgBrep_In.Faces.Count))\r\n        else:\r\n            rgFace_Brep0 = objref.Face()\r\n            if gB_In in gBreps_In:\r\n                if rgFace_Brep0 in idxs_Faces_perBrep[gBreps_In.index(gB_In)]:\r\n                    continue\r\n                else:\r\n                    idxs_Faces_perBrep[gBreps_In.index(gB_In)].append(rgFace_Brep0.FaceIndex)\r\n            else:\r\n                gBreps_In.append(gB_In)\r\n                idxs_Faces_perBrep.append([rgFace_Brep0.FaceIndex])\r\n\r\n    return gBreps_In, idxs_Faces_perBrep\r\n\r\n\r\ndef processBrepObjects(rhFaces, **kwargs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    bTrimToSegs = getOpt('bTrimToSegs')\r\n    fEdgeLen_Min = getOpt('fEdgeLen_Min')\r\n    fSplitTol = getOpt('fSplitTol')\r\n    bOutputSplitOnFail = getOpt('bOutputSplitOnFail')\r\n    bOutputTrimmingCrvs = getOpt('bOutputTrimmingCrvs')\r\n    bDotFailures = getOpt('bDotFailures')\r\n    iDotFontHt = getOpt('iDotFontHt')\r\n    bExtractNotAdd = getOpt('bExtractNotAdd')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    def getRhinoObject(rhObj):\r\n        \"\"\"\r\n        'Deleted objects cannot be found by id.'\r\n        (https://developer.rhino3d.com/api/RhinoCommon/html/M_Rhino_DocObjects_Tables_ObjectTable_FindId.htm)\r\n        \"\"\"\r\n        if isinstance(rhObj, rd.RhinoObject):\r\n            return rhObj\r\n        elif isinstance(rhObj, rd.ObjRef):\r\n            return rhObj.Object()\r\n        elif isinstance(rhObj, Guid):\r\n            return sc.doc.Objects.FindId(rhObj) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(rhObj)\r\n\r\n\r\n    def getBrepObject(rhObj):\r\n        rdObj = getRhinoObject(rhObj)\r\n        if rdObj and (rdObj.ObjectType == rd.ObjectType.Brep):\r\n            return rdObj\r\n\r\n\r\n    def dotSrf(rgSrf, text='', iDotHeight=14, rgb=(255, 255, 255)):\r\n    \r\n        rgDot = dotGeometryAtSurfaceCentroid(\r\n                rgSrf=rgSrf,\r\n                text=text,\r\n                iDotHeight=iDotHeight)\r\n        if rgDot is None: return\r\n    \r\n        attr = rd.ObjectAttributes()\r\n        attr.ColorSource = rd.ObjectColorSource.ColorFromObject\r\n        attr.ObjectColor = Color.FromArgb(*rgb)\r\n    \r\n        gDot = sc.doc.Objects.AddTextDot(rgDot, attr)\r\n    \r\n        rgDot.Dispose()\r\n    \r\n        if gDot != Guid.Empty: return rgDot\r\n\r\n\r\n    gBs_In, idxs_F_perB = _getSortedBrepIdsAndFaces(rhFaces)\r\n    if not gBs_In: return\r\n\r\n    idxs_AtTenths = [int(round(0.1*i*len(gBs_In),0)) for i in range(10)]\r\n\r\n    gBs_1F_Success_allBreps = []\r\n\r\n    for iB, gB_In in enumerate(gBs_In):\r\n        if bDebug:\r\n            print('-'*80 + '\\n' + '-'*80)\r\n            print(\"Phase 1\")\r\n        \r\n        if sc.escape_test(False):\r\n            print(\"Searching interrupted by user.\")\r\n            return\r\n        \r\n        if iB in idxs_AtTenths:\r\n            Rhino.RhinoApp.CommandPrompt = \"Processed {:d}% of {} breps ...\".format(\r\n                int(100.0 * (iB+1) / len(gBs_In)), len(gBs_In))\r\n        \r\n        rdBrep_In = getBrepObject(gB_In)\r\n        rgBrep_In = rdBrep_In.Geometry\r\n\r\n        idxFaces_TrimSuccess = []\r\n        rgBs_1F_Pos_thisBrep = []\r\n\r\n        for iF, idxFace in enumerate(idxs_F_perB[iB]):\r\n\r\n            rgFace_In = rgBrep_In.Faces[idxFace]\r\n        \r\n            rgB_1F_Retrimmed = xBrepFace.retrimFace(\r\n                rgFace_In,\r\n                fSplitTol=fSplitTol,\r\n                bTrimToSegs=bTrimToSegs,\r\n                fEdgeLen_Min=fEdgeLen_Min,\r\n                bOutputSplitOnFail=bOutputSplitOnFail,\r\n                bOutputTrimmingCrvs=bOutputTrimmingCrvs,\r\n                bEcho=bEcho,\r\n                bDebug=bDebug,\r\n                )\r\n            if rgB_1F_Retrimmed is None:\r\n                if bDotFailures: dotSrf(rgFace_In, '', (255, 0, 0))\r\n                continue\r\n\r\n            rgBs_1F_Pos_thisBrep.append(rgB_1F_Retrimmed)\r\n\r\n            idxFaces_TrimSuccess.append(idxFace)\r\n\r\n        if not rgBs_1F_Pos_thisBrep:\r\n            continue # to next brep.\r\n\r\n        if bEcho:\r\n            if len(idxFaces_TrimSuccess) != len(idxs_F_perB[iB]):\r\n                print(\"{} faces of {} could not be calculated.\".format(\r\n                    len(idxs_F_perB[iB]) - len(idxFaces_TrimSuccess),\r\n                    gB_In))\r\n\r\n        if bExtractNotAdd:\r\n            rc = xBrepObject.replaceFaces(\r\n                gB_In,\r\n                idxs_rgFaces=idxFaces_TrimSuccess,\r\n                rgBreps_NewGeom=rgBs_1F_Pos_thisBrep,\r\n                bExtract=True)\r\n            gB_Replaced = rc[0]\r\n            if gB_Replaced:\r\n                gBs_1F_Success_allBreps.extend(gB_Replaced)\r\n            else:\r\n                if bDotFailures:\r\n                    dotSrf(rgFace_In, '', (255, 0, 0))\r\n                if bEcho:\r\n                    print(\"Attempt to replace {} has failed.\".format(gB_In))\r\n        else:\r\n            gB = sc.doc.Objects.AddBrep(rgB_1F_Retrimmed)\r\n            if gB == Guid.Empty:\r\n                bScrapAddFail = True\r\n                if bDotFailures:\r\n                    dotSrf(rgFace_In, '', (255, 0, 0))\r\n                if bEcho:\r\n                    print(\"Attempt to add a new monoface brep has failed.\")\r\n            else:\r\n                gBs_1F_Success_allBreps.append(gB)\r\n\r\n\r\n        for rgB in rgBs_1F_Pos_thisBrep: rgB.Dispose()\r\n\r\n    if bEcho:\r\n        if bExtractNotAdd:\r\n            print(\"Replaced {} faces with retrimmed monoface breps.\".format(\r\n                len(set(gBs_1F_Success_allBreps))))\r\n        else:\r\n            print(\"Added {} retrimmed monoface breps.\".format(\r\n                len(gBs_1F_Success_allBreps)))\r\n\r\n    return gBs_1F_Success_allBreps\r\n\r\n\r\ndef main():\r\n    \r\n    rhFaces = getInput()\r\n    if rhFaces is None: return\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(\"Working ...\")\r\n\r\n    rc = processBrepObjects(rhFaces)\r\n\r\n    sc.doc.Views.Redraw()\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "scriptcontext"
  ],
  "has_docstring": true
}