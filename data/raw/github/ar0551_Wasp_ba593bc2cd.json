{
  "source_url": "https://github.com/ar0551/Wasp/blob/66f63c018f2420d37aa451ade0178de260946b0c/src/wasp/core/constraints.py",
  "repo": "ar0551/Wasp",
  "repo_stars": 67,
  "repo_description": "Combinatorial Design with Grasshopper plug-in (LGPL) initiated by Andrea Rossi",
  "license": "LGPL-3.0",
  "filepath": "src/wasp/core/constraints.py",
  "instruction": "(C) 2017-2020 Andrea Rossi <ghwasp@gmail.com>",
  "code": "\"\"\"\n(C) 2017-2020 Andrea Rossi <ghwasp@gmail.com>\n\nThis file is part of Wasp. https://github.com/ar0551/Wasp\n@license GPL-3.0 <https://www.gnu.org/licenses/gpl.html>\n\n@version 0.6.001\n\nConstraints classes\n\"\"\"\n\nfrom Rhino.Geometry.Intersect import Intersection\nfrom Rhino.Geometry import Vector3d, Point3d, Line, Plane, Interval\n\nfrom wasp import global_tolerance\nfrom wasp.utilities import plane_from_data, plane_to_data, mesh_from_data, mesh_to_data\n\nimport math\n\n\n#################################################################### Plane Constraint ####################################################################\nclass Plane_Constraint(object):\n\t\n\t## constructor\n\tdef __init__(self, _plane, _positive = True, _soft = True, _required = True, _parts=[]):\n\t\tself.type = 'plane'\n\t\tself.plane = _plane\n\t\tself.positive = _positive\n\t\tself.soft = _soft\n\t\tself.required = _required\n\t\tself.parts = _parts\n\t\n\n\t## override Rhino .ToString() method (display name of the class in Gh)\n\tdef ToString(self):\n\t\treturn \"WaspPlaneConstraint [+: %s, soft: %s, required: %s]\" % (self.positive, self.soft, self.required)\n\t\n\n\t## create class from data dictionary\n\t@classmethod\n\tdef from_data(cls, data):\n\t\treturn cls(plane_from_data(data['plane']), _positive=data['positive'], _soft=data['soft'], _required=data['required'], _parts=data['parts'])\n\n\t\t\n\t## return the data dictionary representing the constraint\n\tdef to_data(self):\n\t\tdata = {}\n\t\tdata['type'] = self.type\n\t\tdata['plane'] = plane_to_data(self.plane)\n\t\tdata['positive'] = self.positive\n\t\tdata['soft'] = self.soft\n\t\tdata['required'] = self.required\n\t\tdata['parts'] = self.parts\n\t\treturn data\t\n\t\n\t\n\t## constraint check method\n\tdef check(self, pt = None, collider = None, p_name=None):\n\t\t## check if the constraint is part-specific\n\t\tif p_name is not None and len(self.parts) > 0:\n\t\t\t## check if the constraint is assigned to this part\n\t\t\tif p_name in self.parts:\n\t\t\t\tif self.soft:\n\t\t\t\t\treturn self.check_soft(pt)\n\t\t\t\telse:\n\t\t\t\t\treturn self.check_hard(pt, collider)\n\t\t\telse:\n\t\t\t\treturn True\n\t\telse:\n\t\t\tif self.soft:\n\t\t\t\treturn self.check_soft(pt)\n\t\t\telse:\n\t\t\t\treturn self.check_hard(pt, collider)\n\t\n\n\t## hard constraint check method\n\tdef check_hard(self, pt, collider):\n\t\tif self.check_soft(pt):\n\t\t\tfor geo in collider.geometry:\n\t\t\t\tif Intersection.MeshPlane(geo, self.plane) is not None:\n\t\t\t\t\treturn False\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n\t\n\t## soft constraint check method\n\tdef check_soft(self, pt):\n\t\tmapped_pt = self.plane.RemapToPlaneSpace(pt)[1]\n\t\tif self.positive:\n\t\t\tif mapped_pt.Z > 0:\n\t\t\t\treturn True\n\t\telse:\n\t\t\tif mapped_pt.Z < 0:\n\t\t\t\treturn True\n\t\treturn False\n\n\n#################################################################### Mesh Constraint ####################################################################\nclass Mesh_Constraint(object):\n\t\n\t## constructor\n\tdef __init__(self, _geo, _inside = True, _soft = True, _required = True, _parts=[]):\n\t\tself.type = 'mesh_collider'\n\t\tself.geo = _geo\n\t\tself.inside = _inside\n\t\tself.soft = _soft\n\t\tself.required = _required\n\t\tself.parts = _parts\n\t\n\n\t## override Rhino .ToString() method (display name of the class in Gh)\n\tdef ToString(self):\n\t\treturn \"WaspMeshConstraint [in: %s, soft: %s, required: %s]\" % (self.inside, self.soft, self.required)\n\t\n\t## create class from data dictionary\n\t@classmethod\n\tdef from_data(cls, data):\n\t\treturn cls(mesh_from_data(data['geometry']), inside=data['inside'], _soft=data['soft'], _required=data['required'], _parts=data['parts'])\n\n\t\t\n\t## return the data dictionary representing the constraint\n\tdef to_data(self):\n\t\tdata = {}\n\t\tdata['type'] = self.type\n\t\tdata['geometry'] = mesh_to_data(self.geo)\n\t\tdata['inside'] = self.inside\n\t\tdata['soft'] = self.soft\n\t\tdata['required'] = self.required\n\t\tdata['parts'] = self.parts\n\t\treturn data\t\n\n\n\t## constraint check method\n\tdef check(self, pt = None, collider = None, p_name=None):\n\t\t## check if the constraint is part-specific\n\t\tif p_name is not None and len(self.parts) > 0:\n\t\t\t## check if the constraint is assigned to this part\n\t\t\tif p_name in self.parts:\n\t\t\t\tif self.soft:\n\t\t\t\t\treturn self.check_soft(pt)\n\t\t\t\telse:\n\t\t\t\t\treturn self.check_hard(pt, collider)\n\t\t\telse:\n\t\t\t\treturn True\n\t\telse:\n\t\t\tif self.soft:\n\t\t\t\treturn self.check_soft(pt)\n\t\t\telse:\n\t\t\t\treturn self.check_hard(pt, collider)\n\t\n\n\t## hard constraint check method\n\tdef check_hard(self, pt, collider):\n\t\tif self.check_soft(pt):\n\t\t\tfor geo in collider.geometry:\n\t\t\t\tif len(Intersection.MeshMeshFast(self.geo, geo)) > 0:\n\t\t\t\t\treturn False\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n\t\n\t## soft constraint check method\n\tdef check_soft(self, pt):\n\t\tis_inside = self.geo.IsPointInside(pt, global_tolerance, False)\n\t\tif self.inside:\n\t\t\tif is_inside:\n\t\t\t\treturn True\n\t\telse:\n\t\t\tif not is_inside:\n\t\t\t\treturn True\n\t\treturn False\n\n\n#################################################################### Adjacency Constraint ####################################################################\nclass Adjacency_Constraint(object):\n\n\t## constructor\n\tdef __init__(self, _dir, _is_adjacency, _names = []):\n\t\tself.directions = _dir\n\t\tself.is_adjacency = _is_adjacency\n\n\t\tself.names = _names\n\t\tself.name_independent = False\n\t\tif len(self.names) == 0:\n\t\t\tself.name_independent = True\n\t\n\n\t## override Rhino .ToString() method (display name of the class in Gh)\n\tdef ToString(self):\n\t\treturn \"WaspAdjacencyConstraint [size: %s, type: %s]\" % (len(self.directions), \"Adjacency\" if self.is_adjacency else \"Exclusion\")\n\t\n\n\t## create class from data dictionary\n\t@classmethod\n\tdef from_data(cls, data):\n\t\td_directions = []\n\t\tfor d_data in data['directions']:\n\t\t\td = Line(d_data['start'][0], d_data['start'][1], d_data['start'][2], d_data['end'][0], d_data['end'][1], d_data['end'][2])\n\t\t\td_directions.append(d)\n\t\treturn cls(d_directions, data['is_adjacency'], _names=data['names'])\n\n\t\t\n\t## return the data dictionary representing the constraint\n\tdef to_data(self):\n\t\tdata = {}\n\t\tdata['directions'] = []\n\t\tfor d in self.directions:\n\t\t\td_data = {}\n\t\t\td_data['start'] = [d.FromX, d.FromY, d.FromZ]\n\t\t\td_data['end'] = [d.ToX, d.ToY, d.ToZ]\n\t\t\tdata['directions'].append(d_data)\n\t\tdata['is_adjacency'] = self.is_adjacency\n\t\tdata['names'] = self.names\n\t\treturn data\n\t\n\n\t## return a transformed copy of the support\n\tdef transform(self, trans):\n\t\tdirections_trans = []\n\t\tfor d in self.directions:\n\t\t\td = d.ToNurbsCurve()\n\t\t\tstart_trans = d.PointAtStart\n\t\t\tend_trans = d.PointAtEnd\n\t\t\tstart_trans.Transform(trans)\n\t\t\tend_trans.Transform(trans)\n\t\t\td_trans = Line(start_trans, end_trans)\n\t\t\tdirections_trans.append(d_trans)\n\t\tadj_constraint_trans = Adjacency_Constraint(directions_trans, self.is_adjacency, self.names)\n\t\treturn adj_constraint_trans\n\t\n\n\t## return a copy of the support\n\tdef copy(self):\n\t\tdirections_copy = []\n\t\tfor d in self.directions:\n\t\t\td = d.ToNurbsCurve()\n\t\t\tstart_copy = d.PointAtStart\n\t\t\tend_copy = d.PointAtEnd\n\t\t\td_copy = Line(start_copy, end_copy)\n\t\t\tdirections_copy.append(d_copy)\n\t\tadj_constraint_copy = Adjacency_Constraint(directions_copy, self.is_adjacency, self.names)\n\t\treturn adj_constraint_copy\n\t\n\n\t## check against a list of parts\n\tdef check(self, parts, possible_ids):\n\t\t## check adjacencies\n\t\tif self.is_adjacency:\n\t\t\trequired_adjacencies = len(self.directions)\n\t\t\tfor i in range(len(self.directions)):\n\t\t\t\tfor id in possible_ids:\n\t\t\t\t\tif self.name_independent:\n\t\t\t\t\t\tif parts[id].collider.check_intersection_w_line(self.directions[i]):\n\t\t\t\t\t\t\trequired_adjacencies -= 1\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\telse:\n\t\t\t\t\t\tif parts[id].name == self.names[i]:\n\t\t\t\t\t\t\tif parts[id].collider.check_intersection_w_line(self.directions[i]):\n\t\t\t\t\t\t\t\trequired_adjacencies -= 1\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\n\t\t\tif required_adjacencies == 0:\n\t\t\t\treturn True\n\t\t\n\t\t## check exclusions\n\t\telse:\n\t\t\tfor i in range(len(self.directions)):\n\t\t\t\tfor id in possible_ids:\n\t\t\t\t\tif self.name_independent:\n\t\t\t\t\t\tif parts[id].collider.check_intersection_w_line(self.directions[i]):\n\t\t\t\t\t\t\treturn False\n\t\t\t\t\telse:\n\t\t\t\t\t\tif parts[id].name == self.names[i]:\n\t\t\t\t\t\t\tif parts[id].collider.check_intersection_w_line(self.directions[i]):\n\t\t\t\t\t\t\t\treturn False\n\t\t\treturn True\n\n\t\treturn False\n\t\n\n\t## check against a single part (for back-checking exclusions)\n\tdef check_single(self, part):\n\t\t## check adjacencies [NOT NECESSARY]\n\t\tif self.is_adjacency:\n\t\t\trequired_adjacencies = len(self.directions)\n\t\t\tfor i in range(len(self.directions)):\n\t\t\t\tif self.name_independent:\n\t\t\t\t\tif part.collider.check_intersection_w_line(self.directions[i]):\n\t\t\t\t\t\trequired_adjacencies -= 1\n\t\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tif part.name == self.names[i]:\n\t\t\t\t\t\tif part.collider.check_intersection_w_line(self.directions[i]):\n\t\t\t\t\t\t\trequired_adjacencies -= 1\n\t\t\t\t\t\t\tbreak\n\t\t\t\n\t\t\tif required_adjacencies == 0:\n\t\t\t\treturn True\n\t\t\n\t\t## check exclusions\n\t\telse:\n\t\t\tfor i in range(len(self.directions)):\n\t\t\t\tif self.name_independent:\n\t\t\t\t\tif part.collider.check_intersection_w_line(self.directions[i]):\n\t\t\t\t\t\treturn False\n\t\t\t\telse:\n\t\t\t\t\tif part.name == self.names[i]:\n\t\t\t\t\t\tif part.collider.check_intersection_w_line(self.directions[i]):\n\t\t\t\t\t\t\treturn False\n\t\t\treturn True\n\n\t\treturn False\n\n\n\n#################################################################### Adjacency Constraint ####################################################################\nclass Orientation_Constraint(object):\n\n\t## constructor\n\tdef __init__(self, _dir, _plane, _range, _c_dir=None):\n\t\tself.base_dir = _dir\n\t\tself.plane = _plane\n\t\tself.range = _range\n\t\t\n\t\tself.current_dir = None\n\t\tif _c_dir is None:\n\t\t\tself.current_dir = self.base_dir\n\t\telse:\n\t\t\tself.current_dir = _c_dir\n\t\n\n\t## override Rhino .ToString() method (display name of the class in Gh)\n\tdef ToString(self):\n\t\treturn \"WaspOrientationConstraint [dir: %s,%s,%s, range: %s:%s]\" % (self.base_dir.X, self.base_dir.Y, self.base_dir.Z, self.range[0], self.range[1])\n\t\n\n\t## create class from data dictionary\n\t@classmethod\n\tdef from_data(cls, data):\n\t\td_base_dir = Vector3d(data['base_dir'][0], data['base_dir'][1], data['base_dir'][2])\n\t\td_plane = plane_from_data(data['plane'])\n\t\td_range = Interval(data['range'][0], data['range'][1])\n\t\td_current_dir = None\n\t\tif data['current_dir'] is not None:\n\t\t\td_current_dir = Vector3d(data['current_dir'][0], data['current_dir'][1], data['current_dir'][2])\n\t\treturn cls(d_base_dir, d_plane, d_range, _c_dir=d_current_dir)\n\n\t\t\n\t## return the data dictionary representing the constraint\n\tdef to_data(self):\n\t\t#### NOT IMPLEMENTED\n\t\tdata = {}\n\t\tdata['base_dir'] = [self.base_dir.X, self.base_dir.Y, self.base_dir.Z]\n\t\tdata['plane'] = plane_to_data(self.plane)\n\t\tdata['range'] = [self.range.T0, self.range.T1]\n\t\tdata['current_dir'] = None\n\t\tif self.current_dir is not None:\n\t\t\tdata['current_dir'] = [self.current_dir.X, self.current_dir.Y, self.current_dir.Z]\n\t\treturn data\n\n\t\n\t## return a transformed copy of the support\n\tdef transform(self, trans):\n\t\tbase_dir_trans = Vector3d(self.base_dir)\n\t\tpln_trans = Plane(self.plane.Origin, self.plane.XAxis, self.plane.YAxis)\n\t\tpln_trans.Transform(trans)\n\t\tcurrent_dir_trans = Vector3d(self.current_dir)\n\t\tcurrent_dir_trans.Transform(trans)\n\t\torient_constraint_trans = Orientation_Constraint(base_dir_trans, pln_trans, self.range, _c_dir=current_dir_trans)\n\t\treturn orient_constraint_trans\n\t\n\n\t## return a copy of the support\n\tdef copy(self):\n\t\tbase_dir_copy = Vector3d(self.base_dir)\n\t\tpln_copy = Plane(self.plane.Origin, self.plane.XAxis, self.plane.YAxis)\n\t\tcurrent_dir_copy = Vector3d(self.current_dir)\n\t\torient_constraint_copy = Orientation_Constraint(base_dir_copy, pln_copy, self.range, _c_dir=current_dir_copy)\n\t\treturn orient_constraint_copy\n\t\n\n\t## check if orientation is valid\n\tdef check(self):\n\t\tangle = Vector3d.VectorAngle(self.base_dir, self.current_dir, self.plane)\n\t\tangle = math.degrees(min(math.pi*2, max(-math.pi*2, angle)))\n\t\tif angle > 180:\n\t\t\tangle = angle - 360\n\t\tif self.range.IncludesParameter(angle):\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n\n\n#################################################################### Support ####################################################################\nclass Support(object):\n\t\n\t## constructor\n\tdef __init__(self, support_directions):\n\t\tself.sup_dir = support_directions\n\t\n\t## override Rhino .ToString() method (display name of the class in Gh)\n\tdef ToString(self):\n\t\treturn \"WaspSupport [len: %s]\" % (len(self.sup_dir))\n\t\n\t## return the data dictionary representing the support\n\tdef to_data(self):\n\t\tdata = {}\n\t\tdata['directions'] = []\n\t\tfor d in self.sup_dir:\n\t\t\td_data = {}\n\t\t\td = d.ToNurbsCurve()\n\t\t\td_data['start'] = [d.PointAtStart.X, d.PointAtStart.Y, d.PointAtStart.Z]\n\t\t\td_data['end'] = [d.PointAtEnd.X, d.PointAtEnd.Y, d.PointAtEnd.Z]\n\t\t\tdata['directions'].append(d_data)\n\t\treturn data\n\t\n\t## create class from data dictionary\n\t@classmethod\n\tdef from_data(cls, data):\n\t\tsup_directions = []\n\t\tfor d_data in data['directions']:\n\t\t\td = Line(d_data['start'][0], d_data['start'][1], d_data['start'][2], d_data['end'][0], d_data['end'][1], d_data['end'][2])\n\t\t\tsup_directions.append(d)\n\t\treturn cls(sup_directions)\n\n\t## return a transformed copy of the support\n\tdef transform(self, trans):\n\t\tsup_dir_trans = []\n\t\tfor dir in self.sup_dir:\n\t\t\tdir = dir.ToNurbsCurve()\n\t\t\tstart_trans = dir.PointAtStart\n\t\t\tend_trans = dir.PointAtEnd\n\t\t\tstart_trans.Transform(trans)\n\t\t\tend_trans.Transform(trans)\n\t\t\tdir_trans = Line(start_trans, end_trans)\n\t\t\tsup_dir_trans.append(dir_trans)\n\t\tsup_trans = Support(sup_dir_trans)\n\t\treturn sup_trans\n\t\n\t## return a copy of the support\n\tdef copy(self):\n\t\tsup_dir_copy = []\n\t\tfor dir in self.sup_dir:\n\t\t\tdir = dir.ToNurbsCurve()\n\t\t\tstart_copy = dir.PointAtStart\n\t\t\tend_copy = dir.PointAtEnd\n\t\t\tdir_copy = Line(start_copy, end_copy)\n\t\t\tsup_dir_copy.append(dir_copy)\n\t\tsup_copy = Support(sup_dir_copy)\n\t\treturn sup_copy",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}