{
  "source_url": "https://github.com/adapt-ai-team/ADAPT_AI/blob/5de8b42c4f4d4ad35cbd8e79588fc6e869398bc4/spz_analysis2/osm_correct.py",
  "repo": "adapt-ai-team/ADAPT_AI",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "spz_analysis2/osm_correct.py",
  "instruction": "Osm correct",
  "code": "import requests\nimport pyproj\nimport shapely.geometry as sg\nimport trimesh\nimport rhino3dm\nimport numpy as np\nimport os\nfrom flask import Flask, request, jsonify\nimport sys\n\n# ğŸ“‚ File paths\nOSM_GLB_PATH = r\"D:\\spz_pipeline\\pipeline_outputs\\osm_3d_environment.glb\"\nINPUT_GLB_PATH = r\"D:\\spz_pipeline\\pipeline_outputs\\example_image.glb\"\nFIXED_INPUT_GLB_PATH = r\"D:\\spz_pipeline\\pipeline_outputs\\example_image_fixed.glb\"\nOUTPUT_3DM_PATH = r\"D:\\spz_pipeline\\pipeline_outputs\\merged_model.3dm\"\nLATLON_FILE = r\"D:\\spz_pipeline\\pipeline_outputs\\latlon.txt\"\n\n# ğŸ“ Constants\nRADIUS = 500  # Max area in meters for OSM data fetch\n\n# Initialize Flask app\napp = Flask(__name__)\n\n@app.route('/save_latlon', methods=['POST'])\ndef save_latlon():\n    try:\n        data = request.json\n        latitude = data.get(\"latitude\")\n        longitude = data.get(\"longitude\")\n\n        if latitude is None or longitude is None:\n            return jsonify({\"status\": \"error\", \"message\": \"Invalid lat/lon values\"}), 400\n\n        with open(LATLON_FILE, \"w\") as file:\n            file.write(f\"{latitude},{longitude}\")\n        \n        return jsonify({\"status\": \"success\", \"message\": \"Lat/lon saved successfully\"}), 200\n    except Exception as e:\n        return jsonify({\"status\": \"error\", \"message\": str(e)}), 500\n\ndef get_saved_latlon():\n    try:\n        if not os.path.exists(LATLON_FILE):\n            print(f\"âš ï¸ Warning: Lat/lon file not found at {LATLON_FILE}\")\n            return None, None\n        with open(LATLON_FILE, \"r\") as file:\n            latlon = file.read().strip()\n            if \",\" not in latlon:\n                print(f\"âš ï¸ Warning: Invalid format in {LATLON_FILE}. Expected 'lat,lon'\")\n                return None, None\n            lat, lon = map(float, latlon.split(\",\"))\n            print(f\"âœ… Successfully read coordinates from {LATLON_FILE}\")\n            return lat, lon\n    except Exception as e:\n        print(f\"âŒ Error reading lat/lon file: {e}\")\n        return None, None\n\ndef latlon_to_utm(lat, lon):\n    proj = pyproj.Proj(proj=\"utm\", zone=int((lon + 180) / 6) + 1, ellps=\"WGS84\")\n    x, y = proj(lon, lat)\n    return x, y\n\ndef compute_bottom_center(bounds, up_axis=2):\n    \"\"\"\n    Compute the bottom center point of the bounding box based on the up axis.\n    \n    For up_axis = 2 (Z up): returns \n        [ (min_x + max_x)/2, (min_y + max_y)/2, min_z ]\n    \n    For up_axis = 1 (Y up): returns \n        [ (min_x + max_x)/2, min_y, (min_z + max_z)/2 ]\n    \n    For up_axis = 0 (X up, rarely used): returns \n        [ min_x, (min_y + max_y)/2, (min_z + max_z)/2 ]\n    \"\"\"\n    bmin = bounds[0]\n    bmax = bounds[1]\n    pivot = np.empty(3)\n    for i in range(3):\n        if i == up_axis:\n            pivot[i] = bmin[i]\n        else:\n            pivot[i] = (bmin[i] + bmax[i]) / 2\n    return pivot\n\ndef process_example_image(up_axis=2):\n    \"\"\"Process example_image.glb to match OSM model position and scale.\"\"\"\n    scene = trimesh.load(INPUT_GLB_PATH)\n    new_scene = trimesh.Scene()\n\n    # Load OSM model and get its bounds and center\n    osm_scene = trimesh.load(OSM_GLB_PATH)\n    osm_bounds = osm_scene.bounds\n    osm_center = np.mean(osm_bounds, axis=0)\n    osm_lowest_z = osm_bounds[0][2]\n    print(f\"ğŸ“ OSM Model Bounds: {osm_bounds}\")\n    print(f\"ğŸ“ OSM Center Point: {osm_center}\")\n    print(f\"ğŸ“ OSM Lowest Z: {osm_lowest_z}\")\n\n    for mesh_name, geometry in scene.geometry.items():\n        print(f\"Processing mesh: {mesh_name}\")\n\n        # 1. Get original bounds and center\n        bounds = geometry.bounds\n        current_center = np.mean(bounds, axis=0)\n        current_lowest_z = bounds[0][2]\n        print(f\"ğŸ“ Original Bounds: {bounds}\")\n        print(f\"ğŸ“ Original Center: {current_center}\")\n        \n        # 2. Scale by 1000 uniformly from current position\n        scale_factor = 1000\n        \n        # Use bottom center as pivot point\n        pivot_point = np.array([\n            current_center[0],  # X center\n            bounds[0][1],      # Y bottom\n            current_center[2]   # Z center\n        ])\n        \n        # Create scaling transformation\n        to_origin = np.eye(4)\n        to_origin[:3, 3] = -pivot_point\n        \n        scale = np.eye(4)\n        scale[:3, :3] *= scale_factor\n        \n        from_origin = np.eye(4)\n        from_origin[:3, 3] = pivot_point\n        \n        # Apply scaling transformation\n        transform = from_origin @ scale @ to_origin\n        geometry.apply_transform(transform)\n        \n        # 3. Get updated bounds after scaling\n        updated_bounds = geometry.bounds\n        updated_center = np.mean(updated_bounds, axis=0)\n        \n        # 4. Calculate translation to match centers on XZ plane\n        translation = np.array([\n            osm_center[0] - updated_center[0],  # X alignment\n            0,                                  # Keep Y unchanged\n            osm_center[2] - updated_center[2]   # Z alignment\n        ])\n        \n        # 5. Apply translation\n        T_translate = np.eye(4)\n        T_translate[:3, 3] = translation\n        geometry.apply_transform(T_translate)\n        \n        # 6. Verify final position\n        final_bounds = geometry.bounds\n        final_center = np.mean(final_bounds, axis=0)\n        print(f\"ğŸ“ Final Bounds: {final_bounds}\")\n        print(f\"ğŸ“ Final Center: {final_center}\")\n        \n        # Verify center alignment on XZ plane\n        center_difference_xz = np.array([\n            abs(final_center[0] - osm_center[0]),\n            abs(final_center[2] - osm_center[2])\n        ])\n        print(f\"ğŸ“ XZ Center Difference: {center_difference_xz}\")\n        \n        if np.any(center_difference_xz > 0.001):\n            print(f\"âš ï¸ Warning: XZ center alignment offset detected: {center_difference_xz}\")\n\n        new_scene.add_geometry(geometry)\n\n    new_scene.export(FIXED_INPUT_GLB_PATH)\n    print(f\"âœ… Model processed and saved as `{FIXED_INPUT_GLB_PATH}`\")\n    return new_scene\n\n# (The rest of your code remains unchanged)\n\ndef fetch_osm_data(lat, lon, radius):\n    query = f\"\"\"\n    [out:json];\n    (\n        way(around:{radius},{lat},{lon})[building];\n    );\n    out body;\n    >;\n    out skel qt;\n    \"\"\"\n    api_endpoints = [\n        \"https://overpass-api.de/api/interpreter\",\n        \"https://lz4.overpass-api.de/api/interpreter\",\n        \"https://z.overpass-api.de/api/interpreter\",\n        \"https://maps.mail.ru/osm/tools/overpass/api/interpreter\"\n    ]\n    for endpoint in api_endpoints:\n        try:\n            print(f\"ğŸ” Trying to connect to Overpass API at: {endpoint}\")\n            response = requests.get(endpoint, params={\"data\": query}, timeout=30)\n            if response.status_code == 200:\n                print(f\"âœ… Successfully fetched OSM data from {endpoint}\")\n                return response.json()\n            else:\n                print(f\"âš ï¸ API returned status code {response.status_code}\")\n        except requests.exceptions.RequestException as e:\n            print(f\"âš ï¸ Connection error with {endpoint}: {e}\")\n    print(\"âŒ All Overpass API endpoints failed. Trying to load cached data if available...\")\n    cache_file = \"osm_cache.json\"\n    if os.path.exists(cache_file):\n        try:\n            import json\n            with open(cache_file, 'r') as f:\n                print(f\"âœ… Loading OSM data from cache file: {cache_file}\")\n                return json.load(f)\n        except Exception as e:\n            print(f\"âŒ Failed to load cached data: {e}\")\n    return None\n\ndef parse_osm_data(osm_data):\n    buildings = []\n    nodes = {}\n    for element in osm_data[\"elements\"]:\n        if element[\"type\"] == \"node\":\n            x, y = latlon_to_utm(element[\"lat\"], element[\"lon\"])\n            nodes[element[\"id\"]] = (x - REF_X, y - REF_Y)\n    for element in osm_data[\"elements\"]:\n        if element[\"type\"] == \"way\" and \"building\" in element.get(\"tags\", {}):\n            try:\n                height = float(element[\"tags\"].get(\"height\", 10))\n                footprint = []\n                for node_id in element[\"nodes\"]:\n                    if node_id in nodes:\n                        footprint.append(nodes[node_id])\n                if len(footprint) >= 3:\n                    buildings.append({\"footprint\": footprint, \"height\": height})\n            except Exception as e:\n                print(f\"Error processing building: {e}\")\n                continue\n    return buildings\n\ndef create_3d_model(buildings, scale_factor=1.0):\n    scene = trimesh.Scene()\n    for building in buildings:\n        footprint = building[\"footprint\"]\n        height = building[\"height\"]\n        polygon = sg.Polygon(footprint)\n        try:\n            extruded = trimesh.creation.extrude_polygon(polygon, height, engine=\"triangle\")\n        except ValueError:\n            try:\n                extruded = trimesh.creation.extrude_polygon(polygon, height, engine=\"earcut\")\n            except ValueError:\n                continue\n        rot_z = trimesh.transformations.rotation_matrix(-np.pi/2, [0, 0, 1])\n        extruded.apply_transform(rot_z)\n        rot_x = trimesh.transformations.rotation_matrix(-np.pi/2, [1, 0, 0])\n        extruded.apply_transform(rot_x)\n        extruded.apply_scale(scale_factor)\n        print(\"ğŸ”„ Applied coordinate system transformations for web compatibility\")\n        scene.add_geometry(extruded)\n    return scene\n\ndef export_scene_to_3dm(scene, output_path):\n    model = rhino3dm.File3dm()\n    for mesh_name, geometry in scene.geometry.items():\n        if not isinstance(geometry, trimesh.Trimesh):\n            continue\n        rhino_mesh = rhino3dm.Mesh()\n        for v in geometry.vertices:\n            rhino_mesh.Vertices.Add(float(v[0]), float(v[1]), float(v[2]))\n        for face in geometry.faces:\n            if len(face) == 3:\n                rhino_mesh.Faces.AddFace(int(face[0]), int(face[1]), int(face[2]))\n            elif len(face) == 4:\n                rhino_mesh.Faces.AddFace(int(face[0]), int(face[1]), int(face[2]), int(face[3]))\n        rhino_mesh.Normals.ComputeNormals()\n        rhino_mesh.Compact()\n        model.Objects.AddMesh(rhino_mesh)\n    model.Write(output_path, 5)\n    print(f\"âœ… Merged model exported as `{output_path}`\")\n\nif __name__ == \"__main__\":\n    from threading import Thread\n    flask_thread = Thread(target=lambda: app.run(port=5000, debug=False))\n    flask_thread.daemon = True\n    flask_thread.start()\n    \n    if len(sys.argv) == 3:\n        lon, lat = float(sys.argv[1]), float(sys.argv[2])\n        with open(LATLON_FILE, \"w\") as file:\n            file.write(f\"{lat},{lon}\")\n        LAT, LON = lat, lon\n        print(f\"ğŸ“ Using coordinates from command line: {LAT}, {LON}\")\n    else:\n        LAT, LON = get_saved_latlon()\n        if LAT is None or LON is None:\n            print(\"âŒ Could not read coordinates from file. Ensure:\")\n            print(f\"1. File exists at {LATLON_FILE}\")\n            print(\"2. File contains coordinates in format: latitude,longitude\")\n            print(\"3. File has correct permissions\")\n            exit(1)\n    \n    print(f\"ğŸ”¹ Using Lat/Lon: {LAT}, {LON}\")\n    \n    REF_X, REF_Y = latlon_to_utm(LAT, LON)\n    REF_Z = 0\n    print(f\"ğŸ”¹ Reference UTM Coordinates: ({REF_X}, {REF_Y})\")\n    \n    osm_data = fetch_osm_data(LAT, LON, RADIUS)\n    if osm_data:\n        print(f\"ğŸ“ Found {len(osm_data['elements'])} OSM elements\")\n        buildings = parse_osm_data(osm_data)\n        print(f\"ğŸ¢ Parsed {len(buildings)} buildings\")\n        if not buildings:\n            print(\"âš ï¸ No buildings found. Try increasing RADIUS or verifying coordinates.\")\n            exit(1)\n        scene_osm = create_3d_model(buildings, scale_factor=10)\n        if len(scene_osm.geometry) > 0:\n            scene_osm.export(OSM_GLB_PATH)\n            print(\"âœ… OSM model exported\")\n        else:\n            print(\"âŒ No valid geometry created from buildings\")\n            exit(1)\n    else:\n        print(\"âŒ Failed to fetch OSM data\")\n        exit(1)\n    \n    scene_osm = trimesh.load(OSM_GLB_PATH)\n    # Set up_axis=1 if you suspect Y is up; otherwise use up_axis=2.\n    scene_input = process_example_image(up_axis=2)\n    \n    if scene_osm and scene_input:\n        osm_bounds = scene_osm.bounds\n        osm_center = np.mean(osm_bounds, axis=0)\n        print(f\"ğŸ“ Final OSM Center: {osm_center}\")\n        input_bounds = scene_input.bounds\n        input_center = np.mean(input_bounds, axis=0)\n        print(f\"ğŸ“ Final Input Center: {input_center}\")\n        merged_scene = trimesh.Scene()\n        merged_scene.add_geometry(scene_osm)\n        merged_scene.add_geometry(scene_input)\n        export_scene_to_3dm(merged_scene, OUTPUT_3DM_PATH)\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}