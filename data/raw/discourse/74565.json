{
  "source_url": "https://discourse.mcneel.com/t/python-draw-fibonacci-squares-and-spiral/74565",
  "topic_id": 74565,
  "title": "Python draw Fibonacci squares (and spiral)?",
  "question": "Hello,\n\n\nI’m currently trying to come up with a pythonic way in Grasshopper to draw the Fibonacci squares.\n\nMy plan is to feed a Fibonacci sequence (i.e. 0, 1, 1, 3, 4, 7, etc.) into a Python container. For each Fibonacci number in the sequence, the vertices of the square will be produced by starting at an initial point, placing the next point at a given direction x-units (where x is a Fibonacci number) from the start point and changing the direction by 90° to the right. This is going to be repeated 4 times producing 4 vertices that will form a square per Fibonacci number.\n\nThe starting point of the next number will always be the 3 vertex of the previous square, from which a new square will be drawn for the next Fibonacci number in the sequence.\n\n(The circle fragments of each square will produce a Fibonacci spiral.)\n\n\nSo far I’ve come up with this:\n\n\n\ndef draw_square(start_pt, dir, side_length):\n    vtx = []\n    vtx.append(start_pt)\n    rot_dir = dir # rotated direction\n    for i in range(2):\n        # find next point by moving x-units (side_length) in a given direction (dir) \n        vtx.append(next_pt)\n        # rotate the direction by 90° to the right and save it to rot_dir for the next iteration\n    return vtx\n\n\n\nIf the function \ndraw_square\n is called it should return a list of vertices \nvtx\n, representing a square with a side length of \nside_length\n. Its first point is the \nstart_pt\n. Its next points are drawn at a distance \nside_length\n and a direction \ndir\n from their previous points. The direction is than, at each generation, rotated by 90° to the right an so fourth.\n\n\n\nsquares = []\nfor i, num in enumerate(fibonacci_sequence):\n\t\tif i == 0: # first square\n\t\t\t\tstart_pt = (0,0,0)\n\t\t    start_dir = (1, 0, 0)\n        square = draw_square(start_pt, start_dir, num)\n\t\t\t\tsquares.append(square)\n\t\telse: # other squares\n\t\t\t\tstart_pt = squares[-1][2] # 3 vertex of last square\n\t\t    dir = rs.VectorUnitize(rs.VectorCreate(squares[-1][1], start_pt))\n        square = draw_s...",
  "code_blocks": [
    {
      "code": "\"\"\"Pythonic generator of sequential Fibonacci squares and their corresponding nautilus spiral.\n    Inputs:\n        P: start point of the spiral and the sequence of squares \n        L: list of Fibonacci numbers, corresponding to the side length of the squares\n    Output:\n        V: tree with L-branches of 5 3d points, representing the squares vertices\n        C: list of closed, planar polylines representing the squares as cells\n        S: list of arcs, representing the spiral fragment per square\n        F: numbers of the used Fibonacci sequence\"\"\"\n\n__author__ = \"P1r4t3b0y\"\n\nghenv.Component.Name = \"Pythonic Fibonacci Squares And Spiral Generator\"\nghenv.Component.NickName = 'pyFibSpiral'\n\n\nfrom Grasshopper import DataTree as Tree\nfrom Grasshopper.Kernel.Data import GH_Path as Path\nfrom System import Array\nimport rhinoscriptsyntax as rs\nimport math\n\n\ndef list_to_tree(input, none_and_holes=True, source=[0]):\n    \"\"\"Transforms nestings of lists or tuples to a Grasshopper DataTree\"\"\"\n    # written by Giulio Piacentino, giulio@mcneel.com\n    def proc(input,tree,track):\n        path = Path(Array[int](track))\n        if len(input) == 0 and none_and_holes: tree.EnsurePath(path); return\n        for i,item in enumerate(input):\n            if hasattr(item, '__iter__'): #if list or tuple\n                track.append(i); proc(item,tree,track); track.pop()\n            else:\n                if none_and_holes: tree.Insert(item,path,i)\n                elif item is not None: tree.Add(item,path)\n    if input is not None: t=Tree[object]();proc(input,t,source[:]);return t\n\n\ndef tree_to_list(input, retrieve_base = lambda x: x[0]):\n    \"\"\"Returns a list representation of a Grasshopper DataTree\"\"\"\n    # written by Giulio Piacentino, giulio@mcneel.com\n    def extend_at(path, index, simple_input, rest_list):\n        target = path[index]\n        if len(rest_list) <= target: rest_list.extend([None]*(target-len(rest_list)+1))\n        if index == path.Length - 1:\n            rest_list[target] = list(simple_input)\n        else:\n            if rest_list[target] is None: rest_list[target] = []\n            extend_at(path, index+1, simple_input, rest_list[target])\n    all = []\n    for i in range(input.BranchCount):\n        path = input.Path(i)\n        extend_at(path, 0, input.Branch(path), all)\n    return retrieve_base(all)\n\n\ndef squares_sequence_vtx(start_pt, side_lengths, directions):\n    \"\"\"Returns a list of lists with vertices per square.\n    \n    \tKeyword arguments:\n    \t- start_pt     : 3D Point (start point of the spiral and sequence) \n    \t- side_lengths : List of float/integer numbers (fibonacci sequence of numbers)\n    \t- directions   : List of 3D points (directions for the vertices)\"\"\"\n    tmp_next_vtx = 0\n    rot_idx = 0 # rotation index\n    square_vtx = []\n    for s in range(len(side_lengths)): # loops over the Fibonacci sequence\n        vtx = []\n        for v in range(4): # the loop runs 4 times for 4 vtx per square\n            new_vtx = rs.coerce3dpoint(start_pt) + (side_lengths[s] * directions[rot_idx][v])\n            vtx.append(new_vtx)\n            if v == 2:\n                tmp_next_vtx = new_vtx\n            elif v == 3: # append start point as last point for each square\n                new_vtx = rs.coerce3dpoint(start_pt) + (side_lengths[s] * directions[rot_idx][0])\n                vtx.append(new_vtx)\n        start_pt = tmp_next_vtx\n        rot_idx += 1\n        square_vtx.append(vtx)\n        \n        if rot_idx > 3: \n            # resets rotation index for next row of directions\n            rot_idx = 0\n    return square_vtx\n\n\ndef pt_on_circle(center_pt, radius, angle):\n    \"\"\"Returns a 3d point on a circle and its guid.\n\n    \tKeyword arguments:\n    \t- center_pt : 3D Point (origin of the circle) \n    \t- radius    : Float/Integer (radius of the circle)\n    \t- angle     : Float/Integer (angle in degrees)\"\"\"\n    x = center_pt[0] + radius * math.cos(math.radians(angle))\n    y = center_pt[1] + radius * math.sin(math.radians(angle))\n    z = center_pt[2]\n    pt_id = rs.AddPoint((x,y,z))\n    pt = rs.coerce3dpoint(pt_id)\n    return pt, pt_id\n\n\nif __name__ == \"__main__\":\n    # SQUARE SEQUENCE VERTICES GENERATION\n    dirs_lt = [\n        [(0,0,0), (1,0,0), (1,-1,0), (0,-1,0)],\n        [(0,0,0), (0,-1,0), (-1,-1,0), (-1,0,0)],\n        [(0,0,0), (-1,0,0), (-1,1,0), (0,1,0)],\n        [(0,0,0), (0,1,0), (1,1,0), (1,0,0)]]\n\n    # converts the list of coordinates to 3d points\n    dir_pts = []\n    for dt in dirs_lt: \n        dir_pt = []\n        for s in dt:\n            pt_id = rs.AddPoint(s)\n            pt = rs.coerce3dpoint(pt_id)\n            dir_pt.append(pt)\n        dir_pts.append(dir_pt)\n\n    fibo_nums = L[1:] # 0 at the beginning of the Fibonacci number sequence is omitted\n    square_vtx = squares_sequence_vtx(P, fibo_nums, dir_pts)\n\n    # SPIRAL ARCS GENERATION\n    square_crvs = []\n    spiral_arcs = []\n\n    for i, vtx in enumerate(square_vtx):\n        arc_pt1 = vtx[0]\n        arc_pt2 = vtx[2]\n        radius = fibo_nums[i]\n        center_pt = rs.coerce3dpoint(vtx[3])\n        crv = rs.AddPolyline(vtx)\n        arc_pton, arc_pton_id = None, None\n        # evaluates a point on each arc\n        for i in range(4): \n            angle = 45 + (i * 90)\n            test_pt_params = pt_on_circle(center_pt, radius, angle)\n            test = rs.PointInPlanarClosedCurve(test_pt_params[0], crv)\n            if test == 1: # point inside fibonacci box\n                arc_pton, arc_pton_id = test_pt_params\n                arc = rs.AddArc3Pt(arc_pt1, arc_pt2, arc_pton)\n                spiral_arcs.append(arc)\n                break\n        square_crvs.append(crv)\n\n\n    # OUTPUTS\n    V = list_to_tree(square_vtx)\n    C = square_crvs\n    S = spiral_arcs\n    F = fibo_nums",
      "language": "python",
      "author": "diff-arch",
      "post_number": 2,
      "is_solution": true
    },
    {
      "code": "squares = []\nfor i, num in enumerate(fibonacci_sequence):\n\t\tif i == 0: # first square\n\t\t\t\tstart_pt = (0,0,0)\n\t\t    start_dir = (1, 0, 0)\n        square = draw_square(start_pt, start_dir, num)\n\t\t\t\tsquares.append(square)\n\t\telse: # other squares\n\t\t\t\tstart_pt = squares[-1][2] # 3 vertex of last square\n\t\t    dir = rs.VectorUnitize(rs.VectorCreate(squares[-1][1], start_pt))\n        square = draw_square(start_pt, dir, num)\n\t\t\t\tsquares.append(square)",
      "language": "python",
      "author": "diff-arch",
      "post_number": 1,
      "is_solution": false
    }
  ],
  "tags": [
    "file-io",
    "geometry",
    "grasshopper",
    "python",
    "rhinoscriptsyntax",
    "transformation"
  ],
  "has_accepted_answer": true,
  "category_id": 8,
  "posts_count": 6,
  "views": 4625
}