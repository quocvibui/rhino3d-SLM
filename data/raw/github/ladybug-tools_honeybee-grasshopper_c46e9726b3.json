{
  "source_url": "https://github.com/ladybug-tools/honeybee-grasshopper/blob/18fcfdcc61aa01fcf43846b6a5e2f9d3cf820e71/honeybee_plus/plus.py",
  "repo": "ladybug-tools/honeybee-grasshopper",
  "repo_stars": 18,
  "repo_description": ":honeybee: :green_book: Honeybee library and plugin for Grasshopper, also known as honeybee[+]",
  "license": "GPL-3.0",
  "filepath": "honeybee_plus/plus.py",
  "instruction": "Collection of methods for Honeybee geometry operations in Grasshopper.",
  "code": "\"\"\"Collection of methods for Honeybee geometry operations in Grasshopper.\"\"\"\nfrom collections import namedtuple\n\ntry:\n    import Rhino as rc\nexcept ImportError as e:\n    pass\n\n\n# ------------------------- Required functions -----------------------------------------\n#  In order to create a plus library you must overwrite these three methods.\n#  The structure of arguments and returns should stay the same.\n# --------------------------------------------------------------------------------------\n# TODO(someone!): Implement triangulate\ndef extract_geometry_points(geometries, meshing_parameters=None):\n    \"\"\"Calculate list of points for a Grasshopper geometry.\n\n    For planar surfaces the length of the list will be only 1. For non-planar\n    surfaces or surfaces with internal edges it will be a number of lists.\n\n    Args:\n        geometries: List of meshes or Breps\n        meshing_parameters: Optional Rhino meshing_parameters. This will only be used if\n            the surface is non-planar or has an internal edge and needs to be meshed.\n            Default:\n                Rhino.Geometry.meshing_parameters.Coarse; SimplePlanes = True for planar\n                surfaces; Rhino.Geometry.meshing_parameters.Smooth for non-planar\n                surfaces\n    Returns:\n        A Collection of (geometry, points) in which each geometry is coupled by points.\n        For planar surfaces the length of the points list will be only 1. For\n        non-planar surfaces, meshes or surfaces with internal edges it will be multiple\n        lists.\n    \"\"\"\n    if not hasattr(geometries, '__iter__'):\n        geometries = (geometries,)\n\n    for geometry in geometries:\n\n        if isinstance(geometry, rc.Geometry.Mesh):\n            yield extract_mesh_points((geometry,))\n        elif isinstance(geometry, rc.Geometry.Brep):\n            yield extract_brep_points(geometry, meshing_parameters)\n        else:\n            raise TypeError(\n                'Input surface should be a Mesh or a Brep not {}.'.format(type(geometry))\n            )\n\n\ndef xyz_to_geometrical_points(xyz_points):\n    \"\"\"convert a sequence of (x, y, z) values to Grasshopper points.\n\n    Input should be list of lists of points.\n    \"\"\"\n    for xyz_list in xyz_points:\n        for xyz in xyz_list:\n            yield rc.Geometry.Point3d(xyz[0], xyz[1], xyz[2])\n\n\ndef polygon(point_list):\n    \"\"\"Return a polygon from points.\"\"\"\n    return rc.Geometry.Polyline(point_list).ToNurbsCurve()\n\n\n# ------------------------- End of honeybee[+] methods -----------------------------\n# ------------------------------ Utilities -----------------------------------------\ndef is_planar(geometry, tol=1e-3):\n    \"\"\"Check if a surface in planar.\"\"\"\n    return geometry.Faces[0].IsPlanar(tol)\n\n\ndef extract_brep_points(brep, meshing_parameters=None, tol=1e-3):\n    \"\"\"Extract points from Brep.\"\"\"\n    meshing_parameters = meshing_parameters or rc.Geometry.MeshingParameters.Coarse\n    for fid in xrange(brep.Faces.Count):\n        geometry = brep.Faces[fid].DuplicateFace(False)\n        if not brep.Faces[fid].IsPlanar(tol):\n            meshes = rc.Geometry.Mesh.CreateFromBrep(geometry, meshing_parameters)\n            yield next(extract_mesh_points(meshes))\n        else:\n            # planar surface\n            pts = geometry.DuplicateVertices()\n            # sort points anti clockwise\n            # this is only important for energy simulation and won't make a difference\n            # for Radiance\n\n            # To sort the points we find border of the surface and evaluate points\n            # on border and use the parameter value to sort them\n            border = rc.Geometry.Curve.JoinCurves(geometry.DuplicateEdgeCurves(True))\n\n            if len(border) > 1:\n                # mesh the surface\n                meshing_parameters.SimplePlanes = True\n                meshes = rc.Geometry.Mesh.CreateFromBrep(geometry, meshing_parameters)\n                yield next(extract_mesh_points(meshes))\n            else:\n                # In some strange cases Rhino returns a single point for the surface\n                if len(pts) == 1:\n                    pts = (p.Location for p in border[0].Points)\n\n                points_sorted = sorted(pts, key=lambda pt: border[0].ClosestPoint(pt)[1])\n                # make sure points are anti clockwise\n                if not is_points_sorted_anticlockwise(\n                        points_sorted,\n                        get_surface_center_pt_and_normal(geometry).normal_vector):\n                    points_sorted.reverse()\n                # return sorted points\n                # Wrap in a list as Honeybee accepts list of list of points\n                yield geometry, (points_sorted,)\n\n\ndef extract_mesh_points(meshes):\n    \"\"\"Extract points from a mesh.\"\"\"\n    for mesh in meshes:\n        yield mesh, tuple(\n            tuple(mesh.Vertices[face[i]] for i in range(4))\n            if face.IsQuad else\n            tuple(mesh.Vertices[face[i]] for i in range(3))\n            for face in mesh.Faces\n        )\n\n\ndef vectors_cross_product(vector1, vector2):\n    \"\"\"Calculate cross product of two vectors.\"\"\"\n    return vector1.X * vector2.X + \\\n        vector1.Y * vector2.Y + vector1.Z * vector2.Z\n\n\ndef is_points_sorted_anticlockwise(sorted_points, normal):\n    \"\"\"Check if an ordered list of points are anti-clockwise.\"\"\"\n    vector0 = rc.Geometry.Vector3d(sorted_points[1] - sorted_points[0])\n    vector1 = rc.Geometry.Vector3d(sorted_points[-1] - sorted_points[0])\n    pts_normal = rc.Geometry.Vector3d.CrossProduct(vector0, vector1)\n\n    # in case points are anti-clockwise then normals should be parallel\n    if vectors_cross_product(pts_normal, normal) > 0:\n        return True\n    else:\n        return False\n\n\ndef get_surface_center_pt_and_normal(geometry):\n    \"\"\"Calculate center point and normal for a hb_surface.\n\n    Args:\n        hb_surface: A Honeybee surface\n\n    Returns:\n        Returns a tuple as (center_pt, normal_vector)\n    \"\"\"\n    brep_face = geometry.Faces[0]\n    if brep_face.IsPlanar and brep_face.IsSurface:\n        u_domain = brep_face.Domain(0)\n        v_domain = brep_face.Domain(1)\n        center_u = (u_domain.Min + u_domain.Max) / 2\n        center_v = (v_domain.Min + v_domain.Max) / 2\n\n        center_pt = brep_face.PointAt(center_u, center_v)\n        normal_vector = brep_face.NormalAt(center_u, center_v)\n    else:\n        centroid = rc.Geometry.AreaMassProperties.Compute(brep_face).Centroid\n        uv = brep_face.ClosestPoint(centroid)\n        center_pt = brep_face.PointAt(uv[1], uv[2])\n        normal_vector = brep_face.NormalAt(uv[1], uv[2])\n\n    SurfaceData = namedtuple('SurfaceData', 'center_pt normal_vector')\n\n    return SurfaceData(center_pt, normal_vector)\n\n\ndef check_planarity(hb_surface, tolerance=1e-3):\n    \"\"\"Check planarity of a hb_surface.\n\n    Args:\n        hb_surface: A Honeybee surface\n        tolerance: A float number as tolerance (Default: 1e-3)\n\n    Returns:\n        True is the surface is planar, otherwise return False.\n    \"\"\"\n    try:\n        return hb_surface.geometry.Faces[0].is_planar(tolerance)\n    except AttributeError as e:\n        raise TypeError(\"Input is not a hb_surface: %s\" % str(e))\n\n\ndef check_for_internal_edge(hb_surface):\n    \"\"\"Check if the surface has an internal edge.\n\n    For surfaces with internal edge surfaces needs to be meshed to extract the points.\n\n    Args:\n        hb_surface: A Honeybee surface\n\n    Returns:\n        True is the surface has an internal edge, otherwise return False.\n\n    \"\"\"\n    # I believe there should be a direct method in RhinoCommon to indicate if a\n    # surface is an open brep but since I couldn't find it I'm using this method\n    # if Surface has no intenal edges the length of joined border is 1\n    try:\n        edges = hb_surface.geometry.DuplicateEdgeCurves(True)\n    except AttributeError as e:\n        raise TypeError(\"Input is not a hb_surface: %s\" % str(e))\n    else:\n        border = rc.Geometry.Curve.JoinCurves(edges)\n        if len(border) > 1:\n            return True\n        else:\n            return False\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}