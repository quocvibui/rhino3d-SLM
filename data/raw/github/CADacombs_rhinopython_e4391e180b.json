{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Brep_sliverFaces.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Brep_sliverFaces.py",
  "instruction": "160704: Created starting with FindShortEdges.py.\r\n...\r\n191104: Actual edge count, not only over fOverlap_MinAllowed, is now compared with iCt_MaxEdgesOfFace.\r\n191107: Bug fix.\r\n200619, 0701:...",
  "code": "\"\"\"\r\n160704: Created starting with FindShortEdges.py.\r\n...\r\n191104: Actual edge count, not only over fOverlap_MinAllowed, is now compared with iCt_MaxEdgesOfFace.\r\n191107: Bug fix.\r\n200619, 0701: Import-related update.\r\n210209: Again, only edges over a fOverlap_MinAllowed are counted.  Why was this changed on 191104?\r\n210429: Modified an option default value.\r\n210506: Fixed bug in main routine and added more options for quick tolerance value changes.\r\n210519: Now will find faces that have all short non-seam edges.\r\n210526: Trialing another quick select value.\r\n210630: Added progress status of faces processed.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\nfrom System.Collections.Generic import List\r\n\r\nimport xBrepObject\r\n\r\n\r\nclass Opts():\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'fOverlap_MinAllowed'; keys.append(key)\r\n    values[key] = 0.1 * sc.doc.ModelAbsoluteTolerance\r\n    names[key] = 'MinTol'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bAnyEdgeCt'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iCt_MaxEdgesOfFace'; keys.append(key)\r\n    values[key] = 2\r\n    names[key] = 'MaxEdgeCt'\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key], True, 1)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAllOverlapsMustBeSlivers'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bExtract'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        if not idxOpt: print \"Add option for {} failed.\".format(key)\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fOverlap_MinAllowed':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue == 0.0:\r\n                cls.riOpts[key].CurrentValue = Rhino.RhinoMath.ZeroTolerance\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get breps with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select breps\")\r\n    go.SetCommandPromptDefault(\"All normal when none are selected\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Brep\r\n\r\n    go.AcceptNothing(True)\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Do not clear objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False) # Do not unselect object when an option selected, a number is entered, etc.\r\n    \r\n    bPreselectedObjsChecked = False\r\n    \r\n    s  = \"Tolerance = Minimum tolerance of the maximum edge overlap\"\r\n    s += \"  0 of MaxEdgeCount means no limit\"\r\n    s += \"  |  MaxEdgeCount does not include seams.\"\r\n    print s\r\n\r\n    idxs_Opt = {}\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n        addOption('fOverlap_MinAllowed')\r\n        key = 'TenthMT'; idxs_Opt[key] = go.AddOption(key)\r\n        key = 'HalfMT'; idxs_Opt[key] = go.AddOption(key)\r\n        key = 'MT'; idxs_Opt[key] = go.AddOption(key)\r\n        key = 'TwoMT'; idxs_Opt[key] = go.AddOption(key)\r\n        key = 'TenMT'; idxs_Opt[key] = go.AddOption(key)\r\n        addOption('bAnyEdgeCt')\r\n        if not Opts.values['bAnyEdgeCt']:\r\n            addOption('iCt_MaxEdgesOfFace')\r\n        addOption('bAllOverlapsMustBeSlivers')\r\n        addOption('bExtract')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        # Use bPreselectedObjsChecked so that only objects before the\r\n        # first call to go.GetMultiple is considered.\r\n        if not bPreselectedObjsChecked and go.ObjectsWerePreselected:\r\n            bPreselectedObjsChecked = True\r\n            go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n            continue\r\n        \r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return (\r\n                objrefs,\r\n                Opts.values['fOverlap_MinAllowed'],\r\n                None if Opts.values['bAnyEdgeCt'] else Opts.values['iCt_MaxEdgesOfFace'],\r\n                Opts.values['bAllOverlapsMustBeSlivers'],\r\n                Opts.values['bExtract'],\r\n                Opts.values['bEcho'],\r\n                Opts.values['bDebug'],\r\n                )\r\n\r\n        if res == ri.GetResult.Nothing:\r\n            iter = rd.ObjectEnumeratorSettings()\r\n            iter.NormalObjects = True\r\n            iter.LockedObjects = False\r\n            iter.IncludeLights = False\r\n            iter.IncludeGrips = False\r\n            rdBrepObjects = []\r\n            for rdRhinoObject in sc.doc.Objects.GetObjectList(iter):\r\n                if rdRhinoObject.ObjectType == rd.ObjectType.Brep:\r\n                    rdBrepObjects.append(rdRhinoObject)\r\n            go.Dispose()\r\n            return (\r\n                rdBrepObjects,\r\n                Opts.values['fOverlap_MinAllowed'],\r\n                None if Opts.values['bAnyEdgeCt'] else Opts.values['iCt_MaxEdgesOfFace'],\r\n                Opts.values['bAllOverlapsMustBeSlivers'],\r\n                Opts.values['bExtract'],\r\n                Opts.values['bEcho'],\r\n                Opts.values['bDebug'],\r\n                )\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fOverlap_MinAllowed'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        if go.Option().Index == idxs_Opt['TenthMT']:\r\n            key = 'fOverlap_MinAllowed'\r\n            Opts.riOpts[key].CurrentValue = 0.1 * sc.doc.ModelAbsoluteTolerance\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        if go.Option().Index == idxs_Opt['HalfMT']:\r\n            key = 'fOverlap_MinAllowed'\r\n            Opts.riOpts[key].CurrentValue = 0.5 * sc.doc.ModelAbsoluteTolerance\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        if go.Option().Index == idxs_Opt['MT']:\r\n            key = 'fOverlap_MinAllowed'\r\n            Opts.riOpts[key].CurrentValue = sc.doc.ModelAbsoluteTolerance\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        if go.Option().Index == idxs_Opt['TwoMT']:\r\n            key = 'fOverlap_MinAllowed'\r\n            Opts.riOpts[key].CurrentValue = 2.0 * sc.doc.ModelAbsoluteTolerance\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        if go.Option().Index == idxs_Opt['TenMT']:\r\n            key = 'fOverlap_MinAllowed'\r\n            Opts.riOpts[key].CurrentValue = 10.0 * sc.doc.ModelAbsoluteTolerance\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef getFaces(rgBrep, fOverlap_MinAllowed=None, iCt_MaxEdgesOfFace=None, bAllOverlapsMustBeSlivers=True, bEcho=False, bDebug=False):\r\n    \"\"\"\r\n    Search all faces of brep for slivers.\r\n\r\n    Returns:\r\n        sorted(idxs_rgFaces_Pass), nOverlapPairCt, fOverlap_Brep_MaxBelowTol\r\n        Or None on error.\r\n    \"\"\"\r\n\r\n    rgB = rgBrep\r\n\r\n    if fOverlap_MinAllowed == None:\r\n        fOverlap_MinAllowed = sc.doc.ModelAbsoluteTolerance\r\n\r\n\r\n    # Previous sliver-finding routine.\r\n    #    def isFaceSliver(rgFace, fSliverMaximumTolerance=2.0*sc.doc.ModelAbsoluteTolerance, bEcho=True):\r\n    #        \r\n    #        rgBrep_1F = rgFace.DuplicateFace(False)\r\n    #        # Use DuplicateNakedEdgeCurves instead of AdjacentEdges to skip seams.\r\n    #        rgCrvs = rgBrep_1F.DuplicateNakedEdgeCurves(outer=True, inner=True)\r\n    #        rgBrep_1F.Dispose()\r\n    #        \r\n    #        # Reject faces with number of edges exceeding 2.\r\n    #        if len(rgCrvs) != 2:\r\n    #            map(lambda x: x.Dispose(), rgCrvs)\r\n    #            return False\r\n    #        \r\n    #        rc = indexPairsOfOverlappingCurves(rgCrvs, fSliverMaximumTolerance, bAllOverlapsMustBeSlivers=True)\r\n    #        map(lambda x: x.Dispose(), rgCrvs)\r\n    #        \r\n    #        if rc is None or len(rc[0]) == 0: return False\r\n    #        \r\n    #        return True\r\n\r\n\r\n    def indexPairsOfOverlappingCurves(rgCrvs, fOverlap_MinAllowed, bAllOverlapsMustBeSlivers):\r\n\r\n        idx_rgCrvs_OverlapPairs = []\r\n        #fOverlap_Face_Min = None\r\n        fOverlap_Face_MaxBelowTol = None\r\n\r\n        # 180702: Added.\r\n        for rgC in rgCrvs:\r\n            if not rgC.IsValid:\r\n                print \"Warning: Curve is invalid, so this group of curves will be skipped because rg.Curve.GetDistancesBetweenCurves may hang.\"\r\n                return\r\n\r\n        if len(rgCrvs) == 1:\r\n            rgC_In = rgCrvs[0]\r\n            rgCs_CheckLength = [\r\n                rgC_In.Trim(t0=rgC_In.Domain.T0, t1=rgC_In.Domain.Mid),\r\n                rgC_In.Trim(t0=rgC_In.Domain.Mid, t1=rgC_In.Domain.T1)\r\n            ]\r\n            bSingle_crv_was_split = True\r\n        elif len(rgCrvs) >= 2:\r\n            rgCs_CheckLength = rgCrvs\r\n            bSingle_crv_was_split = False\r\n        else:\r\n            raise ValueError(\"Curve set has no curves!\")\r\n\r\n\r\n        rgCs_LongEnough = []\r\n        for rgC in rgCrvs:\r\n            length = rgC.GetLength()\r\n            if length >= fOverlap_MinAllowed:\r\n                rgCs_LongEnough.append(rgC)\r\n\r\n\r\n        iCt_Cs = len(rgCs_LongEnough)\r\n\r\n        for iE_A in xrange(iCt_Cs):\r\n            rgC_A = rgCs_LongEnough[iE_A]\r\n            for iE_B in xrange(iE_A+1, iCt_Cs):\r\n                rgC_B = rgCs_LongEnough[iE_B]\r\n                rc = rg.Curve.GetDistancesBetweenCurves(\r\n                    rgC_A,\r\n                    rgC_B,\r\n                    tolerance=0.1*sc.doc.ModelAbsoluteTolerance)\r\n                if rc[0]:\r\n                    fOverlap_Max = rc[1]\r\n                    fOverlap_Min = rc[4]\r\n                    if fOverlap_Max < fOverlap_MinAllowed:\r\n                        if bSingle_crv_was_split:\r\n                            return (0, 0), fOverlap_Max\r\n\r\n                        idx_rgCrvs_OverlapPairs.append((iE_A, iE_B))\r\n        #                    if fOverlap_Face_Min is None or fOverlap_Min < fOverlap_Face_Min:\r\n        #                        fOverlap_Face_Min = fOverlap_Min\r\n                        if fOverlap_Face_MaxBelowTol is None or fOverlap_Max > fOverlap_Face_MaxBelowTol:\r\n                            fOverlap_Face_MaxBelowTol = fOverlap_Max\r\n                    elif bAllOverlapsMustBeSlivers:\r\n                        # Skip any face with an overlap larger than fOverlap_MinAllowed.\r\n                        return\r\n\r\n        return idx_rgCrvs_OverlapPairs, fOverlap_Face_MaxBelowTol\r\n\r\n\r\n    idxs_rgFaces_Pass = []\r\n    #fOverlap_Min_Brep = None\r\n    fOverlaps_Brep_MaxBelowTol = []\r\n    nOverlapPairCt = 0\r\n\r\n\r\n    iCt_Fs = rgBrep.Faces.Count\r\n\r\n    idxs_AtTenths = [int(round(0.1*i*iCt_Fs,0)) for i in range(10)]\r\n\r\n    sCmdPrompt0 = Rhino.RhinoApp.CommandPrompt\r\n\r\n\r\n    for idxF in xrange(rgB.Faces.Count):\r\n        \r\n        # 180702: Commented out.\r\n    #        rgBrep_1F = rgFace.DuplicateFace(False)\r\n    #        # Use DuplicateNakedEdgeCurves instead of AdjacentEdges to skip seams.\r\n    #        rgCrvs = rgBrep_1F.DuplicateNakedEdgeCurves(outer=True, inner=True)\r\n    #        rgBrep_1F.Dispose()\r\n\r\n        if iCt_Fs == 1:\r\n            pass\r\n        elif iCt_Fs < 100:\r\n            Rhino.RhinoApp.SetCommandPrompt(\r\n                sCmdPrompt0 +\r\n                \"  Analyzing {} of {} faces\".format(\r\n                    idxF+1, iCt_Fs))\r\n        elif idxF in idxs_AtTenths:\r\n            Rhino.RhinoApp.SetCommandPrompt(\r\n                sCmdPrompt0 +\r\n                \"  Analysis at {:d}% of {} faces ...\".format(\r\n                    int(100.0 * (idxF+1) / iCt_Fs), iCt_Fs))\r\n\r\n\r\n        rgF = rgB.Faces[idxF]\r\n\r\n        rgCrvs = []\r\n        edges_face = rgF.AdjacentEdges()\r\n\r\n        for idx_rgEdge in edges_face:\r\n            rgEdge = rgB.Edges[idx_rgEdge]\r\n\r\n            # Skip short edges.\r\n            if len(edges_face) > 2:\r\n                fLengthEdge = rgEdge.GetLength()\r\n                if fLengthEdge < fOverlap_MinAllowed:\r\n                    continue\r\n\r\n            # Skip seams.\r\n            if rgEdge.Valence == rg.EdgeAdjacency.Interior:\r\n                rgFaces_Adj = rgEdge.AdjacentFaces()\r\n                if rgFaces_Adj[0] == rgFaces_Adj[1]:\r\n                    continue\r\n\r\n            rgCrvs.append(rgEdge)\r\n\r\n        # Skip faces with number of edges exceeding iCt_MaxEdgesOfFace.\r\n        if iCt_MaxEdgesOfFace and len(rgCrvs) > iCt_MaxEdgesOfFace:\r\n            continue\r\n        \r\n        if len(rgCrvs) == 0:\r\n            # All short non-seam edges?\r\n            idxs_rgFaces_Pass.append(rgF.FaceIndex)\r\n            continue\r\n\r\n        rc = indexPairsOfOverlappingCurves(rgCrvs, fOverlap_MinAllowed, bAllOverlapsMustBeSlivers)\r\n        if rc is None or len(rc[0]) == 0:\r\n            continue\r\n\r\n        idx_rgCrvs_OverlapPairs, fOverlap_Face_MaxBelowTol = rc\r\n        \r\n        idxs_rgFaces_Pass.append(rgF.FaceIndex)\r\n        \r\n        nOverlapPairCt += len(idx_rgCrvs_OverlapPairs)\r\n        \r\n        fOverlaps_Brep_MaxBelowTol.append(fOverlap_Face_MaxBelowTol)\r\n        \r\n        #        if fOverlap_Min_Brep is None or fOverlap_Face_Min < fOverlap_Min_Brep:\r\n        #            fOverlap_Min_Brep = fOverlap_Face_Min\r\n        #        if fOverlap_Brep_MaxBelowTol is None or fOverlap_Face_MaxBelowTol > fOverlap_Brep_MaxBelowTol:\r\n        #            fOverlap_Brep_MaxBelowTol = fOverlap_Face_MaxBelowTol\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(sCmdPrompt0)\r\n\r\n    return sorted(idxs_rgFaces_Pass), nOverlapPairCt, fOverlaps_Brep_MaxBelowTol\r\n\r\n\r\ndef processBrepObjects(rhBreps0, **kwargs):\r\n    \"\"\"\r\n    Parameters:\r\n        rhBreps0\r\n        fOverlap_MinAllowed,\r\n        iCt_MaxEdgesOfFace,\r\n        bAllOverlapsMustBeSlivers,\r\n        bExtract,\r\n        bEcho,\r\n        bDebug,\r\n    \"\"\"\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    fOverlap_MinAllowed = getOpt('fOverlap_MinAllowed')\r\n    iCt_MaxEdgesOfFace = getOpt('iCt_MaxEdgesOfFace')\r\n    bAllOverlapsMustBeSlivers = getOpt('bAllOverlapsMustBeSlivers')\r\n    bExtract = getOpt('bExtract')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    fOverlap_Min_All = fOverlap_Max_All = None\r\n    fOverlaps_BelowTol_AllBreps = []\r\n    gBreps_Extracted_All = [] # Accumulation of duplicated faces (breps)\r\n    iOverlap_ct_total = 0\r\n    \r\n    len_rhBs0 = len(rhBreps0)\r\n    idxs_AtTenths = [int(round(0.1*i*len(rhBreps0),0)) for i in range(10)]\r\n\r\n\r\n    # escape_test is sometimes called when this script is called by a (Rhino Python Editor: New -) Command.\r\n    if sc.escape_test(throw_exception=False, reset=True):\r\n        print \"sc.escape_test was triggered.\"\r\n\r\n\r\n    iCt_FacesSel_All = 0\r\n\r\n    for iB, rhBrep0 in enumerate(rhBreps0):\r\n        if sc.escape_test(False):\r\n            print \"Searching interrupted by user.\"\r\n            return\r\n        \r\n        if len_rhBs0 == 1:\r\n            Rhino.RhinoApp.SetCommandPrompt(\"Analyzing brep ...\")\r\n        elif len_rhBs0 <= 12:\r\n            Rhino.RhinoApp.SetCommandPrompt(\"Analyzing {} of {} breps\".format(\r\n                iB+1, len_rhBs0))\r\n        elif iB in idxs_AtTenths:\r\n            # May be many monoface breps.\r\n            Rhino.RhinoApp.SetCommandPrompt(\"Analysis at {:d}% of {} breps ...\".format(\r\n                int(100.0 * (iB+1) / len_rhBs0), len_rhBs0))\r\n\r\n        # Obtain GUID, RhinoObject, and geometry.\r\n        if isinstance(rhBrep0, Guid):\r\n            gBrep0 = rhBrep0\r\n            rdBrep0 = sc.doc.Objects.FindId(gBrep0) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(gBrep0)\r\n            if rdBrep0 is None: continue\r\n        elif isinstance(rhBrep0, rd.ObjRef):\r\n            gBrep0 = rhBrep0.ObjectId\r\n            rdBrep0 = rhBrep0.Object()\r\n        elif isinstance(rhBrep0, rd.RhinoObject):\r\n            rdBrep0 = rhBrep0\r\n            gBrep0 = rhBrep0.Id\r\n        else:\r\n            print \"GUID could not be obtained.\"\r\n            continue\r\n        \r\n        rgBrep0 = rdBrep0.Geometry\r\n        if rgBrep0 is None or (rgBrep0.IsSolid and rgBrep0.IsSurface): continue\r\n        if not rgBrep0.IsValid and bEcho:\r\n            print \"Brep {} is invalid and will be skipped because rg.Curve.GetDistancesBetweenCurves may hang.\".format(gBrep0)\r\n            continue\r\n        \r\n        rc = getFaces(\r\n                rgBrep=rgBrep0,\r\n                fOverlap_MinAllowed=fOverlap_MinAllowed,\r\n                iCt_MaxEdgesOfFace=iCt_MaxEdgesOfFace,\r\n                bAllOverlapsMustBeSlivers=bAllOverlapsMustBeSlivers,\r\n                bEcho=bEcho,\r\n                bDebug=bDebug)\r\n        rgBrep0.Dispose()\r\n        if rc is None: continue\r\n\r\n        (\r\n            idxs_rgFaces_Pass,\r\n            iCt_Overlaps_1Brep,\r\n            fOverlaps_MaxBelowTol_1Brep,\r\n            ) = rc\r\n    \r\n        if not idxs_rgFaces_Pass: continue\r\n\r\n        if bExtract:\r\n            rc = xBrepObject.extractFaces(\r\n                    gBrep0,\r\n                    idxs_rgFaces_Pass,\r\n                    bCurrentLayer=False,\r\n                    bByLayerColor=False,\r\n                    bAddOnlyMonofaces=True,\r\n                    bEcho=False,\r\n                    bDebug=bDebug)\r\n            if rc is None: continue\r\n            gBreps_Extracted_All.extend(rc[0])\r\n        else:\r\n            iCt_FacesSel = xBrepObject.selectFaces(\r\n                    gBrep0,\r\n                    idxs_rgFaces_Pass,\r\n                    bEcho=bEcho)\r\n            iCt_FacesSel_All += iCt_FacesSel\r\n        \r\n        iOverlap_ct_total += iCt_Overlaps_1Brep\r\n        \r\n        fOverlaps_BelowTol_AllBreps.extend(fOverlaps_MaxBelowTol_1Brep)\r\n        \r\n        #        if fOverlap_Min_All is None or fOverlap_Min_ThisBrep < fOverlap_Min_All:\r\n        #            fOverlap_Min_All = fOverlap_Min_ThisBrep\r\n        #        if fOverlap_Max_All is None or fOverlaps_MaxBelowTol_1Brep > fOverlap_Max_All:\r\n        #            fOverlap_Max_All = fOverlaps_MaxBelowTol_1Brep\r\n    \r\n    if iOverlap_ct_total > 0:\r\n        print \"{} completely overlapping edge(s) found.\".format(iOverlap_ct_total)\r\n        \r\n        if bExtract:\r\n            if len(gBreps_Extracted_All) > 1:\r\n                sc.doc.Objects.Select(List[Guid](gBreps_Extracted_All))\r\n            else:\r\n                sc.doc.Objects.Select(gBreps_Extracted_All[0])\r\n            rdBreps1_Selected = [rdObj for rdObj in\r\n                    sc.doc.Objects.GetSelectedObjects(False, False)]\r\n            print \"{} mono-face brep(s) selected.\".format(len(rdBreps1_Selected))\r\n        elif iCt_FacesSel_All:\r\n            print \"{} face(s) selected.\".format(iCt_FacesSel_All)\r\n\r\n        print \"Range of distances of completely overlapping edges:\"\r\n        print \" [{0:.{2}f}, {1:.{2}f}]\".format(\r\n                min(fOverlaps_BelowTol_AllBreps),\r\n                max(fOverlaps_BelowTol_AllBreps),\r\n                sc.doc.ModelDistanceDisplayPrecision+1)\r\n    else:\r\n        print \"No completely overlapping edges found.\"\r\n\r\n\r\ndef main():\r\n    \r\n    rc = getInput()\r\n    if rc is None: return\r\n    (\r\n        objrefs,\r\n        fOverlap_MinAllowed,\r\n        iCt_MaxEdgesOfFace,\r\n        bAllOverlapsMustBeSlivers,\r\n        bExtract,\r\n        bEcho,\r\n        bDebug,\r\n       ) = rc\r\n    \r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n    \r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    processBrepObjects(\r\n        rhBreps0=objrefs,\r\n        fOverlap_MinAllowed=fOverlap_MinAllowed,\r\n        iCt_MaxEdgesOfFace=iCt_MaxEdgesOfFace,\r\n        bAllOverlapsMustBeSlivers=bAllOverlapsMustBeSlivers,\r\n        bExtract=bExtract,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug,\r\n        )\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}