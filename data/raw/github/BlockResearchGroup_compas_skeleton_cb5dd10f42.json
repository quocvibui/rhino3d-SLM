{
  "source_url": "https://github.com/BlockResearchGroup/compas_skeleton/blob/c111ff9049ec008b20e445c072dfe015be54f8a3/scripts/old/skeletonobject_old.py",
  "repo": "BlockResearchGroup/compas_skeleton",
  "repo_stars": 8,
  "repo_description": "Mesh generation based on skeleton lines.",
  "license": "NOASSERTION",
  "filepath": "scripts/old/skeletonobject_old.py",
  "instruction": "Skeletonobject old",
  "code": "from __future__ import print_function\nfrom __future__ import absolute_import\nfrom __future__ import division\n\nfrom compas.geometry import Vector\nfrom compas.geometry import dot_vectors\nfrom compas.geometry import add_vectors\n\ntry:\n    import compas_rhino\n    from compas_rhino.objects import mesh_move_vertex\n    from compas_rhino import delete_objects\n    from compas_skeleton.rhino import SkeletonArtist\n    import Rhino.Input.Custom\n    from Rhino.Geometry import Point3d\n    from Rhino.Geometry import Line\n    from System.Drawing.Color import FromArgb\nexcept ImportError:\n    pass\n\n\n__all__ = [\"SkeletonObject\"]\n\n\nclass SkeletonObject(object):\n    \"\"\"Scene object for Skeleton in Rhino.\n\n    Parameters\n    ----------\n    datastructure : :class:`compas_skeleton.datastructure.Skeleton`\n        A Skeleton instance as the datastructure of SkeletonObject\n\n    artist : :class:`compas_skeleton.rhino.SkeletonArtist`\n        The specialised skeleton artist for Rhino.\n\n    Examples\n    --------\n    >>> from compas_skeleton.datastructure import Skeleton\n    >>> from compas_skeleton.rhino import SkeletonObject\n    >>>\n    >>> lines = [\n    >>> ([0.0, 0.0, 0.0], [0.0, 10.0, 0.0]),\n    >>> ([0.0, 0.0, 0.0], [-8.6, -5.0, 0.0]),\n    >>> ([0.0, 0.0, 0.0], [8.6, -5.0, 0.0])\n    >>> ]\n    >>> skeleton = Skeleton.from_skeleton_lines(lines)\n    >>> skeletonobject = SkeletonObject(skeleton)\n    >>> skeletonobject.draw()\n    >>> skeletonobject.dynamic_draw_widths()\n    >>> skeletonobject.update()\n    \"\"\"\n\n    settings = {\n        'layer': \"Skeleton\",\n        'skeleton.layer': \"Skeleton::skeleton\",\n        'mesh.layer': \"Skeleton::mesh\",\n        'color.skeleton.vertices': [255, 0, 0],\n        'color.skeleton.edges': [0, 0, 255],\n        'color.mesh.vertices': [0, 0, 0],\n        'color.mesh.edges': [0, 0, 0],\n        'color.mesh.faces': [0, 0, 0]\n    }\n\n    def __init__(self, skeleton):\n        self.datastructure = skeleton\n        self.artist = SkeletonArtist(self.datastructure)\n        self.artist.settings.update(self.settings)\n        self._guid_skeleton_vertices = {}\n        self._guid_skeleton_edges = {}\n        self._guid_coarse_mesh_vertices = {}\n        self._guid_mesh = {}\n\n    @property\n    def guid_skeleton_vertices(self):\n        return self._guid_skeleton_vertices\n\n    @guid_skeleton_vertices.setter\n    def guid_skeleton_vertices(self, values):\n        self._guid_skeleton_vertices = dict(values)\n\n    @property\n    def guid_skeleton_edges(self):\n        return self._guid_skeleton_edges\n\n    @guid_skeleton_edges.setter\n    def guid_skeleton_edges(self, values):\n        self._guid_skeleton_edges = dict(values)\n\n    @property\n    def guid_coarse_mesh_vertices(self):\n        return self._guid_coarse_mesh_vertices\n\n    @guid_coarse_mesh_vertices.setter\n    def guid_coarse_mesh_vertices(self, values):\n        self._guid_coarse_mesh_vertices = dict(values)\n\n    @property\n    def guid_mesh(self):\n        return self._guid_mesh\n\n    @guid_mesh.setter\n    def guid_mesh(self, values):\n        self._guid_mesh = dict(values)\n\n    # ==============================================================================\n    # modify datastructure with rhino input\n    # ==============================================================================\n\n    def add_lines(self):\n        \"\"\"Update skeleton by adding more skeleon lines from Rhino.\n\n        Examples\n        --------\n        >>> skeletonobjcet.add_lines()\n        >>> skeletonobjcet.draw()\n\n        \"\"\"\n        self.clear_mesh()\n        guids = compas_rhino.select_lines()\n        if not guids:\n            return\n\n        guids = list(self.guid_skeleton_edges.keys()) + guids\n        lines = compas_rhino.get_line_coordinates(guids)\n        compas_rhino.rs.HideObjects(guids)\n        self.datastructure.update_skeleton_lines(lines)\n\n    def remove_lines(self):\n        \"\"\"Update skeleton by removing current skeleon lines.\n\n        Examples\n        --------\n        >>> skeletonobjcet.remove_lines()\n        >>> skeletonobjcet.draw()\n\n        \"\"\"\n        self.clear_mesh()\n\n        def custom_filter(rhino_object, geometry, component_index):\n            if rhino_object.Attributes.ObjectId in list(self.guid_skeleton_edges.keys()):\n                return True\n            return False\n\n        guids = compas_rhino.rs.GetObjects('select skeleton lines to remove', custom_filter=custom_filter)\n\n        if not guids:\n            return\n\n        for guid in guids:\n            del self.guid_skeleton_edges[guid]\n        compas_rhino.rs.DeleteObjects(guids)\n\n        lines = compas_rhino.get_line_coordinates(list(self.guid_skeleton_edges.keys()))\n        if not lines:\n            return\n\n        self.datastructure.update_skeleton_lines(lines)\n\n    def dynamic_draw_widths(self):\n        \"\"\"Dynamic draw leaf width, node width, leaf extend and update the mesh in rhino.\n\n        Examples\n        --------\n        >>> lines = [\n        >>> ([0.0, 0.0, 0.0], [0.0, 10.0, 0.0]),\n        >>> ([0.0, 0.0, 0.0], [-8.6, -5.0, 0.0]),\n        >>> ([0.0, 0.0, 0.0], [8.6, -5.0, 0.0])\n        >>> ]\n        >>> skeleton = Skeleton.from_skeleton_lines(lines)\n        >>> skeletonobjcet = SkeletonObject(skeleton)\n        >>> skeletonobjcet.dynamic_draw_widths()\n\n        \"\"\"\n        if self.datastructure.skeleton_vertices[1]:\n            result = self.dynamic_draw_width('leaf_width')\n            if result == Rhino.Commands.Result.Cancel:\n                return False\n\n        if self.datastructure.skeleton_vertices[0]:\n            result = self.dynamic_draw_width('node_width')\n            if result == Rhino.Commands.Result.Cancel:\n                return False\n\n        if self.datastructure.skeleton_vertices[1]:\n            result = self.dynamic_draw_width('leaf_extend')\n            if result == Rhino.Commands.Result.Cancel:\n                return False\n\n        return True\n\n    def dynamic_draw_width(self, param):\n        \"\"\"Dynamic draw a width value, and update the mesh in rhino.\n\n        Parameters\n        -----------\n        param: str\n            'node_width', 'leaf_width', 'leaf_extend'\n\n        Examples\n        --------\n        >>> lines = [\n        >>> ([0.0, 0.0, 0.0], [0.0, 10.0, 0.0]),\n        >>> ([0.0, 0.0, 0.0], [-8.6, -5.0, 0.0]),\n        >>> ([0.0, 0.0, 0.0], [8.6, -5.0, 0.0])\n        >>> ]\n        >>> skeleton = Skeleton.from_skeleton_lines(lines)\n        >>> skeletonobjcet = SkeletonObject(skeleton)\n        >>> skeletonobjcet.dynamic_draw_width('node_width')\n        \"\"\"\n\n        # get start point\n        gp = Rhino.Input.Custom.GetPoint()\n        if param == 'node_width':\n            node_vertex = self.datastructure.skeleton_vertices[0][0]\n            sp = Point3d(*(self.datastructure.vertex_coordinates(node_vertex)))\n            gp.SetCommandPrompt('select the node vertex')\n        else:\n            leaf_vertex = self.datastructure.skeleton_vertices[1][0]\n            sp = Point3d(*(self.datastructure.vertex_coordinates(leaf_vertex)))\n            gp.SetCommandPrompt('select the leaf vertex')\n\n        gp.SetBasePoint(sp, False)\n        gp.ConstrainDistanceFromBasePoint(0.01)\n        gp.Get()\n        print(gp.CommandResult())\n        if gp.CommandResult() != Rhino.Commands.Result.Success:\n            return gp.CommandResult()\n\n        sp = gp.Point()\n\n        gp.SetCommandPrompt('confirm the distance')\n        self.clear_mesh()\n\n        # get current point\n        def OnDynamicDraw(sender, e):\n            cp = e.CurrentPoint\n            e.Display.DrawDottedLine(sp, cp, FromArgb(0, 0, 0))\n\n            mp = Point3d.Add(sp, cp)\n            mp = Point3d.Divide(mp, 2)\n            dist = cp.DistanceTo(sp)\n            e.Display.Draw2dText(str(dist), FromArgb(0, 0, 0), mp, False, 20)\n\n            if param == 'leaf_extend':\n                direction = _get_leaf_extend_direction(cp)\n                dist *= direction\n\n            self.datastructure._update_width(dist, param)\n            self.datastructure.update_mesh_vertices_pos()\n            lines = _get_edge_lines_in_rhino()\n\n            for line in lines:\n                e.Display.DrawLine(line, FromArgb(0, 0, 0), 2)\n\n        def _get_constrain(param):\n            u = leaf_vertex\n            vec_along_edge = self.datastructure._get_vec_along_branch(u)\n\n            if param == 'leaf_width':\n                vec_offset = vec_along_edge.cross(Vector.Zaxis())\n                vec_rhino = Rhino.Geometry.Vector3d(vec_offset[0], vec_offset[1], vec_offset[2])\n\n            if param == 'leaf_extend':\n                vec_rhino = Rhino.Geometry.Vector3d(vec_along_edge[0], vec_along_edge[1], vec_along_edge[2])\n\n            pt_leaf = Point3d(*(self.datastructure.vertex_coordinates(u)))\n            line = Line(pt_leaf, vec_rhino)\n            return line\n\n        def _get_leaf_extend_direction(cp):\n            u = leaf_vertex\n            vec_along_edge = self.datastructure._get_vec_along_branch(u)\n            vec_sp_np = Vector.from_start_end(sp, cp)\n            dot_vec = dot_vectors(vec_along_edge, vec_sp_np)\n\n            if dot_vec == 0:\n                return 0\n\n            return dot_vec / abs(dot_vec)\n\n        def _get_edge_lines_in_rhino():\n            sub_mesh = self.datastructure.to_mesh()\n            edge_lines = []\n            for u, v in sub_mesh.edges():\n                pts = sub_mesh.edge_coordinates(u, v)\n                line = Line(Point3d(*pts[0]), Point3d(*pts[1]))\n                edge_lines.append(line)\n\n            return edge_lines\n\n        if param == 'leaf_width' or param == 'leaf_extend':\n            gp.Constrain(_get_constrain(param))\n        gp.DynamicDraw += OnDynamicDraw\n\n        # get end point\n        gp.Get()\n        ep = gp.Point()\n\n        dist = ep.DistanceTo(sp)\n\n        if param == 'leaf_extend':\n            direction = _get_leaf_extend_direction(ep)\n            dist *= direction\n\n        self.datastructure._update_width(dist, param)\n        self.datastructure.update_mesh_vertices_pos()\n\n        self.draw_mesh()\n        return gp.CommandResult()\n\n    def move_mesh_vertex(self):\n        \"\"\" Move the position of a mesh vertex. \"\"\"\n        guid = compas_rhino.rs.GetObject(\n            message=\"Select a vertex.\",\n            preselect=True,\n            filter=compas_rhino.rs.filter.point | compas_rhino.rs.filter.textdot\n            )\n\n        if not guid:\n            return\n\n        guid_key = self.guid_coarse_mesh_vertices\n        guid_key.update(self.guid_skeleton_vertices)\n\n        key = guid_key[guid]\n        sp = self.datastructure.vertex_coordinates(key)\n        mesh_move_vertex(self.datastructure, key)\n        ep = self.datastructure.vertex_coordinates(key)\n\n        vec = Vector.from_start_end(sp, ep)\n        vec_prvs = self.datastructure.vertex_attribute(key, 'transform')\n        vec = add_vectors(vec_prvs, vec)\n        self.datastructure.vertex[key].update({'transform': list(vec)})\n\n    def move_skeleton_vertex(self):\n        \"\"\" Move the position of a skeleton vertex and update all its descencent vertices.\n\n        Examples\n        --------\n        >>> lines = [\n        >>> ([0.0, 0.0, 0.0], [0.0, 10.0, 0.0]),\n        >>> ([0.0, 0.0, 0.0], [-8.6, -5.0, 0.0]),\n        >>> ([0.0, 0.0, 0.0], [8.6, -5.0, 0.0])\n        >>> ]\n        >>> skeleton = Skeleton.from_skeleton_lines(lines)\n        >>> skeletonobjcet = SkeletonObject(skeleton)\n        >>> skeletonobjcet.move_skeleton_vertex()\n        >>> skeletonobjcet.draw()\n\n        \"\"\"\n        guid = compas_rhino.rs.GetObject(\n            message=\"Select a vertex.\",\n            preselect=True,\n            filter=compas_rhino.rs.filter.point | compas_rhino.rs.filter.textdot\n            )\n\n        if guid not in list(self.guid_skeleton_vertices.keys()):\n            print('Not a skeleton vertex! Please select again:')\n            return\n\n        else:\n            key = self.guid_skeleton_vertices[guid]\n            if not self.datastructure.skeleton_vertices[1]:\n                self._move_skeleton_centerpt(key)  # this is a dome with only one skeleton vertex\n            else:\n                if self.datastructure.vertex_attribute(key, 'type') == 'skeleton_leaf':\n                    self._move_skeleton_leaf(key)\n                else:\n                    self._move_skeleton_joint(key)\n\n    def _move_skeleton_joint(self, key):\n\n        joints_f_before = []\n        nbrs_f_before = []\n        joints_f_after = []\n        nbrs_f_after = []\n\n        nbrs = self.datastructure.vertex_attribute(key, 'neighbors')\n\n        for nbr in nbrs:\n            if self.datastructure.vertex_attribute(nbr, 'type') == 'skeleton_leaf':\n                nbrs_f_before.append(self.datastructure._get_leaf_vertex_frame(nbr))\n            else:\n                f_left = self.datastructure._get_joint_vertex_frame(nbr, key)[0]\n                f_right = self.datastructure._get_joint_vertex_frame(nbr, key)[1]\n                nbrs_f_before.append([f_left, f_right])\n\n            joints_f_before.append(self.datastructure._get_joint_vertex_frame(key, nbr)[0])\n\n        mesh_move_vertex(self.datastructure, key)\n\n        for nbr in nbrs:\n            if self.datastructure.vertex_attribute(nbr, 'type') == 'skeleton_leaf':\n                nbrs_f_after.append(self.datastructure._get_leaf_vertex_frame(nbr))\n            else:\n                f_left = self.datastructure._get_joint_vertex_frame(nbr, key)[0]\n                f_right = self.datastructure._get_joint_vertex_frame(nbr, key)[1]\n                nbrs_f_after.append([f_left, f_right])\n\n            joints_f_after.append(self.datastructure._get_joint_vertex_frame(key, nbr)[0])\n\n        for i, nbr in enumerate(nbrs):\n            if self.datastructure.vertex_attribute(nbr, 'type') == 'skeleton_leaf':\n                self.datastructure._mount_leaf_transformation(nbr, nbrs_f_before[i], nbrs_f_after[i])\n            else:\n                self.datastructure._mount_joint_transformation(\n                    nbr, key, nbrs_f_before[i][0], nbrs_f_after[i][0], 'left')\n                self.datastructure._mount_joint_transformation(\n                    nbr, key, nbrs_f_before[i][1], nbrs_f_after[i][1], 'right')\n\n            self.datastructure._mount_joint_transformation(\n                key, nbr, joints_f_before[i], joints_f_after[i], 'left')\n\n        self.datastructure.update_mesh_vertices_pos()\n\n    def _move_skeleton_leaf(self, key):\n        v = key\n        u = self.datastructure.vertex_attribute(v, 'neighbors')[0]\n\n        leaf_f_before = self.datastructure._get_leaf_vertex_frame(v)\n        joints_f_before = self.datastructure._get_joint_vertex_frame(u, v)\n\n        mesh_move_vertex(self.datastructure, v)\n\n        leaf_f_after = self.datastructure._get_leaf_vertex_frame(v)\n        joints_f_after = self.datastructure._get_joint_vertex_frame(u, v)\n\n        self.datastructure._mount_leaf_transformation(v, leaf_f_before, leaf_f_after)\n        self.datastructure._mount_joint_transformation(u, v, joints_f_before[0], joints_f_after[0], 'left')\n        self.datastructure._mount_joint_transformation(u, v, joints_f_before[1], joints_f_after[1], 'right')\n\n        self.datastructure.update_mesh_vertices_pos()\n\n    def _move_skeleton_centerpt(self, key):\n        f_before =self.datastructure._get_centerpt_frame(key)\n\n        mesh_move_vertex(self.datastructure, key)\n        f_after = self.datastructure._get_centerpt_frame(key)\n\n        nbrs = self.datastructure.vertex_neighbors(key)\n        for nbr in nbrs:\n            self.datastructure._mount_skeleton_vertex_transformation(nbr, f_before, f_after)\n\n        self.datastructure.update_mesh_vertices_pos()\n\n    def update(self):\n        \"\"\"update Skeleton by directly typing command name in Rhino command window.\n\n        Examples\n        --------\n        >>> lines = [\n        >>> ([0.0, 0.0, 0.0], [0.0, 10.0, 0.0]),\n        >>> ([0.0, 0.0, 0.0], [-8.6, -5.0, 0.0]),\n        >>> ([0.0, 0.0, 0.0], [8.6, -5.0, 0.0])\n        >>> ]\n        >>> skeleton = Skeleton.from_skeleton_lines(lines)\n        >>> skeletonobject = SkeletonObject(skeleton)\n        >>> skeletonobject.draw()\n        >>> skeletonobject.update()\n\n        Notes\n        -----\n        This method requests user to input operation names in Rhino command window once update mode is activated.\n        The following operations are supported:\n            * 'm_skeleton'\n            * 'm_mesh'\n            * 'leaf_width'\n            * 'node_width'\n            * 'leaf_extend'\n            * 'subdivide'\n            * 'merge'\n            * 'add_lines'\n            * 'remove_lines'\n            * 'finish'\n        \"\"\"\n\n        while True:\n            operation = compas_rhino.rs.GetString('next')\n            if operation == 'm_skeleton':\n                self.move_skeleton_vertex()\n            elif operation == 'm_mesh':\n                self.draw_coarse_mesh_vertices()\n                self.move_mesh_vertex()\n                self.clear_coarse_mesh_vertices()\n            elif operation == 'leaf_width':\n                if self.datastructure.skeleton_vertices[1]:\n                    self.dynamic_draw_width('leaf_width')\n                else:\n                    print('this skeleton doesn\\'t have any leaf!')\n            elif operation == 'node_width':\n                self.dynamic_draw_width('node_width')\n            elif operation == 'leaf_extend':\n                self.dynamic_draw_width('leaf_extend')\n            elif operation == 'subdivide':\n                self.datastructure.subdivide(k=1)\n            elif operation == 'merge':\n                self.datastructure.merge(k=1)\n            elif operation == 'add_lines':\n                self.add_lines()\n            elif operation == 'remove_lines':\n                self.remove_lines()\n\n            elif operation == 'finish':\n                self.draw()\n                break\n            else:\n                self.draw()\n                break\n\n            self.draw()\n\n    # ==============================================================================\n    # Visualize\n    # ==============================================================================\n\n    def clear(self):\n        \"\"\" Clear the skeleton and skeleton mesh in Rhino. \"\"\"\n        self.clear_skeleton()\n        self.clear_coarse_mesh_vertices()\n        self.clear_mesh()\n\n    def clear_skeleton(self):\n        guid_skeleton_vertices = list(self.guid_skeleton_vertices.keys())\n        guid_skeleton_edges = list(self.guid_skeleton_edges.keys())\n        delete_objects(guid_skeleton_vertices + guid_skeleton_edges, purge=True)\n        self._guid_skeleton_vertices = {}\n        self._guid_skeleton_edges = {}\n\n    def clear_coarse_mesh_vertices(self):\n        guid_coarse_mesh_vertices = list(self.guid_coarse_mesh_vertices.keys())\n        delete_objects(guid_coarse_mesh_vertices, purge=True)\n        self._coarse_mesh_vertices = {}\n\n    def clear_mesh(self):\n        guid_mesh = list(self.guid_mesh.keys())\n        delete_objects(guid_mesh, purge=True)\n        self._guid_mesh = {}\n\n    def draw(self):\n        \"\"\" Draw the skeleton and skeleton mesh in Rhino. \"\"\"\n        self.clear()\n        self.draw_skeleton()\n        self.draw_mesh()\n\n    def draw_skeleton(self):\n        self.artist.skeleton = self.datastructure\n\n        skeleton_vertices = self.datastructure.skeleton_vertices[0] + self.datastructure.skeleton_vertices[1]\n        skeleton_branches = self.datastructure.skeleton_branches\n\n        guids_vertices, guids_edges = self.artist.draw_skeleton(skeleton_vertices, skeleton_branches)\n        self.guid_skeleton_vertices = zip(guids_vertices, skeleton_vertices)\n        self.guid_skeleton_edges = zip(guids_edges, skeleton_branches)\n\n    def draw_coarse_mesh_vertices(self):\n        self.artist.skeleton = self.datastructure\n\n        mesh_vertices_keys = list(self.datastructure.vertices())\n        skeleton_vertices = self.datastructure.skeleton_vertices[0] + self.datastructure.skeleton_vertices[1]\n        boundary_vertices = list(set(mesh_vertices_keys) - set(skeleton_vertices))\n        guids = self.artist.draw_coarse_mesh_vertices(boundary_vertices)\n\n        self.guid_coarse_mesh_vertices = zip(guids, boundary_vertices)\n\n    def draw_mesh(self):\n        self.artist.mesh = self.datastructure.to_mesh()\n\n        key = None\n        guids = self.artist.draw_mesh()\n        self.guid_mesh = zip(guids, [key])\n\n\n# ============================================================================\n# Main\n# ============================================================================\n\nif __name__ == '__main__':\n    pass\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}