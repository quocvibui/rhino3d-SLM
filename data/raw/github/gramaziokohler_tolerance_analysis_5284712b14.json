{
  "source_url": "https://github.com/gramaziokohler/tolerance_analysis/blob/b44750676e3422a0d6938daad691728e3a78e2a3/directed_graph_181029.py",
  "repo": "gramaziokohler/tolerance_analysis",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "directed_graph_181029.py",
  "instruction": "Directed graph 181029",
  "code": "from compas.datastructures.network import Network\r\nfrom compas_fab.fab.geometry import Frame, Transformation, Translation, Rotation\r\nfrom compas.geometry.elements import Line, Point\r\nfrom compas.geometry import distance_point_point\r\nfrom compas.geometry import project_point_plane\r\nfrom compas.geometry import intersection_line_plane\r\nfrom compas_fab.fab.grasshopper.utilities.drawing import xdraw_frame\r\nfrom collections import deque\r\nimport random as r\r\nfrom graphviz import Digraph\r\nfrom heap import Heap\r\nimport random\r\nimport operator\r\nimport itertools\r\nimport math\r\nfrom compas.geometry.elements import Vector, Line\r\nimport Rhino.Geometry as rg\r\nimport rhinoscriptsyntax as rs\r\n\r\nr.seed(1)\r\n\r\n__author__     = 'Augusto Gandia, Gonzalo Casas'\r\n__copyright__  = 'Copyright 2018, Gramazio Kohler Research - ETH Zurich'\r\n__license__    = 'MIT'\r\n__email__      = 'gandia@arch.ethz.ch'\r\n\r\ndef setup(rawData):\r\n        cities = list()\r\n        #Create and return sorted data in list\r\n        data = list() \r\n\r\n        for line in rawData:\r\n            item = list()\r\n            temp = line.split()\r\n            item.extend([temp[0],temp[1],int(temp[2])])\r\n            cities.extend([temp[0],temp[1]])\r\n            data.append(item)\r\n        return sorted(data, key=operator.itemgetter(2)),sorted(set(cities))\r\n\r\ndef init(E):\r\n    nodes = {}\r\n    for e in E:\r\n        nodes[e] = None\r\n    return nodes\r\n\r\ndef find(nodes, U):\r\n    if U not in nodes:\r\n        print('Find failed: ' + str(U) + ' not found')\r\n        return None\r\n    if nodes[U] == None:\r\n        return U\r\n    return find(nodes,nodes[U])\r\n\r\ndef union(nodes,U0,U1):\r\n    U1_temp = find(nodes,U1)\r\n    U0_temp = find(nodes,U0)\r\n    if U1_temp == None or U0_temp == None:\r\n        failed = []\r\n        if U0_temp == None:\r\n            failed.append(U0)\r\n        if U1_temp == None:\r\n            failed.append(U1)\r\n        print('\\nUnion failed: Element(s) ' + str(failed) + ' not found\\n')\r\n        return None\r\n    if U0_temp != U1_temp:\r\n        nodes[U0_temp] = U1_temp\r\n    return U1_temp\r\n\r\ndef check_connectivity(assembly_sequence_network, current_beam, adjacency, beams_geometry, result):\r\n    #Type of beam (0 = bottom chord, 1 = top chord, 2 = verticals, 3 = wall infill, 4 = slab rafter, 5 = diagonals)\r\n    \r\n    beam_type=(assembly_sequence_network.get_vertex_attribute(current_beam, 'beam_type'))\r\n    check=False\r\n    nbrs=set(adjacency[current_beam])\r\n    #0 = bottom chord\r\n    if beam_type==0:\r\n        check=True\r\n\r\n    #1 = top chord\r\n    if beam_type==1:\r\n        #iter nbrs\r\n        counter=0\r\n        for nbr_node in set(nbrs): \r\n            nbr_node_type=assembly_sequence_network.get_vertex_attribute(nbr_node, 'beam_type')\r\n            #if nbr is vertical or diagonal\r\n            if nbr_node_type==2:\r\n                #check if any verticals or diagonal already assembled\r\n                if str(nbr_node) in result:\r\n                    counter=counter+1\r\n        if counter>1:#it is considered to be stable if there is at least two supports\r\n            check=True\r\n\r\n    #2 = verticals\r\n    if beam_type==2:\r\n        counter=0\r\n        #iter nbrs\r\n        for nbr_node in nbrs: \r\n            nbr_node_type=assembly_sequence_network.get_vertex_attribute(nbr_node, 'beam_type')\r\n            #if nbr is bottom_cord \r\n            if nbr_node_type==0:\r\n                #check if any bottom_cord already assembled\r\n                if str(nbr_node) in result:\r\n                    counter=counter+1\r\n                    \r\n        for beam_index in result:\r\n            beam_type=assembly_sequence_network.get_vertex_attribute(int(beam_index), 'beam_type')\r\n            if beam_type==0:\r\n                counter=counter+1\r\n        if counter>10:\r\n            check=True\r\n\r\n    #3 = wall infill\r\n    if beam_type==3:\r\n        #iter nbrs\r\n        counter=0\r\n        for nbr_node in nbrs:\r\n            nbr_node_type=assembly_sequence_network.get_vertex_attribute(nbr_node, 'beam_type')\r\n            #if nbr is bottom or top cord \r\n            if nbr_node_type==0 or nbr_node_type==1:\r\n                #if already assembled\r\n                if str(nbr_node) in result:\r\n                    counter=counter+1\r\n        for beam_index in result:\r\n            beam_type=assembly_sequence_network.get_vertex_attribute(int(beam_index), 'beam_type')\r\n            if beam_type==4:\r\n                counter=counter+1\r\n        if counter>11:\r\n            check=True\r\n\r\n    #4 = slab rafter\r\n    if beam_type==4:\r\n        #iter nbrs\r\n        counter=0\r\n        for nbr_node in nbrs:\r\n            nbr_node_type=assembly_sequence_network.get_vertex_attribute(nbr_node, 'beam_type')\r\n            #if nbr is top cord \r\n            if nbr_node_type==1:\r\n                #if already assembled\r\n                if str(nbr_node) in result:\r\n                    counter=counter+2\r\n            #if nbr is top cord\r\n\r\n            if nbr_node_type==4:\r\n                if str(nbr_node) in result:\r\n                    counter=counter+1\r\n        if counter>1:\r\n            check=True\r\n\r\n    #5 = diagonals\r\n    if beam_type==5:\r\n        #iter nbrs\r\n        counter=0\r\n        for nbr_node in nbrs:\r\n            nbr_node_type=assembly_sequence_network.get_vertex_attribute(nbr_node, 'beam_type')\r\n            #if nbr is bottom or top cord \r\n            if nbr_node_type==0 or nbr_node_type==2:\r\n                #if already assembled\r\n                if str(nbr_node) in result:\r\n                    counter=counter+1\r\n        #check if diagonals are already assembled\r\n\r\n        for beam_index in result:\r\n            beam_type=assembly_sequence_network.get_vertex_attribute(int(beam_index), 'beam_type')\r\n            if beam_type==4:\r\n                counter=counter+1\r\n        if counter>8:\r\n            check=True\r\n    return check\r\n\r\n# Method to perform Kruskal's Algorithm    \r\ndef kruskal(assembly_sequence_network, data,nodes,adjacency_dictionary,beams_geometry):\r\n    #Store beam Type\r\n    #40: used to be 2\r\n    #39: used to be 1\r\n    #network.set_vertex_attribute(child_other_vertex, 'connection_frame', ch_beam_frame_0_compas)\r\n    #Type of beam (0 = bottom chord, 1 = top chord, 2 = verticals, 3 = wall infill, 4 = slab rafter, 5 = diagonals)\r\n    beams_type={0:0, 1:1, 2:2, 3:2, 4:4, 5:5, 6:3, 7:3, 8:3, 9:3, 10:3, 11:3, 12:3, 13:3, 14:5, 15:0, 16:1, \r\n    17:2, 18:4, 19:5, 20:3, 21:3, 22:3, 23:3, 24:3, 25:3, 26:5, 27:0, 28:1 ,29:2, 30:4, 31:5, 32:3, 33:3,\r\n    34:3, 35:3, 36:3, 37:3, 38:0, 39:4 ,40:3 ,41:4, 42:3, 43:3, 44:3, 45:5, 46:0, 47:1, 48:2, 49:4, 50:5,\r\n    51:3, 52:3, 53:3, 54:3, 55:5, 56:5, 57:3, 58:3, 59:3, 60:3, 61:5, 62:0, 63:1, 64:4, 65:5, 66:3, 67:3,\r\n    68:3, 69:3, 70:5, 71:4, 72:4, 73:4, 74:4, 75:4, 76:4, 77:4, 78:4, 79:4, 80:4, 81:4, 82:4, 83:4, 84:4}\r\n    \r\n    for v,attr in assembly_sequence_network.vertices(data=True):\r\n        assembly_sequence_network.set_vertex_attribute(v, 'beam_type', beams_type[v])\r\n\r\n    distance = 0\r\n    result = list()\r\n    nodes = init(nodes)\r\n    forward_counters={}\r\n    building_sequence=[]\r\n    while len(data):\r\n        weighted_edge = data.pop(0)\r\n        if find(nodes,weighted_edge[0]) != find(nodes,weighted_edge[1]):\r\n            if not check_connectivity(assembly_sequence_network,int(weighted_edge[0]), adjacency_dictionary, beams_geometry, result) or not check_connectivity (assembly_sequence_network,int(weighted_edge[1]), adjacency_dictionary, beams_geometry, result):\r\n                key = '%s-%s' % (weighted_edge[0], weighted_edge[1])\r\n                if key in forward_counters:\r\n                    forward_counters[key] += 1\r\n                else:\r\n                    forward_counters[key] = 1\r\n                forward_count=forward_counters[key]\r\n                data.insert(forward_count, weighted_edge)\r\n                continue\r\n            forward_counters = {}\r\n            union(nodes, weighted_edge[0],weighted_edge[1])\r\n            beam_1=weighted_edge[0]\r\n            beam_2=weighted_edge[1]\r\n            result.append(beam_1)\r\n            result.append(beam_2)\r\n            #Store parent of each beam according to fabrication sequence\r\n            #Remove duplicates from result\r\n            seen = set()\r\n            cleaned_result=[x for x in result if not (x in seen or seen.add(x))]\r\n            building_sequence.append(cleaned_result)\r\n            #Build an adjacency dictionary for each assembly step\r\n            beams_parent={}\r\n            #Iterate already assembled beams\r\n            for assembled_beam in cleaned_result:\r\n                #Get current beam nbrs\r\n                beam_nbrs=adjacency_dictionary[int(assembled_beam)]\r\n                #Check if any assembled beam is neighbour of current beam\r\n                for beam in cleaned_result:\r\n                    if int(beam) in beam_nbrs:\r\n                        #if key exists\r\n                        if int(assembled_beam) not in beams_parent:\r\n                            beams_parent.update({int(assembled_beam):[int(beam)]})\r\n    return cleaned_result, beams_parent, building_sequence\r\n\r\ndef midpoint_point_point(a, b):\r\n    return [0.5 * (a[0] + b[0]),\r\n            0.5 * (a[1] + b[1]),\r\n            0.5 * (a[2] + b[2])]\r\n\r\ndef midpoint_line(line):\r\n    return midpoint_point_point(*line)\r\n    \r\ndef vertex_neighbours(self,key):\r\n    \"\"\"Return the neighbours of a vertex.\"\"\"\r\n    return list(self.halfedge[key])\r\n\r\ndef edge_connected_edges(self, u, v):\r\n        edges = []\r\n        for nbr in vertex_neighbours(self,u):\r\n            if nbr in self.edge[u]:\r\n                edges.append((u, nbr))\r\n            else:\r\n                edges.append((nbr, u))\r\n        for nbr in vertex_neighbours(self,v):\r\n            if nbr in self.edge[v]:\r\n                edges.append((v, nbr))\r\n            else:\r\n                edges.append((nbr, v))\r\n        return edges\r\n\r\ndef delete_vertex(self, key): #This could be removed in newer versions of compas\r\n    for nbr in self.vertex_neighbours(key):\r\n        del self.halfedge[key][nbr]\r\n        del self.halfedge[nbr][key]\r\n        if key in self.edge and nbr in self.edge[key]:\r\n            del self.edge[key][nbr]\r\n        else:\r\n            del self.edge[nbr][key]\r\n    del self.vertex[key]\r\n    del self.halfedge[key]\r\n    del self.edge[key]\r\n\r\ndef translate_frame_own_xyz(transformation,x_dist, y_dist, z_dist):\r\n    x_transform = [[1, 0, 0, (transformation[0, 0] * x_dist)],\r\n                   [0, 1, 0, (transformation[1, 0] * x_dist)],\r\n                   [0, 0, 1, (transformation[2, 0] * x_dist)],\r\n                   [0, 0, 0, 1]]\r\n    y_transform = [[1, 0, 0, (transformation[0, 1]*y_dist)],\r\n                   [0, 1, 0, (transformation[1, 1]*y_dist)],\r\n                   [0, 0, 1, (transformation[2, 1]*y_dist)],\r\n                   [0, 0, 0, 1]]\r\n    z_transform = [[1, 0, 0, (transformation[0, 2]*z_dist)],\r\n                   [0, 1, 0, (transformation[1, 2]*z_dist)],\r\n                   [0, 0, 1, (transformation[2, 2]*z_dist)],\r\n                   [0, 0, 0, 0]]\r\n\r\n    return Translation.from_matrix(z_transform)*Translation.from_matrix(y_transform)*Translation.from_matrix(x_transform)\r\n\r\ndef get_vertices_index_GN(vertex_TN):\r\n    vert_u=int(vertex_TN)*2\r\n    vert_v=int(vertex_TN)*2+1\r\n    return vert_u,vert_v\r\n\r\ndef get_deformed_beam_mesh(network, vert_u, vert_v):\r\n    beam_mesh=network.get_edge_attribute(vert_u,vert_v,'deformed_beam') \r\n    return beam_mesh\r\n\r\ndef get_joint_edge_between_beams(network, p_beam_u_GN, p_beam_v_GN, beam_u_GN, beam_v_GN):\r\n    child_to_parent_joint=[]\r\n    #iterate joint edges in GN and find combination of parent and child vertex that matches\r\n    for u,v,attr in network.edges(data=True):\r\n        if attr['edge_type']=='joint':\r\n            # child u \r\n            if (beam_u_GN,p_beam_u_GN)==(u,v):\r\n                child_to_parent_joint.append(u)\r\n                child_to_parent_joint.append(v)\r\n            elif (beam_u_GN,p_beam_u_GN)==(v,u):\r\n                child_to_parent_joint.append(v)\r\n                child_to_parent_joint.append(u)\r\n            elif (beam_u_GN,p_beam_v_GN)==(u,v):\r\n                child_to_parent_joint.append(u)\r\n                child_to_parent_joint.append(v)\r\n            elif (beam_u_GN,p_beam_v_GN)==(v,u):\r\n                child_to_parent_joint.append(v)\r\n                child_to_parent_joint.append(u)\r\n            elif (beam_v_GN,p_beam_u_GN)==(u,v):\r\n                child_to_parent_joint.append(u)\r\n                child_to_parent_joint.append(v)\r\n            elif (beam_v_GN,p_beam_u_GN)==(v,u):\r\n                child_to_parent_joint.append(v)\r\n                child_to_parent_joint.append(u)\r\n            elif (beam_v_GN,p_beam_v_GN)==(u,v):\r\n                child_to_parent_joint.append(u)\r\n                child_to_parent_joint.append(v)\r\n            elif (beam_v_GN,p_beam_v_GN)==(v,u):\r\n                child_to_parent_joint.append(v)\r\n                child_to_parent_joint.append(u)\r\n    #Joint vertices indices (GN)\r\n    child_joint_vertex=child_to_parent_joint[0]\r\n    parent_joint_vertex=child_to_parent_joint[1]\r\n\r\n    if parent_joint_vertex==p_beam_u_GN:\r\n        parent_other_vertex=p_beam_v_GN\r\n    else:\r\n        parent_other_vertex=p_beam_u_GN\r\n    if child_joint_vertex==beam_u_GN:\r\n        child_other_vertex=beam_v_GN\r\n    else:\r\n        child_other_vertex=beam_u_GN\r\n    return parent_other_vertex, parent_joint_vertex, child_other_vertex, child_joint_vertex\r\n\r\ndef get_beam_mesh(network, vert_u, vert_v, beam_type):\r\n    mesh=network.get_edge_attribute(vert_u,vert_v,beam_type)\r\n    return mesh\r\n\r\ndef get_parent_child_frames(network, p_beam_mesh,ch_beam_mesh, parent_other_vertex, parent_joint_vertex, child_other_vertex, child_joint_vertex):\r\n    #Get child and parent beam\r\n    #Get parent unorganized planes\r\n    p_beam_frame_0=p_beam_mesh.end_planes[0]\r\n    p_beam_frame_0_compas=Frame(p_beam_frame_0.Origin, p_beam_frame_0.XAxis, p_beam_frame_0.YAxis)\r\n    p_beam_frame_1=p_beam_mesh.end_planes[1]\r\n    p_beam_frame_1_compas=Frame(p_beam_frame_1.Origin, p_beam_frame_1.XAxis, p_beam_frame_1.YAxis)\r\n    #Get child unorganized planes\r\n    ch_beam_frame_0=ch_beam_mesh.end_planes[0]\r\n    ch_beam_frame_0_compas=Frame(ch_beam_frame_0.Origin, ch_beam_frame_0.XAxis, ch_beam_frame_0.YAxis)\r\n    ch_beam_frame_1=ch_beam_mesh.end_planes[1]\r\n    ch_beam_frame_1_compas=Frame(ch_beam_frame_1.Origin, ch_beam_frame_1.XAxis, ch_beam_frame_1.YAxis)\r\n    #Get parent vertex origin\r\n    parent_other_vertex_pt=(network.get_vertex_attribute(parent_other_vertex, 'x'),network.get_vertex_attribute(parent_other_vertex, 'y'),network.get_vertex_attribute(parent_other_vertex, 'z'))\r\n    parent_joint_vertex_pt=(network.get_vertex_attribute(parent_joint_vertex, 'x'),network.get_vertex_attribute(parent_joint_vertex, 'y'),network.get_vertex_attribute(parent_joint_vertex, 'z'))\r\n    #Get child vertex origin\r\n    child_other_vertex_pt=(network.get_vertex_attribute(child_other_vertex, 'x'),network.get_vertex_attribute(child_other_vertex, 'y'),network.get_vertex_attribute(child_other_vertex, 'z'))\r\n    child_joint_vertex_pt=(network.get_vertex_attribute(child_joint_vertex, 'x'),network.get_vertex_attribute(child_joint_vertex, 'y'),network.get_vertex_attribute(child_joint_vertex, 'z'))\r\n    \r\n    #Compare parent frame 0 with coordinates of parent other vertex and parent other joint and store frame \r\n    if distance_point_point(p_beam_frame_0.Origin,parent_other_vertex_pt) < 200:\r\n        network.set_vertex_attribute(parent_other_vertex, 'connection_frame', p_beam_frame_0_compas)\r\n        network.set_vertex_attribute(parent_joint_vertex, 'connection_frame', p_beam_frame_1_compas)\r\n    if distance_point_point(p_beam_frame_0.Origin,parent_joint_vertex_pt) < 200:\r\n        network.set_vertex_attribute(parent_other_vertex, 'connection_frame', p_beam_frame_1_compas)\r\n        network.set_vertex_attribute(parent_joint_vertex, 'connection_frame', p_beam_frame_0_compas)\r\n    if distance_point_point(ch_beam_frame_0.Origin,child_other_vertex_pt) < 200:\r\n        network.set_vertex_attribute(child_other_vertex, 'connection_frame', ch_beam_frame_0_compas)\r\n        network.set_vertex_attribute(child_joint_vertex, 'connection_frame', ch_beam_frame_1_compas)\r\n    if distance_point_point(ch_beam_frame_0.Origin,child_joint_vertex_pt) < 200:\r\n        network.set_vertex_attribute(child_other_vertex, 'connection_frame', ch_beam_frame_1_compas)\r\n        network.set_vertex_attribute(child_joint_vertex, 'connection_frame', ch_beam_frame_0_compas)\r\n    \r\n    # joint frames\r\n    parent_joint=network.get_vertex_attribute(parent_joint_vertex, 'connection_frame')\r\n    parent_end=network.get_vertex_attribute(parent_other_vertex, 'connection_frame')\r\n    child_joint=network.get_vertex_attribute(child_joint_vertex, 'connection_frame')\r\n    child_end=network.get_vertex_attribute(child_other_vertex, 'connection_frame')\r\n    return parent_end, parent_joint, child_end, child_joint\r\n\r\ndef get_middle_frame(beam):\r\n    origin_frame=Frame([0, 0, 0], [1, 0, 0], [0, 1, 0])\r\n    middle_frame=Frame(beam.frame[0],beam.frame[1],beam.frame[2])\r\n    middle_frame_transform=Transformation.from_frame(middle_frame)\r\n    middle_frame_inv_transform=Transformation.from_frame(middle_frame).inverse()\r\n    middle_frame.transform(middle_frame_inv_transform)\r\n    fix_middle_rot_x=Rotation.from_axis_and_angle(origin_frame.xaxis,math.radians(180))\r\n    fix_middle_rot_y=Rotation.from_axis_and_angle(origin_frame.yaxis,math.radians(-90))\r\n    middle_frame.transform(fix_middle_rot_x)\r\n    middle_frame.transform(fix_middle_rot_y)\r\n    middle_frame.transform(middle_frame_transform)\r\n    return middle_frame\r\n\r\ndef rotate_points_around_plane(pt, plane, axis_rotation):\r\n    int_pt=Frame(pt, plane.xaxis, plane.yaxis)\r\n    int_pt.transform(Transformation.from_frame(plane).inverse())\r\n    int_pt.transform(axis_rotation)\r\n    int_pt.transform(Transformation.from_frame(plane))\r\n    return int_pt\r\n    \"\"\"\r\ndef calculate_beam_deformation(network, axial_translation_value, axial_rotation_value):\r\n    beams_deformation=[]\r\n    for beam_index_in_sequence in range(len(network.result)):\r\n        p_beam, ch_beam, parent_end, parent_joint, child_joint, child_end, parent_other_vertex, parent_joint_vertex, child_joint_vertex, child_other_vertex = network.get_child_and_parent_data(beam_index_in_sequence)\r\n        #Beam 0 - World 0,0,0\r\n        origin_frame=Frame([0, 0, 0], [1, 0, 0], [0, 1, 0])\r\n        axial_rotation=Rotation.from_axis_and_angle(origin_frame.zaxis,math.radians(axial_rotation_value))\r\n        #Beam 0 - Middle\r\n        middle_frame=get_middle_frame(ch_beam)\r\n        F0=Frame(middle_frame.point, middle_frame.xaxis, middle_frame.yaxis)        \r\n\r\n        #Beam 0 - End 0\r\n        F1=Frame(child_end.point, child_end.xaxis, child_end.yaxis)\r\n        A1=translate_frame_own_xyz(Transformation.from_frame(F1),axial_translation_value[0],axial_translation_value[1],0)\r\n        F1.transform(A1)\r\n        \r\n        #Beam 0 - End 1\r\n        F2=Frame(child_joint.point, child_joint.xaxis, child_joint.yaxis)\r\n        #Translate end\r\n        A2=translate_frame_own_xyz(Transformation.from_frame(F2),axial_translation_value[0],axial_translation_value[1],0)\r\n        F2.transform(A2)\r\n\r\n        #Store deformed beam frames in beams GN\r\n        current_beam_index_GN=network.result[beam_index_in_sequence]\r\n        vert_u, vert_v=get_vertices_index_GN(current_beam_index_GN)\r\n        network.set_edge_attribute(vert_u,vert_v,'deformed_frame_u',F2)\r\n        network.set_edge_attribute(vert_u,vert_v,'deformed_frame_v',F1)\r\n                \r\n        #get beam vertices according to deformation\r\n        pt_0, pt_1, pt_2, pt_3=get_beam_vertices(ch_beam)\r\n        pt_0_mid, int_pt_0=get_point_on_deformed_frames(pt_0,middle_frame,F2,axial_rotation)\r\n        pt_1_mid, int_pt_1=get_point_on_deformed_frames(pt_1,middle_frame,F2,axial_rotation)\r\n        pt_2_mid, int_pt_2=get_point_on_deformed_frames(pt_2,middle_frame,F2,axial_rotation)\r\n        pt_3_mid, int_pt_3=get_point_on_deformed_frames(pt_3,middle_frame,F2,axial_rotation)\r\n        pt_4_mid, int_pt_4=get_point_on_deformed_frames(pt_0,middle_frame,F1,axial_rotation)\r\n        pt_5_mid, int_pt_5=get_point_on_deformed_frames(pt_1,middle_frame,F1,axial_rotation)\r\n        pt_6_mid, int_pt_6=get_point_on_deformed_frames(pt_2,middle_frame,F1,axial_rotation)\r\n        pt_7_mid, int_pt_7=get_point_on_deformed_frames(pt_3,middle_frame,F1,axial_rotation)\r\n\r\n        #Store rail1 (3pts), sweep shape 1 and 2 (two squares = 4pts, 4 pts)\r\n        beams_deformation.append([[int_pt_2.point,pt_2_mid,int_pt_6.point],[int_pt_0.point,int_pt_1.point,int_pt_2.point,int_pt_3.point,int_pt_0.point],[int_pt_4.point,int_pt_5.point,int_pt_6.point,int_pt_7.point,int_pt_4.point]])\r\n    return beams_deformation\r\n    \"\"\"\r\n\r\ndef get_beam_vertices(ch_beam):\r\n    pt_0=ch_beam.beam_vertices[0]\r\n    pt_1=ch_beam.beam_vertices[1]\r\n    pt_2=ch_beam.beam_vertices[2]\r\n    pt_3=ch_beam.beam_vertices[3]\r\n    return pt_0,pt_1,pt_2,pt_3\r\n\r\ndef get_point_on_deformed_frames(pt,middle_frame, end_frame, axial_rotation):\r\n    #Pt 0 - project pt in middle frame\r\n    pt_0_mid=project_point_plane(pt,(middle_frame.point,middle_frame.zaxis))\r\n    pt_0_fake=project_point_plane(pt_0_mid,(end_frame.point, Vector(middle_frame.point, end_frame.point)))\r\n    int_pt_0=intersection_line_plane(Line(pt_0_mid,pt_0_fake), (end_frame.point, end_frame.zaxis))\r\n    int_pt_0=rotate_points_around_plane(int_pt_0,end_frame,axial_rotation)\r\n    return pt_0_mid, int_pt_0\r\n\r\ndef get_rg_deformed_beam(deformed_beam_display_data): \r\n    rail_1=rs.AddInterpCurve(deformed_beam_display_data[0],3)\r\n    rec_1=rs.AddPolyline(deformed_beam_display_data[1])\r\n    rec_2=rs.AddPolyline(deformed_beam_display_data[2])\r\n    sweep=rs.AddSweep1(rail_1,[rec_1,rec_2],True)[0]\r\n    rs.CapPlanarHoles(sweep)\r\n    return sweep\r\n\r\ndef calculate_height_from_rotation(angle_deg):\r\n    #extend to different beam heights and thicknesses\r\n    #it is not parametric, it is based on pithagoras, thus big angles are not valid\r\n    half_height=100\r\n    total_height=math.tan(math.radians(angle_deg))*half_height\r\n    return total_height\r\n\r\ndef calculate_insertion_poses(network):\r\n    #Generate insertion poses        \r\n    for i in range(len(network.result)):\r\n        #Type of beam (0=bottom chord, 1=top chord, 2=verticals, 3=wall infill, 4=slab rafter, 5=diagonals)\r\n        beam_type=network.assembly_sequence_network.get_vertex_attribute(int(network.result[i]), 'beam_type')\r\n        if beam_type==0 or beam_type==1 or beam_type==2:\r\n            p_beam, ch_beam, parent_end, parent_joint, child_joint, child_end, parent_other_vertex, parent_joint_vertex, child_joint_vertex, child_other_vertex = network.get_child_and_parent_data(i)\r\n            #Anchor pt\r\n            mid_pt=get_middle_frame(ch_beam).point\r\n            insertion_pose_x=rg.Vector3d.Subtract(rg.Vector3d(child_joint.point[0],child_joint.point[1],child_joint.point[2]),rg.Vector3d(mid_pt[0],mid_pt[1],mid_pt[2])) \r\n            anchor_vec=rg.Vector3d(mid_pt[0],mid_pt[1],mid_pt[2])\r\n            #Beam frames Y vector\r\n            vec_y_u=rg.Vector3d(child_joint.yaxis[0],child_joint.yaxis[1],child_joint.yaxis[2])\r\n            vec_y_v=rg.Vector3d(child_end.yaxis[0],child_end.yaxis[1],child_end.yaxis[2])\r\n            gravity=rg.Vector3d(0,0,1)\r\n\r\n            #Inserion pose=bisector of beam frames (Y vector) and then its bisector with gravity\r\n            insertion_pose_y=rg.Vector3d.Add(rg.Vector3d.Add(vec_y_u,vec_y_v),gravity)\r\n            #Inverse vector to express insertion direction\r\n            scaled_insertion_pose_y=insertion_pose_y*-80\r\n            #Shift vectors along their length to define anchor pt\r\n            anchor_pt=rg.Point3d(rg.Vector3d.Add(anchor_vec, insertion_pose_y*80))\r\n\r\n            insertion_pose_frame=Frame(anchor_pt,scaled_insertion_pose_y,insertion_pose_x)\r\n            origin_frame=Frame([0, 0, 0], [1, 0, 0], [0, 1, 0])\r\n            T_origin=Transformation.from_frame_to_frame(origin_frame,insertion_pose_frame)\r\n            insertion_pose_frame.transform(T_origin.inverse())\r\n            rotation=Rotation.from_axis_and_angle(origin_frame.yaxis,math.radians(90))\r\n            insertion_pose_frame.transform(rotation)\r\n            insertion_pose_frame.transform(T_origin)                \r\n\r\n            #Store in_pose and anchor in network\r\n            network.assembly_sequence_network.set_vertex_attribute(int(network.result[i]), 'insertion_pose', scaled_insertion_pose_y)\r\n            network.assembly_sequence_network.set_vertex_attribute(int(network.result[i]), 'insertion_pose_frame', xdraw_frame(insertion_pose_frame))\r\n            network.assembly_sequence_network.set_vertex_attribute(int(network.result[i]), 'anchor_point', anchor_pt)\r\n\r\nclass ToleranceNetwork(Network):\r\n    #General Network required to 1) generate assembly sequence to 2) perform tolerance analysis\r\n    def __init__(self, joint_edges, beam_edges, ordered_beams, assembly_priority_weights_list):\r\n        super(ToleranceNetwork, self).__init__()\r\n        input_dict = {'joint_edges': joint_edges, 'beam_edges': beam_edges, 'ordered_beams': ordered_beams}\r\n        self.attributes.update(input_dict)\r\n        self.build_geometry_network()\r\n        self.build_topology_network (assembly_priority_weights_list)\r\n        self.assembly_sequence_search()\r\n        #self.propagate_tolerance_middle()\r\n\r\n    def build_geometry_network(self):\r\n        #add vertices of beam_edges to Tolerance Network(vertices same as Geometry network)\r\n        #iterate beam_edges indexes\r\n        for index in range(len(self.attributes['beam_edges'])):\r\n            #get vertex coordinates \r\n            position = self.attributes['beam_edges'][index][0]\r\n            #generate vertex u, add coordinates and vertex type as attribute\r\n            u=self.add_vertex(attr_dict={'x': position[0], 'y' : position[1], 'z' : position[2], 'vertex_type': 'member'})\r\n            #get vertex coordinates \r\n            position = self.attributes ['beam_edges'][index][1]\r\n            #generate vertex v, add coordinates and vertex type as attribute\r\n            v=self.add_vertex(attr_dict={'x': position[0], 'y' : position[1], 'z' : position[2], 'vertex_type': 'member'})\r\n            #add beam edge, beam object, edge_type, u_coordinate , v_coordinate\r\n            self.add_edge(u,v, {'edge_type': 'member','beam': self.attributes ['ordered_beams'][index], 'u_coordinate':self.vertex_coordinates(u), 'v_coordinate': self.vertex_coordinates(v), 'member_edge_nbrs': []})\r\n        \r\n        # BUILD GEOMETRY NETWORK\r\n        #compare joint edges and beam edges\r\n        store_joint_new_u=[]\r\n        store_joint_new_v=[]\r\n        #iterate joint edges\r\n        for index in range (len(self.attributes['joint_edges'])):\r\n            #get joint_vertices coordinates\r\n            joint_u_coordinate=self.attributes ['joint_edges'][index][0] \r\n            joint_v_coordinate=self.attributes ['joint_edges'][index][1]\r\n            #iterate beam edges\r\n            corresponding_joint_u_index=None #this can be revised\r\n            corresponding_joint_v_index=None\r\n            for u,v,attr in self.edges(data=True):\r\n                #get beam_vertices coordinates\r\n                beam_u_coordinate=attr['u_coordinate']\r\n                beam_v_coordinate=attr['v_coordinate']\r\n                #compare joint vertex u and beam vertex u\r\n                if distance_point_point(joint_u_coordinate,beam_u_coordinate) < 0.5:\r\n                    global corresponding_joint_u_index\r\n                    corresponding_joint_u_index=u\r\n                #compare joint vertex u and beam vertex v\r\n                elif distance_point_point(joint_u_coordinate,beam_v_coordinate) < 0.5:\r\n                    global corresponding_joint_u_index\r\n                    corresponding_joint_u_index=v\r\n                #compare joint vertex v and beam vertex u\r\n                elif distance_point_point(joint_v_coordinate,beam_u_coordinate) < 0.5:\r\n                    global corresponding_joint_v_index\r\n                    corresponding_joint_v_index=u\r\n                #compare joint vertex v and beam vertex v\r\n                elif distance_point_point(joint_v_coordinate,beam_v_coordinate) < 0.5:\r\n                    global corresponding_joint_v_index\r\n                    corresponding_joint_v_index=v\r\n            #store corresponding joint v index\r\n            store_joint_new_u.append(corresponding_joint_u_index)\r\n            #store corresponding joint u index\r\n            store_joint_new_v.append(corresponding_joint_v_index)\r\n\r\n        for index in range(len(store_joint_new_v)):\r\n            self.add_edge(store_joint_new_u[index], store_joint_new_v[index], {'edge_type': 'joint', 'beam': None})\r\n        \r\n        # STORE CONNECTIVITY IN EDGE MEMBERS\r\n        for u,v,attr in self.edges(data=True):\r\n            #filter joint edges\r\n            if attr['edge_type']=='joint':\r\n                #edges connected to joint edge\r\n                connected_edges=edge_connected_edges(self,u,v) \r\n                connected_member_edges=[]\r\n                #filter connected member edges and store connected member edges\r\n                for connected_edge in connected_edges:\r\n                    #if edge is beam edge\r\n                    if self.get_edge_attribute(connected_edge[0],connected_edge[1],'edge_type')=='member':\r\n                        #store it (two members per joint)   \r\n                        connected_member_edges.append((connected_edge[0],connected_edge[1])) \r\n                #get existing neighbours from first edge\r\n                first_member_edge_neighbours=self.get_edge_attribute(connected_member_edges[0][0],connected_member_edges[0][1],'member_edge_nbrs')\r\n                #(by appending them they get included in the attribute)\r\n                first_member_edge_neighbours.append(connected_member_edges[1]) \r\n                #get existing neighbours from second edge \r\n                sec_member_edge_neighbours=self.get_edge_attribute(connected_member_edges[1][0],connected_member_edges[1][1],'member_edge_nbrs')\r\n                #(by appending them they get included in the attribute)\r\n                sec_member_edge_neighbours.append(connected_member_edges[0])\r\n\r\n    #GENERATE ASSEMBLY SEQUENCE NETWORK (beams=nodes and connections=edges)\r\n    def build_topology_network(self, weights_list):\r\n        beams_geometry=self.attributes['ordered_beams']\r\n        #this \"topology network\" is an inversion of the \"geometry_network\" by turning beams into vertices\r\n        self.assembly_sequence_network=AssemblySequenceNetwork(self, weights_list, beams_geometry)\r\n\r\n    def assembly_sequence_search(self):\r\n        #Adjacency dictionary for COMPAS deph_first_tree\r\n        adjacency_dictionary=self.assembly_sequence_network.adjacency_dictionary\r\n        beams_geometry=self.assembly_sequence_network.beams_geometry\r\n        #Create a list that represents the relations for a directed graph\r\n        #List with weighted edges (a, b, c) a=start vertex b=end vertex c=weight\r\n        directed_edges=[]\r\n        #Iterate nodes\r\n        for node in adjacency_dictionary:\r\n            parent_weight = self.assembly_sequence_network.get_vertex_attribute(node, 'weight')\r\n            #Iterate neighbours of each node\r\n            for nbr in adjacency_dictionary[node]:\r\n                child_weight = self.assembly_sequence_network.get_vertex_attribute(nbr, 'weight') \r\n                parent = [str(nbr), str(node), parent_weight]\r\n                child = [str(node), str(nbr), child_weight]\r\n                if parent_weight > child_weight:\r\n                    directed_edges.append(parent)\r\n                    if child in directed_edges:\r\n                        directed_edges.remove(child)\r\n                else:\r\n                    directed_edges.append(child)\r\n                    if parent in directed_edges:\r\n                        directed_edges.remove(parent)\r\n\r\n        sorted_directed_edges = sorted(directed_edges, key=operator.itemgetter(2))\r\n        self.sorted_directed_edges = sorted_directed_edges[:]\r\n        nodes = map(str, self.assembly_sequence_network.vertices())\r\n        result, beams_parent, building_sequence=kruskal(self.assembly_sequence_network,sorted_directed_edges,nodes,adjacency_dictionary,beams_geometry)\r\n        self.result=result\r\n        self.beams_parent=beams_parent\r\n\r\n        #Correct first values (To be fixed)\r\n        building_sequence.insert(0,[building_sequence[0][0]])\r\n        building_sequence.insert(2,[building_sequence[2][0], building_sequence[2][1], building_sequence[2][2]])\r\n        building_sequence.pop(3)\r\n        self.building_sequence=building_sequence    \r\n\r\n    def assembly_sequence_draw(self):\r\n        result=self.result\r\n        weighted_edges=self.sorted_directed_edges\r\n        #color convention\r\n        color=\"/rdbu8/\"\r\n        #setup\r\n        directed_graph=Digraph(format='png')\r\n        directed_graph.attr(ranksep='7', resolution='80', lheight='1000', lwidth='2000', smoothing='true')\r\n        root=result[0]\r\n        #add Root\r\n        directed_graph.node(root, fontsize='60', width='3', fixedsize='true', shape='circle', label='Beam '+str(root), style='filled', color=color+str(1))#label='beam '+str(root) #Brewer colors http://graphviz.org/doc/info/colors.html#brewer\r\n        #add nodes and edges returned from assembly sequence\r\n        for beams in result:\r\n            weight=self.result_network.get_vertex_attribute(int(beams), 'weight')\r\n            directed_graph.node(beams, fontsize='60', width='3', fixedsize='true', shape='circle', label='Beam '+str(beams), style='filled', color=color+str(weight))#, color='transparent')\r\n\r\n    def get_child_and_parent_data(self, beam_nr_assembly_sequence):\r\n\r\n        #Get TN indexes in sequence\r\n        child_beam_index_TN=int(self.result[beam_nr_assembly_sequence])\r\n        parent_beam_index_TN=self.beams_parent[child_beam_index_TN][0]\r\n        #Get parent and child vertices index in GN\r\n        beam_u_GN, beam_v_GN=get_vertices_index_GN(child_beam_index_TN)\r\n        p_beam_u_GN, p_beam_v_GN=get_vertices_index_GN(parent_beam_index_TN)\r\n        #Get parent and child joint_beam vertices\r\n        parent_other_vertex, parent_joint_vertex, child_other_vertex, child_joint_vertex=get_joint_edge_between_beams(self, p_beam_u_GN, p_beam_v_GN, beam_u_GN, beam_v_GN)\r\n        p_beam_mesh=get_beam_mesh(self, parent_other_vertex, parent_joint_vertex, 'beam')\r\n        ch_beam_mesh=get_beam_mesh(self, child_other_vertex, child_joint_vertex, 'beam')\r\n        #Get parent and child end frames \r\n        parent_end, parent_joint, child_end, child_joint=get_parent_child_frames(self, p_beam_mesh, ch_beam_mesh, parent_other_vertex, parent_joint_vertex, child_other_vertex, child_joint_vertex)\r\n        return p_beam_mesh, ch_beam_mesh, parent_end, parent_joint, child_joint, child_end, parent_other_vertex, parent_joint_vertex, child_joint_vertex, child_other_vertex\r\n\r\n    def beam_nbrs_data(self, beam_TN_index, nbr_1_TN_index, nbr_2_TN_index ):\r\n        #Get vertices index in GN\r\n        beam_u_GN, beam_v_GN=get_vertices_index_GN(beam_TN_index)\r\n        nbr_1_u_GN, nbr_1_v_GN=get_vertices_index_GN(nbr_1_TN_index)\r\n        nbr_2_u_GN, nbr_2_v_GN=get_vertices_index_GN(nbr_2_TN_index)\r\n\r\n    def get_deformed_beam_data(self, beam_nr_assembly_sequence):\r\n        #Get TN indexes in sequence\r\n        child_beam_index_TN=int(self.result[beam_nr_assembly_sequence])\r\n        parent_beam_index_TN=self.beams_parent[child_beam_index_TN][0]\r\n        #Get parent and child vertices index in GN\r\n        beam_u_GN, beam_v_GN=get_vertices_index_GN(child_beam_index_TN)\r\n        p_beam_u_GN, p_beam_v_GN=get_vertices_index_GN(parent_beam_index_TN)\r\n        ch_beam=get_beam_mesh(self, beam_u_GN, beam_v_GN, 'deformed_beam')\r\n        p_beam=get_beam_mesh(self, p_beam_u_GN, p_beam_v_GN, 'deformed_beam')\r\n        return p_beam, ch_beam\r\n\r\n    def propagate_tolerance_middle(self,axial_translation_x_range,axial_translation_y_range,axial_rotation_range):\r\n        #Worse case x=1.410440759 and y=1.813207606\r\n        axial_translation_x_min=axial_translation_x_range[0]\r\n        axial_translation_x_max=axial_translation_x_range[1]\r\n        axial_translation_y_min=axial_translation_y_range[0]\r\n        axial_translation_y_max=axial_translation_y_range[1]\r\n        axial_rotation_min=axial_rotation_range[0]\r\n        axial_rotation_max=axial_rotation_range[1]\r\n\r\n        adjacency_dictionary=self.assembly_sequence_network.adjacency_dictionary\r\n        beams_deformation=[]\r\n\r\n        #World 0,0,0\r\n        origin_frame=Frame([0, 0, 0], [1, 0, 0], [0, 1, 0])\r\n        axial_rotation=Rotation.from_axis_and_angle(origin_frame.zaxis,math.radians(axial_rotation_max))\r\n        neg_axial_rotation=Rotation.from_axis_and_angle(origin_frame.zaxis,math.radians(axial_rotation_min))\r\n        deformed_beams=[]\r\n        ideal_beam_ends=[]\r\n\r\n        for i in range(len(self.result)):\r\n            #Generate a random value in range for each beam\r\n            axial_translation_x=r.uniform(axial_translation_x_min,axial_translation_x_max)\r\n            axial_translation_y=r.uniform(axial_translation_y_min,axial_translation_y_max)\r\n            axial_rotation_value=r.uniform(axial_rotation_min,axial_rotation_max)\r\n            current_beam_index=int(self.result[i])\r\n            current_beam_type=self.assembly_sequence_network.get_vertex_attribute(current_beam_index,'beam_type')\r\n            current_beam_index_AN=self.result[i]\r\n            #If bottom beam\r\n            if current_beam_type==0:\r\n                #Get beam data\r\n                p_beam, ch_beam, parent_end, parent_joint, child_joint, child_end, parent_other_vertex, parent_joint_vertex, child_joint_vertex, child_other_vertex = self.get_child_and_parent_data(i)\r\n\r\n                #Middle frame\r\n                middle_frame_copy=get_middle_frame(ch_beam)\r\n                trans_origin_middle=Frame(middle_frame_copy.point, middle_frame_copy.xaxis, middle_frame_copy.yaxis)\r\n                trans_origin_middle=Transformation.from_frame_to_frame(origin_frame,trans_origin_middle)\r\n                #Beam 0 - End 0\r\n                F1=Frame(child_end.point, child_end.xaxis, child_end.yaxis)\r\n                #Beam 0 - End 1\r\n                F2=Frame(child_joint.point, child_joint.xaxis, child_joint.yaxis)\r\n                #Store deformations in GN edge\r\n                vert_u, vert_v=get_vertices_index_GN(current_beam_index_AN)\r\n                self.set_edge_attribute(vert_u,vert_v,'propagated_frame_u',F2)#Cross section deformation needs to be added later\r\n                self.set_edge_attribute(vert_u,vert_v,'propagated_frame_v',F1)\r\n\r\n                #get beam vertices according to deformation\r\n                pt_0, pt_1, pt_2, pt_3=get_beam_vertices(ch_beam)\r\n                pt_0_mid, int_pt_0=get_point_on_deformed_frames(pt_0,middle_frame_copy,F2,axial_rotation)\r\n                pt_1_mid, int_pt_1=get_point_on_deformed_frames(pt_1,middle_frame_copy,F2,axial_rotation)\r\n                pt_2_mid, int_pt_2=get_point_on_deformed_frames(pt_2,middle_frame_copy,F2,axial_rotation)\r\n                pt_3_mid, int_pt_3=get_point_on_deformed_frames(pt_3,middle_frame_copy,F2,axial_rotation)\r\n                pt_4_mid, int_pt_4=get_point_on_deformed_frames(pt_0,middle_frame_copy,F1,neg_axial_rotation)\r\n                pt_5_mid, int_pt_5=get_point_on_deformed_frames(pt_1,middle_frame_copy,F1,neg_axial_rotation)\r\n                pt_6_mid, int_pt_6=get_point_on_deformed_frames(pt_2,middle_frame_copy,F1,neg_axial_rotation)\r\n                pt_7_mid, int_pt_7=get_point_on_deformed_frames(pt_3,middle_frame_copy,F1,neg_axial_rotation)\r\n\r\n                #Build beam geometry (3pts), sweep shape 1 and 2 (two squares = 4pts, 4 pts)\r\n                deformed_beam_data=[[int_pt_2.point,pt_2_mid,int_pt_6.point],[int_pt_0.point,int_pt_1.point,int_pt_2.point,int_pt_3.point,int_pt_0.point],[int_pt_4.point,int_pt_5.point,int_pt_6.point,int_pt_7.point,int_pt_4.point]]\r\n                deformed_beam=get_rg_deformed_beam(deformed_beam_data)\r\n                #Store deformed beam geometry in Network\r\n                self.set_edge_attribute(vert_u,vert_v,'deformed_beam', deformed_beam)\r\n                #Calculate and store tolerance transferred due to axial rotation\r\n                axial_rotation_shift=calculate_height_from_rotation(axial_rotation_value)\r\n                self.set_edge_attribute(vert_u,vert_v,'axial_rotation_shift', axial_rotation_shift)\r\n                deformed_beams.append(deformed_beam)\r\n            \r\n            #If vertical beam\r\n            elif current_beam_type==2:\r\n                #Get beam data\r\n                p_beam, ch_beam, parent_end, parent_joint, child_joint, child_end, parent_other_vertex, parent_joint_vertex, child_joint_vertex, child_other_vertex = self.get_child_and_parent_data(i)\r\n                #Get neighbours\r\n                connected_vertices=self.assembly_sequence_network.get_vertex_attribute(current_beam_index,'connected_vertices')\r\n                \r\n                #Get connected existing bottom beam\r\n                for connected_beam in connected_vertices:\r\n                    connected_beam_type=self.assembly_sequence_network.get_vertex_attribute(connected_beam,'beam_type')\r\n                    if str(connected_beam) in self.building_sequence[i] and connected_beam_type==0:\r\n                        built_connected_member=connected_beam\r\n\r\n                vert_u, vert_v=get_vertices_index_GN(built_connected_member)\r\n                rotation_tolerance=self.get_edge_attribute(vert_u,vert_v,'axial_rotation_shift')\r\n                #Middle frame\r\n                middle_frame=get_middle_frame(ch_beam)\r\n                #Middle_frame with tolerance\r\n                middle_frame_shifted=Frame(middle_frame.point, middle_frame.xaxis, middle_frame.yaxis)\r\n                shift=translate_frame_own_xyz(Transformation.from_frame(middle_frame_shifted),0,0,-rotation_tolerance)\r\n                middle_frame_shifted.transform(shift)\r\n                F0=Frame(middle_frame.point, middle_frame.xaxis, middle_frame.yaxis)\r\n                #Beam 0 - End 0\r\n                F1=Frame(child_end.point, child_end.xaxis, child_end.yaxis)\r\n                F1_shifted=translate_frame_own_xyz(Transformation.from_frame(F1),axial_translation_x,axial_translation_y,-rotation_tolerance)\r\n                F1.transform(F1_shifted)\r\n                #Beam 0 - End 1\r\n                F2=Frame(child_joint.point, child_joint.xaxis, child_joint.yaxis)\r\n                #Translate end\r\n                F2_shifted=translate_frame_own_xyz(Transformation.from_frame(F2),axial_translation_x,axial_translation_y,-rotation_tolerance)\r\n                F2.transform(F2_shifted)\r\n                \r\n                vert_u, vert_v=get_vertices_index_GN(current_beam_index_AN)\r\n                self.set_edge_attribute(vert_u,vert_v,'propagated_frame_u',F2) #Cross section deformation missing\r\n                self.set_edge_attribute(vert_u,vert_v,'propagated_frame_v',F1) \r\n\r\n                pt_0, pt_1, pt_2, pt_3=get_beam_vertices(ch_beam)\r\n\r\n                #from pt on ideal beam to point on deformed frames\r\n                pt_0_mid, int_pt_0=get_point_on_deformed_frames(pt_0,middle_frame_shifted,F2,axial_rotation)\r\n                pt_1_mid, int_pt_1=get_point_on_deformed_frames(pt_1,middle_frame_shifted,F2,axial_rotation)\r\n                pt_2_mid, int_pt_2=get_point_on_deformed_frames(pt_2,middle_frame_shifted,F2,axial_rotation)\r\n                pt_3_mid, int_pt_3=get_point_on_deformed_frames(pt_3,middle_frame_shifted,F2,axial_rotation)\r\n                pt_4_mid, int_pt_4=get_point_on_deformed_frames(pt_0,middle_frame_shifted,F1,neg_axial_rotation)\r\n                pt_5_mid, int_pt_5=get_point_on_deformed_frames(pt_1,middle_frame_shifted,F1,neg_axial_rotation)\r\n                pt_6_mid, int_pt_6=get_point_on_deformed_frames(pt_2,middle_frame_shifted,F1,neg_axial_rotation)\r\n                pt_7_mid, int_pt_7=get_point_on_deformed_frames(pt_3,middle_frame_shifted,F1,neg_axial_rotation)\r\n\r\n                #Ends polyline\r\n                def_face_1_polyline=[int_pt_0.point,int_pt_1.point,int_pt_2.point,int_pt_3.point,int_pt_0.point]\r\n                def_face_2_polyline=[int_pt_4.point,int_pt_5.point,int_pt_6.point,int_pt_7.point,int_pt_4.point]\r\n\r\n                #Store rail1 (3pts), sweep shape 1 and 2 (two squares = 4pts, 4 pts)\r\n                deformed_beam_data=[[int_pt_2.point,pt_2_mid,int_pt_6.point], def_face_1_polyline, def_face_2_polyline]\r\n                #Build beam geometry\r\n                deformed_beam=get_rg_deformed_beam(deformed_beam_data)\r\n                #Store beam geometry\r\n                self.set_edge_attribute(vert_u,vert_v,'deformed_beam', deformed_beam)\r\n                #Store accumulated tolerance\r\n                self.set_edge_attribute(vert_u,vert_v,'axial_rotation_shift',rotation_tolerance)\r\n                deformed_beams.append(deformed_beam)\r\n\r\n                #Get ideal beam ends (to be function later)\r\n                axial_rotation_NULL=Rotation.from_axis_and_angle(origin_frame.zaxis,math.radians(0))\r\n                F3=Frame(child_end.point, child_end.xaxis, child_end.yaxis)\r\n                F4=Frame(child_joint.point, child_joint.xaxis, child_joint.yaxis)\r\n                #project middle points on ideal end planes\r\n                pt_0_mid, int_pt_0=get_point_on_deformed_frames(pt_0,middle_frame,F3,axial_rotation_NULL)\r\n                pt_1_mid, int_pt_1=get_point_on_deformed_frames(pt_1,middle_frame,F3,axial_rotation_NULL)\r\n                pt_2_mid, int_pt_2=get_point_on_deformed_frames(pt_2,middle_frame,F3,axial_rotation_NULL)\r\n                pt_3_mid, int_pt_3=get_point_on_deformed_frames(pt_3,middle_frame,F3,axial_rotation_NULL)\r\n                pt_4_mid, int_pt_4=get_point_on_deformed_frames(pt_0,middle_frame,F4,axial_rotation_NULL)\r\n                pt_5_mid, int_pt_5=get_point_on_deformed_frames(pt_1,middle_frame,F4,axial_rotation_NULL)\r\n                pt_6_mid, int_pt_6=get_point_on_deformed_frames(pt_2,middle_frame,F4,axial_rotation_NULL)\r\n                pt_7_mid, int_pt_7=get_point_on_deformed_frames(pt_3,middle_frame,F4,axial_rotation_NULL)\r\n\r\n                \r\n                ideal_face_1_polyline=[int_pt_0.point,int_pt_1.point,int_pt_2.point,int_pt_3.point,int_pt_0.point]\r\n                ideal_face_2_polyline=[int_pt_4.point,int_pt_5.point,int_pt_6.point,int_pt_7.point,int_pt_4.point]\r\n\r\n                if rs.Distance(def_face_1_polyline[0],ideal_face_1_polyline[0]) < 1000:\r\n                    crvs=[rs.AddPolyline(def_face_1_polyline), rs.AddPolyline(ideal_face_1_polyline)]\r\n                    tolerance_srf_1=rs.AddLoftSrf(crvs, None, None, 0, 0, 0, False)\r\n                    ideal_beam_ends.extend(tolerance_srf_1)\r\n                else:\r\n                    crvs=[rs.AddPolyline(def_face_1_polyline), rs.AddPolyline(ideal_face_2_polyline)]\r\n                    tolerance_srf_1=rs.AddLoftSrf(crvs, None, None, 0, 0, 0, False)\r\n                    ideal_beam_ends.extend(tolerance_srf_1)\r\n\r\n                if rs.Distance(def_face_2_polyline[0],ideal_face_1_polyline[0]) < 1000:\r\n                    crvs=[rs.AddPolyline(def_face_2_polyline), rs.AddPolyline(ideal_face_1_polyline)]\r\n                    tolerance_srf_2=rs.AddLoftSrf(crvs, None, None, 0, 0, 0, False)\r\n                    ideal_beam_ends.extend(tolerance_srf_2)\r\n\r\n                else:\r\n                    crvs=[rs.AddPolyline(def_face_2_polyline), rs.AddPolyline(ideal_face_2_polyline)]\r\n                    tolerance_srf_2=rs.AddLoftSrf(crvs, None, None, 0, 0, 0, False)\r\n                    ideal_beam_ends.extend(tolerance_srf_2)\r\n\r\n                self.ideal_beam_ends=ideal_beam_ends\r\n\r\n            #If top cord beam\r\n            elif current_beam_type==1:\r\n\r\n                #Get beam data\r\n                p_beam, ch_beam, parent_end, parent_joint, child_joint, child_end, parent_other_vertex, parent_joint_vertex, child_joint_vertex, child_other_vertex = self.get_child_and_parent_data(i)\r\n                current_beam_index=int(self.result[i])\r\n\r\n                #Get neighbours\r\n                connected_vertices=set(self.assembly_sequence_network.get_vertex_attribute(current_beam_index,'connected_vertices'))\r\n\r\n                #Get built and connected vertical beams\r\n                built_connected_members=[]\r\n                for connected_vertex in connected_vertices:\r\n                    beam_type=self.assembly_sequence_network.get_vertex_attribute(connected_vertex,'beam_type')\r\n                    if str(connected_vertex) in self.building_sequence[i] and beam_type==2:\r\n                        built_connected_members.append(connected_vertex)\r\n                \r\n                #Get rotation from connected vertical beams \r\n                rotation_tolerance=[]\r\n                for built_connected_member in built_connected_members:\r\n                    vert_u, vert_v=get_vertices_index_GN (built_connected_member)\r\n                    axial_rotation_shift=self.get_edge_attribute(vert_u,vert_v,'axial_rotation_shift')\r\n                    rotation_tolerance.append(axial_rotation_shift)\r\n\r\n                #Middle frame\r\n                middle_frame=get_middle_frame(ch_beam)\r\n                F0=Frame(middle_frame.point, middle_frame.xaxis, middle_frame.yaxis)\r\n\r\n                #Beam End 0\r\n                F1=Frame(child_end.point, child_end.xaxis, child_end.yaxis)\r\n                F1_shifted=translate_frame_own_xyz(Transformation.from_frame(F1),axial_translation_x+(rotation_tolerance[1]*1.8),axial_translation_y,0)\r\n                F1.transform(F1_shifted)\r\n\r\n                #Beam End 1\r\n                F2=Frame(child_joint.point, child_joint.xaxis, child_joint.yaxis)\r\n                F2_shifted=translate_frame_own_xyz(Transformation.from_frame(F2),axial_translation_x+(rotation_tolerance[1]*1.8),axial_translation_y,0)\r\n                F2.transform(F2_shifted)\r\n                \r\n                #Store ends deformations\r\n                vert_u, vert_v=get_vertices_index_GN(current_beam_index_AN) \r\n                self.set_edge_attribute(vert_u,vert_v,'propagated_frame_u',F2)#Cross section deformation missing\r\n                self.set_edge_attribute(vert_u,vert_v,'propagated_frame_v',F1)\r\n\r\n                pt_0, pt_1, pt_2, pt_3=get_beam_vertices(ch_beam)\r\n\r\n                #from pt on ideal beam to point on deformed frames\r\n                pt_0_mid, int_pt_0=get_point_on_deformed_frames(pt_0,middle_frame,F2,axial_rotation)\r\n                pt_1_mid, int_pt_1=get_point_on_deformed_frames(pt_1,middle_frame,F2,axial_rotation)\r\n                pt_2_mid, int_pt_2=get_point_on_deformed_frames(pt_2,middle_frame,F2,axial_rotation)\r\n                pt_3_mid, int_pt_3=get_point_on_deformed_frames(pt_3,middle_frame,F2,axial_rotation)\r\n                pt_4_mid, int_pt_4=get_point_on_deformed_frames(pt_0,middle_frame,F1,neg_axial_rotation)\r\n                pt_5_mid, int_pt_5=get_point_on_deformed_frames(pt_1,middle_frame,F1,neg_axial_rotation)\r\n                pt_6_mid, int_pt_6=get_point_on_deformed_frames(pt_2,middle_frame,F1,neg_axial_rotation)\r\n                pt_7_mid, int_pt_7=get_point_on_deformed_frames(pt_3,middle_frame,F1,neg_axial_rotation)\r\n\r\n                #Store rail1 (3pts), sweep shape 1 and 2 (two squares = 4pts, 4 pts)\r\n                deformed_beam_data=[[int_pt_2.point,pt_2_mid,int_pt_6.point],[int_pt_0.point,int_pt_1.point,int_pt_2.point,int_pt_3.point,int_pt_0.point],[int_pt_4.point,int_pt_5.point,int_pt_6.point,int_pt_7.point,int_pt_4.point]]\r\n                \r\n                #Build beam geometry\r\n                deformed_beam=get_rg_deformed_beam(deformed_beam_data)\r\n                deformed_beams.append(deformed_beam)\r\n\r\n        #Display tolerances in RH\r\n        self.deformed=deformed_beams\r\n        \r\n        #Generate and store insertion poses\r\n        calculate_insertion_poses(self)\r\n\r\n    def display_collisions_stepwise(self):\r\n        #Store deformed beams in assembled beams\r\n        display_built_structure=[]\r\n        display_built_structure.append([None])\r\n        counter=0\r\n\r\n        for i in range(len(self.result)):\r\n            counter+=1\r\n            beam_meshes_in_step=[]\r\n            for beam_index in range(counter):\r\n                built_beam=self.get_deformed_beam_data(int(beam_index))[1]\r\n                beam_meshes_in_step.append(built_beam)\r\n            display_built_structure.append(beam_meshes_in_step)\r\n        self.display_built_structure=display_built_structure        \r\n        \r\n#Network to generate assembly sequence\r\nclass AssemblySequenceNetwork (Network):\r\n    def __init__(self, geometry_network, weights_list, beams_geometry):\r\n        super(AssemblySequenceNetwork, self).__init__() \r\n        input_dict = {'edges': geometry_network.edges(data=True)}\r\n        self.attributes.update(input_dict)\r\n        self.beams_geometry=beams_geometry\r\n        self.invert_network(weights_list)\r\n\r\n    def invert_network (self, weights_list):\r\n        #to translate from member being an edge to member being a vertex \r\n        #only the u value of each member is used and divided by 2.\r\n        #thus it turns from being (u=0,u=2,u=4...) to (u=0,u=1,u=2...) \r\n        #iter member edges of geometry network\r\n        for u,v,attr in self.attributes['edges']:\r\n            if attr['edge_type']=='member':\r\n                #get midpoint for each member edge of geometry network\r\n                beam_edge_mid=midpoint_line((attr['u_coordinate'],attr['v_coordinate']))\r\n                #create new vertex and use as coordinate the midpoint of u and v\r\n                self.add_vertex(attr_dict={'x': beam_edge_mid[0], 'y' : beam_edge_mid[1], 'z' : beam_edge_mid[2]})#add beam_vertex\r\n\r\n        #create adjacency dictionary\r\n        adjacency_dict={}\r\n        for u,v,attr in self.attributes['edges']:\r\n            if attr['edge_type']=='member':\r\n                temp_connected_vertex=[]\r\n                #iter connected member edges of geometry network\r\n                for connected_vertices in attr['member_edge_nbrs']:\r\n                    #store connected member as its u value divided by 2 \r\n                    temp_connected_vertex.append(connected_vertices[0]/2)\r\n                adjacency_dict[u/2]=temp_connected_vertex\r\n        #prepare adjacency dictionary for COMPAS traverse\r\n        self.adjacency_dictionary=adjacency_dict\r\n        #add adjacency and weight attribute to vertices\r\n        for u, attr in self.vertices(data=True):\r\n            self.set_vertex_attribute(u,'weight', weights_list[u])\r\n            self.set_vertex_attribute(u,'connected_vertices', adjacency_dict[u])\r\n\r\nif __name__ == \"__main__\":\r\n    temp_frames_array = [] \r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}