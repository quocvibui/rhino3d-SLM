{
  "source_url": "https://github.com/createchaos/abb_communication/blob/740ea3c6bf93b9b0d03e63a6d56ee8ad748e4e38/src/abb_communication/holder.py",
  "repo": "createchaos/abb_communication",
  "repo_stars": 3,
  "repo_description": "communication library for abb robot control",
  "license": "NOASSERTION",
  "filepath": "src/abb_communication/holder.py",
  "instruction": ". . . . . . . . . . . . . . . . . .\r\n.                                 .\r\n.   <<><><>    <<><><>  <<        .\r\n.   <<    ><   <<       <<        .\r\n.   <<><><>    <<><><   <<        .\r\n.   <<  ><    ...",
  "code": "'''\r\n. . . . . . . . . . . . . . . . . .\r\n.                                 .\r\n.   <<><><>    <<><><>  <<        .\r\n.   <<    ><   <<       <<        .\r\n.   <<><><>    <<><><   <<        .\r\n.   <<  ><     <<       <<        .\r\n.   <<   <>    <<       <<        .\r\n.   <<    ><   <<       <<><><>   .\r\n.                                 .\r\n.             GKR 2016/17         .\r\n. . . . . . . . . . . . . . . . . .\r\n\r\nCreated on 09.12.2016\r\n\r\n\r\n@author: kathrind, stefanap\r\n'''\r\n\r\nfrom compas.geometry import Frame\r\n\r\nfrom client_container import ClientContainer\r\nfrom messages.messagetypes import MSG_CURRENT_POSE_CARTESIAN, MSG_CURRENT_POSE_JOINT, MSG_CURRENT_POSE_CARTESIAN_BASE, MSG_COMMAND, MSG_STOP\r\nfrom messages.messagetypes import CMD_PICK_ROD, CMD_MILL_ROD_END, CMD_MILL_ROD_START, CMD_REGRIP_PLACE, CMD_REGRIP_PICK, CMD_SAFE_POS, CMD_OPEN_GRIPPER, CMD_CLOSE_GRIPPER, CMD_OPEN_CLAMP\r\nfrom messages.messagetypes import CMD_GO_TO_TASKTARGET, CMD_GO_TO_TASKTARGET_JOINTS, CMD_GO_TO_JOINTTARGET_ABS, CMD_GO_TO_JOINTTARGET_REL, CMD_PICK_BRICK, CMD_PLACE_BRICK, CMD_PICK_BRICK_FROM_POSE\r\nfrom messages.messagetypes import CMD_STU_PICK, CMD_STU_PLACE_1, CMD_STU_PLACE_2\r\nfrom messages.messagetypes import CMD_MAS_PICK, CMD_MAS_PLACE, CMD_MAS_PICK_MAGAZINE, CMD_MAS_PLACE_MAGAZINE, CMD_LWS_DYNAMIC_PICKUP, CMD_RAPID_STOP, CMD_PULSEDO\r\nfrom messages.messagetypes import CMD_SENDMOVELRELTOOL, CMD_COORDINATED_GANTRY_MOVE, CMD_SET_SPEED_INPUT\r\n\r\nimport time\r\nimport Rhino.Geometry as rg\r\nimport math as m\r\n\r\n\r\n\r\nclass ABBCommunication(ClientContainer):\r\n    \"\"\" The class ABBComm extends the Clientcontainer class.\r\n    It can send and receive data from the ABB arm\r\n\r\n    \"\"\"\r\n\r\n    def __init__(self, identifier, host='127.0.0.1', port_snd=30003, port_rcv=30004, ghenv = None):\r\n        ClientContainer.__init__(self,  identifier, host, port_snd, port_rcv, ghenv = ghenv)\r\n\r\n        \" create \"\r\n        self.tool_frame = Frame([0, 0, 0], [1, 0, 0], [0, 1, 0])\r\n\r\n        # init values for command messages\r\n        self.int_speed = 0 # speed: 0 = slow, 1 = mid, 2 = fast\r\n        self.float_duration = 0 #duration is not used, use velocity instead\r\n        self.int_zonedata = 10 # zonedata: in mm\r\n        self.int_tool = 0 # toolnumber: 0 = tool0, 1 = vacgrip_vert, 2 = hokuyo\r\n        self.int_wobj = 0 # wobjnumber: 0 = wobj0, 1 = wobj_common, 2 = wobj_base\r\n        # self.int_rob_num = 0\r\n        self.float_arbitrary = 0 #robot number to access\r\n\r\n        # home positions cartesian - to change!!!!! - stefana\r\n        self.tool_plane_home_mid = rg.Plane(rg.Point3d(1000,0,650), rg.Vector3d(1,0,0), rg.Vector3d(0,-1,0))\r\n        self.tool_plane_home_left = rg.Plane(rg.Point3d(-665.507, 629.086, 720.0), rg.Vector3d(-1,0,0), rg.Vector3d(0,1,0))\r\n\r\n        # home positions joint targets - to change!!!! - stefana\r\n        self.jointtarget_home_zero = [0,0,0,0,0,0]\r\n        self.jointtarget_home_pickbrick = [130.9, -56.8, 58.3, 7.4, 30.1, 51.9]\r\n\r\n        ##################################### changed stefana #########################################\r\n        self.current_joint_values = [0,0,0,0,0,0,0,0,0]\r\n        self.current_tool0_pose = [0,0,0,0,0,0,0,0,0,0]\r\n        #self.ghComp = None\r\n        self.debug_print = []\r\n        ###############################################################################################\r\n    # =================================================================================\r\n    # robot convert plane to frame\r\n    # =================================================================================\r\n    # =================================================================================\r\n    def get_pose(self, input):\r\n        if isinstance(input, rg.plane):\r\n            frame = Frame(input.Origin, input.XAxis, input.YAxis)\r\n            pose = frame.point.data + frame.quaternion.wxyz\r\n        else:\r\n            pose = input.point.data + input.quaternion.wxyz\r\n        return pose\r\n    # =================================================================================\r\n    # robot tool\r\n    # =================================================================================\r\n    # =================================================================================\r\n    def set_tool_to_plane(self, plane):\r\n        \"\"\" move the base to a plane position \"\"\"\r\n        self.tool_frame.set_to_plane(plane)\r\n    # =================================================================================\r\n    def get_tool_plane(self):\r\n        \"\"\" return the plane of the baseframe \"\"\"\r\n        return self.tool_frame.plane\r\n    # =================================================================================\r\n    def get_tool_tmatrix_from(self):\r\n        \"\"\" return the transformation matrix (Transform class of Rhino) of the baseframe to the origin \"\"\"\r\n        return self.tool_frame.get_tmatrix_from()\r\n    # =================================================================================\r\n    def get_tool_tmatrix_to(self):\r\n        \"\"\" return the transformation matrix (Transform class of Rhino) of the origin to the baseframe \"\"\"\r\n        return self.tool_frame.get_tmatrix_to()\r\n\r\n\r\n    # =================================================================================\r\n    # receive robot info from queues\r\n    # =================================================================================\r\n    # =================================================================================\r\n\r\n    def get_current_pose_cartesian(self):\r\n        \"\"\" get the current tool pose from the queue and set the tool_frame according to the pose \"\"\"\r\n        msg_current_pose_cart = self.get_from_rcv_queue(MSG_CURRENT_POSE_CARTESIAN)\r\n        if msg_current_pose_cart <= None:\r\n            pose = msg_current_pose_cart[1]\r\n            self.current_tool0_pose = pose\r\n            #self.tool_frame.set_to_pose(pose)\r\n            return pose\r\n        else:\r\n            return None\r\n\r\n    # =================================================================================\r\n    def get_current_pose_cartesian_base(self):\r\n        \"\"\" get the current tool pose from the queue in robot base coordinate system and set the tool_frame according to the pose \"\"\"\r\n        msg_current_pose_cart_base = self.get_from_rcv_queue(MSG_CURRENT_POSE_CARTESIAN_BASE)\r\n        if msg_current_pose_cart_base <= None:\r\n            pose = msg_current_pose_cart_base[1]\r\n            self.current_tool0_pose = pose\r\n            #self.tool_frame.set_to_pose(pose)\r\n            return pose\r\n        else:\r\n            return None\r\n\r\n    # =================================================================================\r\n    def get_current_pose_joint(self):\r\n        \"\"\" get the current tool pose from the queue and set the tool_frame according to the pose \"\"\"\r\n        msg_current_pose_joint = self.get_from_rcv_queue(MSG_CURRENT_POSE_JOINT)\r\n        if msg_current_pose_joint <= None:\r\n            pose_joint = msg_current_pose_joint[1]\r\n            self.current_joint_values = [m.degrees(pj) for pj in pose_joint]\r\n            return pose_joint\r\n        else:\r\n            return None\r\n\r\n\r\n    # =================================================================================\r\n    # send robot commands\r\n    # =================================================================================\r\n    # =================================================================================\r\n    def send_stop(self, int_arr = None):\r\n        \"\"\" send stop to robot \"\"\"\r\n        pose = [0,0,0,0,0,0,0,0,0,0]\r\n        if int_arr == None:\r\n            cmd = [CMD_RAPID_STOP] + pose + [0, 0, 0, 0, self.float_arbitrary, 0]\r\n        else:\r\n            cmd = [CMD_RAPID_STOP] + pose + int_arr\r\n        self.send(MSG_COMMAND, cmd)\r\n\r\n    # =================================================================================\r\n    def send_single_move_command(self, input, ext_axes, num_cmd, int_arr = None):\r\n        \"\"\" create command from plane, frame or joint values and send to robot\r\n        num_cmd = number of command in rapid\r\n        \"\"\"\r\n\r\n        if isinstance(input, list):\r\n            if len(input)==6:\r\n                pose_axes = input + ext_axes + [0]\r\n            else:\r\n                print( \"length of input not correct\")\r\n        else:\r\n            pose = get_pose(self, input)\r\n            pose_axes = pose + ext_axes\r\n            self.debug_print = pose_axes\r\n\r\n        if int_arr == None:\r\n            cmd = [num_cmd] + pose_axes + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary, self.int_wobj]\r\n        else:\r\n            cmd = [num_cmd] + pose_axes + int_arr\r\n\r\n        self.send(MSG_COMMAND, cmd)\r\n        return cmd\r\n\r\n    # =================================================================================\r\n    def send_pose_cartesian(self, input, ext_axes_in = [100000, 100000, 100000], int_arr=None):\r\n        \"\"\" create command from plane or frame and send task target to robot,\r\n        int_arr can be defined outside, or if None, default values are sent.\r\n        int_arr = [int_speed, float_duration, int_zonedata, int_tool, float_arbitrary, int_wobj]\r\n        ext_axes values are optional, either in list format or as single float value for only one axis\"\"\"\r\n\r\n        pose = get_pose(self, input)\r\n\r\n\r\n        if type(ext_axes_in)==list or type(ext_axes_in)==tuple:\r\n            if len(ext_axes_in)==1:\r\n                ext_axes = [ext_axes_in[0], 0, 0]\r\n            elif len(ext_axes_in)==2:\r\n                ext_axes = [ext_axes_in[0], ext_axes_in[1], 0]\r\n            else:\r\n                ext_axes = ext_axes_in\r\n        else:\r\n            print (\"wrong data type for external axes value\")\r\n\r\n        if int_arr == None:\r\n            cmd = [CMD_GO_TO_TASKTARGET] + pose + ext_axes + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary, self.int_wobj]\r\n        else:\r\n            cmd = [CMD_GO_TO_TASKTARGET] + pose + ext_axes + int_arr\r\n\r\n        self.send(MSG_COMMAND, cmd)\r\n        return cmd\r\n\r\n    # =================================================================================\r\n    def send_pose_cartesian_joints(self, input, ext_axes_in = [100000, 100000, 100000], int_arr=None):\r\n        \"\"\" create command from plane or frame and send task target to robot,\r\n        int_arr can be defined outside, or if None, default values are sent.\r\n        int_arr = [int_speed, float_duration, int_zonedata, int_tool, float_arbitrary, int_wobj]\r\n        ext_axes values are optional, either in list format or as single float value for only one axis\"\"\"\r\n\r\n        pose = get_pose(self, input)\r\n\r\n        if type(ext_axes_in) == list or type(ext_axes_in) == tuple:\r\n            if len(ext_axes_in) == 1:\r\n                ext_axes = [ext_axes_in[0], 0, 0]\r\n            elif len(ext_axes_in) == 2:\r\n                ext_axes = [ext_axes_in[0], ext_axes_in[1], 0]\r\n            else:\r\n                ext_axes = ext_axes_in\r\n        else:\r\n            print(\"wrong data type for external axes value\")\r\n\r\n        if int_arr == None:\r\n            cmd = [CMD_GO_TO_TASKTARGET_JOINTS] + pose + ext_axes + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary, self.int_wobj]\r\n        else:\r\n            cmd = [CMD_GO_TO_TASKTARGET_JOINTS] + pose + ext_axes + int_arr\r\n\r\n        self.send(MSG_COMMAND, cmd)\r\n        return cmd\r\n\r\n    # =================================================================================\r\n    def send_pose_quat(self, pose, ext_axes_in=[100000, 100000, 100000], int_arr=None):\r\n        \"\"\" create command from pose quaternions and send task target to robot,\r\n        int_arr can be defined outside, or if None, default values are sent.\r\n        int_arr = [int_speed, float_duration, int_zonedata, int_tool, float_arbitrary, int_wobj]\r\n        ext_axes values are optional, either in list format or as single float value for only one axis\"\"\"\r\n\r\n        if type(ext_axes_in) == list or type(ext_axes_in) == tuple:\r\n            if len(ext_axes_in) == 1:\r\n                ext_axes = [ext_axes_in[0], 0, 0]\r\n            elif len(ext_axes_in) == 2:\r\n                ext_axes = [ext_axes_in[0], ext_axes_in[1], 0]\r\n            else:\r\n                ext_axes = ext_axes_in\r\n        else:\r\n            print (\"wrong data type for external axes value\")\r\n\r\n        if int_arr == None:\r\n            cmd = [CMD_GO_TO_TASKTARGET] + pose + ext_axes + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary, self.int_wobj]\r\n        else:\r\n            cmd = [CMD_GO_TO_TASKTARGET] + pose + ext_axes + int_arr\r\n\r\n        self.send(MSG_COMMAND, cmd)\r\n        return cmd\r\n\r\n    # =================================================================================\r\n    def send_pose_cartesian_list(self, inputs, ext_axes_in=None, int_arr=None):\r\n        \"\"\" create command from planes or frames and send task targets to robot,\r\n        int_arr can be defined outside, or if None, default values are sent.\r\n        int_arr = [int_speed, float_duration, int_zonedata, int_tool, float_arbitrary] \"\"\"\r\n\r\n        #####################################add case with single value list ####################################################\r\n\r\n        ext_axes_list = []\r\n        if ext_axes_in == None:\r\n            for i, input in enumerate(inputs):\r\n                ext_axes_list.append([100000, 100000, 100000])\r\n        elif type(ext_axes_in) == list or type(ext_axes_in) == tuple:\r\n            if type(ext_axes_in[0]) == list or type(ext_axes_in[0]) == tuple:\r\n                for i, inputs in enumerate(inputs):\r\n                    if len(ext_axes_in[i])==1:\r\n                        ext_axes_list.append([ext_axes_in[i][0], 100000, 100000])\r\n                    elif len(ext_axes_in[i])==2:\r\n                        ext_axes_list.append([ext_axes_in[i][0], ext_axes_in[i][1], 100000])\r\n                    elif len(ext_axes_in[i])==3:\r\n                        ext_axes_list.append([ext_axes_in[i][0], ext_axes_in[i][1], ext_axes_in[i][2]])\r\n                    else:\r\n                        print( \"too many values for external axes (maximum number = 3)\")\r\n            else:\r\n                for i, input in enumerate(inputs):\r\n                    if len(ext_axes_in) == 1:\r\n                        ext_axes_list.append([ext_axes_in[0], 100000, 100000])\r\n                    elif len(ext_axes_in) == 2:\r\n                        ext_axes_list.append(\r\n                            [ext_axes_in[0], ext_axes_in[1], 100000])\r\n                    elif len(ext_axes_in) == 3:\r\n                        ext_axes_list.append(\r\n                            [ext_axes_in[0], ext_axes_in[1], ext_axes_in[2]])\r\n                    else:\r\n                        print(\"too many values for external axes (maximum number = 3)\")\r\n        else:\r\n            print(\"wrong data type for external axes value - list required\")\r\n\r\n        for i, input in enumerate(inputs):\r\n            self.send_pose_cartesian(input, ext_axes_list[i], int_arr)\r\n\r\n        # =================================================================================\r\n\r\n    def send_pose_cartesian_joints_list(self, planes, ext_axes_list, int_arr=None):\r\n        \"\"\" create command from plane and send task target to robot,\r\n        int_arr can be defined outside, or if None, default values are sent.\r\n        int_arr = [int_speed, float_duration, int_zonedata, int_tool, float_arbitrary] \"\"\"\r\n\r\n        for i, plane in enumerate (planes):\r\n            self.send_pose_cartesian_joints(plane, ext_axes_list[i], int_arr)\r\n\r\n    # =================================================================================\r\n    def send_axes_relative(self, axes, int_arr=None):\r\n        \"\"\" relative joint axes commands for the abb arm \"\"\"\r\n        if int_arr:\r\n            cmd = [CMD_GO_TO_JOINTTARGET_REL] + axes + [0] + int_arr\r\n        else:\r\n            cmd = [CMD_GO_TO_JOINTTARGET_REL] + axes + [0] + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary, self.int_wobj]\r\n\r\n        self.send(MSG_COMMAND, cmd)\r\n        return cmd\r\n    # =================================================================================\r\n    def send_axes_absolute(self, axes, int_arr=None):\r\n        \"\"\" absolute joint axes commands for the arm \"\"\"\r\n        if int_arr:\r\n            cmd = [CMD_GO_TO_JOINTTARGET_ABS] + axes + [0] + int_arr\r\n        else:\r\n            cmd = [CMD_GO_TO_JOINTTARGET_ABS] + axes + [0] + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary, 0]\r\n        self.send(MSG_COMMAND, cmd)\r\n\r\n    # =================================================================================\r\n    def send_axes_absolute_list(self, axes_list, int_arr=None):\r\n        \"\"\" absolute joint axes commands for the arm \"\"\"\r\n\r\n        for axes in axes_list:\r\n            if int_arr:\r\n                cmd = [CMD_GO_TO_JOINTTARGET_ABS] + axes + [0] + int_arr\r\n            else:\r\n                cmd = [CMD_GO_TO_JOINTTARGET_ABS] + axes + [0] + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary, 0]\r\n            self.send(MSG_COMMAND, cmd)\r\n\r\n    # =================================================================================\r\n    def send_movel_relrool(self, offset_axis_X, offset_axis_Y, offset_axis_Z, int_arr = None):\r\n        \" send command for opening gripper through DO\"\r\n        pose = [offset_axis_X, offset_axis_Y, offset_axis_Z, 0,0,0,0,0,0,0]\r\n        if int_arr == None:\r\n            cmd = [CMD_SENDMOVELRELTOOL] + pose + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary, 0]\r\n        else:\r\n            cmd = [CMD_SENDMOVELRELTOOL] + pose + int_arr\r\n        self.send(MSG_COMMAND, cmd)\r\n\r\n    # =================================================================================\r\n    def send_coordinated_gantry_move(self, pose, ext_axes, int_arr=None):\r\n        \"\"\"coordinated movement of two robots on a gantry.\r\n        Send the same procedure to both robots at the same time, and they will sync their movements.\r\n        Important: send the same X ganrty value!\"\"\"\r\n        if int_arr == None:\r\n            cmd = [CMD_COORDINATED_GANTRY_MOVE] + pose + ext_axes + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary, 0]\r\n        else:\r\n            cmd = [CMD_COORDINATED_GANTRY_MOVE] + pose + ext_axes + int_arr\r\n\r\n        print (\"send_coordinated_gantry_move sent to Rapid!\"), CMD_COORDINATED_GANTRY_MOVE\r\n        self.send(MSG_COMMAND, cmd)\r\n\r\n    # =================================================================================\r\n    def send_pose_cartesian_home(self, int_arr=None):\r\n        \"\"\" send the \"home\" position as task target as defined in init \"\"\"\r\n        self.send_pose_cartesian(self.tool_plane_home_mid, int_arr)\r\n\r\n    # =================================================================================\r\n    def send_pose_joint_home(self, int_arr=None):\r\n        \"\"\" send the \"home\" position as jointtarget as defined in init \"\"\"\r\n        self.send_axes_absolute(self.jointtarget_home_zero, int_arr)\r\n\r\n    # =================================================================================\r\n    def send_pose_joint_pick_brick(self, int_arr=None):\r\n        \"\"\" send the \"home\" position as jointtarget as defined in init \"\"\"\r\n        self.send_axes_absolute(self.jointtarget_home_pickbrick, int_arr)\r\n\r\n    # =================================================================================\r\n    def send_pick_brick_from_pose(self, plane, int_arr=None):\r\n        \"\"\" send a command for picking up the material and go to the given plane or frame\r\n        sequence:\r\n        1. drive from actual pos to pick up the brick at the given plane\r\n        (== >> this routine is defined in RobotStudio, the command consist only out of the pick-up plane.\r\n        \"\"\"\r\n\r\n        pose = get_pose(self, input)\r\n\r\n        if int_arr == None:\r\n            cmd = [CMD_PICK_BRICK_FROM_POSE] + pose + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary, self.int_wobj]\r\n        else:\r\n            cmd = [CMD_PICK_BRICK_FROM_POSE] + pose + int_arr\r\n        self.send(MSG_COMMAND, cmd)\r\n\r\n    # =================================================================================\r\n    def send_pick_brick_from_feed(self, fullbrick = True, int_arr=None):\r\n        \"\"\" send a command for picking up the material and go to the given plane sequence:\r\n        1. drive from actual pos to the homeposition, defined as jointtarget, on the left side of the robot.\r\n        2. go on the trajectory to pick up a brick from the feeder and drive back to the homeposition\r\n        == >> this routine is defined in RobotStudio, the command consist only out of the homeposition.\r\n        cmd = [CMD_PICK_BRICK, joints, int_speed, float_duration, int_zonedata, int_tool, float_arbitrary] float_arbitrary => 0 = fullbrick  / 1 = halfbrick\r\n        \"\"\"\r\n\r\n        jointpose = self.jointtarget_home_pickbrick\r\n        float_arbitrary = 0 if fullbrick == True else 1 #this parameter has to read in Rapid, to either pick a fullbrick or a halfbrick\r\n\r\n        if int_arr == None:\r\n            cmd = [CMD_PICK_BRICK] + jointpose + [0] + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, float_arbitrary, self.int_wobj]\r\n        else:\r\n            cmd = [CMD_PICK_BRICK] + jointpose + [0] + int_arr\r\n\r\n        self.send(MSG_COMMAND, cmd)\r\n\r\n    # =================================================================================\r\n    def send_place_brick(self, input, send_pick_brick_from_feed = True, fullbrick = True, int_arr = None):\r\n        \"\"\" send a command for placing the material at the given plane or frame\r\n        sequence:\r\n        1. drive to home_pos, pick a brick and drive back to homepos\r\n        1. drive from home pos to the a point 20 cm above the given plane\r\n        2. go on the trajectory to place the brick and drive back to a point 20 cm above the given plane\r\n        == >> this routine is defined in RobotStudio, and is defined\r\n        cmd = [x,y,z,q1,q2,q3,q4,int_speed, int_zonedata, int_proc] int_proc = 3 = place the brick\r\n\r\n        cmd = [CMD_PICK_BRICK, robtarget, int_speed, float_duration, int_zonedata, int_tool, float_arbitrary]\r\n        \"\"\"\r\n        if send_pick_brick_from_feed:\r\n            self.send_pick_brick_from_feed(fullbrick, int_arr)\r\n\r\n        pose = get_pose(self, input)\r\n\r\n\r\n        if int_arr == None:\r\n            cmd = [CMD_PLACE_BRICK] + pose + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary, self.int_wobj]\r\n        else:\r\n            cmd = [CMD_PLACE_BRICK] + pose + int_arr\r\n\r\n        self.send(MSG_COMMAND, cmd)\r\n\r\n\r\n    # =================================================================================\r\n    def set_home_pos_left_to_origin(self):\r\n        self.tool_plane_home_left = rg.Plane(rg.Point3d(-665.507, 629.086, 720.0), rg.Vector3d(-1,0,0), rg.Vector3d(0,1,0))\r\n\r\n    # =================================================================================\r\n    def get_home_pos_left(self):\r\n        return self.tool_plane_home_left\r\n\r\n    # =================================================================================\r\n    def get_home_pos_left_for_180(self):\r\n        plane = rg.Plane(self.get_home_pos_left())\r\n        plane.Translate(rg.Vector3d(1200,0,0))\r\n        plane.Rotate(m.radians(180), plane.ZAxis, plane.Origin)\r\n        return plane\r\n\r\n    # =================================================================================\r\n    # functions Stefana\r\n    # =================================================================================\r\n\r\n    def send_pick_rod_from_feed(self, input, ext_axes, int_arr = None):\r\n        \"\"\" send a command for picking a rod from the feeder\r\n        sequence:\r\n        1. drive to safe_pos_pick\r\n        2. open gripper\r\n        3. drive to pick up position\r\n        4. close gripper\r\n        5. drive to safe position up\r\n        == >> this routine is defined in RobotStudio, and is defined\r\n        cmd = [x,y,z,q1,q2,q3,q4,int_speed, int_zonedata, int_proc] int_proc = 7\r\n\r\n        cmd = [CMD_PICK_ROD, robtarget, int_speed, float_duration, int_zonedata, int_tool, float_arbitrary]\"\"\"\r\n\r\n        pose = get_pose(self, input)\r\n\r\n\r\n\r\n        if int_arr == None:\r\n            cmd = [CMD_PICK_ROD] + pose + ext_axes + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary, self.int_wobj]\r\n        else:\r\n            cmd = [CMD_PICK_ROD] + pose + ext_axes + int_arr\r\n\r\n\r\n\r\n        self.send(MSG_COMMAND, cmd)\r\n\r\n\r\n    def send_mill_rod(self, input1, input2, ext_axes1, ext_axes2, jointpos_1, jointpos_2, int_arr=None):\r\n\r\n        self.send_axes_absolute(jointpos_1, int_arr)\r\n        self.send_axes_absolute(jointpos_2, int_arr)\r\n\r\n        pose_1 = get_pose(self, input1)\r\n\r\n        if int_arr == None:\r\n            cmd = [CMD_MILL_ROD_START] + pose_1 + ext_axes1 + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary, self.int_wobj]\r\n        else:\r\n            cmd = [CMD_MILL_ROD_START] + pose_1 + ext_axes1 + int_arr\r\n\r\n        self.send(MSG_COMMAND, cmd)\r\n\r\n        pose_2 = get_pose(self, input2)\r\n\r\n        if int_arr == None:\r\n            cmd = [CMD_MILL_ROD_END] + pose_2 + ext_axes2 + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary, self.int_wobj]\r\n        else:\r\n            cmd = [CMD_MILL_ROD_END] + pose_2 + ext_axes2 + int_arr\r\n\r\n        self.send(MSG_COMMAND, cmd)\r\n\r\n        return pose_1\r\n\r\n    def send_mill_rod3(self, plane1, plane2, ext_axes1, ext_axes2, jointpos_1, jointpos_2, int_arr=None):\r\n        \"\"\" send a command for millig a rod\r\n        sequence:\r\n        1. drive to safe position for milling\r\n        2. set velocity to superslow\r\n        3. drive through milling planes\r\n        4. set velocity to normal\r\n        5. drive to safe position up\r\n        == >> this routine is defined in RobotStudio, and is defined\r\n        cmd = [x,y,z,q1,q2,q3,q4,int_speed, int_zonedata, int_proc] int_proc = 8, int_proc = 9\r\n\r\n        cmd = [CMD_MILL_ROD_START, robtarget, int_speed, float_duration, int_zonedata, int_tool, float_arbitrary]\r\n        cmd = [CMD_MILL_ROD_END, robtarget, int_speed, float_duration, int_zonedata, int_tool, float_arbitrary]\"\"\"\r\n\r\n        return (\"before anything python\")\r\n\r\n        self.send_axes_absolute(jointpos_1, int_arr)\r\n        self.send_axes_absolute(jointpos_2, int_arr)\r\n\r\n        #return \"axes_sent\"\r\n\r\n        plane_local_1 = self.set_tool_to_plane_sysworld(rg.Plane(plane1))\r\n        plane_local_1 = self.get_tool_plane_local()\r\n        #plane_local_1 = plane1\r\n        pose_1 = get_pose(self, plane_local_1)\r\n\r\n        if int_arr == None:\r\n            cmd = [CMD_MILL_ROD_START] + pose_1 + ext_axes1 + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary, self.int_wobj]\r\n        else:\r\n            cmd = [CMD_MILL_ROD_START] + pose_1 + ext_axes1 + int_arr\r\n\r\n        self.send(MSG_COMMAND, cmd)\r\n\r\n        plane_local_2 = self.set_tool_to_plane_sysworld(rg.Plane(plane2))\r\n        plane_local_2 = self.get_tool_plane_local()\r\n        #plane_local_2 = plane2\r\n        pose_2 = get_pose(self, plane_local_2)\r\n\r\n        if int_arr == None:\r\n            cmd = [CMD_MILL_ROD_END] + pose_2 + ext_axes2 + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary, self.int_wobj]\r\n        else:\r\n            cmd = [CMD_MILL_ROD_END] + pose_2 + ext_axes2 + int_arr\r\n\r\n        self.send(MSG_COMMAND, cmd)\r\n\r\n    def send_regrip_rod(self, input1, input2, ext_axes1, ext_axes2, int_arr=None):\r\n        \"\"\" send a command for regripping a rod\r\n        sequence:\r\n\r\n        == >> this routine is defined in RobotStudio, and is defined\r\n        cmd = [x,y,z,q1,q2,q3,q4,int_speed, int_zonedata, int_proc] int_proc = 10, int_proc = 11\r\n\r\n        cmd = [CMD_MILL_ROD_START, robtarget, int_speed, float_duration, int_zonedata, int_tool, float_arbitrary]\r\n        cmd = [CMD_MILL_ROD_END, robtarget, int_speed, float_duration, int_zonedata, int_tool, float_arbitrary]\"\"\"\r\n\r\n        pose = get_pose(self, input1)\r\n\r\n        if int_arr == None:\r\n            cmd = [CMD_REGRIP_PLACE] + pose + ext_axes1 + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary, self.int_wobj]\r\n        else:\r\n            cmd = [CMD_REGRIP_PLACE] + pose + ext_axes1 + int_arr\r\n\r\n        self.send(MSG_COMMAND, cmd)\r\n\r\n        pose = = get_pose(self, input2)\r\n\r\n        if int_arr == None:\r\n            cmd = [CMD_REGRIP_PICK] + pose + ext_axes2 + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary, self.int_wobj]\r\n        else:\r\n            cmd = [CMD_REGRIP_PICK] + pose + ext_axes2 + int_arr\r\n\r\n        self.send(MSG_COMMAND, cmd)\r\n\r\n        return \"regrip done\"\r\n\r\n    def send_move_to_safe_pos(self, joint_vals, int_arr=None):\r\n        \"\"\" send a command for moving to safe position\r\n        sequence:\r\n\r\n        == >> this routine is defined in RobotStudio, and is defined\r\n        cmd = [x,y,z,q1,q2,q3,q4,int_speed, int_zonedata, int_proc] int_proc = 12\r\n\r\n        cmd = [CMD_SAFE_POS, jointtarget, int_speed, float_duration, int_zonedata, int_tool, float_arbitrary]\"\"\"\r\n\r\n\r\n        if int_arr == None:\r\n            cmd = [CMD_SAFE_POS] + joint_vals + [0] + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary, 0]\r\n        else:\r\n            cmd = [CMD_SAFE_POS] + joint_vals + [0] + int_arr\r\n\r\n        self.send(MSG_COMMAND, cmd)\r\n\r\n\r\n    def send_position_rod(self, joint_vals, plane, ext_axes, int_arr=None):\r\n\r\n        self.send_axes_absolute_list(joint_vals, int_arr)\r\n        self.send_pose_cartesian(plane, ext_axes, int_arr)\r\n\r\n    def send_pick_and_pos_rod(self, joint_pick_1, joint_pick_2, joint_vals, plane, ext_axes, int_arr=None):\r\n\r\n        self.send_open_gripper(int_arr)\r\n        self.send_axes_absolute(joint_pick_1, int_arr)\r\n        self.send_close_gripper(int_arr)\r\n        self.send_open_clamp(int_arr)\r\n        self.send_axes_absolute(joint_pick_2, int_arr)\r\n        self.send_axes_absolute_list(joint_vals, int_arr)\r\n        self.send_pose_cartesian(plane, ext_axes, int_arr)\r\n\r\n        #return \"picked and positioned\"\r\n\r\n    def send_pick_pos(self, joint_pick_1, joint_pick_2, joint_vals, plane, ext_axes, int_arr=None):\r\n\r\n        self.send_open_gripper(int_arr)\r\n        self.send_axes_absolute(joint_pick_1, int_arr)\r\n        self.send_axes_absolute(joint_pick_2, int_arr)\r\n        self.send_close_gripper(int_arr)\r\n        self.send_open_clamp(int_arr)\r\n        self.send_axes_absolute(joint_pick_1, int_arr)\r\n\r\n        joint_pick_3 = [joint_pick_1[0], joint_pick_1[1], joint_pick_1[2]+30, joint_pick_1[3], joint_pick_1[4], joint_pick_1[5], joint_pick_1[6], joint_pick_1[7], joint_pick_1[8]]\r\n\r\n        self.send_axes_absolute(joint_pick_3, int_arr)\r\n\r\n    def send_move_back(self, joint_vals, joint_vals_safe, int_arr=None):\r\n        self.send_open_gripper(int_arr)\r\n        self.send_axes_absolute_list(joint_vals, int_arr)\r\n        self.send_axes_absolute(joint_vals_safe, int_arr)\r\n\r\n\r\n    def dynamic_pickup(self, floor_distance, pipe_length, int_arr = None):\r\n        \" send command for calling the dynamic pickup procedure\"\r\n        pose = [floor_distance, pipe_length, 0,0,0,0,0,0,0,0]\r\n        if int_arr == None:\r\n            cmd = [CMD_LWS_DYNAMIC_PICKUP] + pose + [0, 0, 0, 0, self.float_arbitrary, 0]\r\n        else:\r\n            cmd = [CMD_LWS_DYNAMIC_PICKUP] + pose + int_arr\r\n        self.send(MSG_COMMAND, cmd)\r\n\r\n\r\n    def send_PulseDO(self, signal_do, pulse_length, high, int_arr = None):\r\n        \"\"\" PulseDO is used to generate a pulse on a digital output signal.\r\n        signal_do: The name of the signal on which a pulse is to be generated.\r\n        pulse_length: The length of the pulse in seconds (0.001 - 2000 s). If the argument is omitted a 0.2 second pulse is generated.\r\n        high: Specifies that the signal value should always be set to high (value 1) when the instruction is executed independently of its current state.\r\n        \"\"\"\r\n        pose = [signal_do, pulse_length, high, 0,0,0,0,0,0,0]\r\n        if int_arr == None:\r\n            cmd = [CMD_PULSEDO] + pose + [0, 0, 0, 0, self.float_arbitrary, 0]\r\n        else:\r\n            cmd = [CMD_PULSEDO] + pose + int_arr\r\n        self.send(MSG_COMMAND, cmd)\r\n\r\n\r\n    def send_open_gripper(self, int_arr = None):\r\n        \" send command for opening gripper through DO\"\r\n        pose = [0,0,0,0,0,0,0,0,0,0]\r\n        if int_arr == None:\r\n            cmd = [CMD_OPEN_GRIPPER] + pose + [0, 0, 0, 0, self.float_arbitrary, 0]\r\n        else:\r\n            cmd = [CMD_OPEN_GRIPPER] + pose + int_arr\r\n        self.send(MSG_COMMAND, cmd)\r\n\r\n\r\n    def send_open_clamp(self, int_arr = None):\r\n        \" send command for opening clamp through DO\"\r\n        pose = [0,0,0,0,0,0,0,0,0,0]\r\n        if int_arr == None:\r\n            cmd = [CMD_OPEN_CLAMP] + pose + [0, 0, 0, 0, self.float_arbitrary, 0]\r\n        else:\r\n            cmd = [CMD_OPEN_CLAMP] + pose + int_arr\r\n\r\n        self.send(MSG_COMMAND, cmd)\r\n\r\n    def send_set_speed(self, speed1, speed2=10, int_arr = None):\r\n        \" send command for opening clamp through DO\"\r\n        speed = [speed1,speed2,0,0,0,0,0,0,0,0]\r\n        if int_arr == None:\r\n            cmd = [CMD_SET_SPEED_INPUT] + speed + [0, 0, 0, 0, self.float_arbitrary, 0]\r\n        else:\r\n            cmd = [CMD_SET_SPEED_INPUT] + speed + int_arr\r\n\r\n        self.send(MSG_COMMAND, cmd)\r\n\r\n\r\n    def send_close_gripper(self, int_arr = None):\r\n        \" send command for closing gripper through DO\"\r\n        pose = [0,0,0,0,0,0,0,0,0,0]\r\n        if int_arr == None:\r\n            cmd = [CMD_CLOSE_GRIPPER] + pose + [0, 0, 0, 0, self.float_arbitrary, 0]\r\n        else:\r\n            cmd = [CMD_CLOSE_GRIPPER] + pose + int_arr\r\n\r\n        self.send(MSG_COMMAND, cmd)\r\n\r\n    # ========================== funcions andreas ===============================================\r\n    def send_stu_pick(self, input, ext_axes, int_arr=None):\r\n        \"\"\" create command from plane or frame and send pick command to robot,\r\n        int_arr can be defined outside, or if None, default values are sent.\r\n        int_arr = [int_speed, float_duration, int_zonedata, int_tool, float_arbitrary, int_wobj] \"\"\"\r\n\r\n        pose = get_pose(self, input)\r\n        if int_arr == None:\r\n            cmd = [CMD_STU_PICK] + pose + ext_axes + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary, self.int_wobj]\r\n        else:\r\n            cmd = [CMD_STU_PICK] + pose + ext_axes + int_arr\r\n\r\n        self.send(MSG_COMMAND, cmd)\r\n        return cmd\r\n\r\n    def send_stu_place_plane(self, input1, input2, ext_axes_1, ext_axes_2, int_arr=None):\r\n        \"\"\" create command from plane or frame and send pick command to robot,\r\n        int_arr can be defined outside, or if None, default values are sent.\r\n        int_arr = [int_speed, float_duration, int_zonedata, int_tool, float_arbitrary, int_wobj] \"\"\"\r\n\r\n        pose_1 = get_pose(self, input1)\r\n        if int_arr == None:\r\n            cmd = [CMD_STU_PLACE_1] + pose_1 + ext_axes_1 + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary, self.int_wobj]\r\n        else:\r\n            cmd = [CMD_STU_PLACE_1] + pose_1 + ext_axes_1 + int_arr\r\n\r\n        self.send(MSG_COMMAND, cmd)\r\n\r\n        pose_2 = get_pose(self, input2)\r\n        if int_arr == None:\r\n            cmd = [CMD_STU_PLACE_2] + pose_2 + ext_axes_2 + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary, self.int_wobj]\r\n        else:\r\n            cmd = [CMD_STU_PLACE_2] + pose_2 + ext_axes_2 + int_arr\r\n\r\n        self.send(MSG_COMMAND, cmd)\r\n\r\n\r\n    # ========================== funcions MAS ===============================================\r\n    def send_mas_pick_brick_plane(self, input, ext_axes, int_arr=None):\r\n        \"\"\" create command from plane or frame and send pick command to robot,\r\n        int_arr can be defined outside, or if None, default values are sent.\r\n        int_arr = [int_speed, float_duration, int_zonedata, int_tool, float_arbitrary, int_wobj] \"\"\"\r\n\r\n        pose = get_pose(self, input)\r\n\r\n        if int_arr == None:\r\n            cmd = [CMD_MAS_PICK] + pose + ext_axes + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary, self.int_wobj]\r\n        else:\r\n            cmd = [CMD_MAS_PICK] + pose + ext_axes + int_arr\r\n\r\n        self.send(MSG_COMMAND, cmd)\r\n        return cmd\r\n\r\n    def send_mas_place_brick_plane(self, input, ext_axes, int_arr=None):\r\n        \"\"\" create command from plane or frame and send place command to robot,\r\n        int_arr can be defined outside, or if None, default values are sent.\r\n        int_arr = [int_speed, float_duration, int_zonedata, int_tool, float_arbitrary, int_wobj] \"\"\"\r\n        pose = get_pose(self, input)\r\n\r\n        if int_arr == None:\r\n            cmd = [CMD_MAS_PLACE] + pose + ext_axes + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary, self.int_wobj]\r\n        else:\r\n            cmd = [CMD_MAS_PLACE] + pose + ext_axes + int_arr\r\n\r\n        self.send(MSG_COMMAND, cmd)\r\n        return cmd\r\n\r\n\r\n    def send_mas_pick_brick_magazine(self, input, ext_axes, int_arr=None):\r\n        \"\"\" create command from plane or frame and send pick command to robot,\r\n        int_arr can be defined outside, or if None, default values are sent.\r\n        int_arr = [int_speed, float_duration, int_zonedata, int_tool, float_arbitrary, int_wobj] \"\"\"\r\n\r\n        pose = get_pose(self, input)\r\n\r\n\r\n        if int_arr == None:\r\n            cmd = [CMD_MAS_PICK_MAGAZINE] + pose + ext_axes + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary, self.int_wobj]\r\n        else:\r\n            cmd = [CMD_MAS_PICK_MAGAZINE] + pose + ext_axes + int_arr\r\n\r\n        self.send(MSG_COMMAND, cmd)\r\n        return cmd\r\n\r\n    def send_mas_place_brick_magazine(self, input, ext_axes, int_arr=None):\r\n        \"\"\" create command from plane or frame and send place command to robot,\r\n        int_arr can be defined outside, or if None, default values are sent.\r\n        int_arr = [int_speed, float_duration, int_zonedata, int_tool, float_arbitrary, int_wobj] \"\"\"\r\n\r\n        pose = get_pose(self, input)\r\n        if int_arr == None:\r\n            cmd = [CMD_MAS_PLACE_MAGAZINE] + pose + ext_axes + [self.int_speed, self.float_duration, self.int_zonedata, self.int_tool, self.float_arbitrary, self.int_wobj]\r\n        else:\r\n            cmd = [CMD_MAS_PLACE_MAGAZINE] + pose + ext_axes + int_arr\r\n\r\n        self.send(MSG_COMMAND, cmd)\r\n        return cmd\r\n\r\n    # =================================================================================\r\n    # set command parameters (for int_arr)\r\n    # =================================================================================\r\n    # =================================================================================\r\n    def set_speed_fast(self):\r\n        self.int_speed = 2\r\n        self.int_zonedata = 100\r\n    # =================================================================================\r\n    def set_speed_mid(self):\r\n        self.int_speed = 1\r\n        self.int_zonedata = 20\r\n    # =================================================================================\r\n    def set_speed_slow(self):\r\n        self.int_speed = 0\r\n        self.int_zonedata = 10\r\n    # =================================================================================\r\n    #added - stefana\r\n    def set_speed_superslow(self):\r\n        self.int_speed = 3\r\n        self.int_zonedata = 10\r\n\r\n    # =================================================================================\r\n    def set_rob_num(self,rob_num):\r\n        self.int_rob_num = rob_num\r\n\r\n    # =================================================================================\r\n    def set_tool_to_num(self, num_tool):\r\n        self.int_tool = num_tool\r\n\r\n    # def set_tool0(self):\r\n    #     # toolnumber: 0 = tool0, 1 = vacgrip_vert, 2 = hokuyo\r\n    #     self.int_tool = 0\r\n    # # =================================================================================\r\n    # def set_tool_meshmould(self):\r\n    #     # toolnumber: 0 = tool0, 1 = meshmould, 2 = hokuyo\r\n    #     self.int_tool = 1\r\n    # # =================================================================================\r\n    # def set_tool_lrf(self):\r\n    #     # toolnumber: 0 = tool0, 1 = vacgrip_vert, 2 = hokuyo\r\n    #     self.int_tool = 2\r\n    # # =================================================================================\r\n    # def set_tool_concrete_surface(self, ttype=\"puncher\"):\r\n    #     # toolnumber: 0 = tool0, 1 = meshmould, 2 = hokuyo, 3 = puncher, 4 = roller, 5 = sweeper\r\n    #     if ttype == \"puncher\":\r\n    #         self.int_tool = 3\r\n    #     elif ttype == \"roller\":\r\n    #         self.int_tool = 4\r\n    #     else: # ttype = \"sweeper\"\r\n    #         self.int_tool = 5\r\n    # # =================================================================================\r\n    # def set_tool_mtip(self):\r\n    #     # toolnumber: 0 = tool0, 1 = meshmould, 2 = hokuyo\r\n    #     self.int_tool = 6\r\n\r\n    # #################### tools stefana #######################\r\n    # def set_tool_lws_gripper(self):\r\n    #     self.int_tool = 7\r\n\r\n    # def set_tool_stu_gripper(self):\r\n    #     self.int_tool = 8\r\n\r\n    # def set_tool_mas_gripper(self):\r\n    #     self.int_tool = 9\r\n\r\n    # def set_tool_mas_magazine(self):\r\n    #     self.int_tool = 10\r\n    ###########################################################\r\n\r\n    # =================================================================================\r\n    # def set_wobj_0(self):\r\n    #     self.int_wobj = 0\r\n    # # =================================================================================\r\n    # def set_wobj_common(self):\r\n    #     self.int_wobj = 1\r\n    # # =================================================================================\r\n    # def set_wobj_base(self):\r\n    #     self.int_wobj = 2\r\n\r\n    # =================================================================================\r\n    # Edvard add for ARC574\r\n    def set_wobj_to_num(self, num_wobj):\r\n        self.int_wobj = num_wobj\r\n\r\n    # =============================== workobjects Andreas =============================\r\n    # def set_wobj_stu_pick(self):\r\n    #     self.int_wobj = 3\r\n\r\n    # def set_wobj_stu_base(self):\r\n    #     self.int_wobj = 4\r\n\r\n\r\nif __name__ == '__main__':\r\n    robot = ABBCommunication(\"ABB\", '192.168.125.1')\r\n    robot.start()\r\n    time.sleep(1)\r\n\r\n    robot.set_speed_slow()\r\n    print (robot.get_state())\r\n\r\n    robot.send_pose_joint_pick_brick()\r\n\r\n    time.sleep(0.1)\r\n    print (robot.get_state())\r\n\r\n    while robot.get_state() <= 1:\r\n\r\n        #robot.send_pose_joint_home()\r\n        #time.sleep(0.2)\r\n        #robot.send_pose_joints_pick_brick()\r\n        time.sleep(0.01)\r\n        current_pose_joints = robot.get_current_pose_joint()\r\n        print( current_pose_joints)\r\n        print( robot.cmd_exec_counter_from_client)\r\n        print( robot.cmd_counter_to_client)\r\n\r\n    print( \"comd sent: \", robot.cmd_counter_to_client)\r\n    print( \"cmd exec: \", robot.cmd_exec_counter_from_client)\r\n    print( \"state: \", robot.get_state())\r\n    \"\"\"\r\n    robot.send_pose_joint_home()\r\n\r\n\r\n    time.sleep(0.1)\r\n\r\n    print robot.get_state()\r\n\r\n    while robot.get_state() <> 1:\r\n\r\n        #robot.send_pose_joint_home()\r\n        #time.sleep(0.2)\r\n        #robot.send_pose_joints_pick_brick()\r\n        time.sleep(0.01)\r\n        current_pose_joints = robot.get_current_pose_joint()\r\n        print current_pose_joints\r\n\r\n    robot.wait_for_state_ready(0.0)\r\n\r\n    robot.set_speed_slow()\"\"\"\r\n\r\n    print (\"ready\")\r\n    robot.close()\r\n    print (\"closed\")\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}