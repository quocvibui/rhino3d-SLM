{
  "source_url": "https://github.com/AntonelloDN/lb_envimet/blob/f49c125fcf2cc2dd9deaab3ae220523a805a0247/lb_envimet/envimetObj/grid.py",
  "repo": "AntonelloDN/lb_envimet",
  "repo_stars": 4,
  "repo_description": "ï»¿lb_envimet: a series of components to connect Ladybug and Gismo to Envimet for urban microclimatic analysis",
  "license": "GPL-3.0",
  "filepath": "lb_envimet/envimetObj/grid.py",
  "instruction": "This modules provides main envimet classes.",
  "code": "\"\"\"\nThis modules provides main envimet classes.\n\nClasses:\n    NestingGrid\n    Grid2D\n    Grid3D\n    Dem\n    Plants3D\n\"\"\"\n\nimport Rhino as rc\nimport scriptcontext as sc\nimport collections\n\n\nclass NestingGrid(object):\n    \"\"\"Use this class to set nesting grid\n    \"\"\"\n    def __init__(self):\n        self.numNestingGrid = 3\n        self.soilProfileA = 'LO'\n        self.soilProfileB = 'LO'\n        self.name = 'NestingGrid'\n\n\nclass Grid2D(object):\n    \"\"\"Use this class to generate 2d element matrix\n    \"\"\"\n\n    basePoint = rc.Geometry.Point3d.Origin\n\n    def __init__(self, numX, numY, numZ, dimX, dimY, dimZ, verticalStretch=0, startStretch=0):\n        self.numX = numX\n        self.numY = numY\n        self.numZ = numZ\n        self.dimX = dimX\n        self.dimY = dimY\n        self.dimZ = dimZ\n        self.startStretch = startStretch\n        self.verticalStretch = verticalStretch\n\n\n    def viewEquidistantGrid(self):\n\n        points = []\n        for k in range(self.numZ+5):\n            for j in range(self.numY):\n                for i in range(self.numX):\n                    if k<5:\n                        point = rc.Geometry.Point3d(i*self.dimX+self.dimX/2 + self.basePoint.X, j*self.dimY+self.dimY/2 + self.basePoint.Y, k*self.dimZ/5+self.dimZ/10 + self.basePoint.Z)\n                    else:\n                        point = rc.Geometry.Point3d(i*self.dimX+self.dimX/2 + self.basePoint.X, j*self.dimY+self.dimY/2 + self.basePoint.Y, (k-4)*self.dimZ+self.dimZ/2 + self.basePoint.Z)\n                    points.append(point)\n\n        points = [p for p in points if p.X == ((self.numX - 1)*self.dimX)+self.dimX/2 + self.basePoint.X or p.Y == ((self.numY - 1)*self.dimY)+self.dimY/2 + self.basePoint.Y or p.Z == self.dimZ/10 + self.basePoint.Z]\n\n        return points\n\n\n    def create2DMatrixPerObj(self, dataList):\n\n        nestedMatrix = []\n        pts = []\n\n        for d in dataList:\n            matrix = []\n            for j in range(self.numY):\n                row = []\n                for i in range(self.numX):\n                    point = rc.Geometry.Point3d(i*self.dimX+self.dimX/2 + self.basePoint.X, j*self.dimY+self.dimY/2 + self.basePoint.Y, self.basePoint.Z)\n                    line = rc.Geometry.Line(point, rc.Geometry.Vector3d.ZAxis, self.dimX*2)\n\n                    # this is because of class and basePoint\n                    plane = rc.Geometry.Plane(self.basePoint, rc.Geometry.Vector3d.ZAxis)\n                    xprj = rc.Geometry.Transform.PlanarProjection(plane)\n                    d[0].Transform(xprj)\n\n                    if rc.Geometry.Intersect.Intersection.CurveBrep(line.ToNurbsCurve(), d[0], sc.doc.ModelAbsoluteTolerance)[2]:\n                        row.append(str(d[1]))\n                    else:\n                        row.append('')\n\n                matrix.append(row)\n            nestedMatrix.append(matrix)\n\n        return nestedMatrix\n\n\n\n    def mergeMatrix(self, nestedMatrix, altObj):\n\n        mergeMatrix = []\n        for m in zip(*nestedMatrix):\n            row = []\n            for l in zip(*m):\n                counter = collections.Counter(l)\n                if len(''.join(l)) == 4:\n                    row.append(''.join(l)[:-2])\n                elif len(counter.values()) != 1 and '' in l:\n                    row.append(''.join(l))\n                elif len(''.join(l)) == 2:\n                    row.append(''.join(l))\n                else:\n                    row.append(altObj)\n            mergeMatrix.append(row)\n\n        return mergeMatrix\n\n\n    def fromPythonToEnvimetMatrix(self, mergedMatrix):\n        stringMatrix = []\n        for line in mergedMatrix:\n            lineStr = ','.join(map(str, line))\n            stringMatrix.append(lineStr)\n\n        finalMatrix = '\\n'.join(reversed(stringMatrix))\n\n        return finalMatrix\n\n\n    def emptyMatrix(self):\n        matrix = []\n        for j in range(self.numY+1):\n            row = []\n            for i in range(self.numX+1):\n                row.append('')\n            matrix.append(','.join(row))\n        matrix = '\\n'.join(matrix)\n\n        return matrix\n\n\nclass Grid3D(Grid2D):\n    \"\"\"Use this class to generate 3d element matrix\n    \"\"\"\n    def __init__(self, numX, numY, numZ, dimX, dimY, dimZ):\n        Grid2D.__init__(self, numX, numY, numZ, dimX, dimY, dimZ)\n\n        #super().__init__(metaname)\n\n    def createAllGridPoints(self, numX, numY, numZ, dimX, dimY, gZ, flag):\n        buildingFlagAndNr, nestedLayers = [], []\n        # XY Grid\n        for index, building in enumerate(buildings):\n            layers = []\n            for k in range(len(gZ)):\n                columns = []  # Antonello\n                for j in range(self.numY):\n                    rows = []  # Antonello\n                    for i in range(self.numX):\n                        point = rc.Geometry.Point3d((i * dimX) + minX, (j * self.dimY) + minY, gZ[k])\n\n                        if building.IsPointInside(point, sc.doc.ModelAbsoluteTolerance * 10, False):\n                            bNr = ','.join([str(i), str(j), str(k), '1', str(index + 1)])\n                            id = index + 1\n                            buildingFlagAndNr.append(bNr)\n\n                            if flag == 0:\n                                rows.append(point.Z)\n                            else:\n                                rows.append(id)\n                        else:\n                            rows.append(0)\n                    columns.append(rows)\n                layers.append(columns)\n            nestedLayers.append(layers)\n\n        buildingFlagAndNrMatrix = '\\n'.join(buildingFlagAndNr)\n\n        return buildingFlagAndNrMatrix, nestedLayers\n\n\n    def matrixConstruction(self, buildings, flag=0):\n        \"\"\"Set flag = 1 if you want to run detailed mode\n        \"\"\"\n        buildingFlagAndNr, nestedLayers = [], []\n\n        for index, building in enumerate(buildings):\n            layers = []\n            for k in range(self.numZ+5):\n                columns = []\n                for j in range(self.numY):\n                    rows = []\n                    for i in range(self.numX):\n                        if k<5:\n                            point = rc.Geometry.Point3d(i*self.dimX+self.dimX/2 + self.basePoint.X, j*self.dimY+self.dimY/2 + self.basePoint.Y, k*self.dimZ/5+self.dimZ/10 + self.basePoint.Z)\n                        else:\n                            point = rc.Geometry.Point3d(i*self.dimX+self.dimX/2 + self.basePoint.X, j*self.dimY+self.dimY/2 + self.basePoint.Y, (k-4)*self.dimZ+self.dimZ/2 + self.basePoint.Z)\n\n                        if building.IsPointInside(point, sc.doc.ModelAbsoluteTolerance * 10, False):\n                            bNr = ','.join([str(i),str(j),str(k),'1',str(index+1)])\n                            id = index+1\n                            buildingFlagAndNr.append(bNr)\n\n                            if flag == 0:\n                                rows.append(point.Z)\n                            else:\n                                rows.append(id)\n                        else:\n                            rows.append(0)\n                    columns.append(rows)\n                layers.append(columns)\n            nestedLayers.append(layers)\n\n        buildingFlagAndNrMatrix = '\\n'.join(buildingFlagAndNr)\n\n        return buildingFlagAndNrMatrix, nestedLayers\n\n\n    def createOneMatrixForBuildings(self, buildings, nestedLayers):\n        # merge Matrix\n        oneMatrix = []\n        for k in zip(*nestedLayers):\n            columns = []\n            for y in zip(*k):\n                rows = []\n                for x in zip(*y):\n                    total = sum(x)\n                    # overlap issue ;)\n                    if total > len(buildings):\n                        total = 0\n                    rows.append(total)\n                columns.append(rows)\n            oneMatrix.append(columns)\n\n        return oneMatrix\n\n\n    def setMaterials(self, oneMatrix, matWall, matRoof):\n        # spare matrix\n        WallDB = []\n\n        for k, layer in enumerate(oneMatrix):\n            for j, column in enumerate(layer):\n                for i, row in enumerate(column):\n\n                    if row != 0 and oneMatrix[k][j][i-1] == 0 and oneMatrix[k][j-1][i] == 0 and oneMatrix[k-1][j][i] == 0:\n                        index = int(row)-1\n                        WallDB.append(','.join([str(i),str(j),str(k),matWall[index],matWall[index],matRoof[index]]))\n                    elif row != 0 and oneMatrix[k][j][i-1] == 0 and oneMatrix[k][j-1][i] != 0 and oneMatrix[k-1][j][i] == 0:\n                        index = int(row)-1\n                        WallDB.append(','.join([str(i),str(j),str(k),matWall[index],'',matRoof[index]]))\n                    elif row != 0 and oneMatrix[k][j][i-1] != 0 and oneMatrix[k][j-1][i] == 0 and oneMatrix[k-1][j][i] == 0:\n                        index = int(row)-1\n                        WallDB.append(','.join([str(i),str(j),str(k),'',matWall[index],matRoof[index]]))\n\n                    elif row != 0 and oneMatrix[k][j][i-1] == 0 and oneMatrix[k][j-1][i] == 0 and oneMatrix[k-1][j][i] != 0:\n                        index = int(row)-1\n                        WallDB.append(','.join([str(i),str(j),str(k),matWall[index],matWall[index],'']))\n                    elif row != 0 and oneMatrix[k][j][i-1] == 0 and oneMatrix[k][j-1][i] != 0 and oneMatrix[k-1][j][i] != 0:\n                        index = int(row)-1\n                        WallDB.append(','.join([str(i),str(j),str(k),matWall[index],'','']))\n                    elif row != 0 and oneMatrix[k][j][i-1] != 0 and oneMatrix[k][j-1][i] == 0 and oneMatrix[k-1][j][i] != 0:\n                        index = int(row)-1\n                        WallDB.append(','.join([str(i),str(j),str(k),'',matWall[index],'']))\n                    elif row != 0 and oneMatrix[k][j][i-1] != 0 and oneMatrix[k][j-1][i] != 0 and oneMatrix[k-1][j][i] == 0:\n                        index = int(row)-1\n                        WallDB.append(','.join([str(i),str(j),str(k),'','',matRoof[index]]))\n\n                    # empty cells\n                    elif row == 0 and oneMatrix[k][j][i-1] != 0 and oneMatrix[k][j-1][i] == 0 and oneMatrix[k-1][j][i] == 0:\n                        index = int(oneMatrix[k][j][i-1])-1\n                        WallDB.append(','.join([str(i),str(j),str(k),matWall[index],'','']))\n                    elif row == 0 and oneMatrix[k][j][i-1] == 0 and oneMatrix[k][j-1][i] != 0 and oneMatrix[k-1][j][i] == 0:\n                        index = int(oneMatrix[k][j-1][i])-1\n                        WallDB.append(','.join([str(i),str(j),str(k),'',matWall[index],'']))\n                    elif row == 0 and oneMatrix[k][j][i-1] == 0 and oneMatrix[k][j-1][i] == 0 and oneMatrix[k-1][j][i] != 0:\n                        index = int(oneMatrix[k-1][j][i])-1\n                        WallDB.append(','.join([str(i),str(j),str(k),'','',matRoof[index]]))\n\n                    elif row == 0 and oneMatrix[k][j][i-1] != 0 and oneMatrix[k][j-1][i] != 0 and oneMatrix[k-1][j][i] == 0:\n                        index = int(oneMatrix[k][j-1][i])-1\n                        WallDB.append(','.join([str(i),str(j),str(k),matWall[index],matWall[index],'']))\n                    elif row == 0 and oneMatrix[k][j][i-1] != 0 and oneMatrix[k][j-1][i] == 0 and oneMatrix[k-1][j][i] != 0:\n                        indexW = int(oneMatrix[k][j][i-1])-1\n                        indexR = int(oneMatrix[k-1][j][i])-1\n                        WallDB.append(','.join([str(i),str(j),str(k),matWall[indexW],'',matRoof[indexR]]))\n                    elif row == 0 and oneMatrix[k][j][i-1] == 0 and oneMatrix[k][j-1][i] != 0 and oneMatrix[k-1][j][i] != 0:\n                        indexW = int(oneMatrix[k][j-1][i])-1\n                        indexR = int(oneMatrix[k-1][j][i])-1\n                        WallDB.append(','.join([str(i),str(j),str(k),'',matWall[indexW],matRoof[indexR]]))\n                    elif row == 0 and oneMatrix[k][j][i-1] != 0 and oneMatrix[k][j-1][i] != 0 and oneMatrix[k-1][j][i] != 0:\n                        indexW = int(oneMatrix[k][j-1][i])-1\n                        indexR = int(oneMatrix[k-1][j][i])-1\n                        WallDB.append(','.join([str(i),str(j),str(k),matWall[indexW],matWall[indexW],matRoof[indexR]]))\n\n        WallDBMatrix = '\\n'.join(WallDB)\n\n        return WallDBMatrix, oneMatrix\n\n\n    def HmaxNestedMatrix(self, nestedLayers):\n        edifici = []\n        for singoloEd in nestedLayers:\n            lista = []\n            for y in zip(*singoloEd):\n                listaMaxAltezza = []\n                for x in zip(*y):\n                    total = max(x)\n                    if total != 0:\n                        total = int(round(total - self.basePoint.Z, 1))\n                    listaMaxAltezza.append(total)\n                lista.append(listaMaxAltezza)\n            edifici.append(lista)\n        return edifici\n\n\n    def HminNestedMatrix(self, nestedLayers):\n        edifici = []\n        for singoloEd in nestedLayers:\n            lista = []\n            for y in zip(*singoloEd):\n                listaMinAltezza = []\n                for x in zip(*y):\n                    for num in x:\n                        if num != 0:\n                            num = int(round(num - self.basePoint.Z - self.dimZ/10, 1))\n                            break\n                    listaMinAltezza.append(num)\n                lista.append(listaMinAltezza)\n            edifici.append(lista)\n\n        return edifici\n\n\n    def mergeBuildingMatrix(self, hmatrix):\n        mergeMatrix = []\n        for m in zip(*hmatrix):\n            row = []\n            for l in zip(*m):\n                if 0 in l:\n                    num = sum(l)\n                else:\n                    num = l[0]\n\n                row.append(num)\n            mergeMatrix.append(row)\n\n        return mergeMatrix\n\n\n    def index2DMatrix(self, oneMatrix):\n        buildingNr = []\n\n        for k in zip(*oneMatrix):\n            columns = []\n            emptyColumns = []\n            for y in zip(*k):\n                index = sum(set(y))\n                columns.append(index)\n\n            linebuildingNr = ','.join(map(str, columns))\n            buildingNr.append(linebuildingNr)\n\n        buildingNrMatrix = '\\n'.join(reversed(buildingNr))\n\n        return buildingNrMatrix\n\n\nclass Dem(Grid2D):\n    \"\"\"Use this class to generate envimet dem, this is temporarily available only for equidistant grid\n    \"\"\"\n    def __init__(self, numX, numY, numZ, dimX, dimY, dimZ):\n        Grid2D.__init__(self, numX, numY, numZ, dimX, dimY, dimZ)\n        #super().__init__(metaname)\n\n\n    def digitalElevationModel3D(self, terrain):\n\n        terrainflag = []\n\n        for k in range(self.numZ+5):\n            columns = []\n            for j in range(self.numY):\n                rows = []\n                for i in range(self.numX):\n                    if k<5:\n                        point = rc.Geometry.Point3d(i*self.dimX+self.dimX/2 + self.basePoint.X, j*self.dimY+self.dimY/2 + self.basePoint.Y, k*self.dimZ/5+self.dimZ/10 + self.basePoint.Z)\n                    else:\n                        point = rc.Geometry.Point3d(i*self.dimX+self.dimX/2 + self.basePoint.X, j*self.dimY+self.dimY/2 + self.basePoint.Y, (k-4)*self.dimZ+self.dimZ/2 + self.basePoint.Z)\n                    if terrain.IsPointInside(point, sc.doc.ModelAbsoluteTolerance*10, False):\n                        tN = ','.join([str(i),str(j),str(k),str('1.00000')])\n\n                        terrainflag.append(tN)\n\n        terrainFlagMatrix = '\\n'.join(terrainflag)\n\n        return terrainFlagMatrix\n\n\n    def digitalElevationModel2D(self, terrain):\n\n        def findMaxHeight(terrain):\n            bbox = terrain.GetBoundingBox(True)\n            maxHeight = bbox.Max.Z\n            return maxHeight\n\n        altitude = findMaxHeight(terrain)\n\n        terrainPattern = []\n\n        for y in range(self.numY):\n            rowsHeight = []\n            rowsBottom = []\n            for x in range(self.numX):\n                line = rc.Geometry.Line(rc.Geometry.Point3d(x*self.dimX + self.basePoint.X + self.dimX/2, y*self.dimY + self.basePoint.Y + self.dimY/2, self.basePoint.Z), rc.Geometry.Vector3d.ZAxis, altitude*2)\n                intersection = rc.Geometry.Intersect.Intersection.MeshLine(terrain, line)[0]\n                if intersection:\n                    heightData = sorted(intersection)\n                    rowsHeight.append(str(int(round(max([h.Z for h in heightData]),0))))\n                else:\n                    rowsHeight.append('0')\n                line = ','.join(map(str, rowsHeight))\n            terrainPattern.append(line)\n\n        demPattern = '\\n'.join(reversed(terrainPattern))\n\n        return demPattern\n\n\nclass Plants3D(Grid2D):\n    \"\"\"Use this class to generate envimet 3d plants\n    \"\"\"\n    def __init__(self, numX, numY, numZ, dimX, dimY, dimZ):\n        Grid2D.__init__(self, numX, numY, numZ, dimX, dimY, dimZ)\n\n\n    def threeDimensionalPlants(self, dataList):\n        nestedMatrix = []\n        for index, d in enumerate(dataList):\n            curves = [c for c in d[0].DuplicateEdgeCurves()]\n            closedCrv = [crv for crv in rc.Geometry.Curve.JoinCurves(curves)][0]\n\n            for j in range(self.numY):\n                for i in range(self.numX):\n                    point = rc.Geometry.Point3d(i*self.dimX+self.dimX/2 + self.basePoint.X, j*self.dimY+self.dimY/2 + self.basePoint.Y, self.basePoint.Z)\n                    if rc.Geometry.Curve.Contains(closedCrv, point, rc.Geometry.Plane.WorldXY, sc.doc.ModelAbsoluteTolerance) == rc.Geometry.PointContainment.Inside:\n                        idAndDescription = d[1].split(',')\n                        nestedMatrix.append([str(i+1),str(j+1),'0', idAndDescription[0], idAndDescription[1], '0'])\n        return nestedMatrix\n",
  "language": "python",
  "imports": [
    "Rhino",
    "scriptcontext"
  ],
  "has_docstring": true
}