{
  "source_url": "https://github.com/dtbinh/T1_python-exercises/blob/f4710c3dc2ba8ddb3e3e9069ab8d65df674463ab/07_ur_online/shifted_frames_setup/compas/src/compas_rhino/helpers/network.py",
  "repo": "dtbinh/T1_python-exercises",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "07_ur_online/shifted_frames_setup/compas/src/compas_rhino/helpers/network.py",
  "instruction": "Network",
  "code": "from __future__ import print_function\n\nimport ast\n\nfrom compas.utilities.colors import color_to_colordict\nfrom compas.utilities import geometric_key\nfrom compas.geometry import distance_point_point\n\nimport compas_rhino\n\ntry:\n    import Rhino\n    from Rhino.Geometry import Point3d\n    import rhinoscriptsyntax as rs\nexcept ImportError:\n    import platform\n    if platform.python_implementation() == 'IronPython':\n        raise\n\n\n__author__    = 'Tom Van Mele'\n__copyright__ = 'Copyright 2016, Block Research Group - ETH Zurich'\n__license__   = 'MIT license'\n__email__     = 'vanmelet@ethz.ch'\n\n\n__all__ = [\n    'draw_network',\n    'select_network_vertices',\n    'select_network_vertex',\n    'select_network_edges',\n    'select_network_edge',\n    'select_network_faces',\n    'select_network_face',\n    'update_network_attributes',\n    'update_network_vertex_attributes',\n    'update_network_from_points',\n    'update_network_edge_attributes',\n    'update_network_from_lines',\n    'update_network_face_attributes',\n    'display_network_vertex_labels',\n    'display_network_edge_labels',\n    'display_network_face_labels',\n    'move_network',\n    'move_network_vertex',\n    'display_network_axial_forces',\n    'display_network_reaction_forces',\n    'display_network_residual_forces',\n    'display_network_selfweight',\n    'display_network_applied_loads',\n]\n\n\n# ==============================================================================\n# constructors\n# ==============================================================================\n\n# ==============================================================================\n# draw\n# ==============================================================================\n\n\ndef draw_network(network,\n                 layer=None,\n                 clear_layer=False,\n                 vertexcolor=None,\n                 edgecolor=None,\n                 edgelabel=None):\n    \"\"\"Draw a network data structure in Rhino.\n\n    Parameters:\n        network (compas.datastructures.network.Network): The network object.\n        layer (str): Optional. The layer to draw in. Default is ``None``. If\n            ``None``, the currenlt layer is used.\n        clear_layer (bool): Optional. Clear the layer if ``True``. Default is ``False``.\n        vertexcolor (list, tuple, str, dict): Optional. The color specification\n            for the vertices. Default is ``None``.\n\n                * list, tuple: rgb color, with color specs between 0 and 255 (e.g. ``(255, 0, 0)``).\n                * str: hex color (e.g. ``'#ff0000'``).\n                * dict: dictionary of hex or rgb colors.\n\n        edgecolor (list, tuple, str, dict): Optional. The color specification\n            for the edges. Default is ``None``.\n\n                * list, tuple: rgb color, with color specs between 0 and 255 (e.g. ``(255, 0, 0)``).\n                * str: hex color (e.g. ``'#ff0000'``).\n                * dict: dictionary of hex or rgb color.\n\n    Note:\n        * Any network objects with the same name that are already present in the\n          model will be deleted by this function.\n        * To also clear the entire layer the network will be drawn on, for\n          example, if you have a dedicated network layer, use the ``clear_layer`` flag as well.\n\n    See Also:\n        * :class:`compas.datastructures.network.Network`\n        * :func:`compas_compas_rhino.utilities.drawing.xdraw_lines`\n        * :func:`compas_compas_rhino.utilities.drawing.xdraw_points`\n\n    Example:\n\n        .. code-block:: python\n            :emphasize-lines: 7\n\n            import compas\n            from compas.datastructures.network import Network\n            import compas_rhino as compas_rhino\n\n            network = Network.from_obj(compas.get_data('lines.obj'))\n\n            compas_compas_rhino.draw_network(network)\n\n    \"\"\"\n    vertexcolor = color_to_colordict(vertexcolor,\n                                     network.vertices(),\n                                     default=network.attributes['color.vertex'],\n                                     colorformat='rgb',\n                                     normalize=False)\n\n    edgecolor = color_to_colordict(edgecolor,\n                                   network.edges(),\n                                   default=network.attributes['color.edge'],\n                                   colorformat='rgb',\n                                   normalize=False)\n\n    edgelabel = edgelabel or {}\n\n    points = []\n    for key, attr in network.vertices(True):\n        points.append({\n            'pos'  : network.vertex_coordinates(key),\n            'name' : '{0}.vertex.{1}'.format(network.attributes['name'], repr(key)),\n            'color': vertexcolor[key]\n        })\n\n    lines = []\n    for u, v, attr in network.edges(True):\n        lines.append({\n            'start': network.vertex_coordinates(u),\n            'end'  : network.vertex_coordinates(v),\n            'name' : '{0}.edge.{1}-{2}'.format(network.attributes['name'], repr(u), repr(v)),\n            'color': edgecolor[(u, v)]\n        })\n\n    labels = []\n    for (u, v), text in edgelabel.items():\n        labels.append({\n            'pos'  : network.edge_midpoint(u, v),\n            'text' : str(text),\n            'name' : '{0}.edge.label.{1}-{2}'.format(network.attributes['name'], repr(u), repr(v)),\n            'color': edgecolor[(u, v)],\n        })\n\n    guids = compas_rhino.get_objects(name='{0}.*'.format(network.attributes['name']))\n    compas_rhino.delete_objects(guids)\n\n    compas_rhino.xdraw_points(\n        points,\n        layer=layer,\n        clear=clear_layer,\n        redraw=False\n    )\n    compas_rhino.xdraw_lines(\n        lines,\n        layer=layer,\n        clear=False,\n        redraw=False\n    )\n    compas_rhino.xdraw_labels(\n        labels,\n        layer=layer,\n        clear=False,\n        redraw=True\n    )\n\n\n# ==============================================================================\n# select\n# ==============================================================================\n\n\ndef select_network_vertices(network, message=\"Select network vertices.\"):\n    \"\"\"Select vertices of a network.\n\n    Parameters:\n        network (compas.datastructures.network.Network): The network object.\n        message (str): Optional. The message to display to the user.\n            Default is ``\"Select network vertices.\"``\n\n    Returns:\n        list: The keys of the selected vertices.\n\n    Note:\n        Selection is based on naming conventions.\n        When a network is drawn using the function :func:`draw_network`,\n        the point objects representing the vertices get assigned a name that\n        has the following pattern::\n\n            '{0}.vertex.{1}'.format(network.attributes['name'], key)\n\n    Example:\n\n        .. code-block:: python\n            :emphasize-lines: 9\n\n            from compas.datastructures.network import Network\n            import compas_rhino as compas_rhino as rhino\n\n            guids = compas_rhino.select_objects()\n            lines = compas_rhino.select_line_coordinates(guids)\n\n            network = Network.from_lines(lines)\n\n            keys = compas_rhino.select_network_vertices(network)\n\n            print(keys)\n\n\n    See Also:\n        * :func:`select_network_edges`\n        * :func:`select_network_faces`\n\n    \"\"\"\n    keys = []\n    guids = rs.GetObjects(message, preselect=True, filter=rs.filter.point | rs.filter.textdot)\n    if guids:\n        prefix = network.attributes['name']\n        seen = set()\n        for guid in guids:\n            name = rs.ObjectName(guid).split('.')\n            if 'vertex' in name:\n                if not prefix or prefix in name:\n                    key = name[-1]\n                    if not seen.add(key):\n                        key = ast.literal_eval(key)\n                        keys.append(key)\n    return keys\n\n\ndef select_network_vertex(network, message=\"Select a network vertex\"):\n    \"\"\"Select one vertex of a network.\n\n    Parameters:\n        network (compas.datastructures.network.Network): The network object.\n        message (str): Optional. The message to display to the user.\n            Default is ``\"Select network vertex.\"``\n\n    Returns:\n        * str: The key of the selected vertex.\n        * None: If no vertex was selected.\n\n    See Also:\n        * :func:`select_network_vertices`\n\n    \"\"\"\n    guid = rs.GetObject(message, preselect=True, filter=rs.filter.point | rs.filter.textdot)\n    if guid:\n        prefix = network.attributes['name']\n        name = rs.ObjectName(guid).split('.')\n        if 'vertex' in name:\n            if not prefix or prefix in name:\n                key = name[-1]\n                key = ast.literal_eval(key)\n                return key\n    return None\n\n\ndef select_network_edges(network, message=\"Select network edges\"):\n    \"\"\"Select edges of a network.\n\n    Parameters:\n        network (compas.datastructures.network.Network): The network object.\n        message (str): Optional. The message to display to the user.\n            Default is ``\"Select network edges.\"``\n\n    Returns:\n        list: The keys of the selected edges. Each key is a *uv* pair.\n\n    Note:\n        Selection is based on naming conventions.\n        When a network is drawn using the function :func:`draw_network`,\n        the curve objects representing the edges get assigned a name that\n        has the following pattern::\n\n            '{0}.edge.{1}-{2}'.format(network.attributes['name'], u, v)\n\n    See Also:\n        * :func:`select_network_vertices`\n        * :func:`select_network_faces`\n\n    \"\"\"\n    keys = []\n    guids = rs.GetObjects(message, preselect=True, filter=rs.filter.curve | rs.filter.textdot)\n    if guids:\n        prefix = network.attributes['name']\n        seen = set()\n        for guid in guids:\n            name = rs.ObjectName(guid).split('.')\n            if 'edge' in name:\n                if not prefix or prefix in name:\n                    key = name[-1]\n                    if not seen.add(key):\n                        u, v = key.split('-')\n                        u = ast.literal_eval(u)\n                        v = ast.literal_eval(v)\n                        keys.append((u, v))\n    return keys\n\n\ndef select_network_edge(network, message=\"Select a network edge\"):\n    \"\"\"Select one edge of a network.\n\n    Parameters:\n        network (compas.datastructures.network.Network): The network object.\n        message (str): Optional. The message to display to the user.\n            Default is ``\"Select network edges.\"``\n\n    Returns:\n        tuple: The key of the selected edge.\n        None: If no edge was selected.\n\n    See Also:\n        * :func:`select_network_edges`\n\n    \"\"\"\n    guid = rs.GetObject(message, preselect=True, filter=rs.filter.curve | rs.filter.textdot)\n    if guid:\n        prefix = network.attributes['name']\n        name = rs.ObjectName(guid).split('.')\n        if 'edge' in name:\n            if not prefix or prefix in name:\n                key = name[-1]\n                u, v = key.split('-')\n                u = ast.literal_eval(u)\n                v = ast.literal_eval(v)\n                return u, v\n    return None\n\n\ndef select_network_faces(network, message='Select network faces.'):\n    \"\"\"Select faces of a network.\n\n    Parameters:\n        network (compas.datastructures.network.Network): The network object.\n        message (str): Optional. The message to display to the user.\n            Default is ``\"Select network edges.\"``\n\n    Returns:\n        list: The keys of the selected faces.\n\n    Note:\n        Selection of faces is based on naming conventions.\n        When a network is drawn using the function :func:`draw_network`,\n        the curve objects representing the edges get assigned a name that\n        has the following pattern::\n\n            '{0}.edge.{1}-{2}'.format(network.attributes['name'], u, v)\n\n    Example:\n\n        .. code-block:: python\n            :emphasize-lines: 14\n\n            import compas\n            from compas.datastructures.network import Network\n            from compas.datastructures.network.algorithms import find_network_faces\n\n            import compas_rhino as compas_rhino as rhino\n\n            network = Network.from_obj(compas.get_data('lines.obj'))\n\n            find_network_faces(network, network.leaves())\n\n            compas_rhino.draw_network(network)\n            compas_rhino.display_network_face_labels(network)\n\n            fkeys = compas_rhino.select_network_faces(network)\n\n            print(fkeys)\n\n\n    See Also:\n        * :func:`select_network_vertices`\n        * :func:`select_network_edges`\n\n    \"\"\"\n    keys = []\n    guids = rs.GetObjects(message, preselect=True, filter=rs.filter.textdot)\n    if guids:\n        prefix = network.attributes['name']\n        seen = set()\n        for guid in guids:\n            name = rs.ObjectName(guid).split('.')\n            if 'face' in name:\n                if not prefix or prefix in name:\n                    key = name[-1]\n                    if not seen.add(key):\n                        key = ast.literal_eval(key)\n                        keys.append(key)\n    return keys\n\n\ndef select_network_face(network, message='Select face.'):\n    \"\"\"Select one face of a network.\n\n    Parameters:\n        network (compas.datastructures.network.Network): The network object.\n        message (str): Optional. The message to display to the user.\n            Default is ``\"Select network edges.\"``\n\n    Returns:\n        tuple: The key of the selected face.\n        None: If no face was selected.\n\n    See Also:\n        * :func:`select_network_faces`\n\n    \"\"\"\n    guid = rs.GetObjects(message, preselect=True, filter=rs.filter.textdot)\n    if guid:\n        prefix = network.attributes['name']\n        name = rs.ObjectName(guid).split('.')\n        if 'face' in name:\n            if not prefix or prefix in name:\n                key = name[-1]\n                key = ast.literal_eval(key)\n                return key\n    return None\n\n\n# ==============================================================================\n# attributes\n# ==============================================================================\n\n\ndef update_network_attributes(network):\n    \"\"\"Update the attributes of a network.\n\n    Parameters:\n        network (compas.datastructures.network.Network): The network object.\n\n    Returns:\n        bool: ``True`` if the update was successful, and ``False`` otherwise.\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as compas_rhino\n            from compas.datastructures.network import Network\n\n            network = Network.from_obj(compas.get_data('lines.obj'))\n\n            if compas_compas_rhino.update_network_attributes(network):\n                print('network attributes updated')\n            else:\n                print('network attributres not updated')\n\n\n    See Also:\n        * :func:`update_network_vertex_attributes`\n        * :func:`update_network_edge_attributes`\n        * :func:`update_network_face_attributes`\n\n    \"\"\"\n    names  = sorted(network.attributes.keys())\n    values = [str(network.attributes[name]) for name in names]\n    values = compas_rhino.update_named_values(names, values)\n    if values:\n        for name, value in zip(names, values):\n            try:\n                network.attributes[name] = ast.literal_eval(value)\n            except (ValueError, TypeError):\n                network.attributes[name] = value\n        return True\n    return False\n\n\ndef update_network_vertex_attributes(network, keys, names=None):\n    \"\"\"Update the attributes of the vertices of a network.\n\n    Parameters:\n        network (compas.datastructures.network.Network): The network object.\n        keys (tuple, list): The keys of the vertices to update.\n        names (tuple, list): Optional. The names of the atrtibutes to update.\n            Defaults to ``None``. If ``None``, all attributes are included in the\n            update.\n\n    Returns:\n        bool: ``True`` if the update was successful, and ``False`` otherwise.\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as compas_rhino\n\n            from compas.datastructures.network import Network\n\n            network = Network.from_obj(compas.get_data('lines.obj'))\n\n            keys = network.vertices()\n\n            if compas_compas_rhino.update_network_vertex_attributes(network, keys):\n                print('network vertex attributes updated')\n            else:\n                print('network vertex attributes not updated')\n\n\n    See Also:\n        * :func:`update_network_attributes`\n        * :func:`update_network_edge_attributes`\n        * :func:`update_network_face_attributes`\n\n    \"\"\"\n    if not names:\n        names = network.default_vertex_attributes.keys()\n    names = sorted(names)\n    values = [network.vertex[keys[0]][name] for name in names]\n    if len(keys) > 1:\n        for i, name in enumerate(names):\n            for key in keys[1:]:\n                if values[i] != network.vertex[key][name]:\n                    values[i] = '-'\n                    break\n    values = map(str, values)\n    values = compas_rhino.update_named_values(names, values)\n    if values:\n        for name, value in zip(names, values):\n            if value != '-':\n                for key in keys:\n                    try:\n                        network.vertex[key][name] = ast.literal_eval(value)\n                    except (ValueError, TypeError):\n                        network.vertex[key][name] = value\n        return True\n    return False\n\n\ndef update_network_from_points(network, guids):\n    points = compas_rhino.get_point_coordinates(guids)\n    names = compas_rhino.get_object_names(guids)\n    gkey_key = {geometric_key(network.vertex_coordinates(key)): key for key in network}\n    for i, xyz in enumerate(points):\n        name = names[i]\n        try:\n            attr = ast.literal_eval(name)\n        except ValueError:\n            pass\n        else:\n            gkey = geometric_key(xyz)\n            if gkey in gkey_key:\n                key = gkey_key[gkey]\n                network.vertex[key].update(attr)\n\n\ndef update_network_edge_attributes(network, keys, names=None):\n    \"\"\"Update the attributes of the edges of a network.\n\n    Parameters:\n        network (compas.datastructures.network.Network): The network object.\n        keys (tuple, list): The keys of the edges to update. Note that the keys\n            should be pairs of vertex keys.\n        names (tuple, list): Optional. The names of the atrtibutes to update.\n            Defaults to ``None``. If ``None``, all attributes are included in the\n            update.\n\n    Returns:\n        bool: ``True`` if the update was successful, and ``False`` otherwise.\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as compas_rhino\n\n            from compas.datastructures.network import Network\n\n            network = Network.from_obj(compas.get_data('lines.obj'))\n\n            keys = network.edges()\n\n            if compas_compas_rhino.update_network_edge_attributes(network, keys):\n                print('network edge attributes updated')\n            else:\n                print('network edge attributes not updated')\n\n\n    See Also:\n        * :func:`update_network_attributes`\n        * :func:`update_network_vertex_attributes`\n        * :func:`update_network_face_attributes`\n\n    \"\"\"\n    if not names:\n        names = network.default_edge_attributes.keys()\n    names = sorted(names)\n    u, v = keys[0]\n    values = [network.edge[u][v][name] for name in names]\n    if len(keys) > 1:\n        for i, name in enumerate(names):\n            for u, v in keys[1:]:\n                if values[i] != network.edge[u][v][name]:\n                    values[i] = '-'\n                    break\n    values = map(str, values)\n    values = compas_rhino.update_named_values(names, values)\n    if values:\n        for name, value in zip(names, values):\n            if value != '-':\n                for u, v in keys:\n                    try:\n                        network.edge[u][v][name] = ast.literal_eval(value)\n                    except (ValueError, TypeError):\n                        network.edge[u][v][name] = value\n        return True\n    return False\n\n\ndef update_network_from_lines(network, guids):\n    lines = compas_rhino.get_line_coordinates(guids)\n    names = compas_rhino.get_object_names(guids)\n    gkey_key = {geometric_key(network.vertex_coordinates(key)): key for key in network}\n    for i, (sp, ep) in enumerate(lines):\n        name = names[i]\n        try:\n            attr = ast.literal_eval(name)\n        except ValueError:\n            pass\n        else:\n            a = geometric_key(sp)\n            b = geometric_key(ep)\n            if a in gkey_key and b in gkey_key:\n                u = gkey_key[a]\n                v = gkey_key[b]\n                if v in network.edge[u]:\n                    network.edge[u][v].update(attr)\n                else:\n                    network.edge[v][u].update(attr)\n\n\ndef update_network_face_attributes(network, fkeys, names=None):\n    \"\"\"Update the attributes of the faces of a network.\n\n    Parameters:\n        network (compas.datastructures.network.Network): The network object.\n        keys (tuple, list): The keys of the faces to update.\n        names (tuple, list): Optional. The names of the atrtibutes to update.\n            Defaults to ``None``. If ``None``, all attributes are included in the\n            update.\n\n    Returns:\n        bool: ``True`` if the update was successful, and ``False`` otherwise.\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as compas_rhino\n\n            from compas.datastructures.network import Network\n\n            network = Network.from_obj(compas.get_data('lines.obj'))\n\n            keys = network.faces()\n\n            if compas_compas_rhino.update_network_face_attributes(network, keys):\n                print('network face attributes updated')\n            else:\n                print('network face attributes not updated')\n\n\n    See Also:\n        * :func:`update_network_attributes`\n        * :func:`update_network_vertex_attributes`\n        * :func:`update_network_edge_attributes`\n\n    \"\"\"\n    if not network.dualdata:\n        return\n    if not names:\n        names = sorted(network.default_face_attributes.keys())\n    values = [network.dualdata.vertex[fkeys[0]][name] for name in names]\n    if len(fkeys) > 1:\n        for i, name in enumerate(names):\n            for fkey in fkeys[1:]:\n                if values[i] != network.dualdata.vertex[fkey][name]:\n                    values[i] = '-'\n                    break\n    values = map(str, values)\n    values = compas_rhino.update_attributes(names, values)\n    if values:\n        for name, value in zip(names, values):\n            if value != '-':\n                for fkey in fkeys:\n                    try:\n                        network.dualdata.vertex[fkey][name] = ast.literal_eval(value)\n                    except (ValueError, TypeError):\n                        network.dualdata.vertex[fkey][name] = value\n        return True\n    return False\n\n\n# ==============================================================================\n# labels\n# ==============================================================================\n\n# use color callables to generate dynamic colors\n# rename formatter to data_formatter\n\ndef display_network_vertex_labels(network, attr_name=None, layer=None, color=None, formatter=None):\n    \"\"\"Display labels for the vertices of a network.\n\n    Parameters:\n        network (compas.datastructures.network.Network): The network object.\n        attr_name (str): Optional. The name of the attribute value to display in the label.\n            Default is ``None``. If ``None``, the key of the vertex is displayed.\n        layer (str): Optional. The layer to draw in. Default is ``None``.\n        color (str, tuple, list, dict): Optional. The color specification. Default is ``None``.\n            The following values are supported:\n\n                * str: A HEX color. For example, ``'#ff0000'``.\n                * tuple, list: RGB color. For example, ``(255, 0, 0)``.\n                * dict: A dictionary of RGB and/or HEX colors.\n\n            If ``None``, the default vertex color of the network will be used.\n        formatter (callable): Optional. A formatting function. Default is ``None``.\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as compas_rhino\n\n            from compas.datastructures.network import Network\n\n            network = Network.from_obj(compas.get_data('lines.obj'))\n\n            compas_compas_rhino.display_network_vertex_labels(network)\n\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as compas_rhino\n\n            from compas.datastructures.network import Network\n\n            network = Network.from_obj(compas.get_data('lines.obj'))\n\n            def formatter(value):\n                return '{0:.3f}'.format(value)\n\n            compas_compas_rhino.display_network_vertex_labels(network, attr_name='x' formatter=formatter)\n\n\n    See Also:\n        * :func:`display_network_edge_labels`\n        * :func:`display_network_face_labels`\n\n    \"\"\"\n    compas_rhino.delete_objects(compas_rhino.get_objects(name=\"{0}.vertex.label.*\".format(network.attributes['name'])))\n\n    if not attr_name:\n        attr_name = 'key'\n\n    colordict = color_to_colordict(color,\n                                   network.vertices(),\n                                   default=network.attributes['color.vertex'],\n                                   colorformat='rgb',\n                                   normalize=False)\n    if formatter:\n        if not callable(formatter):\n            raise Exception('The provided formatter is not callable.')\n    else:\n        formatter = str\n\n    labels = []\n\n    for index, (key, attr) in enumerate(network.vertices(True)):\n        if 'key' == attr_name:\n            value = key\n        elif 'index' == attr_name:\n            value = index\n        else:\n            value = attr[attr_name]\n\n        labels.append({'pos'  : network.vertex_coordinates(key),\n                       'text' : formatter(value),\n                       'name' : \"{0}.vertex.label.{1}\".format(network.attributes['name'], key),\n                       'color': colordict[key], })\n\n    compas_rhino.xdraw_labels(\n        labels,\n        layer=layer,\n        clear=False,\n        redraw=True\n    )\n\n\ndef display_network_edge_labels(network, attr_name=None, layer=None, color=None, formatter=None):\n    \"\"\"Display labels for the edges of a network.\n\n    Parameters:\n        network (compas.datastructures.network.Network): The network object.\n        attr_name (str): Optional. The name of the attribute value to display in the label.\n            Default is ``None``. If ``None``, the key of the edge is displayed.\n        layer (str): Optional. The layer to draw in. Default is ``None``.\n        color (str, tuple, list, dict): Optional. The color specification. Default is ``None``.\n            The following values are supported:\n\n                * str: A HEX color. For example, ``'#ff0000'``.\n                * tuple, list: RGB color. For example, ``(255, 0, 0)``.\n                * dict: A dictionary of RGB and/or HEX colors.\n\n            If ``None``, the default edge color of the network will be used.\n        formatter (callable): Optional. A formatting function. Default is ``None``.\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as compas_rhino\n\n            from compas.datastructures.network import Network\n\n            network = Network.from_obj(compas.get_data('lines.obj'))\n\n            compas_compas_rhino.display_network_edge_labels(network)\n\n\n    See Also:\n        * :func:`display_network_vertex_labels`\n        * :func:`display_network_face_labels`\n\n    \"\"\"\n    compas_rhino.delete_objects(compas_rhino.get_objects(name=\"{0}.edge.label.*\".format(network.attributes['name'])))\n\n    if not attr_name:\n        attr_name = 'key'\n\n    colordict = color_to_colordict(color,\n                                   network.edges(),\n                                   default=network.attributes['color.vertex'],\n                                   colorformat='rgb',\n                                   normalize=False)\n    if formatter:\n        if not callable(formatter):\n            raise Exception('The provided formatter is not callable.')\n    else:\n        formatter = str\n\n    labels = []\n\n    for index, (u, v, attr) in enumerate(network.edges(True)):\n\n        if attr_name == 'key':\n            value = '{0}-{1}'.format(u, v)\n        elif attr_name == 'index':\n            value = index\n        else:\n            value = attr[attr_name]\n\n        labels.append({'pos'  : network.edge_midpoint(u, v),\n                       'text' : formatter(value),\n                       'name' : '{0}.edge.label.{1}-{2}'.format(network.attributes['name'], u, v),\n                       'color': colordict[(u, v)], })\n\n    compas_rhino.xdraw_labels(\n        labels,\n        layer=layer,\n        clear=False,\n        redraw=True\n    )\n\n\ndef display_network_face_labels(network, attr_name=None, layer=None, color=None, formatter=None):\n    \"\"\"Display labels for the faces of a network.\n\n    Parameters:\n        network (compas.datastructures.network.Network): The network object.\n        attr_name (str): Optional. The name of the attribute value to display in the label.\n            Default is ``None``. If ``None``, the key of the face is displayed.\n        layer (str): Optional. The layer to draw in. Default is ``None``.\n        color (str, tuple, list, dict): Optional. The color specification. Default is ``None``.\n            The following values are supported:\n\n                * str: A HEX color. For example, ``'#ff0000'``.\n                * tuple, list: RGB color. For example, ``(255, 0, 0)``.\n                * dict: A dictionary of RGB and/or HEX colors.\n\n            If ``None``, the default face color of the network will be used.\n        formatter (callable): Optional. A formatting function. Default is ``None``.\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as compas_rhino\n\n            from compas.datastructures.network import Network\n\n            network = Network.from_obj(compas.get_data('lines.obj'))\n\n            compas_compas_rhino.display_network_face_labels(network)\n\n\n    See Also:\n        * :func:`display_network_vertex_labels`\n        * :func:`display_network_edge_labels`\n\n    \"\"\"\n    compas_rhino.delete_objects(compas_rhino.get_objects(name=\"{0}.face.label.*\".format(network.attributes['name'])))\n\n    if not attr_name:\n        attr_name = 'key'\n\n    colordict = color_to_colordict(color,\n                                   network.faces(),\n                                   default=network.attributes['color.face'],\n                                   colorformat='rgb',\n                                   normalize=False)\n\n    if formatter:\n        if not callable(formatter):\n            raise Exception('The provided formatter is not callable.')\n    else:\n        formatter = str\n\n    labels = []\n\n    for index, fkey in enumerate(network.faces()):\n        if attr_name == 'key':\n            value = fkey\n        elif attr_name == 'index':\n            value = index\n        else:\n            value = network.facedata[fkey][attr_name]\n\n        labels.append({\n            'pos'  : network.face_centroid(fkey),\n            'text' : formatter(value),\n            'name' : '{0}.face.label.{1}'.format(network.attributes['name'], fkey),\n            'color': colordict[fkey]\n        })\n\n    compas_rhino.xdraw_labels(\n        labels,\n        layer=layer,\n        clear=False,\n        redraw=True\n    )\n\n\n# ==============================================================================\n# geometry\n# ==============================================================================\n\n\ndef move_network(network):\n    \"\"\"Move the entire network.\n\n    Parameters:\n        network (compas.datastructures.network.Network): A network object.\n\n    \"\"\"\n    color  = Rhino.ApplicationSettings.AppearanceSettings.FeedbackColor\n    origin = {key: network.vertex_coordinates(key) for key in network.vertices()}\n    vertex = {key: network.vertex_coordinates(key) for key in network.vertices()}\n    edges  = network.edges()\n    start  = compas_rhino.pick_point('Point to move from?')\n\n    if not start:\n        return\n\n    def OnDynamicDraw(sender, e):\n        current = list(e.CurrentPoint)\n        vec = [current[i] - start[i] for i in range(3)]\n        for key in vertex:\n            vertex[key] = [origin[key][i] + vec[i] for i in range(3)]\n        for u, v in iter(edges):\n            sp = vertex[u]\n            ep = vertex[v]\n            sp = Point3d(*sp)\n            ep = Point3d(*ep)\n            e.Display.DrawDottedLine(sp, ep, color)\n\n    guids = compas_rhino.get_objects(name='{0}.*'.format(network.attributes['name']))\n    compas_rhino.delete_objects(guids, False)\n\n    gp = Rhino.Input.Custom.GetPoint()\n    gp.SetCommandPrompt('Point to move to?')\n    gp.DynamicDraw += OnDynamicDraw\n    gp.Get()\n\n    if gp.CommandResult() == Rhino.Commands.Result.Success:\n        end = list(gp.Point())\n        vec = [end[i] - start[i] for i in range(3)]\n        for key, attr in network.vertices(True):\n            attr['x'] += vec[0]\n            attr['y'] += vec[1]\n            attr['z'] += vec[2]\n\n    try:\n        network.draw()\n    except AttributeError:\n        # this may result in the network being drawn in a different layer then before\n        draw_network(network)\n\n\ndef move_network_vertex(network, key, constraint=None, allow_off=None):\n    \"\"\"Move on vertex of the network.\n\n    Parameters:\n        network (compas.datastructures.network.Network): The network object.\n        key (str): The vertex to move.\n        constraint (Rhino.Geometry): Optional. A ``Rhino.Geometry`` object to\n            constrain the movement to. Default is ``None``.\n        allow_off (bool): Optional. Allow the vertex to move off the constraint.\n            Default is ``None``.\n\n    Example:\n\n        .. code-block:: python\n\n            import compas\n            import compas_rhino as compas_rhino\n\n            from compas.datastructures.network import Network\n\n            network = Network.from_obj(compas.get_data('lines.obj'))\n\n            key = compas_compas_rhino.select_network_vertex(network)\n\n            if key:\n                compas_compas_rhino.move_network_vertex(network, key)\n\n    \"\"\"\n    color = Rhino.ApplicationSettings.AppearanceSettings.FeedbackColor\n    nbrs  = [network.vertex_coordinates(nbr) for nbr in network.vertex_neighbours(key)]\n    nbrs  = [Point3d(*xyz) for xyz in nbrs]\n\n    def OnDynamicDraw(sender, e):\n        for ep in nbrs:\n            sp = e.CurrentPoint\n            e.Display.DrawDottedLine(sp, ep, color)\n\n    gp = Rhino.Input.Custom.GetPoint()\n    gp.SetCommandPrompt('Point to move to?')\n    gp.DynamicDraw += OnDynamicDraw\n\n    if constraint:\n        if allow_off is not None:\n            gp.Constrain(constraint, allow_off)\n        else:\n            gp.Constrain(constraint)\n\n    gp.Get()\n\n    if gp.CommandResult() == Rhino.Commands.Result.Success:\n        pos = list(gp.Point())\n        network.vertex[key]['x'] = pos[0]\n        network.vertex[key]['y'] = pos[1]\n        network.vertex[key]['z'] = pos[2]\n\n    try:\n        network.draw()\n    except AttributeError:\n        # this may result in the network being drawn in a different layer then before\n        draw_network(network)\n\n\n# ==============================================================================\n# forces\n# ==============================================================================\n\n\ndef display_network_axial_forces(network,\n                                 display=True,\n                                 layer=None,\n                                 clear_layer=False,\n                                 scale=1.0,\n                                 attr_name='f',\n                                 color_tension=(255, 0, 0),\n                                 color_compression=(0, 0, 255)):\n    \"\"\"Display the axial forces in the edges of a network.\n\n    Parameters:\n        network (compas.datastructures.network.Network):\n            The network object.\n        display (bool): Optional.\n            If ``True``, display the axial forces.\n            If ``False``, don't display the axial forces.\n            Default is ``True``.\n        layer (str): Optional.\n            The layer to draw in. Default is ``None``.\n        clear_layer (bool): Optional.\n            Flag for clearing the layer.\n            Default is ``False``.\n        scale (float): Optional.\n            The scale of the forces.\n            Default is ``1.0``.\n        attr_name (str): Optional.\n            The name of the edge attribute storing the force value.\n            Default is ``'f'``.\n        color_tension (tuple): Optional.\n            The color to use for tension forces.\n            Default is ``(255, 0, 0)``.\n        color_compression (tuple): Optional.\n            The color to use for compression forces.\n            Default is ``(0, 0, 255)``.\n\n    Example:\n\n        .. code-block:: python\n\n            import random\n            import compas\n            import compas_rhino as compas_rhino\n\n            from compas.datastructures.network import Network\n\n            network = Network.from_obj(compas.get_data('lines.obj'))\n\n            for u, v, attr in network.edges(True):\n                attr['f'] = random.choice([-1.0, 1.0]) * random.randint(1, 10)\n\n            compas_compas_rhino.display_network_axial_forces(network)\n\n    See Also:\n        * :func:`display_network_reaction_forces`\n        * :func:`display_network_residual_forces`\n        * :func:`display_network_selfweight`\n\n    \"\"\"\n    tol = compas_rhino.get_tolerance()\n    objects = compas_rhino.get_objects(name='{0}.force:axial.*'.format(network.attributes['name']))\n    compas_rhino.delete_objects(objects)\n\n    if not display:\n        return\n\n    lines = []\n\n    for u, v, attr in network.edges(True):\n        start  = network.vertex_coordinates(u)\n        end    = network.vertex_coordinates(v)\n        force  = attr['f']\n        color  = color_tension if force > 0.0 else color_compression\n        radius = scale * ((force ** 2) ** 0.5 / 3.14159) ** 0.5\n        name   = '{0}.force:axial.{1}-{2}'.format(network.attributes['name'], u, v)\n\n        if radius < tol:\n            continue\n\n        lines.append({\n            'start' : start,\n            'end'   : end,\n            'name'  : name,\n            'color' : color,\n            'radius': radius,\n        })\n\n    compas_rhino.xdraw_cylinders(lines, layer=layer, clear=clear_layer)\n\n\ndef display_network_reaction_forces(network,\n                                    display=True,\n                                    layer=None,\n                                    clear_layer=False,\n                                    scale=1.0,\n                                    color=(0, 255, 0),\n                                    attr_name='is_anchor'):\n\n    tol = compas_rhino.get_tolerance()\n    objects = compas_rhino.get_objects(name='{0}.force:reaction.*'.format(network.attributes['name']))\n    compas_rhino.delete_objects(objects)\n\n    if not display:\n        return\n\n    lines = []\n\n    for key, attr in network.vertices(True):\n\n        if not attr[attr_name]:\n            continue\n\n        force  = attr['rx'], attr['ry'], attr['rz']\n        start  = network.vertex_coordinates(key)\n        end    = [start[i] - scale * force[i] for i in range(3)]\n        length = sum((end[i] - start[i]) ** 2 for i in range(3)) ** 0.5\n        arrow  = 'end'\n        name   = '{0}.force:reaction.{1}'.format(network.attributes['name'], key)\n\n        if length < tol:\n            continue\n\n        lines.append({\n            'start': start,\n            'end'  : end,\n            'name' : name,\n            'color': color,\n            'arrow': arrow,\n        })\n\n    compas_rhino.xdraw_lines(lines, layer=layer, clear=clear_layer)\n\n\ndef display_network_residual_forces(network,\n                                    display=True,\n                                    layer=None,\n                                    clear_layer=False,\n                                    scale=1.0,\n                                    color=(0, 255, 255),\n                                    attr_name='is_anchor'):\n\n    tol = compas_rhino.get_tolerance()\n    guids = compas_rhino.get_objects(name='{0}.force:residual.*'.format(network.attributes['name']))\n    compas_rhino.delete_objects(guids)\n\n    if not display:\n        return\n\n    lines = []\n\n    for key, attr in network.vertices(True):\n\n        if attr[attr_name]:\n            continue\n\n        force  = attr['rx'], attr['ry'], attr['rz']\n        start  = network.vertex_coordinates(key)\n        end    = [start[i] + scale * force[i] for i in range(3)]\n        length = distance_point_point(start, end)\n        arrow  = 'end'\n        name   = '{0}.force:residual.{1}'.format(network.attributes['name'], key)\n\n        if length < tol:\n            continue\n\n        lines.append({\n            'start' : start,\n            'end'   : end,\n            'name'  : name,\n            'color' : color,\n            'arrow' : arrow,\n        })\n\n    compas_rhino.xdraw_lines(lines, layer=layer, clear=clear_layer)\n\n\ndef display_network_selfweight(network,\n                               display=True,\n                               layer=None,\n                               clear_layer=False,\n                               scale=1.0,\n                               color=(0, 255, 0)):\n\n    tol = compas_rhino.get_tolerance()\n    guids = compas_rhino.get_objects(name='{0}.force:selfweight.*'.format(network.attributes['name']))\n    compas_rhino.delete_objects(guids)\n\n    if not display:\n        return\n\n    lines = []\n\n    for key, attr in network.vertices(True):\n        load   = 0, 0, network.vertex_area(key)\n        start  = network.vertex_coordinates(key)\n        end    = [start[i] - scale * load[i] for i in range(3)]\n        name   = '{0}.force:selfweight.{1}'.format(network.attributes['name'], key)\n        arrow  = 'end'\n        length = distance_point_point(start, end)\n\n        if length < tol:\n            continue\n\n        lines.append({\n            'start': start,\n            'end'  : end,\n            'name' : name,\n            'color': color,\n            'arrow': arrow,\n        })\n\n    compas_rhino.xdraw_lines(lines, layer=layer, clear=clear_layer)\n\n\ndef display_network_applied_loads(network,\n                                  display=True,\n                                  layer=None,\n                                  clear_layer=False,\n                                  scale=1.0,\n                                  color=(0, 0, 255)):\n\n    tol = compas_rhino.get_tolerance()\n    guids = compas_rhino.get_objects(name='{0}.force:load.*'.format(network.attributes['name']))\n    compas_rhino.delete_objects(guids)\n\n    if not display:\n        return\n\n    lines = []\n\n    for key, attr in network.vertices(True):\n        load   = attr['px'], attr['py'], attr['pz']\n        end    = network.vertex_coordinates(key)\n        start  = [end[i] - scale * load[i] for i in range(3)]\n        length = distance_point_point(start, end)\n        arrow  = 'end'\n        name   = '{0}.force:load.{1}'.format(network.attributes['name'], key)\n\n        if length < tol:\n            continue\n\n        lines.append({\n            'start': start,\n            'end'  : end,\n            'name' : name,\n            'color': color,\n            'arrow': arrow,\n        })\n\n    compas_rhino.xdraw_lines(lines, layer=layer, clear=clear_layer)\n\n\n# ==============================================================================\n# Debugging\n# ==============================================================================\n\nif __name__ == \"__main__\":\n    pass\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}