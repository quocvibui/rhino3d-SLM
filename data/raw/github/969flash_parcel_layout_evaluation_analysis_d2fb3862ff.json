{
  "source_url": "https://github.com/969flash/parcel_layout_evaluation_analysis/blob/af8592ec3f658bf5bb8b63064ff33fdbf46240d0/grasshopper/utils.py",
  "repo": "969flash/parcel_layout_evaluation_analysis",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "grasshopper/utils.py",
  "instruction": null,
  "code": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Any, Optional, Union\nimport math\nimport functools\nimport Rhino\nimport Rhino.Geometry as geo\nimport ghpythonlib.components as ghcomp\n\nfrom constants import TOL, ROUNDING_PRECISION, BIGNUM, OP_TOL, CLIPPER_TOL\n\n# Type Hinting\nCurveLike = Union[geo.Curve, List[geo.Curve]]\n\n\ndef convert_io_to_list(func):\n    \"\"\"인풋과 아웃풋을 리스트로 만들어주는 데코레이터\"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        new_args = []\n        for arg in args:\n            if isinstance(arg, geo.Curve):\n                arg = [arg]\n            new_args.append(arg)\n\n        result = func(*new_args, **kwargs)\n        if isinstance(result, geo.Curve):\n            result = [result]\n        if hasattr(result, \"__dict__\"):\n            for key, values in result.__dict__.items():\n                if isinstance(values, geo.Curve):\n                    setattr(result, key, [values])\n        return result\n\n    return wrapper\n\n\n# ==============================================================================\n# 1. 코어 지오메트리 유틸리티 (Core Geometry Utilities)\n# ==============================================================================\n\n\ndef get_distance_between_points(point_a: geo.Point3d, point_b: geo.Point3d) -> float:\n    \"\"\"두 점 사이의 거리를 계산합니다.\"\"\"\n    return round(point_a.DistanceTo(point_b), ROUNDING_PRECISION)\n\n\ndef get_distance_between_point_and_curve(point: geo.Point3d, curve: geo.Curve) -> float:\n    \"\"\"점과 커브 사이의 최단 거리를 계산합니다.\"\"\"\n    _, param = curve.ClosestPoint(point)\n    dist = point.DistanceTo(curve.PointAt(param))\n    return round(dist, ROUNDING_PRECISION)\n\n\ndef get_distance_between_curves(curve_a: geo.Curve, curve_b: geo.Curve) -> float:\n    \"\"\"두 커브 사이의 최소 거리를 계산합니다.\"\"\"\n    _, pt_a, pt_b = curve_a.ClosestPoints(curve_b)\n    dist = pt_a.DistanceTo(pt_b)\n    return round(dist, ROUNDING_PRECISION)\n\n\ndef get_vector_from_pts(pt_a: geo.Point3d, pt_b: geo.Point3d) -> geo.Vector3d:\n    \"\"\"두 점 사이의 벡터를 계산합니다.\"\"\"\n    return geo.Vector3d(pt_b.X - pt_a.X, pt_b.Y - pt_a.Y, pt_b.Z - pt_a.Z)\n\n\ndef get_vertices(curve: geo.Curve) -> List[geo.Point3d]:\n    \"\"\"커브의 모든 정점(Vertex)들을 추출합니다.\"\"\"\n    if not curve:\n        return []\n    vertices = [curve.PointAt(curve.SpanDomain(i)[0]) for i in range(curve.SpanCount)]\n    if not curve.IsClosed:\n        vertices.append(curve.PointAtEnd)\n    return vertices\n\n\ndef move_curve(curve: geo.Curve, vector: geo.Vector3d) -> geo.Curve:\n    \"\"\"커브를 주어진 벡터만큼 이동시킨 복사본을 반환합니다.\"\"\"\n    moved_curve = curve.Duplicate()\n    moved_curve.Translate(vector)\n    return moved_curve\n\n\ndef explode_curve(curve: geo.Curve) -> List[geo.Curve]:\n    \"\"\"커브를 분할하여 개별 세그먼트 리스트로 반환합니다.\"\"\"\n    if not curve:\n        return []\n    if isinstance(curve, geo.PolyCurve):\n        return list(curve.DuplicateSegments())\n\n    segments = []\n    if curve.SpanCount > 0:\n        for i in range(curve.SpanCount):\n            sub_curve = curve.Trim(curve.SpanDomain(i))\n            if sub_curve:\n                segments.append(sub_curve)\n    elif curve.IsLinear():\n        segments.append(curve.Duplicate())\n\n    return segments\n\n\ndef get_pts_by_length(\n    crv: geo.Curve, length: float, include_start: bool = False\n) -> List[geo.Point3d]:\n    \"\"\"커브를 주어진 길이로 나누는 점들을 구합니다.\"\"\"\n    params = crv.DivideByLength(length, include_start)\n    if not params:\n        return []\n    return [crv.PointAt(param) for param in params]\n\n\ndef get_area(regions: Union[List[geo.Curve], geo.Curve]) -> float:\n    \"\"\"영역 커브의 면적을 계산합니다.\"\"\"\n    if not isinstance(regions, list):\n        regions = [regions]\n\n    area = sum([geo.AreaMassProperties.Compute(r).Area for r in regions])\n    return round(area, ROUNDING_PRECISION)\n\n\ndef get_length(curve: geo.Curve) -> float:\n    \"\"\"커브의 길이를 계산합니다.\"\"\"\n    if not curve:\n        return 0.0\n    length = curve.GetLength()\n    return round(length, ROUNDING_PRECISION)\n\n\n# ==============================================================================\n# 2. 고급 지오메트리 연산 (Advanced Geometry Operations)\n# ==============================================================================\n\n\ndef has_intersection(\n    curve_a: geo.Curve,\n    curve_b: geo.Curve,\n    plane: geo.Plane = geo.Plane.WorldXY,\n    tol: float = TOL,\n) -> bool:\n    \"\"\"두 커브가 교차하는지 여부를 확인합니다.\"\"\"\n    return geo.Curve.PlanarCurveCollision(curve_a, curve_b, plane, tol)\n\n\ndef get_intersection_points(\n    curve_a: geo.Curve, curve_b: geo.Curve, tol: float = TOL\n) -> List[geo.Point3d]:\n    \"\"\"두 커브 사이의 교차점을 계산합니다.\"\"\"\n    intersections = geo.Intersect.Intersection.CurveCurve(curve_a, curve_b, tol, tol)\n    if not intersections:\n        return []\n    return [event.PointA for event in intersections if event.IsPointAValid]\n\n\ndef has_region_intersection(\n    region_a: geo.Curve, region_b: geo.Curve, tol: float = TOL\n) -> bool:\n    \"\"\"두 닫힌 영역 커브가 교차(겹침 포함)하는지 확인합니다.\"\"\"\n    relationship = geo.Curve.PlanarClosedCurveRelationship(\n        region_a, region_b, geo.Plane.WorldXY, tol\n    )\n    return relationship != geo.RegionContainment.Disjoint\n\n\ndef is_region_inside(\n    inner_region: geo.Curve, outer_region: geo.Curve, tol: float = TOL\n) -> bool:\n    \"\"\"내부 영역이 외부 영역에 포함되는지 확인합니다.\"\"\"\n    relationship = geo.Curve.PlanarClosedCurveRelationship(\n        inner_region, outer_region, geo.Plane.WorldXY, tol\n    )\n\n    return relationship == geo.RegionContainment.AInsideB\n\n\ndef get_overlapped_curves(curve_a: geo.Curve, curve_b: geo.Curve) -> List[geo.Curve]:\n    \"\"\"두 커브가 겹치는 구간의 커브들을 반환합니다.\"\"\"\n    if not has_intersection(curve_a, curve_b) or not ghcomp:\n        return []\n\n    intersection_points = get_intersection_points(curve_a, curve_b)\n    explode_result = ghcomp.Explode(curve_a, True)\n    explode_points = (\n        explode_result.vertices + intersection_points\n        if explode_result\n        else intersection_points\n    )\n\n    if not explode_points:\n        return []\n\n    params = [ghcomp.CurveClosestPoint(pt, curve_a).parameter for pt in explode_points]\n    shatter_result = ghcomp.Shatter(curve_a, params)\n\n    if not shatter_result:\n        return []\n\n    overlapped_segments = [\n        seg for seg in shatter_result if has_intersection(seg, curve_b)\n    ]\n    if not overlapped_segments:\n        return []\n\n    return geo.Curve.JoinCurves(overlapped_segments)\n\n\ndef get_overlapped_length(curve_a: geo.Curve, curve_b: geo.Curve) -> float:\n    \"\"\"두 커브가 겹치는 총 길이를 계산합니다.\"\"\"\n    overlapped_curves = get_overlapped_curves(curve_a, curve_b)\n    if not overlapped_curves:\n        return 0.0\n    return sum(crv.GetLength() for crv in overlapped_curves)\n\n\ndef get_min_bbox(region: geo.Curve) -> geo.BoundingBox:\n    \"\"\"컨벡스헐 알고리즘을 활용해 영역 커브의 최소 외접사각형을 구한다.\"\"\"\n\n    # 1. 컨벡스헐 연산\n    pts = get_vertices(region)\n    hull_pts = ghcomp.ConvexHull(pts, geo.Plane.WorldXY).indices\n    if not hull_pts:\n        raise ValueError(\"컨벡스 헐 계산 실패\")\n\n    # 2. 컨벡스헐 결과물 세그먼트기준으로 바운딩박스 생성\n    bbox_list = []\n    for i in range(len(hull_pts)):\n        pt_a = pts[hull_pts[i]]\n        pt_b = pts[hull_pts[(i + 1) % len(hull_pts)]]\n        # get_plane form pt_a to pt_b\n        line = geo.Line(pt_a, pt_b)\n        dir_vector = line.Direction\n        normal_vector = geo.Vector3d.CrossProduct(dir_vector, geo.Vector3d.ZAxis)\n        plane = geo.Plane(pt_a, dir_vector, normal_vector)\n        bbox = region.GetBoundingBox(plane)\n        bbox_list.append(bbox)\n\n    # 3. 최소 면적 바운딩박스 선택\n    min_bbox = min(bbox_list, key=lambda b: b.Area)\n\n    return min_bbox\n\n\nclass Offset:\n    class _OffsetResult:\n        def __init__(self):\n            self.contour: Optional[List[geo.Curve]] = None\n            self.holes: Optional[List[geo.Curve]] = None\n\n    @convert_io_to_list\n    def polyline_offset(\n        self,\n        crvs: List[geo.Curve],\n        dists: List[float],\n        miter: int = BIGNUM,\n        closed_fillet: int = 2,\n        open_fillet: int = 2,\n        tol: float = Rhino.RhinoMath.ZeroTolerance,\n    ) -> _OffsetResult:\n        \"\"\"\n        Args:\n            crv (_type_): _description_\n            dists (_type_): _description_\n            miter : miter\n            closed_fillet : 0 = round, 1 = square, 2 = miter\n            open_fillet : 0 = round, 1 = square, 2 = butt\n\n        Returns:\n            _type_: _OffsetResult\n        \"\"\"\n        if not crvs:\n            raise ValueError(\"No Curves to offset\")\n\n        plane = geo.Plane(geo.Point3d(0, 0, crvs[0].PointAtEnd.Z), geo.Vector3d.ZAxis)\n        result = ghcomp.ClipperComponents.PolylineOffset(\n            crvs,\n            dists,\n            plane,\n            tol,\n            closed_fillet,\n            open_fillet,\n            miter,\n        )\n\n        polyline_offset_result = Offset._OffsetResult()\n        for name in (\"contour\", \"holes\"):\n            setattr(polyline_offset_result, name, result[name])\n        return polyline_offset_result\n\n\ndef offset_regions_inward(\n    regions: Union[geo.Curve, List[geo.Curve]], dist: float, miter: int = BIGNUM\n) -> List[geo.Curve]:\n    \"\"\"영역 커브를 안쪽으로 offset 한다.\n    단일커브나 커브리스트 관계없이 커브 리스트로 리턴한다.\n    Args:\n        region: offset할 대상 커브\n        dist: offset할 거리\n\n    Returns:\n        offset 후 커브\n    \"\"\"\n\n    if not dist:\n        return regions\n    result = Offset().polyline_offset(regions, dist, miter).holes\n\n    if not result:\n        return []\n\n    if isinstance(regions, geo.Curve):\n        regions = [regions]\n\n    if len(result) < 2:\n        return result\n\n    filtered = [\n        crv for crv in result if any(is_region_inside(crv, reg) for reg in regions)\n    ]\n    return filtered\n\n\ndef offset_regions_outward(\n    regions: Union[geo.Curve, List[geo.Curve]], dist: float, miter: int = BIGNUM\n) -> List[geo.Curve]:\n    \"\"\"영역 커브를 바깥쪽으로 offset 한다.\n    단일커브나 커브리스트 관계없이 커브 리스트로 리턴한다.\n    Args:\n        region: offset할 대상 커브\n        dist: offset할 거리\n    returns:\n        offset 후 커브\n    \"\"\"\n    if isinstance(regions, geo.Curve):\n        regions = [regions]\n\n    return [offset_region_outward(region, dist, miter) for region in regions]\n\n\ndef simplify_regions_with_offset(\n    regions: List[geo.Curve], dist: float, miter: int = BIGNUM\n) -> Union[List[geo.Curve], geo.Curve]:\n    \"\"\"영역 커브를 안팎으로 offset 하여 단순화한다.\n    이로인해 dist 미만의 폭을 가진 영역이 사라진다.\n    Args:\n        region: 단순화할 대상 커브\n        dist: 안팎으로 offset할 거리\n\n    Returns:\n        단순화된 커브 리스트\n    \"\"\"\n    if not regions:\n        return []\n\n    if dist <= 0.0:\n        return regions\n\n    inner = offset_regions_inward(regions, dist * 0.5, miter)\n    if not inner:\n        return []\n\n    outer = offset_regions_outward(inner, dist * 0.5, miter)\n\n    # NOTE:\n    # in -> out 단순화는 수치오차/미터 처리에 따라 원본 영역(regions) 밖으로\n    # 미세하게 확장되는 케이스가 발생할 수 있습니다.\n    # 후속 계산(특히 면적 합산)에서 score > 1 같은 버그로 이어질 수 있으므로\n    # 반드시 원본 영역과의 교집합으로 클램프합니다.\n    clamped = get_intersection_regions(outer, regions)\n    return clamped\n\n\n# ==============================================================================\n# 2.1 폴리라인 기반 세그먼트 감소형 Simplify (전처리 친화)\n# ==============================================================================\n\n\ndef simplify_crv_by_reducing_segments(\n    crv: geo.Curve,\n    tol: float = TOL,\n    angle_tol: Optional[float] = None,\n) -> geo.Curve:\n    \"\"\"MergeColinearSegments + ReduceSegments 기반 단순화.\n\n    - colinear(동일선상) 세그먼트 병합 후, 길이/변화가 tol 이내인 세그먼트 제거로 안정화.\n    - 닫힌 커브의 시작/끝 점 처리 보정 포함.\n    - 실패/과도 단순화 시 원본 반환.\n    \"\"\"\n    if crv is None:\n        return crv\n\n    if angle_tol is None:\n        # 가능하면 constants.ANGLE_TOL 사용, 없으면 약 1도(라디안)\n        try:\n            from constants import ANGLE_TOL as _ANGLE_TOL  # type: ignore\n\n            angle_tol = float(_ANGLE_TOL)\n        except Exception:\n            angle_tol = math.radians(1.0)\n\n    # vertices 기반 polyline 작성\n    pts = get_vertices(crv)\n    if not pts:\n        return crv\n    if crv.IsClosed:\n        pts.append(pts[0])\n\n    pl = geo.Polyline(pts)\n\n    # colinear 병합 및 세그먼트 감소\n    try:\n        pl.MergeColinearSegments(angle_tol, True)\n    except Exception:\n        pass\n    try:\n        pl.ReduceSegments(tol)\n    except Exception:\n        pass\n\n    # 닫힌 커브의 시작점 보정(일부 케이스에서 ReduceSegments가 시작점에 동작하지 않음)\n    try:\n        if pl.IsClosed and pl.Count > 3:\n            pt_items = list(pl.Item)\n            pt_first = pt_items[0]\n            pt1 = pt_items[1]\n            pt2 = pt_items[pl.Count - 2]\n            if geo.Line(pt1, pt2).DistanceTo(pt_first, True) <= tol:\n                pl.RemoveAt(0)\n                pl.RemoveAt(pl.Count - 1)\n                pl.Add(pl.First)\n    except Exception:\n        pass\n\n    polycrv = pl.ToPolylineCurve()\n    if not getattr(polycrv, \"IsValid\", False):\n        # 너무 작은/불안정한 경우 원본 유지\n        return crv\n    return polycrv\n\n\ndef simplify_crvs_by_reducing_segments(\n    crvs: List[geo.Curve], tol: float = TOL, angle_tol: Optional[float] = None\n) -> List[geo.Curve]:\n    \"\"\"여러 커브에 대해 세그먼트 감소형 단순화를 일괄 적용\"\"\"\n    if not crvs:\n        return []\n    out: List[geo.Curve] = []\n    for r in crvs:\n        try:\n            out.append(simplify_crv_by_reducing_segments(r, tol, angle_tol))\n        except Exception:\n            out.append(r)\n    return out\n\n\ndef offset_region_outward(\n    region: geo.Curve, dist: float, miter: float = BIGNUM\n) -> geo.Curve:\n    \"\"\"영역 커브를 바깥쪽으로 offset 한다.\n    단일 커브를 받아서 단일 커브로 리턴한다.\n    Args:\n        region: offset할 대상 커브\n        dist: offset할 거리\n\n    Returns:\n        offset 후 커브\n    \"\"\"\n\n    if not dist:\n        return region\n    if not isinstance(region, geo.Curve):\n        raise ValueError(\"region must be curve\")\n    return Offset().polyline_offset(region, dist, miter).contour[0]\n\n\nclass RegionBool:\n    @convert_io_to_list\n    def _polyline_boolean(\n        self, crvs0, crvs1, boolean_type=None, plane=None, tol=CLIPPER_TOL\n    ):\n        # type: (List[geo.Curve], List[geo.Curve], int, geo.Plane, float) -> List[geo.Curve]\n        if not crvs0 or not crvs1:\n            raise ValueError(\"Check input values\")\n        result = ghcomp.ClipperComponents.PolylineBoolean(\n            crvs0, crvs1, boolean_type, plane, tol\n        )\n\n        # 결과는 IronPython.Runtime.List (파이썬 list처럼 동작) 이거나 단일 커브일 수 있으므로 통일해서 list로 반환\n        if not result:\n            return []\n\n        # IronPython.Runtime.List, System.Collections.Generic.List, tuple 등 반복 가능한 결과를 모두 처리\n        if isinstance(result, geo.Curve):\n            # 단일 커브 객체\n            result = [result]\n        else:\n            try:\n                # IEnumerable / IronPython.Runtime.List / tuple / System.Collections.Generic.List 모두 list() 시도로 통일\n                result = [crv for crv in list(result) if crv]\n            except TypeError:\n                # 반복 불가능한 단일 객체인 예외 상황\n                result = [result]\n\n        return result\n\n    def polyline_boolean_intersection(self, crvs0, crvs1, plane=None, tol=CLIPPER_TOL):\n        # type: (Union[geo.Curve, List[geo.Curve]], Union[geo.Curve, List[geo.Curve]], geo.Plane, float) -> List[geo.Curve]\n        return self._polyline_boolean(crvs0, crvs1, 0, plane, tol)\n\n    def polyline_boolean_union(self, crvs0, crvs1, plane=None, tol=CLIPPER_TOL):\n        # type: (Union[geo.Curve, List[geo.Curve]], Union[geo.Curve, List[geo.Curve]], geo.Plane, float) -> List[geo.Curve]\n        return self._polyline_boolean(crvs0, crvs1, 1, plane, tol)\n\n    def polyline_boolean_difference(self, crvs0, crvs1, plane=None, tol=CLIPPER_TOL):\n        # type: (Union[geo.Curve, List[geo.Curve]], Union[geo.Curve, List[geo.Curve]], geo.Plane, float) -> List[geo.Curve]\n        return self._polyline_boolean(crvs0, crvs1, 2, plane, tol)\n\n\ndef get_intersection_regions(\n    regions_a: List[geo.Curve], regions_b: List[geo.Curve]\n) -> List[geo.Curve]:\n    \"\"\"두 영역 커브 리스트의 교집합을 구합니다.\n    Args:\n        regions_a: 첫 번째 영역 커브 리스트\n        regions_b: 두 번째 영역 커브 리스트\n    Returns:\n        교집합 결과 커브들\n    \"\"\"\n    if not regions_a or not regions_b:\n        return []\n    intersection_result = RegionBool().polyline_boolean_intersection(\n        regions_a, regions_b\n    )\n    return intersection_result\n\n\ndef get_union_regions(regions: List[geo.Curve] = None) -> List[geo.Curve]:\n    \"\"\"주어진 영역 커브들의 합집합을 구합니다.\n    Args:\n        regions: 합집합을 구할 영역 커브들\n    Returns:\n        합집합 결과 커브들\n    \"\"\"\n    if not regions:\n        return []\n\n    if len(regions) == 1:\n        return regions\n\n    union_result = list(geo.Curve.CreateBooleanUnion(regions, TOL))\n    if union_result:\n        return union_result\n\n    union_result = regions[0]\n    for region in regions[1:]:\n        union_result = RegionBool().polyline_boolean_union(union_result, region)\n\n    if not isinstance(union_result, list):\n        union_result = [union_result]\n\n    return union_result\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}