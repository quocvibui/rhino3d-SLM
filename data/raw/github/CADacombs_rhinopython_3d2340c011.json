{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Srf_mirrorAndAverageMatch.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Srf_mirrorAndAverageMatch.py",
  "instruction": "Behavior notes:\r\n    Only untrimmed surfaces (monoface breps) are modified.\r\n    Symmetry planes are per World, not CPlane.",
  "code": "\"\"\"\r\nBehavior notes:\r\n    Only untrimmed surfaces (monoface breps) are modified.\r\n    Symmetry planes are per World, not CPlane.\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, print_function, unicode_literals\r\n\r\n\"\"\"\r\n220731: Created.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'fDistTol'; keys.append(key)\r\n    values[key] = 1.0\r\n    names[key] = 'MaxDist'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'iSymPlane'; keys.append(key)\r\n    values[key] = 0\r\n    listValues[key] = 'X', 'Y', 'Z'\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        if not idxOpt: print(\"Add option for {} failed.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fDistTol':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.values[key] = cls.riOpts[key].InitialValue\r\n            if cls.riOpts[key].CurrentValue <= Rhino.RhinoMath.ZeroTolerance:\r\n                cls.riOpts[key].CurrentValue = cls.values[key] = Rhino.RhinoMath.ZeroTolerance\r\n            else:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n        else:\r\n            if key in cls.riOpts:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n            elif key in cls.listValues:\r\n                cls.values[key] = idxList\r\n            else:\r\n                return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef _getInput_UntrimmedSrfs():\r\n    \"\"\"\r\n    Get curves with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select untrimmed surfaces\")\r\n\r\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Surface\r\n    go.GeometryAttributeFilter = ri.Custom.GeometryAttributeFilter.UntrimmedSurface\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    go.AlreadySelectedObjectSelect = True\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Keep objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False)\r\n\r\n    bPreselectedObjsChecked = False\r\n\r\n    idxs_Opt = {}\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n        addOption('fDistTol')\r\n        #addOption('bEcho')\r\n        #addOption('bDebug')\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        # Use bPreselectedObjsChecked so that only objects before the\r\n        # first call to go.GetMultiple is considered.\r\n        if not bPreselectedObjsChecked and go.ObjectsWerePreselected:\r\n            bPreselectedObjsChecked = True\r\n            go.EnablePreSelect(False, True)\r\n            continue\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fDistTol'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef _getInput_SymmetryPlane():\r\n    \"\"\"\r\n    Get option.\r\n    \"\"\"\r\n\r\n    idxOpt_Default = Opts.values['iSymPlane']\r\n\r\n    go = ri.Custom.GetOption()\r\n\r\n    go.SetCommandPrompt(\"Pick mirror plane\")\r\n    go.SetCommandPromptDefault(Opts.listValues['iSymPlane'][idxOpt_Default])\r\n    go.AcceptNothing(True)\r\n\r\n    idxs_Opt = {}\r\n\r\n    for sOpt in Opts.listValues['iSymPlane']:\r\n        idxs_Opt[sOpt] = go.AddOption(sOpt)\r\n\r\n    res = go.Get()\r\n\r\n\r\n    if res == ri.GetResult.Cancel:\r\n        go.Dispose()\r\n        return\r\n\r\n    if res == ri.GetResult.Nothing:\r\n        idxOpt = idxOpt_Default\r\n    elif res == ri.GetResult.Option:\r\n        idxOpt = go.Option().Index - 1 # '- 1' because go.Option().Index is base 1.\r\n        Opts.setValue('iSymPlane', idxOpt)\r\n\r\n    go.Dispose()\r\n\r\n    return Opts.listValues['iSymPlane'][idxOpt]\r\n\r\n\r\ndef _getPerpCompFromPlane(sPlane):\r\n    if sPlane == 'XY': return 'Z'\r\n    if sPlane == 'YZ': return 'X'\r\n    if sPlane == 'ZX': return 'Y'\r\n\r\n\r\ndef _getLocComp(cp, sLocComp):\r\n    if sLocComp == 'X':\r\n        return cp.X\r\n    if sLocComp == 'Y':\r\n        return cp.Y\r\n    if sLocComp == 'Z':\r\n        return cp.Z\r\n\r\n\r\ndef getSide(ns_In, sPlane, fDistTol):\r\n\r\n    sCompZero = _getPerpCompFromPlane(sPlane)\r\n\r\n    for iu in range(ns_In.Points.CountU):\r\n        cp = ns_In.Points.GetControlPoint(iu, 0)\r\n        if abs(_getLocComp(cp, sCompZero)) > fDistTol:\r\n            break\r\n    else:\r\n        return rg.IsoStatus.South\r\n\r\n    for iv in range(ns_In.Points.CountV):\r\n        cp = ns_In.Points.GetControlPoint(ns_In.Points.CountU-1, iv)\r\n        if abs(_getLocComp(cp, sCompZero)) > fDistTol:\r\n            break\r\n    else:\r\n        return rg.IsoStatus.East\r\n\r\n    for iu in range(ns_In.Points.CountU):\r\n        cp = ns_In.Points.GetControlPoint(iu, ns_In.Points.CountV-1)\r\n        if abs(_getLocComp(cp, sCompZero)) > fDistTol:\r\n            break\r\n    else:\r\n        return rg.IsoStatus.North\r\n\r\n    for iv in range(ns_In.Points.CountV):\r\n        cp = ns_In.Points.GetControlPoint(0, iv)\r\n        if abs(_getLocComp(cp, sCompZero)) > fDistTol:\r\n            break\r\n    else:\r\n        return rg.IsoStatus.West\r\n\r\n\r\ndef createSymmetricPair(ns_In, side, sPlane_Sym):\r\n    \r\n    ns_Out_A = ns_In.Duplicate()\r\n    \r\n    sComp_Perp = _getPerpCompFromPlane(sPlane_Sym)\r\n    \r\n    ius_P0 = []\r\n    ivs_P0 = []\r\n    ius_P1 = []\r\n    ivs_P1 = []\r\n    \r\n    if side == rg.IsoStatus.South:\r\n        for iu in range(ns_Out_A.Points.CountU):\r\n            ius_P0.append(iu)\r\n            ivs_P0.append(0)\r\n            ius_P1.append(iu)\r\n            ivs_P1.append(1)\r\n    elif side == rg.IsoStatus.East:\r\n        for iv in range(ns_Out_A.Points.CountV):\r\n            ius_P0.append(ns_Out_A.Points.CountU-1)\r\n            ivs_P0.append(iv)\r\n            ius_P1.append(1)\r\n            ivs_P1.append(ns_Out_A.Points.CountU-2)\r\n    elif side == rg.IsoStatus.North:\r\n        for iu in range(ns_Out_A.Points.CountU):\r\n            ius_P0.append(iu)\r\n            ivs_P0.append(ns_Out_A.Points.CountV-1)\r\n            ius_P1.append(iu)\r\n            ivs_P1.append(ns_Out_A.Points.CountV-2)\r\n    elif side == rg.IsoStatus.West:\r\n        for iv in range(ns_Out_A.Points.CountV):\r\n            ius_P0.append(0)\r\n            ivs_P0.append(iv)\r\n            ius_P1.append(1)\r\n            ivs_P1.append(iv)\r\n    \r\n    \r\n    def setLocComp(cp, sLocComp, fComp=0.0):\r\n        if sLocComp == 'X':\r\n            cp.X = fComp\r\n            return cp.X == fComp\r\n        if sLocComp == 'Y':\r\n            cp.Y = fComp\r\n            return cp.Y == fComp\r\n        if sLocComp == 'Z':\r\n            cp.Z = fComp\r\n            return cp.Z == fComp\r\n    \r\n    \r\n    for iu_P0, iv_P0, iu_P1, iv_P1 in zip(ius_P0, ivs_P0, ius_P1, ivs_P1):\r\n        cpA = ns_Out_A.Points.GetControlPoint(iu_P0, iv_P0)\r\n        cpB = ns_Out_A.Points.GetControlPoint(iu_P1, iv_P1)\r\n        \r\n        delta_Comp = -_getLocComp(cpA, sComp_Perp)\r\n        \r\n        if delta_Comp != 0.0:\r\n            setLocComp(cpA, sComp_Perp, 0.0)\r\n            ns_Out_A.Points.SetControlPoint(iu_P0, iv_P0, cpA)\r\n            \r\n            setLocComp(\r\n                cpB,\r\n                sComp_Perp,\r\n                delta_Comp + _getLocComp(cpB, sComp_Perp)\r\n                )\r\n            \r\n            ns_Out_A.Points.SetControlPoint(iu_P1, iv_P1, cpB)\r\n        \r\n        for sComp in sPlane_Sym:\r\n            compA = _getLocComp(cpA, sComp)\r\n            if compA != _getLocComp(cpB, sComp):\r\n                setLocComp(cpB, sComp, compA)\r\n                \r\n                ns_Out_A.Points.SetControlPoint(iu_P1, iv_P1, cpB)\r\n    \r\n    \r\n    ns_Out_B = ns_Out_A.Duplicate()\r\n    \r\n    if sPlane_Sym == 'XY':\r\n        plane_sym = rg.Plane.WorldXY\r\n    elif sPlane_Sym == 'YZ':\r\n        plane_sym = rg.Plane.WorldYZ\r\n    elif sPlane_Sym == 'ZX':\r\n        plane_sym = rg.Plane.WorldZX\r\n    else:\r\n        raise Exception(\"What happened?\") \r\n    \r\n    xform = rg.Transform.Mirror(plane_sym)\r\n    \r\n    if not ns_Out_B.Transform(xform):\r\n        print(\"Transformation failed.\")\r\n        ns_Out_A.Dispose()\r\n        ns_Out_B.Dispose()\r\n        return\r\n    \r\n    return ns_Out_A, ns_Out_B\r\n\r\n\r\ndef main():\r\n    \r\n    objrefs_In = _getInput_UntrimmedSrfs()\r\n    if objrefs_In is None: return\r\n    \r\n    sMirrorOpt = _getInput_SymmetryPlane()\r\n    if sMirrorOpt is None: return\r\n    \r\n    fDistTol = Opts.values['fDistTol']\r\n    \r\n    iCt_Results = 0\r\n    \r\n    \r\n    for objref_In in objrefs_In:\r\n        rgF_In = objref_In.Face()\r\n        rgS_In = rgF_In.UnderlyingSurface()\r\n        if not isinstance(rgS_In, rg.NurbsSurface): continue\r\n        \r\n        ns_In = rgS_In\r\n        \r\n        if sMirrorOpt == 'X':\r\n            sPlane_Sym = 'ZX'\r\n        elif sMirrorOpt == 'Y':\r\n            sPlane_Sym = 'YZ'\r\n        elif sMirrorOpt == 'Z':\r\n            sPlane_Sym = 'XY'\r\n        else:\r\n            raise ValueError(\"{} not a value symmetry plane description.\".format(\r\n                sMirrorOpt))\r\n\r\n        side = getSide(ns_In, sPlane_Sym, fDistTol)\r\n        if side is None: continue\r\n        \r\n        nss_WIP = createSymmetricPair(ns_In, side, sPlane_Sym)\r\n        if nss_WIP is None: continue\r\n\r\n        sc.doc.Objects.Replace(objref_In, nss_WIP[0])\r\n\r\n        sc.doc.Objects.AddSurface(nss_WIP[1], objref_In.Object().Attributes)\r\n\r\n        iCt_Results += 1\r\n\r\n    sc.doc.Views.Redraw()\r\n\r\n\r\n    print(\"{} out of {} surfaces made into symmetric pairs.\".format(\r\n        iCt_Results, len(objrefs_In)))\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}