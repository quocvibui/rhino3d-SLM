{
  "source_url": "https://github.com/SimosManiatis/multi-robot-assembly/blob/e0f9038e33e420b5b5cfafb368d99047f645e6d7/src/robotic_assembly/RobotCommand.py",
  "repo": "SimosManiatis/multi-robot-assembly",
  "repo_stars": 0,
  "repo_description": "The project is  focused on designing a system of multi-robot assembly of rigidity-preserving structures, all while eliminating the use of scaffolding. ",
  "license": "MIT",
  "filepath": "src/robotic_assembly/RobotCommand.py",
  "instruction": "Robot command",
  "code": "import Rhino.Geometry as rg\nimport Grasshopper\nfrom Grasshopper.Kernel.Data import GH_Path\n\n# Inputs:\n# target_planes - DataTree of Planes in assembly order\n# approach_planes - DataTree of Planes corresponding to target_planes (optional)\n# task_allocation - DataTree of integers (0 or 1) indicating robot assignment (0 for A, 1 for B)\n# pick_up_planes_A - List of Planes for Robot A's pick-up points\n# pick_up_planes_B - List of Planes for Robot B's pick-up points\n# pickup_approach_planes_A - List of Planes for Robot A's pickup approach points (optional)\n# pickup_approach_planes_B - List of Planes for Robot B's pickup approach points (optional)\n# pause_command - Command to pause the robot (optional)\n# waiting_command - Command for waiting state (optional)\n# home_plane_A - Plane for Robot A's home position (optional)\n# home_plane_B - Plane for Robot B's home position (optional)\n\n# Ensure inputs are set to the correct access and type hints in the Grasshopper Python component\n\n# Initialize output data trees\nrobotA_commands = Grasshopper.DataTree[object]()\nrobotB_commands = Grasshopper.DataTree[object]()\nrobotA_status = Grasshopper.DataTree[str]()\nrobotB_status = Grasshopper.DataTree[str]()\n\n# Initialize gripper states and last edge counters\ngripper_state = {'A': 0, 'B': 0}\nlast_edge_counter = {'A': None, 'B': None}\n\n# Initialize edge counter\nedge_counter = 0\n\n# Initialize pickup plane indices for each robot\npickup_index = {'A': 0, 'B': 0}\n\n# Get the total number of pickup planes for each robot\nnum_pickup_planes_A = len(pick_up_planes_A) if pick_up_planes_A else 1\nnum_pickup_planes_B = len(pick_up_planes_B) if pick_up_planes_B else 1\n\n# Get the total number of pickup approach planes for each robot\nnum_pickup_approach_planes_A = len(pickup_approach_planes_A) if pickup_approach_planes_A else 0\nnum_pickup_approach_planes_B = len(pickup_approach_planes_B) if pickup_approach_planes_B else 0\n\n# Process each branch\nfor path in target_planes.Paths:\n    planes = target_planes.Branch(path)\n    approaches = approach_planes.Branch(path) if approach_planes and approach_planes.PathExists(path) else [None]*len(planes)\n    allocations = task_allocation.Branch(path)\n    num_edges = len(planes)\n    \n    # Check if the branch is {*;0}\n    if path.Indices[-1] == 0:\n        # Special handling for branch {*;0}\n        \n        # Collect indices of edges placed by each robot\n        indices_by_robot = {'A': [], 'B': []}\n        for idx, alloc in enumerate(allocations):\n            robot_name = 'A' if alloc == 0 else 'B'\n            indices_by_robot[robot_name].append(idx)\n        \n        # Prepare variables to keep track of steps\n        max_steps = 0  # To synchronize steps between robots\n        # Lists to store actions per robot\n        actions_A = []\n        actions_B = []\n        \n        # Process the first two edges\n        for idx in range(2):\n            edge_counter += 1\n            plane = planes[idx]\n            approach = approaches[idx] if idx < len(approaches) else None\n            robot = allocations[idx]\n            assigned_robot = 'A' if robot == 0 else 'B'\n            other_robot = 'B' if assigned_robot == 'A' else 'A'\n            last_edge_counter[assigned_robot] = edge_counter\n            \n            # Select the pickup plane for the assigned robot\n            if assigned_robot == 'A':\n                pickup_plane_list = pick_up_planes_A\n                pickup_approach_list = pickup_approach_planes_A\n                num_pickup_planes = num_pickup_planes_A\n                num_pickup_approach_planes = num_pickup_approach_planes_A\n                if num_pickup_planes > 0:\n                    pickup_plane = pickup_plane_list[pickup_index['A'] % num_pickup_planes]\n                else:\n                    pickup_plane = None  # Handle empty list case\n                if num_pickup_approach_planes > 0:\n                    pickup_approach_plane = pickup_approach_list[pickup_index['A'] % num_pickup_approach_planes]\n                else:\n                    pickup_approach_plane = None\n                pickup_index['A'] += 1\n            else:\n                pickup_plane_list = pick_up_planes_B\n                pickup_approach_list = pickup_approach_planes_B\n                num_pickup_planes = num_pickup_planes_B\n                num_pickup_approach_planes = num_pickup_approach_planes_B\n                if num_pickup_planes > 0:\n                    pickup_plane = pickup_plane_list[pickup_index['B'] % num_pickup_planes]\n                else:\n                    pickup_plane = None  # Handle empty list case\n                if num_pickup_approach_planes > 0:\n                    pickup_approach_plane = pickup_approach_list[pickup_index['B'] % num_pickup_approach_planes]\n                else:\n                    pickup_approach_plane = None\n                pickup_index['B'] += 1\n            \n            # Steps for the assigned robot\n            steps_robot = []\n            # Step 1: Move to pickup approach plane (if provided)\n            if pickup_approach_plane is not None:\n                steps_robot.append((\"Move to pickup approach\", pickup_approach_plane))\n            # Step 2: Move to pick up\n            if pickup_plane is not None:\n                steps_robot.append((\"Move to pick up\", pickup_plane))\n            else:\n                steps_robot.append((\"Move to pick up\", \"No pickup plane provided\"))\n            # Step 3: Close gripper\n            steps_robot.append((\"Close gripper\", gripper_close_command))\n            gripper_state[assigned_robot] = 1\n            # Step 4: Move to approach plane (if provided)\n            if approach is not None:\n                steps_robot.append((f\"Move to approach plane {edge_counter}\", approach))\n            # Step 5: Move to target plane\n            steps_robot.append((f\"Move to target {edge_counter}\", plane))\n            # Step 6 onwards: Holding edge\n            steps_robot.append((f\"Holding edge {edge_counter}\", waiting_command))\n            # Add steps to robot's action list\n            if assigned_robot == 'A':\n                actions_A.extend(steps_robot)\n            else:\n                actions_B.extend(steps_robot)\n            \n            # For the other robot, add waiting steps to synchronize\n            num_steps = len(steps_robot)\n            waiting_status = f\"Holding edge {last_edge_counter[other_robot]}\" if gripper_state[other_robot] == 1 else \"Waiting for other robot\"\n            waiting_steps = [(waiting_status, waiting_command)] * num_steps\n            if other_robot == 'A':\n                actions_A.extend(waiting_steps)\n            else:\n                actions_B.extend(waiting_steps)\n            \n            max_steps = max(max_steps, len(actions_A), len(actions_B))\n        \n        # After first two edges, both robots pause for connection\n        if pause_command is not None:\n            pause_step = (\"Pause for connection\", pause_command)\n            actions_A.append(pause_step)\n            actions_B.append(pause_step)\n            max_steps += 1\n        \n        # Process the third edge if it exists\n        if num_edges > 2:\n            idx = 2  # Index of the third edge\n            edge_counter += 1\n            plane = planes[idx]\n            approach = approaches[idx] if idx < len(approaches) else None\n            robot = allocations[idx]\n            assigned_robot = 'A' if robot == 0 else 'B'\n            other_robot = 'B' if assigned_robot == 'A' else 'A'\n            last_edge_counter[assigned_robot] = edge_counter\n            \n            # Select the pickup plane for the assigned robot\n            if assigned_robot == 'A':\n                pickup_plane_list = pick_up_planes_A\n                pickup_approach_list = pickup_approach_planes_A\n                num_pickup_planes = num_pickup_planes_A\n                num_pickup_approach_planes = num_pickup_approach_planes_A\n                if num_pickup_planes > 0:\n                    pickup_plane = pickup_plane_list[pickup_index['A'] % num_pickup_planes]\n                else:\n                    pickup_plane = None\n                if num_pickup_approach_planes > 0:\n                    pickup_approach_plane = pickup_approach_list[pickup_index['A'] % num_pickup_approach_planes]\n                else:\n                    pickup_approach_plane = None\n                pickup_index['A'] += 1\n            else:\n                pickup_plane_list = pick_up_planes_B\n                pickup_approach_list = pickup_approach_planes_B\n                num_pickup_planes = num_pickup_planes_B\n                num_pickup_approach_planes = num_pickup_approach_planes_B\n                if num_pickup_planes > 0:\n                    pickup_plane = pickup_plane_list[pickup_index['B'] % num_pickup_planes]\n                else:\n                    pickup_plane = None\n                if num_pickup_approach_planes > 0:\n                    pickup_approach_plane = pickup_approach_list[pickup_index['B'] % num_pickup_approach_planes]\n                else:\n                    pickup_approach_plane = None\n                pickup_index['B'] += 1\n            \n            # Steps for the assigned robot\n            steps_robot = []\n            # Step 1: Move to pickup approach plane (if provided)\n            if pickup_approach_plane is not None:\n                steps_robot.append((\"Move to pickup approach\", pickup_approach_plane))\n            # Step 2: Move to pick up\n            if pickup_plane is not None:\n                steps_robot.append((\"Move to pick up\", pickup_plane))\n            else:\n                steps_robot.append((\"Move to pick up\", \"No pickup plane provided\"))\n            # Step 3: Close gripper\n            steps_robot.append((\"Close gripper\", gripper_close_command))\n            gripper_state[assigned_robot] = 1\n            # Step 4: Move to approach plane (if provided)\n            if approach is not None:\n                steps_robot.append((f\"Move to approach plane {edge_counter}\", approach))\n            # Step 5: Move to target plane\n            steps_robot.append((f\"Move to target {edge_counter}\", plane))\n            # Step 6: Pause for connection\n            if pause_command is not None:\n                steps_robot.append((\"Pause for connection\", pause_command))\n            # Step 7: Open gripper\n            steps_robot.append((\"Open gripper\", gripper_open_command))\n            gripper_state[assigned_robot] = 0\n            # Step 8: Move back to approach plane (if provided)\n            if approach is not None:\n                steps_robot.append((f\"Move to approach plane {edge_counter}\", approach))\n            # Step 9: Move to home plane (if provided)\n            home_plane = home_plane_A if assigned_robot == 'A' else home_plane_B\n            if home_plane is not None:\n                steps_robot.append((\"Moving to home plane\", home_plane))\n            # Add steps to robot's action list\n            if assigned_robot == 'A':\n                actions_A.extend(steps_robot)\n            else:\n                actions_B.extend(steps_robot)\n            \n            # For the other robot, continue holding edge until pause for connection\n            other_steps = []\n            for i, (step, cmd) in enumerate(steps_robot):\n                if step == \"Pause for connection\" and pause_command is not None:\n                    other_steps.append((\"Pause for connection\", pause_command))\n                else:\n                    if gripper_state[other_robot] == 1:\n                        other_steps.append((f\"Holding edge {last_edge_counter[other_robot]}\", waiting_command))\n                    else:\n                        other_steps.append((\"Waiting for other robot\", waiting_command))\n            if other_robot == 'A':\n                actions_A.extend(other_steps)\n            else:\n                actions_B.extend(other_steps)\n            \n            max_steps = max(max_steps, len(actions_A), len(actions_B))\n        \n        # After the third edge and pause, both robots can open grippers and move home\n        # Open gripper for the robot that was holding edge\n        for robot in ['A', 'B']:\n            if gripper_state[robot] == 1:\n                gripper_state[robot] = 0\n                steps = []\n                # Open gripper\n                steps.append((\"Open gripper\", gripper_open_command))\n                # Move back to approach plane (if provided)\n                if indices_by_robot[robot]:\n                    last_edge_idx = indices_by_robot[robot][-1]\n                    approach = approaches[last_edge_idx] if last_edge_idx < len(approaches) else None\n                    if approach is not None:\n                        steps.append((f\"Move to approach plane {last_edge_counter[robot]}\", approach))\n                else:\n                    approach = None\n                # Move to home plane (if provided)\n                home_plane = home_plane_A if robot == 'A' else home_plane_B\n                if home_plane is not None:\n                    steps.append((\"Moving to home plane\", home_plane))\n                # Add steps to robot's action list\n                if robot == 'A':\n                    actions_A.extend(steps)\n                else:\n                    actions_B.extend(steps)\n                max_steps = max(max_steps, len(actions_A), len(actions_B))\n        \n        # Synchronize steps between robots\n        total_steps = max(len(actions_A), len(actions_B))\n        for i in range(total_steps):\n            sub_path = GH_Path(path)\n            sub_path = sub_path.AppendElement(i)\n            # Robot A actions\n            if i < len(actions_A):\n                status_A, command_A = actions_A[i]\n            else:\n                status_A = \"Waiting for other robot\"\n                command_A = waiting_command\n            robotA_status.Add(status_A, sub_path)\n            robotA_commands.Add(command_A, sub_path)\n            # Robot B actions\n            if i < len(actions_B):\n                status_B, command_B = actions_B[i]\n            else:\n                status_B = \"Waiting for other robot\"\n                command_B = waiting_command\n            robotB_status.Add(status_B, sub_path)\n            robotB_commands.Add(command_B, sub_path)\n    else:\n        # Handle other branches as before\n        for idx in range(num_edges):\n            plane = planes[idx]\n            approach = approaches[idx] if idx < len(approaches) else None\n            robot = allocations[idx]\n            assigned_robot = 'A' if robot == 0 else 'B'\n            other_robot = 'B' if assigned_robot == 'A' else 'A'\n            edge_counter += 1\n            last_edge_counter[assigned_robot] = edge_counter\n            \n            # Select the pickup plane for the assigned robot\n            if assigned_robot == 'A':\n                pickup_plane_list = pick_up_planes_A\n                pickup_approach_list = pickup_approach_planes_A\n                num_pickup_planes = num_pickup_planes_A\n                num_pickup_approach_planes = num_pickup_approach_planes_A\n                if num_pickup_planes > 0:\n                    pickup_plane = pickup_plane_list[pickup_index['A'] % num_pickup_planes]\n                else:\n                    pickup_plane = None\n                if num_pickup_approach_planes > 0:\n                    pickup_approach_plane = pickup_approach_list[pickup_index['A'] % num_pickup_approach_planes]\n                else:\n                    pickup_approach_plane = None\n                pickup_index['A'] += 1\n            else:\n                pickup_plane_list = pick_up_planes_B\n                pickup_approach_list = pickup_approach_planes_B\n                num_pickup_planes = num_pickup_planes_B\n                num_pickup_approach_planes = num_pickup_approach_planes_B\n                if num_pickup_planes > 0:\n                    pickup_plane = pickup_plane_list[pickup_index['B'] % num_pickup_planes]\n                else:\n                    pickup_plane = None\n                if num_pickup_approach_planes > 0:\n                    pickup_approach_plane = pickup_approach_list[pickup_index['B'] % num_pickup_approach_planes]\n                else:\n                    pickup_approach_plane = None\n                pickup_index['B'] += 1\n            \n            # Steps for the assigned robot\n            steps_robot = []\n            # Step 1: Move to pickup approach plane (if provided)\n            if pickup_approach_plane is not None:\n                steps_robot.append((\"Move to pickup approach\", pickup_approach_plane))\n            # Step 2: Move to pick up\n            if pickup_plane is not None:\n                steps_robot.append((\"Move to pick up\", pickup_plane))\n            else:\n                steps_robot.append((\"Move to pick up\", \"No pickup plane provided\"))\n            # Step 3: Close gripper\n            steps_robot.append((\"Close gripper\", gripper_close_command))\n            gripper_state[assigned_robot] = 1\n            # Step 4: Move to approach plane (if provided)\n            if approach is not None:\n                steps_robot.append((f\"Move to approach plane {edge_counter}\", approach))\n            # Step 5: Move to target plane\n            steps_robot.append((f\"Move to target {edge_counter}\", plane))\n            # Step 6: Pause for connection (if provided)\n            if pause_command is not None:\n                steps_robot.append((\"Pause for connection\", pause_command))\n            # Step 7: Open gripper\n            steps_robot.append((\"Open gripper\", gripper_open_command))\n            gripper_state[assigned_robot] = 0\n            # Step 8: Move back to approach plane (if provided)\n            if approach is not None:\n                steps_robot.append((f\"Move to approach plane {edge_counter}\", approach))\n            # Step 9: Move to home plane (if provided)\n            home_plane = home_plane_A if assigned_robot == 'A' else home_plane_B\n            if home_plane is not None:\n                steps_robot.append((\"Moving to home plane\", home_plane))\n            \n            # Steps for the other robot\n            other_steps = []\n            for step, cmd in steps_robot:\n                if step == \"Pause for connection\" and pause_command is not None:\n                    other_steps.append((\"Pause for connection\", pause_command))\n                else:\n                    if gripper_state[other_robot] == 1:\n                        other_steps.append((f\"Holding edge {last_edge_counter[other_robot]}\", waiting_command))\n                    else:\n                        other_steps.append((\"Waiting for other robot\", waiting_command))\n            \n            # Add steps to data trees\n            for i in range(len(steps_robot)):\n                sub_path = GH_Path(path)\n                sub_path = sub_path.AppendElement(idx)\n                sub_path = sub_path.AppendElement(i)\n                # Assigned robot\n                if assigned_robot == 'A':\n                    robotA_status.Add(steps_robot[i][0], sub_path)\n                    robotA_commands.Add(steps_robot[i][1], sub_path)\n                    robotB_status.Add(other_steps[i][0], sub_path)\n                    robotB_commands.Add(other_steps[i][1], sub_path)\n                else:\n                    robotB_status.Add(steps_robot[i][0], sub_path)\n                    robotB_commands.Add(steps_robot[i][1], sub_path)\n                    robotA_status.Add(other_steps[i][0], sub_path)\n                    robotA_commands.Add(other_steps[i][1], sub_path)\n\n# Outputs:\nRobotA_Command = robotA_commands\nRobotB_Command = robotB_commands\nRobotA_Status = robotA_status\nRobotB_Status = robotB_status\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}