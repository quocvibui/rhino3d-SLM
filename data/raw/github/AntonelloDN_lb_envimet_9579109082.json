{
  "source_url": "https://github.com/AntonelloDN/lb_envimet/blob/f49c125fcf2cc2dd9deaab3ae220523a805a0247/Newlb_envimet/lb_envimet/Geometry/building.py",
  "repo": "AntonelloDN/lb_envimet",
  "repo_stars": 4,
  "repo_description": "ï»¿lb_envimet: a series of components to connect Ladybug and Gismo to Envimet for urban microclimatic analysis",
  "license": "GPL-3.0",
  "filepath": "Newlb_envimet/lb_envimet/Geometry/building.py",
  "instruction": "Building",
  "code": "import Rhino as rc\nimport collections\n\n\nclass Building(object):\n\n    def __init__(self, geometry, wallMaterial, roofMaterial):\n        self._matrix = []\n        self._heightMatrix = []\n        self.geometry = geometry\n        self.wallMaterial = wallMaterial\n        self.roofMaterial = roofMaterial\n        self.greenWallMaterial = \"\"\n        self.greenRoofMaterial = \"\"\n\n    def setMatrix(self, value):\n        self._matrix = value\n\n    def getBuildingFlagAndNr(self):\n        return self._buildingFlagAndNr\n\n    def setBuildingFlagAndNr(self, value):\n        self._buildingFlagAndNr = value\n\n    def getMatrix(self):\n        return self._matrix\n\n    def getHightMatrix(self):\n        return self._heightMatrix\n\n    matrix = property(fset=setMatrix, fget=getMatrix)\n\n    buildingHightMatrix = property(fget=getHightMatrix)\n\n    buildingFlagAndNr = property(fset=setBuildingFlagAndNr, fget=getBuildingFlagAndNr)\n\n\n    @staticmethod\n    def voxelPoints(mesh, tol, grid):\n\n        zAxis = rc.Geometry.Vector3d.ZAxis\n\n        planes = []\n        for i, num in enumerate(grid.zHeight):\n            pl = rc.Geometry.Plane(rc.Geometry.Point3d(0,0,num), zAxis)\n            planes.append(pl)\n\n        gridXY = grid.gridPreviewXY()\n\n        polilinee = rc.Geometry.Intersect.Intersection.MeshPlane(mesh, planes)\n        polilinee = [ln.ToNurbsCurve() for ln in polilinee]\n\n        superfici = rc.Geometry.Brep.CreatePlanarBreps(polilinee, tol);\n\n        bbox = mesh.GetBoundingBox(False);\n\n        pointForProjection = []\n\n        # small scaled grid\n        for i, pt in enumerate(gridXY):\n            if (pt.X >= bbox.Min.X - grid.dimX and pt.X <= bbox.Max.X + grid.dimX):\n                if (pt.Y >= bbox.Min.Y - grid.dimY and pt.Y <= bbox.Max.Y + grid.dimY):\n                    pointForProjection.append(rc.Geometry.Point3d(pt.X, pt.Y, 0));\n\n        voxelPoints = rc.Geometry.Intersect.Intersection.ProjectPointsToBreps(superfici, pointForProjection, zAxis, tol);\n\n        return voxelPoints\n\n\n    def createVoxMatrixBuilding(self, buildingPoints, terrainPoints, index, grid):\n\n        buildingFlagAndNr = \"\"\n\n        self._matrix, self._heightMatrix = grid.base3DMatrix(0), grid.base3DMatrix(0)\n\n        for i, pt in enumerate(buildingPoints):\n            valX = round(((pt.X - grid.minX) / grid.dimX), 0)\n            valY = round(((pt.Y - grid.minY) / grid.dimY), 0)\n\n            if pt not in terrainPoints:\n                valZ = grid.castingPrecision(grid.zHeight, pt.Z)\n\n                valX = int(valX)\n                valY = int(valY)\n                valZ = int(valZ)\n\n                # layer, column, item\n                self._heightMatrix [valZ][valY][valX] = pt.Z\n                self._matrix[valZ][valY][valX] = index\n                buildingFlagAndNr += \"{0},{1},{2},{3},{4}\\n\".format(valX, valY, valZ, 1, index)\n\n        return buildingFlagAndNr\n\n\n    # last step, just one matrix\n    @classmethod\n    def mergeMatrix(cls, buildingMatrix, buildings):\n        # merge Matrix\n        uniqueMatrix = []\n        for k in zip(*buildingMatrix):\n            columns = []\n            for y in zip(*k):\n                rows = []\n                for x in zip(*y):\n                    total = sum(x)\n                    # overlap issue ;)\n                    if total > len(buildings):\n                        total = 0\n                    rows.append(total)\n                columns.append(rows)\n            uniqueMatrix.append(columns)\n\n        return uniqueMatrix\n\n\n    @classmethod\n    def setMaterials(cls, uniqueMatrix, matWall, matRoof):\n        # spare matrix\n        WallDB = []\n\n        for k, layer in enumerate(uniqueMatrix):\n            for j, column in enumerate(layer):\n                for i, row in enumerate(column):\n\n                    if row != 0 and uniqueMatrix[k][j][i-1] == 0 and uniqueMatrix[k][j-1][i] == 0 and uniqueMatrix[k-1][j][i] == 0:\n                        index = int(row)-1\n                        WallDB.append(','.join([str(i),str(j),str(k),matWall[index],matWall[index],matRoof[index]]))\n                    elif row != 0 and uniqueMatrix[k][j][i-1] == 0 and uniqueMatrix[k][j-1][i] != 0 and uniqueMatrix[k-1][j][i] == 0:\n                        index = int(row)-1\n                        WallDB.append(','.join([str(i),str(j),str(k),matWall[index],'',matRoof[index]]))\n                    elif row != 0 and uniqueMatrix[k][j][i-1] != 0 and uniqueMatrix[k][j-1][i] == 0 and uniqueMatrix[k-1][j][i] == 0:\n                        index = int(row)-1\n                        WallDB.append(','.join([str(i),str(j),str(k),'',matWall[index],matRoof[index]]))\n\n                    elif row != 0 and uniqueMatrix[k][j][i-1] == 0 and uniqueMatrix[k][j-1][i] == 0 and uniqueMatrix[k-1][j][i] != 0:\n                        index = int(row)-1\n                        WallDB.append(','.join([str(i),str(j),str(k),matWall[index],matWall[index],'']))\n                    elif row != 0 and uniqueMatrix[k][j][i-1] == 0 and uniqueMatrix[k][j-1][i] != 0 and uniqueMatrix[k-1][j][i] != 0:\n                        index = int(row)-1\n                        WallDB.append(','.join([str(i),str(j),str(k),matWall[index],'','']))\n                    elif row != 0 and uniqueMatrix[k][j][i-1] != 0 and uniqueMatrix[k][j-1][i] == 0 and uniqueMatrix[k-1][j][i] != 0:\n                        index = int(row)-1\n                        WallDB.append(','.join([str(i),str(j),str(k),'',matWall[index],'']))\n                    elif row != 0 and uniqueMatrix[k][j][i-1] != 0 and uniqueMatrix[k][j-1][i] != 0 and uniqueMatrix[k-1][j][i] == 0:\n                        index = int(row)-1\n                        WallDB.append(','.join([str(i),str(j),str(k),'','',matRoof[index]]))\n\n                    # empty cells\n                    elif row == 0 and uniqueMatrix[k][j][i-1] != 0 and uniqueMatrix[k][j-1][i] == 0 and uniqueMatrix[k-1][j][i] == 0:\n                        index = int(uniqueMatrix[k][j][i-1])-1\n                        WallDB.append(','.join([str(i),str(j),str(k),matWall[index],'','']))\n                    elif row == 0 and uniqueMatrix[k][j][i-1] == 0 and uniqueMatrix[k][j-1][i] != 0 and uniqueMatrix[k-1][j][i] == 0:\n                        index = int(uniqueMatrix[k][j-1][i])-1\n                        WallDB.append(','.join([str(i),str(j),str(k),'',matWall[index],'']))\n                    elif row == 0 and uniqueMatrix[k][j][i-1] == 0 and uniqueMatrix[k][j-1][i] == 0 and uniqueMatrix[k-1][j][i] != 0:\n                        index = int(uniqueMatrix[k-1][j][i])-1\n                        WallDB.append(','.join([str(i),str(j),str(k),'','',matRoof[index]]))\n\n                    elif row == 0 and uniqueMatrix[k][j][i-1] != 0 and uniqueMatrix[k][j-1][i] != 0 and uniqueMatrix[k-1][j][i] == 0:\n                        index = int(uniqueMatrix[k][j-1][i])-1\n                        WallDB.append(','.join([str(i),str(j),str(k),matWall[index],matWall[index],'']))\n                    elif row == 0 and uniqueMatrix[k][j][i-1] != 0 and uniqueMatrix[k][j-1][i] == 0 and uniqueMatrix[k-1][j][i] != 0:\n                        indexW = int(uniqueMatrix[k][j][i-1])-1\n                        indexR = int(uniqueMatrix[k-1][j][i])-1\n                        WallDB.append(','.join([str(i),str(j),str(k),matWall[indexW],'',matRoof[indexR]]))\n                    elif row == 0 and uniqueMatrix[k][j][i-1] == 0 and uniqueMatrix[k][j-1][i] != 0 and uniqueMatrix[k-1][j][i] != 0:\n                        indexW = int(uniqueMatrix[k][j-1][i])-1\n                        indexR = int(uniqueMatrix[k-1][j][i])-1\n                        WallDB.append(','.join([str(i),str(j),str(k),'',matWall[indexW],matRoof[indexR]]))\n                    elif row == 0 and uniqueMatrix[k][j][i-1] != 0 and uniqueMatrix[k][j-1][i] != 0 and uniqueMatrix[k-1][j][i] != 0:\n                        indexW = int(uniqueMatrix[k][j-1][i])-1\n                        indexR = int(uniqueMatrix[k-1][j][i])-1\n                        WallDB.append(','.join([str(i),str(j),str(k),matWall[indexW],matWall[indexW],matRoof[indexR]]))\n\n        WallDBMatrix = '\\n'.join(WallDB)\n\n        return WallDBMatrix\n\n\n    @classmethod\n    def hmaxMatrixAndIndexMatrix(cls, buildingMatrix):\n        \"\"\"\n            Use the same method for index matrix:\n            nested self.grid for indexMatrix\n            nested self.buildingHightMatrix for height matrix\n        \"\"\"\n        buildings = []\n        for bl in buildingMatrix:\n            row = []\n            for y in zip(*bl):\n                maxHeight = []\n                for x in zip(*y):\n                    total = max(x)\n                    if total != 0:\n                        total = int(round(total, 1))\n                    maxHeight.append(total)\n                row.append(maxHeight)\n            buildings.append(row)\n\n        return buildings\n\n\n    @classmethod\n    def hminMatrix(cls, buildingMatrix, grid):\n        buildings = []\n        for bl in buildingMatrix:\n            row = []\n            for y in zip(*bl):\n                minHight = []\n                for x in zip(*y):\n                    for num in x:\n                        if num != 0:\n                            if not grid._telescope:\n                                num = int(round(num - grid.dimZ/10, 1))\n                            else:\n                                num = int(round(num - grid.zHeight[0]/2, 1))\n                            break\n                    minHight.append(num)\n                row.append(minHight)\n            buildings.append(row)\n\n        return buildings\n\n\n    @classmethod\n    def mergeBuildingMatrix(cls, hmatrix):\n        mergeMatrix = []\n        for m in zip(*hmatrix):\n            row = []\n            for l in zip(*m):\n                if 0 in l:\n                    num = sum(l)\n                else:\n                    num = l[0]\n\n                row.append(num)\n            mergeMatrix.append(row)\n\n        return mergeMatrix\n\n\n    def moveBuildingsUp(self, mesh, terrain):\n\n        zAxis = rc.Geometry.Vector3d.ZAxis\n        noIntersection = 0.0\n        unitBox = 1\n        vecZero = rc.Geometry.Vector3d.Zero\n\n        try:\n            # first traslation\n            center = rc.Geometry.AreaMassProperties.Compute(mesh).Centroid\n            r = rc.Geometry.Ray3d(center, zAxis)\n            intersec = rc.Geometry.Intersect.Intersection.MeshRay(terrain, r)\n\n            pt = r.PointAt(intersec)\n\n            if (intersec != noIntersection):\n                vecCentroid = rc.Geometry.Vector3d(0, 0, pt.Z - center.Z)\n                xmoveCentroid = rc.Geometry.Transform.Translation(vecCentroid)\n                mesh.Transform(xmoveCentroid);\n\n            # move to terrain\n            bBox = mesh.GetBoundingBox(True)\n            meshBox = rc.Geometry.Mesh.CreateFromBox(bBox, unitBox, unitBox, unitBox)\n            lines = rc.Geometry.Intersect.Intersection.MeshMeshFast(terrain, mesh)\n            minBBox = bBox.Min\n\n            # dimension\n            start = minBBox.Z;\n            end = min([l.From.Z for l in lines])\n            vecTerrain = rc.Geometry.Vector3d(0, 0, end - start)\n            xmoveTerrain = rc.Geometry.Transform.Translation(vecTerrain)\n\n        except:\n            xmoveTerrain = rc.Geometry.Transform.Translation(vecZero)\n\n        mesh.Transform(xmoveTerrain)\n\n        return mesh\n",
  "language": "python",
  "imports": [
    "Rhino"
  ],
  "has_docstring": false
}