{
  "source_url": "https://github.com/jonashaldemann/jh_ghp_tools/blob/3f6fad9b1d6b94b1382000d2d9bd27952269a19d/src/jh_ghp_tools/verlaufsschraffur.py",
  "repo": "jonashaldemann/jh_ghp_tools",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "src/jh_ghp_tools/verlaufsschraffur.py",
  "instruction": "Verlaufsschraffur",
  "code": "import Rhino\nimport ghpythonlib.components as gh\nimport random\nimport math\nfrom compas.geometry import Point, Box, Polyline\nfrom compas.geometry import (\n    closest_point_on_polyline,\n    distance_point_point,\n    is_point_in_polygon_xy,\n    distance_point_point,\n)\nfrom compas_rhino.conversions import point_to_rhino, point_to_compas\n\n\ndef verlaufsschraffur(x_domain, y_domain, N, CB, C1, C0, cell_size):\n    \"\"\"\n    Eingangsfunktion, die Punkte innerhalb eines Polygons generiert und filtert.\n    \"\"\"\n    # Konvertiere Polylines\n    cb = curve_to_polyline_smart(CB)\n    c1 = curve_to_polyline_smart(C1)\n    c0 = curve_to_polyline_smart(C0)\n\n    # Bereich aus den Domains extrahieren\n    x0, x1, y0, y1 = deconstruct_domains(x_domain, y_domain)\n\n    # Punkte generieren\n    points = generate_points(cb, c1, c0, x0, x1, y0, y1, N, cell_size)\n\n    # Zusätzliche Filterung am Ende\n    points = filter_points(points, c0, c1)\n\n    return points\n\n\ndef deconstruct_domains(x_domain, y_domain):\n    \"\"\"\n    Extrahiert die Grenzen aus den x- und y-Domains.\n    \"\"\"\n    x0, x1 = x_domain.T0, x_domain.T1\n    y0, y1 = y_domain.T0, y_domain.T1\n    return x0, x1, y0, y1\n\n\ndef is_cell_in_polygon(cell, polygon):\n    \"\"\"\n    Prüft, ob eine Zelle vollständig, teilweise oder gar nicht innerhalb eines Polygons liegt.\n    \"\"\"\n    cell_corners = [cell.corner(i) for i in range(4)]\n    inside_status = [is_point_in_polygon_xy(corner, polygon) for corner in cell_corners]\n\n    if all(inside_status):\n        return \"inside\"\n    elif any(inside_status):\n        return \"partial\"\n    else:\n        return \"outside\"\n\n\ndef generate_points(cb, c1, c0, x0, x1, y0, y1, N, cell_size):\n    \"\"\"\n    Generiert Punkte innerhalb der gegebenen Bereiche basierend auf den Polygonbedingungen.\n    \"\"\"\n    cols = int(\n        (x1 - x0) // cell_size + (1 if (x1 - x0) % cell_size else 0)\n    )  # aufrunden\n    rows = int(\n        (y1 - y0) // cell_size + (1 if (y1 - y0) % cell_size else 0)\n    )  # aufrunden\n    points = []\n    num_points_per_cell = N // (cols * rows)\n\n    for col in range(cols):\n        for row in range(rows):\n            # Zelle definieren\n            x_min = x0 + col * cell_size\n            x_max = x_min + cell_size\n            y_min = y0 + row * cell_size\n            y_max = y_min + cell_size\n\n            # Box mit Eckpunkten erstellen\n            corner_1 = [x_min, y_min, 0.0]\n            corner_2 = [x_max, y_max, 0.0]\n            cell = Box.from_points([corner_1, corner_2])\n\n            # Zelle testen\n            cell_status = is_cell_in_polygon(cell, cb)\n\n            if cell_status == \"inside\":\n                points.extend(\n                    generate_points_in_inside_cell(\n                        x_min, x_max, y_min, y_max, num_points_per_cell, c0, c1\n                    )\n                )\n            elif cell_status == \"partial\":\n                points.extend(\n                    generate_points_in_partial_cell(\n                        x_min, x_max, y_min, y_max, num_points_per_cell, cb, c0, c1\n                    )\n                )\n\n    return points\n\n\ndef generate_points_in_inside_cell(x_min, x_max, y_min, y_max, num_points, c0, c1):\n\n    points = []\n\n    for _ in range(num_points):\n        pt = generate_point_in_cell(x_min, x_max, y_min, y_max, c0, c1)\n        if pt:\n            points.append(point_to_rhino(pt))\n    return points\n\n\ndef generate_points_in_partial_cell(x_min, x_max, y_min, y_max, num_points, cb, c0, c1):\n    \"\"\"\n    Generiert Punkte innerhalb einer vollständig im Polygon liegenden Zelle.\n    \"\"\"\n    points = []\n    for _ in range(num_points):\n        pt = generate_point_in_cell(x_min, x_max, y_min, y_max, c0, c1)\n        if not pt:\n            continue\n        if not is_point_in_polygon_xy(pt, cb):\n            continue\n        points.append(point_to_rhino(pt))\n    return points\n\n\ndef filter_points(points, c0, c1):\n    \"\"\"\n    Filtert die generierten Punkte basierend auf einem Schwellenwert.\n    \"\"\"\n    return [\n        pt\n        for pt in points\n        if calculate_threshold(Point(pt.X, pt.Y, pt.Z), c0, c1) >= random.random()\n    ]\n\n\ndef calculate_threshold(pt, c0, c1):\n    pt0 = closest_point_on_polyline(pt, c0)\n    pt1 = closest_point_on_polyline(pt, c1)\n    dmax = distance_point_point(pt0, pt1)\n    d0 = distance_point_point(pt, pt0)\n    return d0 / dmax\n\n\ndef generate_point_in_cell(x_min, x_max, y_min, y_max, c0, c1):\n    x = random.uniform(x_min, x_max)\n    y = random.uniform(y_min, y_max)\n    pt = Point(x, y, 0.0)\n    return pt\n\n\ndef curve_to_polyline_smart(curve, rebuild_points=5):\n    \"\"\"\n    Konvertiert eine Rhino Curve in eine COMPAS Polyline.\n    Explodiert die Kurve in Teilsegmente:\n    - lineare Segmente werden direkt übernommen\n    - nicht-lineare Segmente werden in 'rebuild_points' Punkten approximiert\n\n    Parameters\n    ----------\n    curve : Rhino.Geometry.Curve\n        Eingabekurve\n    rebuild_points : int\n        Anzahl Stützpunkte für die Approximation nicht-linearer Segmente\n\n    Returns\n    -------\n    Polyline\n        COMPAS Polyline\n    \"\"\"\n    polypoints = []\n\n    # Explodieren\n    segments = curve.DuplicateSegments()\n    if not segments:\n        segments = [curve]  # falls nicht segmentierbar (z.B. einfache Linie)\n\n    for seg in segments:\n        if seg.IsLinear():\n            # Linie = nur Endpunkte\n            pts = [seg.PointAtStart, seg.PointAtEnd]\n        else:\n            # Nicht-linear = rebuild\n            t0, t1 = seg.Domain.T0, seg.Domain.T1\n            ts = [\n                t0 + (t1 - t0) * i / (rebuild_points - 1) for i in range(rebuild_points)\n            ]\n            pts = [seg.PointAt(t) for t in ts]\n\n        # COMPAS Punkte\n        compas_pts = [point_to_compas(pt) for pt in pts]\n\n        # Vermeide doppelte Punkte beim Zusammenfügen\n        if polypoints:\n            if distance_point_point(compas_pts[0], polypoints[-1]) < 1e-6:\n                compas_pts = compas_pts[1:]\n\n        polypoints.extend(compas_pts)\n\n    return Polyline(polypoints)\n\n\n# Ausfhren in GhPython\n# points = verlaufsschraffur(x_domain, y_domain, N, CB, C1, C0, cell_size)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}