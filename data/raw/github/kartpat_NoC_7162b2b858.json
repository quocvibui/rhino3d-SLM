{
  "source_url": "https://github.com/kartpat/NoC/blob/a938cdfe36a5c75f53d5f28a5b3ee017660672f4/mutualAttractor.py",
  "repo": "kartpat/NoC",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "mutualAttractor.py",
  "instruction": "Mutual attractor",
  "code": "import rhinoscriptsyntax as rs \nimport math\nimport random\n\n\n\n# arrPoints = list()\n# for t in rs.frange(-100,100,2):\n# \tx0 = t*math.sin(t)\n# \ty0 = t*math.cos(t)\n# \tz0 = t\n# \tarrPoint = [x0, y0, z0]\n#     # print(arrPoint)\n# \tarrPoints.append(arrPoint)\n\n# print(arrPoints)\n# rs.AddPoint(arrPoint) #Call rs.EnableRedraw(True)\n\n# rs.AddInterpCurve(arrPoints)\t\n\ndef limit(n, minn, maxn):\n    if n < minn:\n        return minn\n    elif n > maxn:\n        return maxn\n    else:\n        return n\n\nclass Mover(object):\n\n    def __init__(self):\n        self.location = [random.randrange(-300,300,1),random.randrange(-300,300,1),random.randrange(-300,300,1)]\n        self.velocity = [random.randrange(-8,8,1),random.randrange(-8,8,1),0]\n        self.acceleration = [0,0,0]\n        self.listPoints = list()\n        self.basePoint = [0,0,0]\n        self.vecVelocity = rs.VectorCreate(self.velocity, self.basePoint)\n        self.vecAcceleration = [0,0,0]\n        self.g = 0.4\n        self.mass = 1\n        # self.topspeed = 10\n\n    def update(self):\n        \n        self.vecAcceleration = rs.VectorCreate(self.acceleration, self.basePoint)    \n        self.vecVelocity = rs.VectorAdd(self.vecVelocity,self.vecAcceleration)\n        self.location = rs.PointAdd(self.location,self.vecVelocity)\n        self.acceleration = rs.VectorScale(self.acceleration,0)\n\n    def display(self):\n        tmpLoc = (self.location[0],self.location[1],self.location[2])\n        # print tmpLoc\n        self.listPoints.append(tmpLoc)\n\n    def applyForce(self,receivedForce):\n        vecForce = rs.VectorCreate(receivedForce, self.basePoint)\n        # print vecForce\n        self.acceleration = rs.VectorAdd(self.acceleration, vecForce)\n        # print self.acceleration\n\n    def attract(self,mover):\n        forceDir = rs.VectorSubtract(self.location,mover.location)\n        forceMag = rs.Distance(self.location,mover.location)\n        forceMag = limit(forceMag,2.0 , 27.0)\n        forceDir = rs.VectorUnitize(forceDir)\n        # print forceDir\n        strength = (self.g*self.mass)/(forceMag*forceMag)\n        # strength = limit(strength,1,15)\n        # print strength\n        finalForce = rs.VectorScale(forceDir,strength)\n        return finalForce\n\nclass Attractor(object):\n\n    def __init__(self):\n        self.location = [0,0,0]\n        self.velocity = [0,.1,.1]\n        self.acceleration = [0,0,0]\n        self.basePoint = [0,0,0]\n        self.vecAcceleration = rs.VectorCreate(self.acceleration, self.basePoint)\n        self.vecVelocity = rs.VectorCreate(self.velocity, self.basePoint) \n        self.mass = 2000\n        self.g = 0.4\n\n    def update(self):\n           \n        self.vecVelocity = rs.VectorAdd(self.vecVelocity,self.vecAcceleration)\n        self.location = rs.PointAdd(self.location,self.vecVelocity)\n        # self.acceleration = rs.VectorScale(self.acceleration,0)\n\n    def attract(self,mover):\n        forceDir = rs.VectorSubtract(self.location,mover.location)\n        forceMag = rs.Distance(self.location,mover.location)\n        forceMag = limit(forceMag,2.0 , 27.0)\n        forceDir = rs.VectorUnitize(forceDir)\n        # print forceDir\n        strength = (self.g*self.mass)/(forceMag*forceMag)\n        # strength = limit(strength,1,15)\n        # print strength\n        finalForce = rs.VectorScale(forceDir,strength)\n        return finalForce\n\n\nmoverList = []\n\nfor i in range(10):\n    moverList.append(Mover())\n\n# a = Attractor()\n\n# THE BELOW FUNCTION SIMULATES THE DRAW LOOP IN PROCESSING\n\nfor x in rs.frange(0, 15000, 1):\n\n    for n1 in range(len(moverList)):\n        for n2 in range(len(moverList)): \n            if n1 != n2:\n                attraction = moverList[n2].attract(moverList[n1])\n                # a.update()\n                # print attraction\n                # print m.vecAcceleration\n                moverList[n1].applyForce(attraction)\n                # moverList[n].applyForce([0,.1,.1])\n        moverList[n1].update()\n        moverList[n1].display()\n                # rs.AddPoint(m.location)\n\n# print m.location[0]\n# print m.listPoints\nfor p in range(len(moverList)):\n    rs.AddInterpCurve(moverList[p].listPoints)\n\n# rs.AddPoint(m.listPoints)\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}