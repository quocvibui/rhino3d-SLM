{
  "source_url": "https://discourse.mcneel.com/t/request-quick-dirty-lay-flat/200030",
  "topic_id": 200030,
  "title": "[Request] Quick & Dirty lay flat",
  "question": "If someone is interested, can you make this one (in Python):\n\n\n\n\nCall the script via macro or keystroke\n\n\nif object wasn’t pre-selected, an option to select the object\n\n\nclick on a planar face of the object\n\n\nthat face lays flat on world plane\n\n\n\n\nthat’s it\n\n\nwhatever orientation that face happens to be in space is how it plops to Z=0\n\n(as in, there’s no describing the plane using something like Orient3pt)\n\n\nfor example, say you select a surface with Auto CPlane turned on. Whatever that chooses for X,Y,Z can just keep X,Y point the same and just remaps to the regular cplane with Z being at zero.\n\n\njust looking for a one-click deal to get an object laying flat with desired surface facing downwards.\n\n\nthanks",
  "code_blocks": [
    {
      "code": "# -*- coding: utf-8 -*-\n\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport Rhino\nimport math\nimport System.Drawing as SD\n\n# ============================================================\n# SETTINGS (STICKY, PERSISTS DURING SESSION)\n# ============================================================\n\nSTICKY_KEY_COPY = \"FLATPLACE_COPY_MODE\"\n\ndef get_sticky_copy_default():\n    if sc.sticky.has_key(STICKY_KEY_COPY):\n        return bool(sc.sticky[STICKY_KEY_COPY])\n    return False\n\ndef set_sticky_copy_value(val):\n    sc.sticky[STICKY_KEY_COPY] = bool(val)\n\n# ============================================================\n# BASIC UTILITIES\n# ============================================================\n\ndef rotation_between(vec_from, vec_to, origin=Rhino.Geometry.Point3d(0,0,0)):\n    v1 = Rhino.Geometry.Vector3d(vec_from)\n    v2 = Rhino.Geometry.Vector3d(vec_to)\n    if not v1.Unitize() or not v2.Unitize():\n        return None\n    axis = Rhino.Geometry.Vector3d.CrossProduct(v1, v2)\n    if axis.IsTiny():\n        axis = Rhino.Geometry.Vector3d.ZAxis\n    angle = Rhino.Geometry.Vector3d.VectorAngle(v1, v2)\n    return Rhino.Geometry.Transform.Rotation(angle, axis, origin)\n\ndef get_bbox_center(obj_id):\n    bb = rs.BoundingBox(obj_id)\n    xs = [pt.X for pt in bb]\n    ys = [pt.Y for pt in bb]\n    zs = [pt.Z for pt in bb]\n    return Rhino.Geometry.Point3d(\n        (min(xs) + max(xs)) / 2.0,\n        (min(ys) + max(ys)) / 2.0,\n        (min(zs) + max(zs)) / 2.0\n    )\n\ndef get_xy_bbox(obj_id):\n    bb = rs.BoundingBox(obj_id)\n    xs = [p.X for p in bb]\n    ys = [p.Y for p in bb]\n    return (min(xs), min(ys), max(xs), max(ys))\n\ndef get_bbox_xy_rectangle(obj_id):\n    minx, miny, maxx, maxy = get_xy_bbox(obj_id)\n    pts = [\n        Rhino.Geometry.Point3d(minx, miny, 0),\n        Rhino.Geometry.Point3d(maxx, miny, 0),\n        Rhino.Geometry.Point3d(maxx, maxy, 0),\n        Rhino.Geometry.Point3d(minx, maxy, 0),\n        Rhino.Geometry.Point3d(minx, miny, 0),\n    ]\n    return Rhino.Geometry.Polyline(pts)\n\n# ============================================================\n# FLATTEN ONE OBJECT USING SAME \"WHICH WAY IS UP\" LOGIC\n# ============================================================\n\ndef flatten_one(obj_id):\n    brep = rs.coercebrep(obj_id)\n    if not brep:\n        print(\"Not a valid Brep/Polysurface.\")\n        return False\n\n    # ---- 1) Collect planar faces ----\n    planar_faces = []  # (face, normal, area, uv)\n    for face in brep.Faces:\n        if not face.IsPlanar():\n            continue\n\n        amp = Rhino.Geometry.AreaMassProperties.Compute(face)\n        if not amp:\n            continue\n        area = amp.Area\n\n        udom = face.Domain(0)\n        vdom = face.Domain(1)\n        u = (udom[0] + udom[1]) * 0.5\n        v = (vdom[0] + vdom[1]) * 0.5\n\n        normal = face.NormalAt(u, v)\n        if not normal.Unitize():\n            continue\n\n        planar_faces.append((face, normal, area, (u, v)))\n\n    if len(planar_faces) < 2:\n        print(\"Not enough planar faces to determine up.\")\n        return False\n\n    # ---- 2) Find best opposite pair using LARGEST FACE rule ----\n    best_pair = None\n    best_dominant_face_area = -1.0\n\n    for i in range(len(planar_faces)):\n        fA, nA, aA, uvA = planar_faces[i]\n        for j in range(i + 1, len(planar_faces)):\n            fB, nB, aB, uvB = planar_faces[j]\n            if Rhino.Geometry.Vector3d.Multiply(nA, nB) < -0.8:\n                dominant = max(aA, aB)\n                if dominant > best_dominant_face_area:\n                    best_dominant_face_area = dominant\n                    best_pair = ((fA, nA, aA, uvA), (fB, nB, aB, uvB))\n\n    if not best_pair:\n        planar_faces.sort(key=lambda x: x[2], reverse=True)\n        best_pair = (planar_faces[0], planar_faces[1])\n\n    (faceA, nA, areaA, uvA), (faceB, nB, areaB, uvB) = best_pair\n\n    # ---- 3) Machining side = smaller-area face ----\n    machining_face = faceA if areaA < areaB else faceB\n\n    # ---- 4) Sample point+normal ----\n    udom_m = machining_face.Domain(0)\n    vdom_m = machining_face.Domain(1)\n    u_m = (udom_m[0] + udom_m[1]) * 0.5\n    v_m = (vdom_m[0] + vdom_m[1]) * 0.5\n\n    pt = machining_face.PointAt(u_m, v_m)\n    normal = machining_face.NormalAt(u_m, v_m)\n    normal.Unitize()\n\n    # ---- 5) Move sample point to origin ----\n    to_origin = Rhino.Geometry.Transform.Translation(-pt.X, -pt.Y, -pt.Z)\n    sc.doc.Objects.Transform(obj_id, to_origin, True)\n\n    # ---- 6) Rotate machining normal → +Z ----\n    rot = rotation_between(normal, Rhino.Geometry.Vector3d.ZAxis)\n    if rot:\n        sc.doc.Objects.Transform(obj_id, rot, True)\n\n    # ---- 7) Sit on Z=0 ----\n    bb2 = rs.BoundingBox(obj_id)\n    zmin = min(p.Z for p in bb2)\n    lift = Rhino.Geometry.Transform.Translation(0, 0, -zmin)\n    sc.doc.Objects.Transform(obj_id, lift, True)\n\n    # ---- 8) Align longest flat edge → +Y ----\n    brep_flat = rs.coercebrep(obj_id)\n    longest = 0.0\n    best_vec = None\n\n    if brep_flat:\n        for edge in brep_flat.Edges:\n            crv = edge.ToNurbsCurve()\n            if not crv or not crv.IsLinear():\n                continue\n            p0 = crv.PointAtStart\n            p1 = crv.PointAtEnd\n            v = Rhino.Geometry.Vector3d(p1 - p0)\n            v.Z = 0.0\n            length = v.Length\n            if length > longest:\n                longest = length\n                best_vec = v\n\n    if best_vec and longest > 1e-6:\n        v = Rhino.Geometry.Vector3d(best_vec)\n        if v.Unitize():\n\n            if Rhino.Geometry.Vector3d.Multiply(v, Rhino.Geometry.Vector3d.YAxis) < 0:\n                v = -v\n\n            yaxis = Rhino.Geometry.Vector3d.YAxis\n            ang = Rhino.Geometry.Vector3d.VectorAngle(v, yaxis)\n            cross = Rhino.Geometry.Vector3d.CrossProduct(v, yaxis)\n            if cross.Z < 0:\n                ang = -ang\n\n            center3 = Rhino.Geometry.BoundingBox(rs.BoundingBox(obj_id)).Center\n            rot_z = Rhino.Geometry.Transform.Rotation(\n                ang, Rhino.Geometry.Vector3d.ZAxis, center3\n            )\n            sc.doc.Objects.Transform(obj_id, rot_z, True)\n\n    # ---- 9) POST-FLATTEN FIX: smallest horizontal face must face UP ----\n    brep2 = rs.coercebrep(obj_id)\n    if brep2:\n        top_area = None\n        bottom_area = None\n\n        for face in brep2.Faces:\n            if not face.IsPlanar():\n                continue\n\n            amp2 = Rhino.Geometry.AreaMassProperties.Compute(face)\n            if not amp2:\n                continue\n            area2 = amp2.Area\n\n            udom = face.Domain(0)\n            vdom = face.Domain(1)\n            u = 0.5*(udom[0] + udom[1])\n            v = 0.5*(vdom[0] + vdom[1])\n            n = face.NormalAt(u, v)\n            n.Unitize()\n\n            if abs(n.Z) > 0.9:\n                if n.Z > 0:\n                    top_area = area2\n                else:\n                    bottom_area = area2\n\n        if top_area is not None and bottom_area is not None:\n            if bottom_area < top_area:\n                centerpt = get_bbox_center(obj_id)\n                flip_x = Rhino.Geometry.Transform.Rotation(\n                    math.radians(180),\n                    Rhino.Geometry.Vector3d.XAxis,\n                    centerpt\n                )\n                sc.doc.Objects.Transform(obj_id, flip_x, True)\n\n                bb3 = rs.BoundingBox(obj_id)\n                zmin3 = min(p.Z for p in bb3)\n                lift2 = Rhino.Geometry.Transform.Translation(0, 0, -zmin3)\n                sc.doc.Objects.Transform(obj_id, lift2, True)\n\n    return True\n\n# ============================================================\n# PREVIEW GETPOINT (DRAW CYAN RECTANGLE)\n# ============================================================\n\nclass PlaceWithPreview(Rhino.Input.Custom.GetPoint):\n    def __init__(self, obj_id):\n        Rhino.Input.Custom.GetPoint.__init__(self)\n        self.obj_id = obj_id\n        self.SetCommandPrompt(\"Pick placement point (drops to World XY)\")\n\n    def OnDynamicDraw(self, e):\n        try:\n            pt = e.CurrentPoint\n            pt = Rhino.Geometry.Point3d(pt.X, pt.Y, 0)\n\n            base_rect = get_bbox_xy_rectangle(self.obj_id)\n\n            minx, miny, _, _ = get_xy_bbox(self.obj_id)\n            dx = pt.X - minx\n            dy = pt.Y - miny\n            xform = Rhino.Geometry.Transform.Translation(dx, dy, 0.0)\n\n            moved = Rhino.Geometry.Polyline(base_rect)\n            moved.Transform(xform)\n\n            e.Display.DrawPolyline(moved, SD.Color.Cyan, 2)\n        except:\n            pass\n\n# ============================================================\n# PLACE FLATTENED OBJECT AT PICKED POINT\n# ============================================================\n\ndef move_to_point(obj_id, target_pt):\n    minx, miny, _, _ = get_xy_bbox(obj_id)\n    dx = target_pt.X - minx\n    dy = target_pt.Y - miny\n    xform = Rhino.Geometry.Transform.Translation(dx, dy, 0.0)\n    sc.doc.Objects.Transform(obj_id, xform, True)\n\n# ============================================================\n# MAIN\n# ============================================================\n\ndef main():\n    import Rhino.Input.Custom\n\n    # sticky default\n    copy_default = get_sticky_copy_default()\n\n    go = Rhino.Input.Custom.GetObject()\n    go.SetCommandPrompt(\"Select one object to lay flat\")\n    go.GeometryFilter = (Rhino.DocObjects.ObjectType.Surface |\n                         Rhino.DocObjects.ObjectType.PolysrfFilter |\n                         Rhino.DocObjects.ObjectType.Brep)\n\n    go.EnablePreSelect(True, True)\n    go.EnablePostSelect(True)\n\n    #AddOptionToggle returns (index, toggle) in Rhino Mac py2.7\n    copy_toggle = Rhino.Input.Custom.OptionToggle(copy_default, \"No\", \"Yes\")\n    opt_copy_tuple = go.AddOptionToggle(\"Copy\", copy_toggle)\n    opt_copy_toggle = opt_copy_tuple[1]\n\n    selected_id = None\n\n    #keep looping until an object is actually selected\n    while True:\n        res = go.Get()\n\n        if res == Rhino.Input.GetResult.Cancel:\n            return\n\n        if res == Rhino.Input.GetResult.Option:\n            # user toggled Copy: update sticky immediately\n            set_sticky_copy_value(opt_copy_toggle.CurrentValue)\n            continue\n\n        if res == Rhino.Input.GetResult.Object:\n            objref = go.Object(0)\n            selected_id = objref.ObjectId\n            break\n\n        # anything else -> bail\n        return\n\n    do_copy = opt_copy_toggle.CurrentValue\n    set_sticky_copy_value(do_copy)  # make sure it's stored\n\n    working_id = selected_id\n\n    if do_copy:\n        dup = rs.CopyObject(selected_id)\n        if not dup:\n            print(\"Copy failed.\")\n            return\n        working_id = dup\n\n    # Hide while we flatten at origin (AND keep hidden until final placement)\n    rs.HideObject(working_id)\n    sc.doc.Views.Redraw()\n\n    ok = flatten_one(working_id)\n    if not ok:\n        rs.ShowObject(working_id)\n        sc.doc.Views.Redraw()\n        return\n\n    # Placement preview (object stays hidden; preview still draws)\n    gp = PlaceWithPreview(working_id)\n    if gp.Get() != Rhino.Input.GetResult.Point:\n        rs.ShowObject(working_id)\n        sc.doc.Views.Redraw()\n        return\n\n    pt = gp.Point()\n    target_pt = Rhino.Geometry.Point3d(pt.X, pt.Y, 0.0)\n\n    # Move while still hidden, then show at final location\n    move_to_point(working_id, target_pt)\n    rs.ShowObject(working_id)\n\n    sc.doc.Views.Redraw()\n    print(\"Done.\")\n\n\nmain()",
      "language": "python",
      "author": "jeff_hammond",
      "post_number": 11,
      "is_solution": false
    }
  ],
  "tags": [
    "file-io",
    "geometry",
    "nurbs",
    "python",
    "rhinocommon",
    "rhinoscriptsyntax",
    "selection",
    "transformation"
  ],
  "has_accepted_answer": false,
  "category_id": 11,
  "posts_count": 11,
  "views": 391
}