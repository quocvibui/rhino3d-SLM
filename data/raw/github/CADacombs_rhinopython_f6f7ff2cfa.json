{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/xBrep_createFromShape.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "xBrep_createFromShape.py",
  "instruction": "191118-19: Created by moving main function from another module.\r\n191215: Corrected debug printed output.\r\n200401: Import-related bug fix.\r\n200611: Implemented more correct use of...",
  "code": "\"\"\"\r\n191118-19: Created by moving main function from another module.\r\n191215: Corrected debug printed output.\r\n200401: Import-related bug fix.\r\n200611: Implemented more correct use of IsPointOnFace.\r\n200715: Joined \r\n210423: replaceShape now uses RemoveShortSegments for splitting curves.\r\n        WIP: Make moveSurfaceSeamsToAvoidCurves avoid endpoints of curves as well.\r\n220420: Repaired a RhinoCommon 7.17 script-breaking change.\r\n\r\nTODO:\r\n    Rotate RevSurface's before moving seams to avoid conversion to NurbsSurface.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.Geometry as rg\r\nimport scriptcontext as sc\r\n\r\nimport xBrep_findMatchingFace\r\nimport xPlaneSurface\r\n\r\nimport random\r\n\r\nmaxExponentFor2 = 4\r\n\r\n\r\ndef rotateSphericalBrepToAvoidCurves(rgBrep0, rgCrvs_ToAvoid, rotationCenter, fTolerance=None, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        rgBrep0\r\n        rgCrvs_ToAvoid\r\n        rotationCenter\r\n    Returns: New brep.\r\n    Moves surface (from sphere) seam away from rgCrvs_ToAvoid.\r\n    Do not use this for spherical surfaces.\r\n    \"\"\"\r\n\r\n\r\n    if fTolerance is None:\r\n        fTolerance = max(\r\n            2.0*sc.doc.ModelAbsoluteTolerance,\r\n            max([e.Tolerance for e in rgBrep0.Edges])\r\n            )\r\n\r\n    # Join curves to be avoided.  Joining them now will reduce the number of tests.\r\n    rgCrvs_Joined = rg.Curve.JoinCurves(rgCrvs_ToAvoid, fTolerance)\r\n    if rgCrvs_Joined is None:\r\n        if bDebug: print \"JoinCurves failed!\"\r\n        return\r\n    if len(rgCrvs_Joined) > 1:\r\n        if bDebug: print \"JoinCurves resulted in {} curves.\".format(len(rgCrvs_Joined))\r\n        return\r\n    rgCrv_ToAvoid_Joined = rgCrvs_Joined[0]\r\n    if not rgCrv_ToAvoid_Joined.IsClosed:\r\n        if bDebug: print \"Joined curve is not closed.\"\r\n        return\r\n    \r\n    #sc.doc.Objects.AddCurve(rgCrv_ToAvoid_Joined); sc.doc.Views.Redraw()\r\n    \r\n    rgCrvs_rgBrep0Edges = rgBrep0.Curves3D\r\n    #sc.doc.Objects.AddBrep(rgBrep0)\r\n\r\n    rgCrvs_Joined = rg.Curve.JoinCurves(rgCrvs_rgBrep0Edges, fTolerance)\r\n    if rgCrvs_Joined is None:\r\n        if bDebug: print \"JoinCurves failed!\"\r\n        return\r\n    if len(rgCrvs_Joined) > 1:\r\n        s  = \"JoinCurves resulted in\"\r\n        s += \" {} curves.\".format(len(rgCrvs_Joined))\r\n        s += \"  Quitting rotation of this brep.\"\r\n        print s\r\n        return\r\n    rgCrv_rgBrep0Edges_Joined = rgCrvs_Joined[0]\r\n    \r\n    #sc.doc.Objects.AddCurve(rgCrv_rgBrep0Edges_Joined); sc.doc.Views.Redraw()\r\n\r\n    # First try starting baseball sphere.\r\n    rc = rgCrv_ToAvoid_Joined.ClosestPoints(otherCurve=rgCrv_rgBrep0Edges_Joined)\r\n    b, ptOnCrv_ToAvoid_Joined, ptOnBaseballEdgeCrv_Joined = rc\r\n    if not b:\r\n        print \"ClosestPoints not found!\"\r\n        return\r\n    dist = ptOnCrv_ToAvoid_Joined.DistanceTo(ptOnBaseballEdgeCrv_Joined)\r\n    if dist > 10.0*max((fTolerance, sc.doc.ModelAbsoluteTolerance)):\r\n        # TODO: Is 10.0* a good multiplier?\r\n        return rgBrep0\r\n        \r\n    angles = [0.0,0.0,0.0]\r\n    for N in xrange(maxExponentFor2):\r\n        sc.escape_test()\r\n        denominator = 2.0**N\r\n        for numerator in xrange(1, denominator, 2):\r\n            sc.escape_test()\r\n            perunus = float(numerator) / float(denominator)\r\n            angles[0] = Rhino.RhinoMath.ToRadians(360.0)*perunus\r\n            for N in xrange(maxExponentFor2):\r\n                sc.escape_test()\r\n                denominator = 2.0**N\r\n                for numerator in xrange(1, denominator, 2):\r\n                    sc.escape_test()\r\n                    perunus = float(numerator) / float(denominator)\r\n                    angles[1] = Rhino.RhinoMath.ToRadians(360.0)*perunus\r\n                    for N in xrange(maxExponentFor2):\r\n                        sc.escape_test()\r\n                        denominator = 2.0**N\r\n                        for numerator in xrange(1, denominator, 2):\r\n                            perunus = float(numerator) / float(denominator)\r\n                            angles[2] = Rhino.RhinoMath.ToRadians(360.0)*perunus\r\n                            rgBaseballEdgeCrv_Joined_WIP = rgCrv_rgBrep0Edges_Joined.Duplicate()\r\n                            rgBaseballEdgeCrv_Joined_WIP.Rotate(\r\n                                    angleRadians=angles[0],\r\n                                    rotationAxis=rg.Vector3d.XAxis,\r\n                                    rotationCenter=rotationCenter)\r\n                            rgBaseballEdgeCrv_Joined_WIP.Rotate(\r\n                                    angleRadians=angles[1],\r\n                                    rotationAxis=rg.Vector3d.YAxis,\r\n                                    rotationCenter=rotationCenter)\r\n                            rgBaseballEdgeCrv_Joined_WIP.Rotate(\r\n                                    angleRadians=angles[2],\r\n                                    rotationAxis=rg.Vector3d.ZAxis,\r\n                                    rotationCenter=rotationCenter)\r\n                                \r\n                            rc = rgCrv_ToAvoid_Joined.ClosestPoints(otherCurve=rgBaseballEdgeCrv_Joined_WIP)\r\n                            b, ptOnCrv_ToAvoid_Joined, ptOnBaseballEdgeCrv_Joined = rc\r\n                            if not b:\r\n                                print \"ClosestPoints not found!\"\r\n                                return\r\n                            dist = ptOnCrv_ToAvoid_Joined.DistanceTo(ptOnBaseballEdgeCrv_Joined)\r\n                            if dist <= 10.0*max((fTolerance, sc.doc.ModelAbsoluteTolerance)):\r\n                                # TODO: Is 10.0* a good multiplier?\r\n                                #sc.doc.Objects.AddSphere(sphereRotX)\r\n                                continue # to next axis rotation.\r\n                                \r\n                            # Found good orientation.\r\n                            #sc.doc.Objects.AddCurve(rgBaseballEdgeCrv_Joined_WIP)\r\n                            rgBrep_Rotated = rgBrep0.Duplicate()\r\n                            if not rgBrep_Rotated.Rotate(\r\n                                angleRadians=angles[0],\r\n                                rotationAxis=rg.Vector3d.XAxis,\r\n                                rotationCenter=rotationCenter\r\n                            ):\r\n                                return\r\n                            if not rgBrep_Rotated.Rotate(\r\n                                angleRadians=angles[1],\r\n                                rotationAxis=rg.Vector3d.YAxis,\r\n                                rotationCenter=rotationCenter\r\n                            ):\r\n                                return\r\n                            if not rgBrep_Rotated.Rotate(\r\n                                angleRadians=angles[2],\r\n                                rotationAxis=rg.Vector3d.ZAxis,\r\n                                rotationCenter=rotationCenter\r\n                            ):\r\n                                return\r\n                            return rgBrep_Rotated\r\n\r\n\r\ndef moveSurfaceSeamsToAvoidCurves(rgSrf0, rgCrvs_ToAvoid, iDirections, tolerance=None, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        rgCrvs_ToAvoid: Curves from which to move the seam.\r\n        \r\n    Returns: New Surface with modified seam, if necessary.\r\n        \r\n    Do not use this for spherical surfaces.\r\n    \"\"\"\r\n        \r\n    rgBrep_1F_ToMoveSrfSeam = rgSrf0.ToBrep()\r\n    if rgBrep_1F_ToMoveSrfSeam is None: return\r\n        \r\n    if tolerance is None:\r\n        tolerance = 4.0*sc.doc.ModelAbsoluteTolerance\r\n    \r\n    # Test at existing seam location(s) in case moving the seam is not necessary.\r\n    # This also gets a base count for the number of faces from split.\r\n    rgFace_ToMoveSeam = rgBrep_1F_ToMoveSrfSeam.Faces[0]\r\n        \r\n    rgCrvs_Joined = rg.Curve.JoinCurves(rgCrvs_ToAvoid)\r\n    if rgCrvs_Joined is None:\r\n        if bDebug: print \"JoinCurves failed!\"\r\n        return\r\n    #for c in rgCrvs_Joined: sc.doc.Objects.AddCurve(c)\r\n        \r\n    ct_rgCrvs_Joined = len(rgCrvs_Joined)\r\n    if ct_rgCrvs_Joined > 1:\r\n        if bDebug: s = \"JoinCurves resulted in {} curves.\".format(len(rgCrvs_Joined))\r\n        bOpen = [True for c in rgCrvs_Joined if not c.IsClosed]\r\n        if bOpen:\r\n            if bDebug: \r\n                s += \"  {} are open.\".format(len(bOpen))\r\n                s += \"  This merge will be skipped.\"\r\n                print s\r\n            return\r\n        # Check whether they probably should be joined.\r\n        ct_TooClose = 0\r\n        for i in range(len(rgCrvs_Joined)):\r\n            for j in range(i+1, len(rgCrvs_Joined)):\r\n                cI = rgCrvs_Joined[i]\r\n                cJ = rgCrvs_Joined[j]\r\n                b, ptI, ptJ = cI.ClosestPoints(cJ)\r\n                if not b:\r\n                    if bDebug:\r\n                        s += \"  Error in checking distances between curves.\"\r\n                        print s\r\n                dist = ptI.DistanceTo(ptJ)\r\n                if dist <= tolerance:\r\n                    if bDebug:\r\n                        s += \"  Distance between 2 curves is only {}.\".\\\r\n                                format(dist)\r\n                        s += \"  This merge will be skipped.\"\r\n                        print s\r\n                    return\r\n    elif not rg.Curve.IsClosed:\r\n        if bDebug: print \"Joined curve is not closed.\"\r\n        return\r\n        \r\n    rgBrep_NewSeamLoc_WIP = rgSrf0.ToBrep()\r\n    rgFace_ToMoveSeam = rgBrep_NewSeamLoc_WIP.Faces[0]\r\n        \r\n    for iDir in iDirections:\r\n        if not rgFace_ToMoveSeam.IsClosed(iDir): continue\r\n        def findLeastIntersectingSeamParameter(iDir):\r\n            parameter_LeastInters = None\r\n            iCt_Inters_Least = None\r\n            for N in xrange(maxExponentFor2):\r\n                denominator = 2.0**N\r\n                numerator_range = (0,) if denominator == 1 else xrange(1, denominator, 2)\r\n                for numerator in numerator_range:\r\n                    perunus = float(numerator) / float(denominator)\r\n                    T0 = rgFace_ToMoveSeam.Domain(direction=iDir).T0\r\n                    T1 = rgFace_ToMoveSeam.Domain(direction=iDir).T1\r\n                    parameter = T0*(1-perunus)+T1*perunus\r\n                    rgSeamCrv = rgFace_ToMoveSeam.IsoCurve(direction=(iDir+1)%2, constantParameter=parameter) # direction is opposite of constantParameter's direction.\r\n                    #sc.doc.Objects.AddCurve(rgSeamCrv); sc.doc.Views.Redraw()\r\n                    iCt_Inters = 0\r\n                    for rgCrv_Joined in rgCrvs_Joined:\r\n                        #sc.doc.Objects.AddCurve(rgCrv_Joined); sc.doc.Views.Redraw()\r\n                        rc = rgCrv_Joined.ClosestPoints(otherCurve=rgSeamCrv)\r\n                        b, ptOnBoundaryCrv, pointOnSeamCurve = rc\r\n                        if not b:\r\n                            if bDebug: print \"ClosestPoints not found!\"\r\n                            return\r\n                        dist = ptOnBoundaryCrv.DistanceTo(other=pointOnSeamCurve)\r\n                        if dist <= tolerance:\r\n                            iCt_Inters += 1\r\n                    if iCt_Inters == 0:\r\n                        return parameter\r\n                    elif iCt_Inters_Least is None or iCt_Inters < iCt_Inters_Least:\r\n                            parameter_LeastInters = parameter\r\n                            iCt_Inters_Least = iCt_Inters\r\n            if iCt_Inters_Least == len(rgCrvs_Joined):\r\n                return\r\n            else:\r\n                return parameter\r\n        parameter = findLeastIntersectingSeamParameter(iDir)\r\n        if parameter is None:\r\n            if len(iDirections) == 1:\r\n                # Seam may have to be present as in the case of a\r\n                # cylindrical or conical face with a full circumference.\r\n                rgSrf1 = rgBrep_NewSeamLoc_WIP.Surfaces[0].Duplicate()\r\n                rgBrep_NewSeamLoc_WIP.Dispose()\r\n                return rgSrf1\r\n            if bDebug: print \"Surface is closed in both directions, so trying to move the other seam first.\"\r\n            for iDir in reversed(iDirections):\r\n                parameter = findLeastIntersectingSeamParameter(iDir)\r\n                if parameter is None:\r\n                    if bDebug: print \"Parameter not found!\"\r\n                    return\r\n                # Check whether seam is different than current.\r\n                if parameter == rgFace_ToMoveSeam.Domain(direction=iDir).T0:\r\n                    rgBrep_NewSeamLoc_WIP\r\n                else:\r\n                    rgBrep_NewSeamLoc_WIP = rg.Brep.ChangeSeam(\r\n                            face=rgFace_ToMoveSeam,\r\n                            direction=iDir,\r\n                            parameter=parameter,\r\n                            tolerance=sc.doc.ModelAbsoluteTolerance)\r\n                    if rgBrep_NewSeamLoc_WIP is None:\r\n                        if bDebug: print \"ChangeSeam resulted in None!\"\r\n                        return\r\n                # For a Torus, move second seam after moving first seam.\r\n                if len(iDirections) == 2:\r\n                    rgFace_ToMoveSeam = rgBrep_NewSeamLoc_WIP.Faces[0]\r\n            return rgBrep_NewSeamLoc_WIP\r\n        # Move seam if the good parameter is different than current seam.\r\n        if parameter == rgFace_ToMoveSeam.Domain(direction=iDir).T0:\r\n            rgBrep_NewSeamLoc_WIP\r\n        else:\r\n            rgBrep_NewSeamLoc_WIP = rg.Brep.ChangeSeam(\r\n                    face=rgFace_ToMoveSeam,\r\n                    direction=iDir,\r\n                    parameter=parameter,\r\n                    tolerance=sc.doc.ModelAbsoluteTolerance)\r\n            if rgBrep_NewSeamLoc_WIP is None:\r\n                if bDebug: print \"ChangeSeam resulted in None!\"\r\n                return\r\n        # For a Torus, move second seam after moving first seam.\r\n        if len(iDirections) == 2:\r\n            rgFace_ToMoveSeam = rgBrep_NewSeamLoc_WIP.Faces[0]\r\n    \r\n    rgSrf1 = rgBrep_NewSeamLoc_WIP.Surfaces[0].Duplicate()\r\n    rgBrep_NewSeamLoc_WIP.Dispose()\r\n    return rgSrf1\r\n\r\n\r\ndef getRandomPointOnFace(rgBrep, idxFace, fDistMin=None):\r\n    \"\"\"\r\n    Parameters:\r\n        rgBrep: Used to get the edges from the edge indices.\r\n        idxFace\r\n        fDistMin: Minimum distance from the face border.\r\n    Returns:\r\n        Point3d on success, None on failure\r\n    \"\"\"\r\n    \r\n    rgFace = rgBrep.Faces[idxFace]\r\n    \r\n    if fDistMin is None:\r\n        fDistMin = 10.0*sc.doc.ModelAbsoluteTolerance\r\n    \r\n    areaMassProp = Rhino.Geometry.AreaMassProperties.Compute(rgFace)\r\n    if areaMassProp is None:\r\n        print \"Face index {} skipped because its AreaMassProperties, \" \\\r\n        \"and thus its centroid, cannot be calculated.\".format(\r\n                idxFace)\r\n        return\r\n    \r\n    ptCentrdW = areaMassProp.Centroid\r\n    getrc, u, v = rgFace.ClosestPoint(ptCentrdW)\r\n    domnU, domnV = rgFace.Domain(0), rgFace.Domain(1)\r\n    fIE = 0. # Ratio from surface borders\r\n    \r\n    rgEdges = [rgBrep.Edges[idxEdge] for idxEdge in rgFace.AdjacentEdges()]\r\n    \r\n    for i in xrange(100000): # If point is not on face, continue searching.\r\n        ptFaceRel = rgFace.IsPointOnFace(u, v)\r\n        if ptFaceRel == rg.PointFaceRelation.Interior:\r\n            # If point is not at least fDistMin from border, continue searching.\r\n            pt = rgFace.PointAt(u, v)\r\n            for rgEdge in rgEdges:\r\n                b, t = rgEdge.ClosestPoint(pt)\r\n                if b:\r\n                    if pt.DistanceTo(rgEdge.PointAt(t)) < fDistMin: # Too close\r\n                        break\r\n            else: # Good point\r\n                map(lambda x: x.Dispose(), rgEdges)\r\n                rgFace.Dispose()\r\n                return pt\r\n        \r\n        # Get new parameters for point.\r\n        u = random.uniform(domnU.T0 + fIE*domnU.Length,\r\n                domnU.T1 - fIE*domnU.Length)\r\n        v = random.uniform(domnV.T0 + fIE*domnV.Length,\r\n                domnV.T1 - fIE*domnV.Length)\r\n    \r\n    map(lambda x: x.Dispose(), rgEdges)\r\n    rgFace.Dispose()\r\n\r\n\r\ndef getFaceAtPoint(rgBrep_Split, ptOnFace, bEcho=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    if bEcho: print 'getFaceAtPoint()...'\r\n    \r\n    # Test the point distance to each face.\r\n    for iF, rgFace in enumerate(rgBrep_Split.Faces):\r\n        rgBrep1_1F = rgFace.DuplicateFace(False)\r\n        if rgBrep1_1F is None:\r\n            if bEcho: sPrint = 'rgBrep1_1F'; print sPrint + ':', eval(sPrint)\r\n            return\r\n        \r\n        b, u, v = rgFace.ClosestPoint(ptOnFace)\r\n        if b:\r\n            # Shouldn't need to implement this if IsPointOnFace correctly\r\n            # returns rg.PointFaceRelation.Interior.\r\n            #pt_Closest = rgFace.PointAt(u, v)\r\n            #fDist = pt_Closest.DistanceTo(ptOnFace)\r\n\r\n            ptFaceRel = rgFace.IsPointOnFace(u, v)\r\n            if ptFaceRel == rg.PointFaceRelation.Interior:\r\n                rgFace.Dispose()\r\n                rgBrep1_1F.Dispose()\r\n                return iF\r\n        \r\n        rgFace.Dispose()\r\n        rgBrep1_1F.Dispose()\r\n\r\n\r\ndef extendCylinderToObjectSize(rgCyl, rgObjForSizeRef, bDebug=False):\r\n    rgBbox_ForSizeRef = rgObjForSizeRef.GetBoundingBox(accurate=False)\r\n    fAddLen = 1.1 * rgBbox_ForSizeRef.Min.DistanceTo(rgBbox_ForSizeRef.Max)\r\n\r\n    if not rgCyl.IsFinite: # Fix cylinder that is infinite (has 0 height).\r\n        if bDebug: print \"Making cylinder finite...\",\r\n        rgCyl.Height1 = -fAddLen\r\n        rgCyl.Height2 = fAddLen\r\n        if bDebug: print \"Height of cylinder after: {}\".format(rgCyl.TotalHeight)\r\n    else: # Increase length of cylinder so that it extends the reference object.\r\n        if bDebug: print \"Height of cylinder before: {}\".format(rgCyl.TotalHeight),\r\n        if rgCyl.Height1 < rgCyl.Height2:\r\n            rgCyl.Height1 -= fAddLen\r\n            rgCyl.Height2 += fAddLen\r\n        else:\r\n            rgCyl.Height1 += fAddLen\r\n            rgCyl.Height2 -= fAddLen\r\n        if bDebug: print \"Height of cylinder after: {}\".format(rgCyl.TotalHeight)\r\n\r\n\r\ndef replaceShape(rgBrep0, shape, fTolerance=None, bDebug=False):\r\n    \"\"\"\r\n    shape_ForMerge can be NurbsSurface, Cone, Cylinder, Plane, Sphere, or Torus.\r\n    \r\n    Returns: New Brep.\r\n    \"\"\"\r\n\r\n    if bDebug: print '-'*80 + '\\n' + 'replaceShape()'\r\n    \r\n    rgBrep_In = rgBrep0\r\n\r\n    shape_In = shape\r\n    \r\n    if not shape_In.IsValid:\r\n        print \"{} is NOT valid in replaceShape!\".format(shape_In)\r\n\r\n    if fTolerance is None:\r\n        fTolerance = max(\r\n            2.0*sc.doc.ModelAbsoluteTolerance,\r\n            max([e.Tolerance for e in rgBrep_In.Edges])\r\n            )\r\n\r\n    # 200715: Disabled rgBrep_0RebuiltEs.\r\n    #    rgBrep_0RebuiltEs = rgBrep_In.DuplicateBrep()\r\n    #    for f in rgBrep_0RebuiltEs.Faces:\r\n    #        f.RebuildEdges(\r\n    #                tolerance=fTolerance,\r\n    #                rebuildSharedEdges=True,\r\n    #                rebuildVertices=True)\r\n\r\n    # Prepare trimming curves.\r\n    rgCrvs_NEs_Otr = rgBrep_In.DuplicateNakedEdgeCurves(True, False) # nakedOuter, nakedInner\r\n    \r\n    #map(sc.doc.Objects.AddCurve, rgCrvs_ToJoin_Otr); sc.doc.Views.Redraw()\r\n    \r\n    #    rgCrvs_ToJoin_Otr = []\r\n    #    for c in rgCrvs_NEs_Otr:\r\n    #        if c.PointAtStart.DistanceTo(c.PointAtEnd) > fTolerance:\r\n    #            rgCrvs_ToJoin_Otr.append(c)\r\n    #        else:\r\n    #            c.Dispose()\r\n    \r\n    rgCrvs_ToJoin_Otr = rgCrvs_NEs_Otr[:]\r\n    \r\n    #map(sc.doc.Objects.AddCurve, rgCrvs_ToJoin_Otr); sc.doc.Views.Redraw()\r\n    \r\n    rgCrvs_NEs_Inr = rgBrep_In.DuplicateNakedEdgeCurves(False, True) # nakedOuter, nakedInner\r\n    \r\n    #map(sc.doc.Objects.AddCurve, rgCrvs_Inr); sc.doc.Views.Redraw()\r\n    \r\n    #    rgCrvs_ToJoin_Inr = []\r\n    #    for c in rgCrvs_NEs_Inr:\r\n    #        if c.PointAtStart.DistanceTo(c.PointAtEnd) > fTolerance:\r\n    #            rgCrvs_ToJoin_Otr.append(c)\r\n    #        else:\r\n    #            c.Dispose()\r\n    \r\n    rgCrvs_ToJoin_Inr = rgCrvs_NEs_Inr[:]\r\n    \r\n    #map(sc.doc.Objects.AddCurve, rgCrvs_ToJoin_Inr); sc.doc.Views.Redraw()\r\n    \r\n    # Join curves because it has been found that small segments can cause\r\n    # BrepFace.Split to fail.\r\n    # A side effect of doing this is that some edges will be merged.\r\n    \r\n    rgCrvs_Joined_Otr = rg.Curve.JoinCurves(rgCrvs_ToJoin_Otr, fTolerance)\r\n\r\n    #map(sc.doc.Objects.AddCurve, rgCrvs_Joined_Otr); sc.doc.Views.Redraw()\r\n    \r\n    rgCrvs_Joined_Inr = rg.Curve.JoinCurves(rgCrvs_ToJoin_Inr, fTolerance)\r\n\r\n    #map(sc.doc.Objects.AddCurve, rgCrvs_Joined_Inr); sc.doc.Views.Redraw()\r\n    \r\n    rgCrvs_Joined_All = rg.Curve.JoinCurves(\r\n        list(rgCrvs_Joined_Otr) + list(rgCrvs_Joined_Inr),\r\n        fTolerance)\r\n    \r\n    for c in rgCrvs_Joined_All:\r\n        if not c.IsClosed:\r\n            #sc.doc.Objects.AddCurve(c); sc.doc.Views.Redraw(); 1/0\r\n            print \"Curve is not closed in xBrep.replaceShape.\"\r\n            return\r\n    \r\n    #rgCrvs_Joined_All = rgCrvs_Joined_Otr + rgCrvs_Joined_Inr\r\n    \r\n    if bDebug: sEval = 'len(rgCrvs_Joined_All)'; print sEval + ':', eval(sEval)\r\n    #map(sc.doc.Objects.AddCurve, rgCrvs_Joined_All); sc.doc.Views.Redraw(); 1/0\r\n    \r\n    # Determine how many faces into which the brep should split.\r\n    # As in the case of a complete cylinder, the outer loop can have more than 1 trim set.\r\n    iCt_Crvs_Joined_Otr = rgCrvs_Joined_Otr.Count\r\n    if bDebug: sEval = 'iCt_Crvs_Joined_Otr'; print sEval + ':', eval(sEval)\r\n    numTargetSplits_Max = (iCt_Crvs_Joined_Otr + rgBrep_In.Loops.Count -\r\n            rgBrep_In.Faces.Count + 1)\r\n    if bDebug: sEval = 'numTargetSplits_Max'; print sEval + ':', eval(sEval)\r\n    \r\n    rgCrvs_ForSplit = []\r\n    for c in rgCrvs_Joined_All:\r\n        print c.RemoveShortSegments(tolerance=fTolerance)\r\n        segs = c.DuplicateSegments()\r\n        if segs:\r\n            rgCrvs_ForSplit.extend(c.DuplicateSegments())\r\n        else:\r\n            rgCrvs_ForSplit.append(c)\r\n            print \"DuplicateSegments returned None.\"\r\n            # Because DuplicateSegments returns None when curve cannot be segmented.\r\n    if bDebug: sEval = 'len(rgCrvs_ForSplit)'; print sEval + ':', eval(sEval)\r\n    \r\n    # Get final brep.\r\n    \r\n    sShape = shape_In.GetType().Name\r\n    \r\n    if sShape == 'Plane':\r\n        rgPlaneSrf1 = xPlaneSurface.createFromPlaneAndObjectSize(\r\n                rgPlane=shape_In, obj_ForSize=rgBrep_In)\r\n        rgBrep_FullSrf = rgPlaneSrf1.ToBrep()\r\n        rgFace_FullSrf = rgBrep_FullSrf.Faces[0]\r\n        \r\n        rgBrep_Split = rgFace_FullSrf.Split(\r\n                curves=rgCrvs_ForSplit,\r\n                tolerance=sc.doc.ModelAbsoluteTolerance)\r\n\r\n    elif sShape == 'NurbsSurface':\r\n        rgNurbsSrf1 = shape_In.Duplicate()\r\n        rgBrep_FromNurbsSrf = rgNurbsSrf1.ToBrep()\r\n        rgFace_FullSrf = rgBrep_FromNurbsSrf.Faces[0]\r\n        \r\n        directions = []\r\n        if rgNurbsSrf1.IsClosed(0):\r\n            directions.append(0)\r\n        if rgNurbsSrf1.IsClosed(1):\r\n            directions.append(1)\r\n        if directions:\r\n            rgSrf1_MovedSeam = moveSurfaceSeamsToAvoidCurves(\r\n                    rgNurbsSrf1,\r\n                    rgCrvs_Joined_Otr,\r\n                    directions,\r\n                    bDebug=bDebug)\r\n            if rgSrf1_MovedSeam is None: return\r\n            rgFace_FullSrf = rgSrf1_MovedSeam.ToBrep().Faces[0]\r\n        \r\n        rgBrep_Split = rgFace_FullSrf.Split(\r\n                curves=rgCrvs_ForSplit,\r\n                tolerance=sc.doc.ModelAbsoluteTolerance)\r\n    \r\n    else:\r\n        # Primitive of RevSurface.\r\n        \r\n        # Check for case of sphere or torus not requiring any trim.\r\n        if len(rgCrvs_Joined_All) == 0:\r\n            if sShape == 'Sphere' or sShape == 'Torus':\r\n                rgRevSrf1_ForSolid = shape_In.ToRevSurface()\r\n                rgBrep_FromRevSrf = rgRevSrf1_ForSolid.ToBrep()\r\n                rgRevSrf1_ForSolid.Dispose()\r\n                return rgBrep_FromRevSrf\r\n\r\n        # Extend rgShapeX of cylinder or cone.\r\n        if sShape == 'Cylinder':\r\n            extendCylinderToObjectSize(shape_In, rgBrep_In, bDebug=bDebug)\r\n            #sc.doc.Objects.AddBrep(shape_In.ToBrep(False, False))\r\n        elif sShape == 'Cone': # Extend length of cone so that surface is larger than trim.\r\n            fScale = 1.1\r\n            shape_In.Radius *= fScale\r\n            shape_In.Height *= fScale\r\n\r\n        rgRevSrf1_FromShape = shape_In.ToRevSurface() # Shape is primitive of RevSurface\r\n\r\n        if isinstance(shape_In, rg.Cylinder) or isinstance(shape_In, rg.Cone):\r\n            rgBrep_FullCyl_FromRevSrf = rgRevSrf1_FromShape.ToBrep()\r\n            rgFace_FullSrf = rgBrep_FullCyl_FromRevSrf.Faces[0]\r\n            \r\n            if rgFace_FullSrf.IsClosed(0):\r\n                directions = 0,\r\n            elif rgFace_FullSrf.IsClosed(1):\r\n                directions = 1,\r\n            else:\r\n                print \"No seam on {}!\".format(shape_In)\r\n                return\r\n            rgSrf1_MovedSeam = moveSurfaceSeamsToAvoidCurves(\r\n                    rgRevSrf1_FromShape,\r\n                    rgCrvs_Joined_Otr,\r\n                    directions,\r\n                    bDebug=bDebug)\r\n            if rgSrf1_MovedSeam is None: return\r\n            #sc.doc.Objects.AddSurface(rgSrf1_MovedSeam)\r\n            \r\n            rgB_FullSrf = rgSrf1_MovedSeam.ToBrep()\r\n            \r\n            rgFace_FullSrf = rgB_FullSrf.Faces[0]\r\n            \r\n            rgBrep_Split = rgFace_FullSrf.Split(\r\n                    curves=rgCrvs_ForSplit,\r\n                    tolerance=sc.doc.ModelAbsoluteTolerance)\r\n\r\n            if not rgBrep_Split.IsValid:\r\n                if bDebug:\r\n                    print \"rgBreps3_1F is invalid.\"\r\n                print rgBrep_Split.IsValidWithLog()\r\n                rgBrep_Split.Dispose()\r\n                sc.doc.Objects.AddBrep(rgB_FullSrf)\r\n                for crv in rgCrvs_ForSplit:\r\n                    sc.doc.Objects.AddCurve(crv)\r\n                return\r\n\r\n        elif isinstance(shape_In, rg.Torus):\r\n            rgBrep_FullTorus_FromRevSrf = rgRevSrf1_FromShape.ToBrep()\r\n            rgFace_FullSrf = rgBrep_FullTorus_FromRevSrf.Faces[0]\r\n            \r\n            directions = 0,1\r\n            rgSrf1_MovedSeam = moveSurfaceSeamsToAvoidCurves(\r\n                    rgRevSrf1_FromShape,\r\n                    rgCrvs_Joined_Otr,\r\n                    directions,\r\n                    bDebug=bDebug)\r\n            if rgSrf1_MovedSeam is None: return\r\n            #            sc.doc.Objects.AddBrep(rgBrep_FullTorus_FromRevSrf)\r\n            #            for rgCrvX in rgCrvs_ForSplit:\r\n            #                sc.doc.Objects.AddCurve(rgCrvX)\r\n            \r\n            if isinstance(rgSrf1_MovedSeam, rg.Brep):\r\n                pass\r\n            \r\n            rgFace_FullSrf = rgSrf1_MovedSeam.ToBrep().Faces[0]\r\n            \r\n            rgBrep_Split = rgFace_FullSrf.Split(\r\n                    curves=rgCrvs_ForSplit,\r\n                    tolerance=sc.doc.ModelAbsoluteTolerance)\r\n    \r\n        elif isinstance(shape_In, rg.Sphere):\r\n            sphere = shape_In\r\n            \r\n            rgBrep_Split = None\r\n            \r\n            # createBrepWithAdjustedSurfaceSeam doesn't\r\n            # work as well with spheres due to poles, so try baseball first.\r\n\r\n            rgBrep_Baseball0 = rg.Brep.CreateBaseballSphere(\r\n                    center=sphere.Center,\r\n                    radius=sphere.Radius,\r\n                    tolerance=Rhino.RhinoMath.ZeroTolerance)\r\n            \r\n            #sc.doc.Objects.AddBrep(rgBrep_Baseball0); sc.doc.Views.Redraw()\r\n\r\n            rgBrep_BaseballSphere_Rotated = rotateSphericalBrepToAvoidCurves(\r\n                    rgBrep0=rgBrep_Baseball0,\r\n                    rgCrvs_ToAvoid=rgCrvs_Joined_Otr,\r\n                    rotationCenter=sphere.Center,\r\n                    fTolerance=fTolerance,\r\n                    bDebug=bDebug)\r\n            if rgBrep_BaseballSphere_Rotated is not None:\r\n                # Find correct Face of baseball sphere brep.\r\n                pt_ToFindFace = rgCrvs_Joined_Otr[0].PointAtStart\r\n                for iF, rgFace1 in enumerate(rgBrep_BaseballSphere_Rotated.Faces):\r\n                    b, u,v = rgFace1.ClosestPoint(pt_ToFindFace)\r\n                    if not b: return\r\n\r\n                    fDist = pt_ToFindFace.DistanceTo(rgFace1.PointAt(u,v))\r\n                    if fDist > sc.doc.ModelAbsoluteTolerance:\r\n                        continue\r\n\r\n                    ptFaceRel = rgFace1.IsPointOnFace(u,v)\r\n                    if ptFaceRel == rg.PointFaceRelation.Interior:\r\n                        rgBrep_Split = rgFace1.Split(\r\n                                curves=rgCrvs_ForSplit,\r\n                                tolerance=sc.doc.ModelAbsoluteTolerance)\r\n                        break\r\n            if rgBrep_Split is None:\r\n                rgBrep_FullSphere_FromRevSrf = rgRevSrf1_FromShape.ToBrep()\r\n                rgFace_FullSrf = rgBrep_FullSphere_FromRevSrf.Faces[0]\r\n                \r\n                if rgFace_FullSrf.IsClosed(0):\r\n                    directions = 0,\r\n                elif rgFace_FullSrf.IsClosed(1):\r\n                    directions = 1,\r\n                \r\n                rgSrf1_MovedSeam = moveSurfaceSeamsToAvoidCurves(\r\n                        rgRevSrf1_FromShape,\r\n                        rgCrvs_Joined_Otr,\r\n                        directions,\r\n                        bDebug=bDebug)\r\n                if rgSrf1_MovedSeam is not None:\r\n                    rgFace_FullSrf = rgSrf1_MovedSeam.ToBrep().Faces[0]\r\n                    rgBrep_Split = rgFace_FullSrf.Split(\r\n                            curves=rgCrvs_ForSplit,\r\n                            tolerance=sc.doc.ModelAbsoluteTolerance)\r\n                \r\n                if rgBrep_Split is None:\r\n                    rgBrep_FullSphere_FromRevSrf_Rotated = rotateSphericalBrepToAvoidCurves(\r\n                            rgBrep0=rgBrep_FullSphere_FromRevSrf,\r\n                            rgCrvs_ToAvoid=rgCrvs_Joined_Otr,\r\n                            rotationCenter=sphere.Center,\r\n                            fTolerance=fTolerance,\r\n                            bDebug=bDebug)\r\n                    if rgBrep_FullSphere_FromRevSrf_Rotated is not None:\r\n                        rgFace_FullSrf = rgBrep_FullSphere_FromRevSrf_Rotated.Faces[0]\r\n                        rgBrep_Split = rgFace_FullSrf.Split(\r\n                                curves=rgCrvs_ForSplit,\r\n                                tolerance=sc.doc.ModelAbsoluteTolerance)\r\n                        if rgBrep_Split is None:\r\n                            print \"Split for non-seam crossing trim surfaces for sphere cannot be obtained!\"\r\n                            sc.doc.Objects.AddBrep(rgBrep_FullSphere_FromRevSrf)\r\n                            rgBrep_FullSphere_FromRevSrf.Dispose()\r\n                            return\r\n                    \r\n                    if rgBrep_Split is None:\r\n                        print \"Non-seam crossing trim surfaces for sphere cannot be obtained!\"\r\n                        sc.doc.Objects.AddBrep(rgBrep_FullSphere_FromRevSrf)\r\n                        rgBrep_FullSphere_FromRevSrf.Dispose()\r\n                        return\r\n                rgBrep_FullSphere_FromRevSrf.Dispose()\r\n        else:\r\n            print \"Skipping this shape:\"\r\n            sEval = 'sShape'; print sEval + ':', eval(sEval)\r\n            return\r\n        \r\n    if rgBrep_Split is None:\r\n        sEval = 'rgBrep_Split'; print sEval + ':', eval(sEval)\r\n        return\r\n    if bDebug:\r\n        print \"Find newly trimmed face:\"\r\n        sEval = 'rgBrep_Split'; print sEval + ':', eval(sEval)\r\n        sEval = 'rgBrep_Split.Faces.Count'; print sEval + ':', eval(sEval)\r\n    \r\n    idx_rgFace_Pos = None\r\n    ptOnFace = getRandomPointOnFace(\r\n            rgBrep=rgBrep_In,\r\n            idxFace=0,\r\n            fDistMin=2.0*sc.doc.ModelAbsoluteTolerance)\r\n    if not ptOnFace:\r\n        ptOnFace = getRandomPointOnFace(\r\n                rgBrep=rgBrep_In,\r\n                idxFace=0,\r\n                fDistMin=1.0*sc.doc.ModelAbsoluteTolerance)\r\n    if ptOnFace:\r\n        #sc.doc.Objects.AddPoint(ptOnFace)\r\n        idx_rgFace_Pos = getFaceAtPoint(\r\n                rgBrep_Split, ptOnFace, bDebug)\r\n    \r\n    if idx_rgFace_Pos is None:\r\n        idx_rgFace_Pos = xBrep_findMatchingFace.usingBoundingBoxOfBrep(\r\n                rgBrep_Split, rgBrep_In)\r\n        if idx_rgFace_Pos is None:\r\n            idx_rgFace_Pos = xBrep_findMatchingFace.usingBoundingBoxOfEdges(\r\n                    rgBrep_Split, rgBrep_In)\r\n            if idx_rgFace_Pos is None:\r\n                return\r\n    \r\n    rgBrep_New1F = rgBrep_Split.Faces[idx_rgFace_Pos].DuplicateFace(False)\r\n    #sc.doc.Objects.AddBrep(rgBrep_New1F); 1/0\r\n    rgBrep_Split.Dispose()\r\n    \r\n    if bDebug: sEval = 'rgBrep_New1F'; print sEval + ':', eval(sEval)\r\n    \r\n    if rgBrep_New1F is None:\r\n        if bDebug: print \"rgBreps3_1F is None.\"\r\n        return\r\n    if not rgBrep_New1F.IsValid:\r\n        if bDebug:\r\n            print \"rgBreps3_1F is invalid.\"\r\n            print rgBrep_New1F.IsValidWithLog()\r\n        rgBrep_New1F.Dispose()\r\n        return\r\n    \r\n    return rgBrep_New1F\r\n\r\n\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "scriptcontext"
  ],
  "has_docstring": true
}