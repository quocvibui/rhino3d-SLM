{
  "source_url": "https://github.com/JonasWard/ClayAdventures/blob/70e453eab058ddb92ad4ee34f3148155e4c1cf31/src/ghPython/PatternBrickLibrary/layerFunctions.py",
  "repo": "JonasWard/ClayAdventures",
  "repo_stars": 3,
  "repo_description": "A width range of different tests and experiments for fdm clay printing",
  "license": "MIT",
  "filepath": "src/ghPython/PatternBrickLibrary/layerFunctions.py",
  "instruction": "layer slicing functions",
  "code": "# layer slicing functions\n\nimport ghpythonlib\nimport Rhino.Geometry as rg\nfrom generalFunctions import *\nimport math\nfrom copy import deepcopy as dc\n\nclass LineSet(object):\n\n    def __init__(self, line, distance, count):\n\n        self.l = line\n        self.d = distance\n        self.c = count\n\n    def createLines(self):\n\n        start_pt, end_pt = self.l.PointAt(0.0), self.l.PointAt(1.0)\n        c_pt = ( start_pt + end_pt ) * .5\n\n        y_vec = rg.Vector3d(end_pt - start_pt)\n        y_vec.Unitize()\n        y_vec = rotObject90Degree(y_vec)\n\n        mv_vec_0 = - y_vec * self.d * (self.c - 1) * .5\n        mv_vec = rg.Vector3d(y_vec * self.d)\n        \n        mv_0 = rg.Transform.Translation(mv_vec_0)\n        mv = rg.Transform.Translation(mv_vec)\n\n        self.lines = []\n\n        tmp_line = dc(self.l)\n        tmp_line.Transform(mv_0)\n\n        self.lines = [dc(tmp_line)]\n\n        for i in range(self.c - 1):\n\n            tmp_line.Transform(mv)\n\n            self.lines.append(dc(tmp_line))\n\n        return self.lines\n\n    def trimLines(self, crv, extend = False):\n\n        crv = polylineTypesToCurve(crv)\n\n        for line in self.lines:\n\n            # line.Domain = rg.Interval(0, 1)\n\n            pts = lineCurveIntersection(line, crv)\n\n            if extend:\n\n                # line.From = line.From\n\n                line.To = pts[0]\n\n            else:\n                \n                line.From = pts[-1]\n\n                # line.To = line.To\n\n        return self.lines\n\n    def joinLines(self, open_link = False):\n\n        # if I am open, that means that two sets will be returned and that the \n        # lines that don't connect will be shortened\n        \n        # pt_set generation\n\n        if (open_link and (len(self.lines) > 3)):\n\n            line_count = len(self.lines)\n\n            lines = dc(self.lines)\n\n            for line_i in range(2, line_count, 1):\n\n                lines[line_i].Extend(- self.d)\n\n        else:\n\n            lines = self.lines\n\n        pt_set = []\n\n        for line_i, line in enumerate(lines):\n\n            if line_i % 2 == 1:\n\n                pt_set.append(line.To)\n                pt_set.append(line.From)\n\n            else:\n\n                pt_set.append(line.From)\n                pt_set.append(line.To)\n\n        pt_set = pt_set[1:-1]\n\n        if open_link:\n\n            return pt_set[:-1], pt_set[-1:]\n\n        else:\n\n            return pt_set[1:-1]\n\n    @ property\n    def Start(self):\n\n        return self.getStartEnd(True)\n\n    @ property\n    def End(self):\n\n        return self.getStartEnd(False)\n\n    def getStartEnd(self, start = True):\n\n        if start:\n\n            return self.lines[0].PointAt(0.0), self.lines[-1].PointAt(0.0)\n\n        else:\n\n            return self.lines[-1].PointAt(1.0), self.lines[0].PointAt(1.0)\n\n    def Transform(self, trans_matrix):\n\n        for l in self.lines:\n\n            l.Transform(trans_matrix)\n\n\nclass PolyCurveSplit(object):\n\n    def __init__(self, crv, intersection_pts):\n\n        self.base_crv = crv\n\n        self.intersectOrganization(intersection_pts)\n\n        self.first_split = False\n        self.second_split = False\n\n    def intersectOrganization(self, pts):\n\n        self.pt_0_a = pts[0][0]\n        self.pt_1_a = pts[0][1]\n\n        self.pt_0_b = pts[1][0]\n        self.pt_1_b = pts[1][1]\n\n    def firstSplit(self, back = True):\n\n        self.first_split = True\n\n        self.back = back\n\n        if self.back:\n            \n            pts = [self.pt_0_a, self.pt_0_b]\n            self.second_set = [self.pt_1_a, self.pt_1_b]\n\n            crvs, _ = layer2ptIntersect(self.base_crv, pts)\n\n        else:\n\n            pts = [self.pt_1_a, self.pt_1_b]\n            self.second_set = [self.pt_0_a, self.pt_0_b]\n\n            crvs, _ = layer2ptIntersect(self.base_crv, pts)\n\n        lengths = [rg.Curve.GetLength(crv) for crv in crvs]\n\n        lengths, crvs = zip(*sorted(zip(lengths, crvs)))\n\n        self.main_crv = crvs[-1]\n\n        return self.main_crv\n\n    def secondSplit(self, reverse = True):\n\n        self.reverse = reverse\n\n        self.second_split = True\n\n        split_ts = [closestPointOnCurve(self.main_crv, pt)[2] for pt in self.second_set]\n\n        result_crvs = [crv for crv in self.main_crv.Split(split_ts)]\n        result_crvs.pop(1)\n\n        if not(self.back) and reverse:\n\n            result_crvs = result_crvs[::-1]\n\n        self.crv_a = result_crvs[0]\n        self.crv_b = result_crvs[1]\n\n        if not(self.back) and not(reverse):\n\n            self.crv_a.Reverse()\n            self.crv_b.Reverse()            \n\n        return result_crvs\n\n    def generatePts(self):\n\n        if self.first_split:\n\n            main_crv = curveToPolyline(self.main_crv)\n            \n            self.main_pts = [pt for pt in main_crv.ToArray()]\n\n        if self.second_split:\n\n            crv_a = curveToPolyline(self.crv_a)\n            crv_b = curveToPolyline(self.crv_b)\n\n            self.pts_a = [pt for pt in crv_a.ToArray()]\n            self.pts_b = [pt for pt in crv_b.ToArray()]\n\n            if self.back:\n\n                self.pts_a.reverse()\n                self.pts_b.reverse()\n\n\nclass LinkingLayers(object):\n\n    def __init__(self, crvs, split_distance, side_bool = True, split_type = \"detached\", split_line = None):\n\n        self.base_crvs = self.crvCheck(crvs)\n\n        self.split_d = split_distance\n        self.side_bool = side_bool\n\n        # to-do find logic to communicate this\n        self.split_type = split_type\n\n        self.splitLineGeneration(split_line)\n\n        if split_type == \"detached\":\n\n            self.reverse_second_split = True\n        \n        elif split_type == \"crossing\":\n\n            self.reverse_second_split = False\n\n\n    def crvCheck(self, crvs):\n\n        new_crvs = []\n        \n        for crv in crvs:\n\n            new_crv = polylineTypesToCurve(crv)\n\n            new_crvs.append(new_crv)\n\n        return new_crvs\n\n\n    def splitLineGeneration(self, split_line = None, angle = None):\n\n        if split_line == None:\n\n            print(\"no line given\")\n\n            self.base_crvs[0].Domain = rg.Interval(0,10)\n\n            pts = [self.base_crvs[0].PointAt(i) for i in range(10)]\n\n            pt_sum = rg.Point3d(0,0,0)\n\n            for pt in pts:\n\n                pt_sum += pt\n\n            pt_sum /= 10\n\n            first_pt = pt_sum\n\n            self.split_line = rg.Line(first_pt, rg.Point3d(0,0,first_pt.Z))\n\n        else:\n\n            print(\"I have given a line\")\n\n            self.split_line = split_line\n\n        self.split_axis = rotObject90Degree(self.split_line, other_angle = angle)\n\n        self.split_a, self.split_b = LineSet(self.split_line, self.split_d, 2).createLines()\n\n\n    def createOrganisedCurves(self):\n\n        self.organised_crvs = []\n\n        pts_output = []\n\n        for crv in self.base_crvs:\n\n            pt_sets = []\n\n            print(type(self.split_a))\n            print(self.split_a.To.Z)\n\n            pts, _ = crvIntersector(crv, self.split_a)\n\n            print(pts)\n\n            pts_a = extremePtsOfAxis(pts, self.split_axis)\n\n            pt_sets.append(pts_a)\n\n            pts_output.extend(pts)\n\n            pts, _ = crvIntersector(crv, self.split_b)\n\n            pts_b = extremePtsOfAxis(pts, self.split_axis)\n\n            pt_sets.append(pts_b)\n\n            pts_output.extend(pts)\n\n            self.organised_crvs.append(PolyCurveSplit(crv, pt_sets))\n\n        # org_crvs = [crv.base_crv for crv in self.organised_crvs]\n\n        main_crvs = []\n        second_sets = []\n        crv_set_a = []\n        crv_set_b = []\n\n        for crv_i, crv in enumerate(self.organised_crvs):\n\n            current_side_bool = bool((crv_i + self.side_bool) % 2)\n\n            print(current_side_bool)\n\n            main_crv = crv.firstSplit(current_side_bool)\n\n            main_crvs.append(main_crv)\n\n        for i in range(1, len(self.organised_crvs), 1):\n\n            second_set = self.organised_crvs[i].secondSplit(self.reverse_second_split)\n\n            crv_set_a.append(second_set[0])\n            crv_set_b.append(second_set[1])\n\n            second_sets.extend(second_set)\n\n        start_crv = main_crvs[0]\n        \n        return pts_output, start_crv, second_sets, crv_set_a, crv_set_b\n\n\n    def joinCrvs(self):\n\n        [crv.generatePts() for crv in self.organised_crvs]\n\n        a_pt_set = []\n        b_pt_set = []\n\n        for crv in self.organised_crvs:\n\n            if crv.second_split:\n\n                b_pt_set.append(crv.pts_a)\n                a_pt_set.append(crv.pts_b)\n\n            else:\n\n                m_pt_set = crv.main_pts\n\n        a_pt_set.reverse()\n        m_pt_set.reverse()\n\n        total_pt_set = []\n\n        for pt_set in a_pt_set:\n\n            total_pt_set.extend(pt_set)\n\n        total_pt_set += m_pt_set\n\n        for pt_set in b_pt_set:\n\n            total_pt_set.extend(pt_set)\n\n        return total_pt_set",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}