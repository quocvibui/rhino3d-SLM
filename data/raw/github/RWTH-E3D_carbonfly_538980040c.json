{
  "source_url": "https://github.com/RWTH-E3D/carbonfly/blob/1b1001000e4cc0277af5eb359b9172a24b53acfd/carbonfly/mesh.py",
  "repo": "RWTH-E3D/carbonfly",
  "repo_stars": 19,
  "repo_description": "An easy-to-use Python library and Grasshopper toolbox for indoor CO2 CFD simulation",
  "license": "LGPL-3.0",
  "filepath": "carbonfly/mesh.py",
  "instruction": "Mesh utilities for Rhino-based OpenFOAM workflows.",
  "code": "\"\"\"\nMesh utilities for Rhino-based OpenFOAM workflows.\n\nThis module provides helper functions to convert Rhino geometries into\ntriangle meshes and export them in formats suitable for OpenFOAM.\n\n.. note::\n   This module depends on the RhinoCommon API and can only be used\n   inside Rhino / Grasshopper. The ``Rhino`` module is provided by Rhino.\n\"\"\"\n\nfrom __future__ import annotations\n\n# carbonfly/mesh.py\ntry:\n    import Rhino\nexcept ImportError:\n    Rhino = None\n\nfrom typing import Iterable, Tuple, List\n\n\ndef _require_rhino() -> None:\n    \"\"\"Raise a clear error if RhinoCommon is not available.\"\"\"\n    if Rhino is None:\n        raise RuntimeError(\"Rhino is required for geometry operations.\")\n\n\ndef brep_to_mesh(brep: Rhino.Geometry.Brep) -> Rhino.Geometry.Mesh:\n    \"\"\"\n    Convert a Rhino Brep into a single unified Mesh.\n\n    Args:\n        brep (Rhino.Geometry.Brep): Input Brep geometry.\n\n    Returns:\n        Rhino.Geometry.Mesh: A unified, triangulated mesh, or None if meshing failed.\n    \"\"\"\n    _require_rhino()\n    mp = Rhino.Geometry.MeshingParameters.Default\n    lst = Rhino.Geometry.Mesh.CreateFromBrep(brep, mp)\n    if not lst:\n        return None\n    m = Rhino.Geometry.Mesh()\n    for x in lst:\n        m.Append(x)\n    m.UnifyNormals()\n    m.Compact()\n    if m.Faces.QuadCount > 0:\n        m.Faces.ConvertQuadsToTriangles()\n    m.Normals.ComputeNormals()\n\n    return m\n\n\ndef mesh_triangles(mesh):\n    \"\"\"\n    Iterate over all triangular faces of a Rhino Mesh and yield triangle vertices + normals.\n    If a face is a quad, it will be triangulated using MeshFace.Triangulate().\n\n    Args:\n        mesh (Rhino.Geometry.Mesh): Input mesh (ideally triangulated).\n\n    Yields:\n        tuple: ((ax,ay,az), (bx,by,bz), (cx,cy,cz), (nx,ny,nz))\n               where (a,b,c) are vertex coordinates and (n) is the face normal.\n    \"\"\"\n    _require_rhino()\n    V, F = mesh.Vertices, mesh.Faces\n    for i in range(F.Count):\n        f = F[i]\n        tris = [(f.A, f.B, f.C)] if f.IsTriangle else list(f.Triangulate())\n        for a, b, c in tris:\n            pa, pb, pc = V[a], V[b], V[c]\n            v1 = Rhino.Geometry.Vector3f(pb.X - pa.X, pb.Y - pa.Y, pb.Z - pa.Z)\n            v2 = Rhino.Geometry.Vector3f(pc.X - pa.X, pc.Y - pa.Y, pc.Z - pa.Z)\n            n = Rhino.Geometry.Vector3f.CrossProduct(v1, v2)\n            if n.Length > 1e-20:\n                n.Unitize()\n            yield (\n                (pa.X, pa.Y, pa.Z),\n                (pb.X, pb.Y, pb.Z),\n                (pc.X, pc.Y, pc.Z),\n                (n.X, n.Y, n.Z),\n            )\n\n\ndef _scale_factor(unit: str) -> float:\n    \"\"\"\n    Return scale factor converting input geometry units to meters.\n\n    Args:\n        unit: Unit label. Supported: \"mm\", \"cm\", \"m\".\n\n    Returns:\n        Scale factor to convert coordinates to meters.\n\n    Raises:\n        ValueError: If unit is not one of \"mm\", \"cm\", \"m\".\n    \"\"\"\n    u = (unit or \"mm\").lower()\n    if u == \"mm\":\n        return 1e-3\n    if u == \"cm\":\n        return 1e-2\n    if u == \"m\":\n        return 1.0\n    raise ValueError(\"unit must be 'mm'|'cm'|'m'\")\n\n\ndef write_multi_solid_ascii_stl(\n    out_path, named_meshes: Iterable[Tuple[str, Rhino.Geometry.Mesh]], unit: str\n):\n    \"\"\"\n    Write a multi-solid ASCII STL file.\n\n    Each entry in `named_meshes` becomes one `solid <name> ... endsolid <name>`\n    block. Geometry is scaled to meters using `unit`.\n\n    Args:\n        out_path: Output path (Path or str).\n        named_meshes: Iterable of (name, mesh) pairs.\n        unit: Unit label for input meshes (\"mm\" | \"cm\" | \"m\").\n\n    Returns:\n        Path to the written STL file.\n    \"\"\"\n    from pathlib import Path\n\n    sf = _scale_factor(unit)\n    lines: List[str] = []\n    for nm, mesh in named_meshes:\n        name = str(nm).replace(\" \", \"_\")\n        lines.append(f\"solid {name}\")\n        for (ax, ay, az), (bx, by, bz), (cx, cy, cz), (nx, ny, nz) in mesh_triangles(\n            mesh\n        ):\n            lines.append(f\"  facet normal {nx:.6e} {ny:.6e} {nz:.6e}\")\n            lines.append(\"    outer loop\")\n            lines.append(f\"      vertex {ax*sf:.6e} {ay*sf:.6e} {az*sf:.6e}\")\n            lines.append(f\"      vertex {bx*sf:.6e} {by*sf:.6e} {bz*sf:.6e}\")\n            lines.append(f\"      vertex {cx*sf:.6e} {cy*sf:.6e} {cz*sf:.6e}\")\n            lines.append(\"    endloop\")\n            lines.append(\"  endfacet\")\n        lines.append(f\"endsolid {name}\")\n    out_path = Path(out_path)\n    out_path.parent.mkdir(parents=True, exist_ok=True)\n    out_path.write_text(\"\\n\".join(lines) + \"\\n\", encoding=\"utf-8\")\n    return out_path\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}