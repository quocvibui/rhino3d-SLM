{
  "source_url": "https://github.com/ladybug-tools/butterfly-plus/blob/51bab2dc7462b5ceacb655e96fb852bb52464444/plugin/grasshopper/src/Butterfly_Plot%20Residuals.py",
  "repo": "ladybug-tools/butterfly-plus",
  "repo_stars": 13,
  "repo_description": "Butterfly[+] plugins...",
  "license": "GPL-3.0",
  "filepath": "plugin/grasshopper/src/Butterfly_Plot Residuals.py",
  "instruction": "Load residual values for a case.",
  "code": "# Butterfly: A Plugin for CFD Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# This file is part of Butterfly.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\"\"\"\nLoad residual values for a case.\n\n-\n\n    Args:\n        _recipe: A Butterfly recipe.\n        _rect: A rectangle for boundary chart.\n        _fields_: Residual fields. If empty solution's fields will be used.\n        _target_res_: Residential number that will be added to the graph as a black line.\n            (default: 1e-4).\n        time_range_: Time range for loading residuals as a domain.\n        method_: Method of ploting the values (0..1). 0: Curves, 1: Colored mesh\n            If you're updating the values frequently use method 1 which is the\n            quicker method.\n        _load: Set to True to plot the chart.\n    Returns:\n        report: Reports, erros, warnings, etc.\n        time_range: Total time range.\n        curves: Lines as curves.\n        meshes: Lines as meshes.\n        residual_line: Residual line.\n        colors: List of colors for meshes to color text, etc.\n\"\"\"\n\nghenv.Component.Name = \"Butterfly_Plot Residuals\"\nghenv.Component.NickName = \"plotResiduals\"\nghenv.Component.Message = 'VER 0.0.05\\nJAN_12_2019'\nghenv.Component.Category = \"Butterfly\"\nghenv.Component.SubCategory = \"07::PostProcess\"\nghenv.Component.AdditionalHelpFromDocStrings = \"1\"\n\nimport Rhino as rc\nimport scriptcontext as sc\nfrom System.Drawing import Color\n\ndef rectFromBoundingBox(bbox):\n    p = rc.Geometry.Plane(bbox.Min, rc.Geometry.Vector3d.ZAxis)\n    return rc.Geometry.Rectangle3d(p, bbox.Min, bbox.Max)\n\ndef rectToRectMapping(geometries, sourceRect, targetRect):\n    \n    def compoundTransform(geometry, transforms):\n        for t in transforms:\n            geometry.Transform(t)\n        return geometry\n    \n    # create a plane in the corner or each rect\n    sp = rc.Geometry.Plane(sourceRect.Corner(0), sourceRect.Plane.Normal)\n    tp = rc.Geometry.Plane(targetRect.Corner(0), targetRect.Plane.Normal)\n    \n    translate0 = rc.Geometry.Transform.Scale(sp,\n                                             targetRect.Width / sourceRect.Width,\n                                             targetRect.Height / sourceRect.Height,\n                                             1)\n    translate1 = rc.Geometry.Transform.PlaneToPlane(sp, tp)\n    \n    return tuple(compoundTransform(g, (translate0, translate1)) for g in geometries)\n\n\ndef coloredMeshFromCurve(curves, width=10, colors=None):\n    def curveToMesh(curve, color):\n        oc = curve.Offset(rc.Geometry.Plane.WorldXY, width,\n                                      sc.doc.ModelAbsoluteTolerance,\n                                      rc.Geometry.CurveOffsetCornerStyle.Sharp)[0]\n        \n        srf = rc.Geometry.Brep.CreateFromLoft((curve, oc), rc.Geometry.Point3d.Unset,\n            rc.Geometry.Point3d.Unset, rc.Geometry.LoftType.Normal, False)[0]\n        \n        mesh = rc.Geometry.Mesh.CreateFromBrep(srf, rc.Geometry.MeshingParameters.Coarse)[0]\n        mesh.VertexColors.CreateMonotoneMesh(color)\n        return mesh\n        \n    meshes = tuple(curveToMesh(curve, color) for curve, color in zip(curves, colors))\n    \n    return meshes\n\ntry:\n    from butterfly.parser import ResidualParser\nexcept ImportError as e:\n    msg = '\\nFailed to import butterfly:'\n    raise ImportError('{}\\n{}'.format(msg, e))\n\ndef main():\n    \n    assert hasattr(_solution, 'residual_file'), \\\n        '{} is not a valid Solution.'.format(_solution)\n    \n    p = ResidualParser(_solution.residual_file)\n    \n    if not _fields_:\n        try:\n            fields = _solution.residual_fields\n        except:\n            raise ValueError('Failed to load fields from solution {}.'.format(_solution))\n    else:\n        fields = _fields_\n    \n    for f in fields:\n        print f\n    \n    time_range = '{} To {}'.format(*p.time_range)\n    \n    # calculate curves\n    crvs = tuple(rc.Geometry.PolylineCurve(rc.Geometry.Point3d(c, float(i), 0)\n        for c, i in enumerate(p.get_residuals(field, time_range_)))\n        for field in fields)\n        \n    # find bounding box for curves\n    bbox = crvs[0].GetBoundingBox(True)\n    \n    for crv in crvs[1:]:\n        bbox = rc.Geometry.BoundingBox.Union(bbox, crv.GetBoundingBox(True))\n    \n    # create residual line\n    startPt = rc.Geometry.Point3d(0, _target_res_, 0)\n    length = bbox.Max[0] - bbox.Min[0]\n    resLine = rc.Geometry.Line(startPt, rc.Geometry.Vector3d(length, 0, 0)).ToNurbsCurve()\n    bbox = rc.Geometry.BoundingBox.Union(bbox, resLine.GetBoundingBox(True))\n\n    # scale curves\n    curves = rectToRectMapping(crvs, rectFromBoundingBox(bbox),\n                      rectFromBoundingBox(_rect.GetBoundingBox(True)))\n    \n    resLine = rectToRectMapping((resLine,), rectFromBoundingBox(bbox),\n                                       rectFromBoundingBox(_rect.GetBoundingBox(True)))\n    \n    # create colored meshes\n    cs3 = ((102,194,165), (252,141,98), (141,160,203), (231,138,195),\n       (166,216,84), (255,217,47), (229,196,148))\n    colors = tuple(Color.FromArgb(*rgb) for rgb in cs3)\n\n    if method_ % 2:\n        residual_line = coloredMeshFromCurve(resLine, width=_lineWidth_,\n                                             colors=[Color.Black])\n        \n        meshes = coloredMeshFromCurve(curves,  width=_lineWidth_,\n                                              colors= colors)\n        \n        return time_range, curves, meshes, residual_line, colors[:len(curves)]\n    \n    return time_range, curves, [], resLine, colors[:len(curves)]\n\nif _solution and _rect and _load:\n    try:\n        output = main()\n    except ZeroDivisionError:\n        raise Exception(\n            'Failed to load residual fields. '\n            'Read the warnings above for more details.'\n        )\n        \n    if output:\n        time_range, curves, meshes, residual_line, colors = output\n\nif method_ % 2:\n    ghenv.Component.Params.Output[3].Name = 'meshes'\n    ghenv.Component.Params.Output[3].NickName = 'meshes'\n    ghenv.Component.Params.Input[4].Name = '_lineWidth_'\n    ghenv.Component.Params.Input[4].NickName = '_lineWidth_'\nelse:\n    ghenv.Component.Params.Output[3].Name = '.'\n    ghenv.Component.Params.Output[3].NickName = '.'\n    ghenv.Component.Params.Input[4].Name = '.'\n    ghenv.Component.Params.Input[4].NickName = '.'\n    \n",
  "language": "python",
  "imports": [
    "Rhino",
    "scriptcontext"
  ],
  "has_docstring": true
}