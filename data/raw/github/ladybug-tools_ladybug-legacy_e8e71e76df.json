{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_Mesh%20Threshold%20Selector.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_Mesh Threshold Selector.py",
  "instruction": "Use this component to select out the part of a colored mesh that meets a certain conditional statement.  This has multiple uses: The generation of a custom shade from a shade benefit analysis,...",
  "code": "# This component makes a simple string for legend parameters\n#\n# Ladybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Ladybug.\n# \n# Copyright (c) 2013-2020, Chris Mackey <Chris@MackeyArchitecture.com> \n# Ladybug is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Ladybug is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to select out the part of a colored mesh that meets a certain conditional statement.  This has multiple uses: The generation of a custom shade from a shade benefit analysis, Quantifying the daylight area from a daylight analysis, Selecting out the portion of a roof with enough solar radiation for PV panels, and much more.\n\n-\nProvided by Ladybug 0.0.69\n    \n    Args:\n        _inputMesh: The mesh for which you would like to highlight the portion that meets a threshold.\n        _analysisResult: A numerical data set whose length corresponds to the number of faces in the _inputMesh.\n        _operator_: A text string representing an operator for the the conditional statement.  The default is set to be greater than (>).  This must be an operator in python and examples include:\n            > - Greater Than\n            < - Less Than\n            >= - Greater or Equal\n            <= - Less or Equal\n            == - Equals\n        percentToKeep_: A number between 0 and 100 that represents the percentage of the mesh faces that you would like to include in the resulting newColoredMesh.  By default, this is set to 25%.\n        levelOfPerform_: An optional number that represents the threshold above which a given mesh face is included in the newColoredMesh.  An input here will override the percent input above.\n    Returns:\n        readMe!: ...\n        totalValue: The sum of all of the values that meet the criteria multiplied by the mesh face area.  For example, if the _inputMesh is a radiation study mesh, this is equal to the total radiation falling on the newColoredMesh.  For an energy shade benefit mesh, this is the total energy saved by a shade of this size.\n        areaMeetsThresh: The area of the newColoredMesh in Rhino model units.\n        newColoredMesh: A new colored mesh with the vlues below the threshold deleted out of it.\n        newMeshOutline: A set of curves outlining the portion of the mesh that is above the threshold.\n\"\"\"\n\nghenv.Component.Name = \"Ladybug_Mesh Threshold Selector\"\nghenv.Component.NickName = 'MeshSelector'\nghenv.Component.Message = 'VER 0.0.69\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"LB-Legacy\"\nghenv.Component.SubCategory = \"5 | Extra\"\n#compatibleLBVersion = VER 0.0.59\\nFEB_01_2015\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"5\"\nexcept: pass\n\n\nimport Rhino as rc\nimport scriptcontext as sc\nimport Grasshopper.Kernel as gh\n\n\n\ndef checkTheInputs():\n    #Check to make sure that the number of shade mesh faces matches the length of the shade New Effect.\n    checkData1 = True\n    if _inputMesh.Faces.Count != len(_analysisResult) and _inputMesh.Vertices.Count != len(_analysisResult):\n        checkData1 = False\n        print \"The number of faces in the _inputMesh does not equal the number of values in the _analysisResult.  Are you sure that you connected a mesh that matches your input data?\"\n        ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, \"The number of faces in the _inputMesh does not equal the number of values in the _analysisResult.  Are you sure that you connected a mesh that matches your input data?\")\n    \n    #Check to see if the user has hooked up a percent to keep and, if not, set it to 50%.\n    if percentToKeep_ == None:\n        percent = 0.25\n        checkData2 = True\n    else:\n        if percentToKeep_ <= 100 and percentToKeep_ >= 0:\n            checkData2 = True\n            percent = percentToKeep_/100\n        else:\n            checkData2 = False\n            percent = None\n            print \"The percentToKeep_ must be a valude between 0 and 100.\"\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, \"The percentToKeep_ must be a valude between 0 and 100.\")\n    \n    # Check the operator.\n    if _operator_ == None:\n        operator = \">\"\n    else:\n        operator = _operator_\n        if levelOfPerform_ == None and operator == \"==\":\n            warning = \"The equality operator cannot be used with the percentToKeep_ method. \\n Operatorhas been changed to be greater than.\"\n            print warning\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\n    \n    #If eveything is good, return a result that says this.\n    checkData = False\n    if checkData1 == True and checkData2 == True: checkData = True\n    \n    return checkData, percent, operator\n\n\ndef main(percent, operator):\n    #Make a list to keep track of all of the faces in the test mesh.\n    faceNumbers = range(len(_analysisResult))\n    \n    #Sort the list of net effect along with the face numbers list and reverse it so the most valuable cells are at the top.\n    faceNumbersSort = [x for (y,x) in sorted(zip(_analysisResult, faceNumbers))]\n    _analysisResult.sort()\n    if \">\" in operator or operator == \"==\":\n        faceNumbersSort.reverse()\n        _analysisResult.reverse()\n    \n    #Remove the faces numbers that are harmful.\n    faceNumbersHarm = []\n    faceNumbersKept = []\n    \n    # Take the specified percent of the helpful cells.\n    shadeNetFinal = []\n    if levelOfPerform_ == None:\n        numToTake  = percent*(len(_analysisResult))\n        for count, num in enumerate(_analysisResult):\n            if count < numToTake:\n                shadeNetFinal.append(num)\n                faceNumbersKept.append(faceNumbersSort[count])\n            else:\n                faceNumbersHarm.append(faceNumbersSort[count])\n    else:\n        for count, num in enumerate(_analysisResult):\n            if eval(str(num) + operator + str(levelOfPerform_)):\n                shadeNetFinal.append(num)\n                faceNumbersKept.append(faceNumbersSort[count])\n            else:\n                faceNumbersHarm.append(faceNumbersSort[count])\n    \n    # Check to see if no values meet the conditional statement.\n    if len(shadeNetFinal) == 0:\n        warning = \"No values meet the conditional statement.\"\n        print warning\n    \n    #Remove the unnecessary cells from the shade mesh.\n    newMesh = _inputMesh\n    areaList = []\n    if _inputMesh.Faces.Count == len(_analysisResult):\n        for fnum in faceNumbersKept:\n            face = newMesh.Faces[fnum]\n            if face.IsQuad:\n                srfBrep = rc.Geometry.Brep.CreateFromCornerPoints(rc.Geometry.Point3d(newMesh.Vertices[face.A]), rc.Geometry.Point3d(newMesh.Vertices[face.B]), rc.Geometry.Point3d(newMesh.Vertices[face.C]), rc.Geometry.Point3d(newMesh.Vertices[face.D]), sc.doc.ModelAbsoluteTolerance)\n            else:\n                srfBrep = rc.Geometry.Brep.CreateFromCornerPoints(rc.Geometry.Point3d(newMesh.Vertices[face.A]), rc.Geometry.Point3d(newMesh.Vertices[face.B]), rc.Geometry.Point3d(newMesh.Vertices[face.C]), sc.doc.ModelAbsoluteTolerance)\n            if type(srfBrep) != rc.Geometry.Brep:\n                pass\n            else:\n                areaList.append(rc.Geometry.AreaMassProperties.Compute(srfBrep).Area)\n        # Delete unwanted faces.\n        newMesh.Faces.DeleteFaces(faceNumbersHarm)\n    else:\n        newMesh.Vertices.Remove(faceNumbersHarm, True)\n    \n    #Try to simplify the brep.\n    try:\n        edgeCrv = newMesh.GetNakedEdges()\n        joinedCrv = rc.Geometry.Curve.JoinCurves(edgeCrv, sc.doc.ModelAbsoluteTolerance)\n    except:\n        try:\n            edgeCrv = newMesh.GetNakedEdges()\n            nurbsCrvs = []\n            for curve in edgeCrv:\n                nurbsCrvs.append(curve.ToNurbsCurve())\n            joinedCrv = rc.Geometry.Curve.JoinCurves(nurbsCrvs, sc.doc.ModelAbsoluteTolerance)\n        except:\n            joinedCrv = None\n    \n    #Calculate the total area and the energy saved by the new mesh.\n    if _inputMesh.Faces.Count == len(_analysisResult):\n        totalArea = sum(areaList)\n        totalEnergyList = []\n        for count, area in enumerate(areaList):\n            totalEnergyList.append(shadeNetFinal[count]*area)\n        totalEnergy = sum(totalEnergyList)\n    else:\n        totalArea = rc.Geometry.AreaMassProperties.Compute(newMesh).Area\n        if totalArea>0:\n            totalEnergy = (sum(shadeNetFinal)/len(shadeNetFinal))*totalArea\n        else:\n            totalEnergy=0\n    \n    return totalEnergy, totalArea, newMesh, joinedCrv\n\n\ncheckData = False\nif _inputMesh != None and _analysisResult != [] and _analysisResult != [None]:\n    checkData, percent, operator = checkTheInputs()\n\nif checkData == True and _inputMesh and _analysisResult != []:\n    totalValue, areaMeetsThresh, newColoredMesh, newMeshOutline = main(percent, operator)\nghenv.Component.Params.Output[3].Hidden = True",
  "language": "python",
  "imports": [
    "Rhino",
    "scriptcontext"
  ],
  "has_docstring": true
}