{
  "source_url": "https://github.com/ladybug-tools/honeybee-legacy/blob/bd62af4862fe022801fb87dbc8794fdf1dff73a9/src/Honeybee_Generator_PV.py",
  "repo": "ladybug-tools/honeybee-legacy",
  "repo_stars": 129,
  "repo_description": ":bee: Honeybee is a free and open source plugin to connect Grasshopper3D to EnergyPlus, Radiance, Daysim and OpenStudio for building energy and daylighting simulation",
  "license": "NOASSERTION",
  "filepath": "src/Honeybee_Generator_PV.py",
  "instruction": "Provided by Honeybee 0.0.66",
  "code": "#\n# Honeybee: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Honeybee.\n# \n# Copyright (c) 2013-2020, Anton Szilasi <ajszilas@gmail.com> \n# Honeybee is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Honeybee is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Honeybee; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\n\"\"\"\nProvided by Honeybee 0.0.66\n\nUse this component to add Energy Plus Photovoltaic generators to a Honeybee Surface. Each surface can only have one Photovoltaic generator. While each PV generator is made up of one or several PV modules. \n-\nAt present only Photovoltaic generators with Simple Photovoltaic performance objects are supported.\n-\nFor each Photovoltaic generator there must be a inverter for power to be produced, if several photovoltaic generators are modelled in the same generatorsystem (Connected to the generationsystem component) these generators must have the same inverter.\n\nFor more information about Photovolatic generators please see: \n-\nhttp://bigladdersoftware.com/epx/docs/8-2/input-output-reference/group-electric-load-center.html#photovoltaic-generators\n\n-\nProvided by Honeybee 0.0.66\n\n    Args:\n        _HBSurfaces: A Honeybee/context surface or a list of Honeybee/context surfaces to which one Photovolatic generator will be mounted on each surface.\n        _name_: An optional input, a name or a list of names of PV generators which correspond sequentially to the Honeybee surfaces in _HBSurfaces. Without this input PV generators will be assigned default names.\n        _SASolarCells: A float or a list of floats that sequentially correspond to what percentage of each Honeybee surface in  _HBSurfaces are covered with Photovoltaics.  e.g the first float corresponds to the first Honeybee surface. If only one float is given this value will be used for all other PV generators.\n        _cellsEfficiency: A float or a list of floats that sequentially detail the efficiency of the Photovoltaic generator cells on each Honeybee surface in _HBSurfaces as a fraction. e.g the first float corresponds to the first Honeybee surface. If only one float is given this value will be used for all other PV generators.\n        _NoParallel: A integer or a list of integers that sequentially correspond to each Honeybee surface in _HBSurfaces. These integers define the series-wired strings of PV modules that are in parallel to form the PV generator on each Honeybee surface. The product of this field and the next field will equal the total number of modules in the PV generator on each Honeybee surface. If only one integer is given this value will be used for all other PV generators.\n        _Noseries: A integer or a list of integers that sequentially correspond to each Honeybee surface in _HBSurfaces.  These integers define the number of modules wired in series (on each string) to form the PV generator on each Honeybee surface in _HBSurfaces. The product of this field and the previous field will equal the total number of modules in the PV generator on each Honeybee surface. If only one integer is given this value will be used for all other PV generators.\n        costPVgen_: A float or a list of floats that sequentially correspond to each Honeybee surface in _HBSurfaces. The float is the cost of each PV module in US dollars (Other currencies will be available in the future). The cost of the PV generator will be the cost of the module multiplied by the number of modules in parallel and series (number of modules as a generator is made up of modules). If only one float is given this value will be used for all other PV generators. Default is set to $0.\n        _powerOutput: A float or a list of floats that sequentially correspond to each Honeybee surface in _HBSurfaces. The float is the power output of each PV module in watts. The power output of the PV generator will be the power output of the module multiplied by the number of modules in parallel and series (number of modules as a generator is made up of modules). If only one float is given this value will be used for all other PV generators.\n        _PVInverter: The inverter servicing all the PV generators in this component - to assign an inverter connect the HB_inverter here from the Honeybee inverter component\n        sandiaMode_: Input just ONE Sandria data set as a panel here. Examples can be seen in C:\\EnergyPlusV8-4-0\\MacroDataSet\\SandiaPVdata\n            \n    Returns:\n        PV_HBSurfaces: The Honeybee/context surfaces that have been modified by this component - these surfaces now contain PV generators to run in an EnergyPlus simulation. To do so you need to add them to a Honeybee generation system first - connect them to the PV_HBSurfaces input of a Honeybee_generationsystem component.\n        \n\"\"\"\n\nghenv.Component.Name = \"Honeybee_Generator_PV\"\nghenv.Component.NickName = 'PVgen'\nghenv.Component.Message = 'VER 0.0.66\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"HB-Legacy\"\nghenv.Component.SubCategory = \"09 | Energy | HVACSystems\"\n#compatibleHBVersion = VER 0.0.56\\nNOV_04_2016\n#compatibleLBVersion = VER 0.0.59\\nFEB_01_2015\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"0\"\nexcept: pass\n\nimport scriptcontext as sc\nimport uuid\nimport Grasshopper.Kernel as gh\nimport itertools\nimport Grasshopper\nimport collections\nimport re\nimport Rhino\n\nhb_hive = sc.sticky[\"honeybee_Hive\"]() # Creating an instance of hb_hive here\nPV_gen = sc.sticky[\"PVgen\"] # Linked to class PV_gen in honeybee honeybee \nhb_hivegen = sc.sticky[\"honeybee_generationHive\"]() # Creating an instance of the hb_hivegen here \n\nreadmedatatree = Grasshopper.DataTree[object]()\n\ndef checktheinputs(_name_,_HBSurfaces,_cellsEfficiency,_NoParallel,_Noseries):\n\n    \"\"\"This function checks all the inputs of the component to ensure that the component is stopped if there is anything wrong with the inputs ie the \n    inputs will produce serious errors in the execution of this component.\n        \n        Args:\n            The arguements seen in the function definition are the same as the arguements on the panel.\n            \n        Returns:\n            If there are any issues with the inputs this function will return -1 and the component will stop\"\"\"\n          \n    # Check if the Honeybee hive is on the sticky\n    \n    if not sc.sticky.has_key(\"honeybee_release\") or not sc.sticky.has_key(\"honeybee_ScheduleLib\"):\n        print \"You should first let the Honeybee fly...\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, \"You should first let the Honeybee fly...\")\n\n        return -1\n\n    try:\n        if not sc.sticky['honeybee_release'].isCompatible(ghenv.Component): return -1\n        if sc.sticky['honeybee_release'].isInputMissing(ghenv.Component): return -1\n    except:\n        \n        warning = \"You need a newer version of Honeybee to use this compoent.\" + \\\n        \"Use updateHoneybee component to update userObjects.\\n\" + \\\n        \"If you have already updated userObjects drag Honeybee_Honeybee component \" + \\\n        \"into canvas and try again.\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n        return -1  \n\n    # Simple check for sandia to be expanded upon\n        \n    # Check that Honeybee Zones are connected\n   \n    if (_PVInverter == []) or (_PVInverter == None):\n        \n        print \" Please connect an inverter to _PVInverter\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, \"Please connect an inverter to _PVInverter\")\n        return -1\n        \n    if len(_PVInverter) != 1:\n        \n        print \" There can only be one inverter for each PV generator please connect only one inverter!\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, \"There can only be one inverter for each PV generator please connect only one inverter!\")\n        return -1\n        \n    \n    if (_HBSurfaces == []) or (_HBSurfaces[0] == None) :\n        print \"PV generators must be mounted on at least one Honeybee surface or context surface please connect a Honeybee surface to _HBSurfaces!\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, \"PV generators must be mounted on at least one Honeybee surface or context surface please connect a Honeybee surface to _HBSurfaces!\")\n        return -1\n       \n    if (_cellsEfficiency == []) or (_cellsEfficiency[0]) == None:\n        print \"_cellsEfficiency must contain one or a number of decimal floats!\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, \"_cellsEfficiency must contain one or a number of decimal floats!\")\n        return -1\n        \n        \n    for cell_n in _cellsEfficiency:\n            \n        if (cell_n >1) or (cell_n < 0):\n            \n            print \"All values of _cellsEfficiency must be between 1 and zero as it is a efficiency!\"\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, \"All values of _cellsEfficiency must be between 1 and zero as it is a efficiency!\")\n            return -1\n            \n    for PVgencount in range(len(_HBSurfaces)):\n        \n        try:\n            _HBSurfaces[PVgencount]\n        except IndexError:\n            warnMsg= \"Every PV generator must have a corresponding surface connected through the field _HBSurfaces! \"\n            print warnMsg\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, warnMsg)\n            return -1 \n    \n    if (_powerOutputPerModule == []) or (_powerOutputPerModule[0]) == None:\n        print \"The power output of the module/s must be specified!\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, \"The power output of the module must be specified!\")\n        return -1\n        \n        \ndef returnmodename(mode):\n    \"\"\" This function converts _integrationMode from an int on the panel to a string for the Generator:Photovoltaic Heat Transfer integration mode\n    so it is an enum function.\n    \"\"\"\n    if mode == 1:\n        return \"Decoupled\"\n    if mode ==2:\n        return \"DecoupledUllebergDynamic\"\n    if mode ==3:\n        return \"IntegratedSurfaceOutsideFace\"\n    if mode==4:\n        return \"IntegratedTranspiredCollector\"\n    if mode==5:\n        return \"IntegratedExteriorVentedCavity\"\n    if mode==6:\n        return \"PhotovoltaicThermalSolarCollector\"\n\n\ndef main(_name_,_HBSurfaces,_cellsEfficiency,_NoParallel,_Noseries,_powerOutput,PVinverter):\n \n    \"\"\" This function is the heart of this component it takes all the component arguments and writes one PV generator onto each Honeybee surface connected to this component\n \n     Args:\n            The arguements seen in the function definition are the same as the arguements on the panel.\n                \n        Returns:\n            The properties of the PV generators connected to this component these properties are then written to an IDF file in Honeybee_ Run Energy Simulation component.\n    \"\"\"\n    \n    HBSurfacesfromhive = hb_hive.callFromHoneybeeHive(_HBSurfaces) # Call Honeybee surfaces from hive\n    \n    PVgencount = 0\n    \n    # CHECK that the same surfaces are not having PV generators added to them twice. If they are stop the component.\n    \n    class myDict(dict):\n\n        def __init__(self):\n            self = dict()\n    \n        def add(self, key, value):\n            self[key] = value\n    \n    HBsurfaces = myDict()\n    \n    for HBsurface in HBSurfacesfromhive:\n        \n        # In order of Honeybee surface, Honeybee surface ID and Brep which corresponds to that Honeybee surface\n        \n        HBsurfaces.add(HBsurface,HBsurface.ID)\n        \n    if len(HBsurfaces.values()) != len(set(HBsurfaces.values())):\n        \n        # Identify duplicateIDs\n        \n        duplicateIDs = collections.Counter([item for item in HBsurfaces.values()]).keys()\n        \n        surfaceCount = 0\n        \n        for surface,surfaceID in HBsurfaces.items():\n            \n            if surfaceID in duplicateIDs:\n                \n                warn = \"Into the input _HBSurfaces you have input the same surface \" + HBsurface.name + \" twice. Use Geometry preview to make sure \\n\"+\\\n                \"that the same surfaces are not being input several times. This component will not run until this is fixed.\"\n                \n                ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Error, warn)\n                \n                # Draw a preview of the geometry so the user can identify it.\n                \n                preview = Grasshopper.Kernel.GH_PreviewUtil()\n                \n                preview.AddBrep(_HBSurfaces[surfaceCount])\n                \n                surfaceCount =+ 1\n                \n                return\n\n    try:\n        i = 0\n        for name,surface in itertools.izip_longest(_name_,HBSurfacesfromhive): \n            # get corresponding properties.\n            celleff = _cellsEfficiency[0] if len(_cellsEfficiency) == 1 else _cellsEfficiency[i]\n            parallel = _NoParallel[0] if len(_NoParallel) == 1 else _NoParallel[i]\n            series = _Noseries[0] if len(_Noseries) == 1 else _Noseries[i]\n            powerout = _powerOutputPerModule[0] if len(_powerOutputPerModule) == 1 else _powerOutputPerModule[i]\n            if len(costPVgen_) == 0:\n                costPVgen = 0\n            else:\n                costPVgen = costPVgen_[0] if len(costPVgen_) == 1 else costPVgen_[i]\n            i += 1\n            \n            surface.containsPVgen = True # Set this it true so the surface can be identified in run and write IDF component\n            \n            surface.PVgenlist = [] # Set the PVgenlist of each surface back to empty otherwise PVgen objects will accumulate on each run\n            \n            \n            namePVperform = \"PVperformance\" + str(PVgencount)+ \" \" + str(surface.name) # Create a name for the PVperformance object for each PV generator - this is always created by automatically here not by the user\n    \n            # Raise some warnings for the following circumstances \n            \n            centerPt, normalVector = surface.getSrfCenPtandNormalAlternate()\n            \n            if normalVector[2] == -1:\n                \n                w = gh.GH_RuntimeMessageLevel.Warning\n                \n                warn = \"Are you sure that you want to mount PV generators on \" + str(surface.name) +\" \\n\"+\\\n                \"the surface normal of this surface is facing down!\"\n                \n                ghenv.Component.AddRuntimeMessage(w, warn)\n                \n            if surface.type == 2.5:\n                \n                w = gh.GH_RuntimeMessageLevel.Warning\n                \n                warn = str(surface.name) +\" is a on-ground slab you probably don't want to mount PV panels on it \\n\"+\\\n                \"but we will go ahead and do it anyway.\"\n                \n                ghenv.Component.AddRuntimeMessage(w, warn)\n    \n            if surface.type == 2.25:\n                \n                w = gh.GH_RuntimeMessageLevel.Warning\n                \n                warn = str(surface.name) +\" is a underground slab you probably don't want to mount PV panels on it \\n\"+\\\n                \"but we will go ahead and do it anyway.\"\n                \n                ghenv.Component.AddRuntimeMessage(w, warn)\n    \n                \n            if surface.type == 0.5:\n            \n                w = gh.GH_RuntimeMessageLevel.Warning\n                \n                warn = str(surface.name) +\" is a underground wall you probably don't want to mount PV panels on it \\n\"+\\\n                \"but we will go ahead and do it anyway.\"\n                \n                ghenv.Component.AddRuntimeMessage(w, warn)\n            \n            try:\n    \n                name = _name_[PVgencount]\n                message0 = _name_[PVgencount] + \" is mounted on Honeybee surface \"+ str(surface.name)\n    \n            except IndexError:\n                \n                name = \"PVgenerator\" + str(PVgencount)\n                message0 = \"For this generator no name has been given so a default name of PVgenerator\" + str(PVgencount) + \" has been assigned. This generator is mounted on Honeybee surface \" + str(surface.name) # If no name given for a PV generator assign one.\n            \n            try:\n    \n                _cellsEfficiency[PVgencount]\n                \n                message4 = \"The number of PV modules in parallel is \"+ str(parallel)\n            \n            except IndexError:\n                \n                parallel = _cellsEfficiency[0]\n                \n                message4 = \"The number of PV modules in parallel is \"+ str(parallel) \n            \n            \n            \n            try:\n    \n                _NoParallel[PVgencount]\n                \n                message4 = \"The number of PV modules in parallel is \"+ str(parallel)\n            \n            except IndexError:\n                \n                parallel = _NoParallel[0]\n                \n                message4 = \"The number of PV modules in parallel is \"+ str(parallel) \n            \n    \n            try:\n    \n                _Noseries[PVgencount]\n                message5 = \"The number of PV modules in series is \" + str(series)\n    \n                \n            except IndexError:\n                \n                series = _Noseries[0]\n                message5 = \"The number of PV modules in series is \" + str(series)\n                \n                \n            message6 = \"So \" + name + \" is made up of \"+ str(series*parallel) + \" PV modules\"\n                \n            try:\n                _powerOutputPerModule[PVgencount]\n    \n                message8 = \"The power output per PV module is \" + str(powerout) + \" W \\n \" +\\\n                \"Therefore the total power output of \"+ name+\" is \" + str(powerout*float(parallel*series)) + \" W \"\n    \n                \n            except IndexError:\n                \n                powerout = _powerOutputPerModule[0]\n                message8 = \"The power output per PV module is \" + str(powerout) + \" W \\n \" +\\\n                \"Therefore the total power output of \"+ name+ \" is \" + str(powerout*float(parallel*series)) + \" W \"\n            \n            # The surface area of the surface that the PV panels cover are calculated from this equation.\n            \n            SA_solarcell = (powerout*parallel*series)/(1000*surface.getArea()*celleff)\n            \n            if (SA_solarcell > 0.85) and (SA_solarcell < 1):\n                \n                warn = \"According to your inputs solar panels cover more than 85% of the surface area of the Honeybee surface \"+ surface.name+ \"\\n\"+\\\n                \"Are you sure that the power rating and the number of modules on this surface are correct? \\n \"+\\\n                \"This value is calculated from the total power output of each PV generator (The sum of each PV module in that generator) divided by the surface area of the surface they are mounted on. \\n\"+ \\\n                \"Don't worry though this component will still run!\"\n                w = gh.GH_RuntimeMessageLevel.Warning\n                ghenv.Component.AddRuntimeMessage(w, warn)\n                \n                \n            if SA_solarcell >= 1:\n                \n                warn = \"Error! According to your inputs solar panels cover more than 100% of the surface area of the Honeybee surface \" + surface.name+\"\\n\"+\\\n                \"Are you sure that the power rating and the number of modules on each surface is correct and that units are in meters? \\n \"+\\\n                \"This value is calculated from the total power output of each PV generator (The sum of each PV module in that generator) divided by the surface area of the surface they are mounted on.\"\n                \"This component will not run until the surface area is less than 100%.\"\n                w = gh.GH_RuntimeMessageLevel.Error\n                ghenv.Component.AddRuntimeMessage(w, warn)\n                \n                return\n\n            if SA_solarcell < 0.025:\n                \n                warn = \"Warning! According to your inputs solar panels cover less than 2.5% of the surface area of \" + surface.name+\"\\n\"+\\\n                \"Are you sure that the power rating and the number of modules on each surface is correct? \\n \"+\\\n                \"This value is calculated from the total power output of each PV generator (The sum of each PV module in that generator) divided by the surface area of the surface they are mounted on.\"\n                \"This component will not run until the surface area is less than 100%.\"\n                w = gh.GH_RuntimeMessageLevel.Warning\n                ghenv.Component.AddRuntimeMessage(w, warn)\n                \n            units = sc.doc.ModelUnitSystem\n            if units != Rhino.UnitSystem.Meters:\n                \n                warn = \"You must use meters as your unit system to work with the PV component!\"\n                w = gh.GH_RuntimeMessageLevel.Error\n                ghenv.Component.AddRuntimeMessage(w, warn)\n                \n                \n            message1 = \"According to the data you entered it is calculated that the modules of this PV generator cover roughly \"+str(round(SA_solarcell*100,2))+ \" % of the surface area of this surface\"\n            \n                \n            surface.PVgenlist.append(PV_gen(name,surface,parallel,series,powerout,SA_solarcell,celleff,costPVgen))\n                \n            # Assign the inverter to each PVgenerator.\n            \n            for PVgen in surface.PVgenlist:\n                \n                PVgen.inverter = PVinverter\n            \n            message = message0 +\" \\n \"+ name + \" has the following properties: \"+\"\\n \"+message1+\"\\n \"+message4+\"\\n \"+message5+\"\\n \"+ message6 +\"\\n \"+message8\n            \n            readmedatatree.Add(message,gh.Data.GH_Path(PVgencount))\n                \n            PVgencount = PVgencount+1\n\n    except Exception as e:\n        \n        if str(e) == \"'NoneType' object has no attribute 'containsPVgen'\":\n            \n            # This catches an error when there is a missing member exception ie length of one of inputs is longer than \n            # number of Honeybee surfaces not sure how to just catch missing member exception!\n            warn = \"The length of a list of inputs into either _name_,_cellsEfficiency \\n\" + \\\n                    \"_integrationMode,_NoParallel,_Noseries,costPVgen_ or _powerOutput \\n\" + \\\n                    \"is longer than the number of Honeybee surfaces connected to this component!\\n\" + \\\n                    \"e.g if you have 2 Honeybee surfaces you cannot have 3 values input into costPVgen_!\\n\" + \\\n                    \"Please check the inputs and try again!\"\n        \n            #print warn\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, warn)\n            return -1\n        \n        else:\n            raise\n        \n    ModifiedHBSurfaces = hb_hive.addToHoneybeeHive(HBSurfacesfromhive, ghenv.Component)\n    \n    return ModifiedHBSurfaces\n\n# Call the PVinverter from the hive\n\nPVinverter = hb_hivegen.callFromHoneybeeHive(_PVInverter)\n\nif checktheinputs(_name_,_HBSurfaces,_cellsEfficiency,_NoParallel,_Noseries) != -1:\n\n    PV_HBSurfaces = main(_name_,_HBSurfaces,_cellsEfficiency,_NoParallel,_Noseries,_powerOutputPerModule,PVinverter)\n    \n    readMe = readmedatatree",
  "language": "python",
  "imports": [
    "Rhino",
    "scriptcontext"
  ],
  "has_docstring": true
}