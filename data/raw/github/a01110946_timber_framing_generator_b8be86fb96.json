{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/scripts/gh_cell_decomposer.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "scripts/gh_cell_decomposer.py",
  "instruction": "Cell Decomposer for Grasshopper.",
  "code": "# File: scripts/gh_cell_decomposer.py\n\"\"\"Cell Decomposer for Grasshopper.\n\nDecomposes wall data into cells (stud regions, opening regions, cripple regions)\nand serializes to JSON format. Supports both whole-wall and panel-aware\ndecomposition for offsite construction workflows.\n\nReads ``framing_segments`` from enriched walls_json (output by Junction\nAnalyzer) so that cells are created within junction-adjusted framing\nbounds rather than the raw ``[0, wall_length]`` range. Multi-segment walls\n(e.g., X-crossing splits) produce one CellData entry per segment.\n\nKey Features:\n1. Cell Decomposition\n   - Splits walls into stud cells (SC), opening cells (OC)\n   - Creates header cripple cells (HCC) above openings\n   - Creates sill cripple cells (SCC) below windows\n\n2. Framing-Segment-Aware Decomposition\n   - Reads ``framing_segments`` per wall (list of [u_start, u_end] pairs)\n   - Cells created within adjusted framing bounds (extended, trimmed, split)\n   - Multi-segment walls produce one CellData per segment\n   - Cell IDs include segment index for multi-segment walls (wall_1_seg0_SC_0)\n   - CellData metadata includes segment_u_start, segment_u_end, segment_index\n   - Backward compatible: absent framing_segments defaults to [0, wall_length]\n\n3. Panel-Aware Mode\n   - Integrates with Panel Decomposer output\n   - Decomposes cells within panel boundaries\n   - Generates panel-aware cell IDs (wall_1_panel_0_SC_0)\n\n4. Legacy Mode\n   - Works without Panel Decomposer\n   - Decomposes entire walls as single units\n   - Backward compatible with existing workflows\n\nEnvironment:\n    Rhino 8\n    Grasshopper\n    Python component (CPython 3)\n\nDependencies:\n    - Rhino.Geometry: Core geometry types\n    - Grasshopper: DataTree for output organization\n    - timber_framing_generator.core: JSON schemas\n    - timber_framing_generator.cell_decomposition: Panel-aware functions\n\nPerformance Considerations:\n    - Processing time scales linearly with wall count\n    - Panel-aware mode adds overhead per panel\n    - Multi-segment walls add one decomposition pass per segment\n    - Typical walls process in < 50ms\n\nUsage:\n    Option A - Without panelization (legacy mode):\n        1. Connect 'wall_json' from Junction Analyzer (enriched walls_json)\n           or from Wall Analyzer (original walls_json, backward compatible)\n        2. Leave 'panels_json' empty\n        3. Set 'run' to True to execute\n\n    Option B - With panelization (recommended for offsite construction):\n        1. Connect 'wall_json' from Junction Analyzer or Wall Analyzer\n        2. Connect 'panels_json' from Panel Decomposer\n        3. Set 'run' to True to execute\n\nInput Requirements:\n    Walls JSON (wall_json) - str:\n        JSON string from Junction Analyzer (enriched with framing_segments)\n        or from Wall Analyzer (backward compatible without segments).\n        Required: Yes\n        Access: Item\n\n    Panels JSON (panels_json) - str:\n        JSON string from Panel Decomposer (optional)\n        Required: No\n        Access: Item\n\n    Run (run) - bool:\n        Boolean to trigger execution\n        Required: Yes\n        Access: Item\n\nOutputs:\n    Cell JSON (cell_json) - str:\n        JSON string containing cell data for all walls/panels\n\n    Cell Surfaces (cell_srf) - DataTree[Surface]:\n        Cell boundary surfaces for visualization\n\n    Cell Types (cell_types) - DataTree[str]:\n        Cell type labels (SC, OC, HCC, SCC)\n\n    Debug Info (debug_info) - str:\n        Debug information and status messages\n\nTechnical Details:\n    - Cell IDs without panels or segments: wall_1_SC_0\n    - Cell IDs with segments: wall_1_seg0_SC_0\n    - Cell IDs with panels: wall_1_panel_0_SC_0\n    - Openings filtered to segment/panel range before decomposition\n    - CellData metadata includes segment bounds for downstream consumers\n\nError Handling:\n    - Invalid JSON returns empty outputs with error in debug_info\n    - Missing panels falls back to legacy mode\n    - Missing framing_segments falls back to full wall range\n    - Processing errors logged but don't halt execution\n\nAuthor: Timber Framing Generator\nVersion: 1.2.0\n\"\"\"\n\n# =============================================================================\n# Imports\n# =============================================================================\n\n# Standard library\nimport sys\nimport json\nimport traceback\nfrom dataclasses import asdict\n\n# .NET / CLR\nimport clr\nclr.AddReference(\"Grasshopper\")\nclr.AddReference(\"RhinoCommon\")\n\n# Rhino / Grasshopper\nimport Rhino.Geometry as rg\nimport Grasshopper\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\n\n# =============================================================================\n# Force Module Reload (CPython 3 in Rhino 8)\n# =============================================================================\n\n# Clear timber_framing_generator modules AND the 'src' package itself.\n_modules_to_clear = [k for k in sys.modules.keys()\n                     if 'timber_framing_generator' in k\n                     or k == 'src']\nfor mod in _modules_to_clear:\n    del sys.modules[mod]\n\n# =============================================================================\n# Project Setup\n# =============================================================================\n\n# Primary: worktree / feature-branch path\n# Fallback: main repo path (for modules not yet in the worktree)\n_WORKTREE_PATH = r\"C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\tfg-sheathing-junctions\"\n_MAIN_REPO_PATH = r\"C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\timber_framing_generator\"\n\nfor _p in (_WORKTREE_PATH, _MAIN_REPO_PATH):\n    while _p in sys.path:\n        sys.path.remove(_p)\nsys.path.insert(0, _MAIN_REPO_PATH)\nsys.path.insert(0, _WORKTREE_PATH)\n\nfrom src.timber_framing_generator.core.json_schemas import (\n    CellData, CellInfo, CellCorners, Point3D,\n    deserialize_wall_data, FramingJSONEncoder\n)\nfrom src.timber_framing_generator.utils.geometry_factory import get_factory\nfrom src.timber_framing_generator.cell_decomposition import (\n    get_openings_in_range,\n    clip_opening_to_range,\n    check_opening_spans_panel_joint,\n    generate_panel_cell_id,\n)\n\n# =============================================================================\n# Constants\n# =============================================================================\n\nCOMPONENT_NAME = \"Cell Decomposer\"\nCOMPONENT_NICKNAME = \"CellDecomp\"\nCOMPONENT_MESSAGE = \"v1.1\"\nCOMPONENT_CATEGORY = \"Timber Framing\"\nCOMPONENT_SUBCATEGORY = \"Analysis\"\n\n# =============================================================================\n# Logging Utilities\n# =============================================================================\n\ndef log_message(message, level=\"info\"):\n    \"\"\"Log to console and optionally add GH runtime message.\"\"\"\n    print(f\"[{level.upper()}] {message}\")\n\n    if level == \"warning\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning, message)\n    elif level == \"error\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Error, message)\n\n\ndef log_debug(message):\n    \"\"\"Log debug message (console only).\"\"\"\n    print(f\"[DEBUG] {message}\")\n\n\ndef log_info(message):\n    \"\"\"Log info message (console only).\"\"\"\n    print(f\"[INFO] {message}\")\n\n\ndef log_warning(message):\n    \"\"\"Log warning message (console + GH UI).\"\"\"\n    log_message(message, \"warning\")\n\n\ndef log_error(message):\n    \"\"\"Log error message (console + GH UI).\"\"\"\n    log_message(message, \"error\")\n\n# =============================================================================\n# Component Setup\n# =============================================================================\n\ndef setup_component():\n    \"\"\"Initialize and configure the Grasshopper component.\n\n    Configures:\n    1. Component metadata (name, category, etc.)\n    2. Input parameter names, descriptions, and access\n    3. Output parameter names and descriptions\n\n    Note: Output[0] is reserved for GH's internal 'out' - start from Output[1]\n\n    IMPORTANT: Type Hints cannot be set programmatically in Rhino 8.\n    They must be configured via UI: Right-click input -> Type hint -> Select type\n    \"\"\"\n    ghenv.Component.Name = COMPONENT_NAME\n    ghenv.Component.NickName = COMPONENT_NICKNAME\n    ghenv.Component.Message = COMPONENT_MESSAGE\n    ghenv.Component.Category = COMPONENT_CATEGORY\n    ghenv.Component.SubCategory = COMPONENT_SUBCATEGORY\n\n    # Configure inputs\n    inputs = ghenv.Component.Params.Input\n    input_config = [\n        (\"Walls JSON\", \"wall_json\", \"JSON string from Wall Analyzer\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Panels JSON\", \"panels_json\", \"JSON string from Panel Decomposer (optional)\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Run\", \"run\", \"Boolean to trigger execution\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n    ]\n\n    for i, (name, nick, desc, access) in enumerate(input_config):\n        if i < inputs.Count:\n            inputs[i].Name = name\n            inputs[i].NickName = nick\n            inputs[i].Description = desc\n            inputs[i].Access = access\n\n    # Configure outputs (start from index 1)\n    outputs = ghenv.Component.Params.Output\n    output_config = [\n        (\"Cell JSON\", \"cell_json\", \"JSON string containing cell data\"),\n        (\"Cell Surfaces\", \"cell_srf\", \"Cell boundary surfaces for visualization\"),\n        (\"Cell Types\", \"cell_types\", \"Cell type labels (SC, OC, HCC, SCC)\"),\n        (\"Debug Info\", \"debug_info\", \"Debug information and status\"),\n    ]\n\n    for i, (name, nick, desc) in enumerate(output_config):\n        idx = i + 1\n        if idx < outputs.Count:\n            outputs[idx].Name = name\n            outputs[idx].NickName = nick\n            outputs[idx].Description = desc\n\n# =============================================================================\n# Helper Functions\n# =============================================================================\n\ndef validate_inputs(wall_json, panels_json, run):\n    \"\"\"Validate component inputs.\n\n    Args:\n        wall_json: JSON string with wall data\n        panels_json: JSON string with panel data (optional)\n        run: Boolean trigger\n\n    Returns:\n        tuple: (is_valid, panels_valid, error_message)\n    \"\"\"\n    if not run:\n        return False, False, \"Component not running. Set 'run' to True.\"\n\n    if not wall_json:\n        return False, False, \"No wall_json input provided\"\n\n    try:\n        json.loads(wall_json)\n    except json.JSONDecodeError as e:\n        return False, False, f\"Invalid JSON in wall_json: {e}\"\n\n    # Validate panels_json (optional input)\n    panels_valid = False\n    if panels_json:\n        log_info(f\"panels_json received: type={type(panels_json).__name__}, len={len(panels_json)}\")\n        try:\n            parsed = json.loads(panels_json)\n            if isinstance(parsed, list) and len(parsed) > 0:\n                panels_valid = True\n                log_info(f\"panels_json parsed: {len(parsed)} wall entries\")\n            else:\n                log_warning(f\"panels_json parsed but empty or not a list: {type(parsed)}\")\n        except json.JSONDecodeError as e:\n            log_warning(f\"Invalid JSON in panels_json: {e}\")\n    else:\n        log_info(f\"panels_json not provided or empty: {repr(panels_json)}\")\n\n    return True, panels_valid, None\n\n\ndef create_cell_surface(corners):\n    \"\"\"Create a visualization surface from cell corners using RhinoCommonFactory.\n\n    Args:\n        corners: CellCorners with bottom_left, bottom_right, top_right, top_left\n\n    Returns:\n        NurbsSurface for visualization, or None if creation fails\n    \"\"\"\n    try:\n        factory = get_factory()\n        return factory.create_surface_from_corners(\n            (corners.bottom_left.x, corners.bottom_left.y, corners.bottom_left.z),\n            (corners.bottom_right.x, corners.bottom_right.y, corners.bottom_right.z),\n            (corners.top_right.x, corners.top_right.y, corners.top_right.z),\n            (corners.top_left.x, corners.top_left.y, corners.top_left.z),\n        )\n    except Exception as e:\n        log_debug(f\"Error creating cell surface: {e}\")\n        return None\n\n\ndef parse_panels_json(panels_json_str):\n    \"\"\"Parse panels JSON to extract panel data.\n\n    Args:\n        panels_json_str: JSON string containing panels data\n\n    Returns:\n        List of panel result dictionaries\n    \"\"\"\n    if not panels_json_str:\n        return []\n    data = json.loads(panels_json_str)\n    return data if isinstance(data, list) else [data]\n\n\ndef get_panels_for_wall(panels_data, wall_id):\n    \"\"\"Get panels for a specific wall from the panels data.\n\n    Args:\n        panels_data: List of panel result dictionaries\n        wall_id: Wall ID to look up\n\n    Returns:\n        List of panel dictionaries for this wall\n    \"\"\"\n    # Convert to string for comparison (handles int vs str mismatch)\n    wall_id_str = str(wall_id)\n    for result in panels_data:\n        if str(result.get('wall_id', '')) == wall_id_str:\n            return result.get('panels', [])\n    return []\n\n\ndef decompose_panel_to_cells(wall_dict, panel, wall_index, panel_index):\n    \"\"\"Decompose a single panel (wall segment) to cells.\n\n    Args:\n        wall_dict: Wall data dictionary from JSON\n        panel: Panel dictionary with id, u_start, u_end, etc.\n        wall_index: Index for this wall\n        panel_index: Index for this panel within the wall\n\n    Returns:\n        Tuple of (CellData, list of surfaces, list of type labels)\n    \"\"\"\n    wall_id = wall_dict.get('wall_id', f'wall_{wall_index}')\n    panel_id = panel.get('id', f'{wall_id}_panel_{panel_index}')\n    panel_u_start = panel.get('u_start', 0)\n    panel_u_end = panel.get('u_end', wall_dict.get('wall_length', 0))\n    panel_length = panel_u_end - panel_u_start\n\n    wall_height = wall_dict.get('wall_height', 0)\n    base_elevation = wall_dict.get('base_elevation', 0)\n\n    base_plane = wall_dict.get('base_plane', {})\n    origin = base_plane.get('origin', {'x': 0, 'y': 0, 'z': 0})\n    x_axis = base_plane.get('x_axis', {'x': 1, 'y': 0, 'z': 0})\n\n    cells = []\n    surfaces = []\n    type_labels = []\n\n    all_openings = wall_dict.get('openings', [])\n    panel_openings = get_openings_in_range(all_openings, panel_u_start, panel_u_end)\n\n    log_debug(f\"Panel {panel_id}: range u={panel_u_start:.2f} to {panel_u_end:.2f}, {len(panel_openings)} openings\")\n\n    def world_point(u_coord, v_coord):\n        return Point3D(\n            origin['x'] + x_axis['x'] * u_coord,\n            origin['y'] + x_axis['y'] * u_coord,\n            base_elevation + v_coord\n        )\n\n    cell_idx = 0\n\n    if not panel_openings:\n        corners = CellCorners(\n            bottom_left=world_point(panel_u_start, 0),\n            bottom_right=world_point(panel_u_end, 0),\n            top_right=world_point(panel_u_end, wall_height),\n            top_left=world_point(panel_u_start, wall_height),\n        )\n        cell = CellInfo(\n            id=generate_panel_cell_id(wall_id, panel_index, \"SC\", cell_idx),\n            cell_type=\"SC\",\n            u_start=panel_u_start,\n            u_end=panel_u_end,\n            v_start=0,\n            v_end=wall_height,\n            corners=corners,\n            panel_id=panel_id,\n        )\n        cells.append(cell)\n        srf = create_cell_surface(corners)\n        if srf:\n            surfaces.append(srf)\n        type_labels.append(\"SC\")\n    else:\n        sorted_openings = sorted(panel_openings, key=lambda o: o.get('u_start', 0))\n        current_u = panel_u_start\n\n        for opening in sorted_openings:\n            clipped = clip_opening_to_range(opening, panel_u_start, panel_u_end)\n            if not clipped:\n                continue\n\n            o_u_start = clipped.get('u_start', 0)\n            o_u_end = clipped.get('u_end', 0)\n            o_v_start = clipped.get('v_start', 0)\n            o_v_end = clipped.get('v_end', 0)\n            o_type = clipped.get('opening_type', 'window')\n            o_id = clipped.get('id', f'opening_{cell_idx}')\n\n            # Stud cell before opening\n            if current_u < o_u_start:\n                corners = CellCorners(\n                    bottom_left=world_point(current_u, 0),\n                    bottom_right=world_point(o_u_start, 0),\n                    top_right=world_point(o_u_start, wall_height),\n                    top_left=world_point(current_u, wall_height),\n                )\n                cell = CellInfo(\n                    id=generate_panel_cell_id(wall_id, panel_index, \"SC\", cell_idx),\n                    cell_type=\"SC\",\n                    u_start=current_u,\n                    u_end=o_u_start,\n                    v_start=0,\n                    v_end=wall_height,\n                    corners=corners,\n                    panel_id=panel_id,\n                )\n                cells.append(cell)\n                srf = create_cell_surface(corners)\n                if srf:\n                    surfaces.append(srf)\n                type_labels.append(\"SC\")\n                cell_idx += 1\n\n            # Header cripple cell (above opening)\n            if o_v_end < wall_height:\n                corners = CellCorners(\n                    bottom_left=world_point(o_u_start, o_v_end),\n                    bottom_right=world_point(o_u_end, o_v_end),\n                    top_right=world_point(o_u_end, wall_height),\n                    top_left=world_point(o_u_start, wall_height),\n                )\n                cell = CellInfo(\n                    id=generate_panel_cell_id(wall_id, panel_index, \"HCC\", cell_idx),\n                    cell_type=\"HCC\",\n                    u_start=o_u_start,\n                    u_end=o_u_end,\n                    v_start=o_v_end,\n                    v_end=wall_height,\n                    corners=corners,\n                    opening_id=o_id,\n                    panel_id=panel_id,\n                )\n                cells.append(cell)\n                srf = create_cell_surface(corners)\n                if srf:\n                    surfaces.append(srf)\n                type_labels.append(\"HCC\")\n                cell_idx += 1\n\n            # Opening cell\n            corners = CellCorners(\n                bottom_left=world_point(o_u_start, o_v_start),\n                bottom_right=world_point(o_u_end, o_v_start),\n                top_right=world_point(o_u_end, o_v_end),\n                top_left=world_point(o_u_start, o_v_end),\n            )\n            cell = CellInfo(\n                id=generate_panel_cell_id(wall_id, panel_index, \"OC\", cell_idx),\n                cell_type=\"OC\",\n                u_start=o_u_start,\n                u_end=o_u_end,\n                v_start=o_v_start,\n                v_end=o_v_end,\n                corners=corners,\n                opening_id=o_id,\n                opening_type=o_type,\n                panel_id=panel_id,\n            )\n            cells.append(cell)\n            srf = create_cell_surface(corners)\n            if srf:\n                surfaces.append(srf)\n            type_labels.append(\"OC\")\n            cell_idx += 1\n\n            # Sill cripple cell (below window)\n            if o_v_start > 0 and o_type == 'window':\n                corners = CellCorners(\n                    bottom_left=world_point(o_u_start, 0),\n                    bottom_right=world_point(o_u_end, 0),\n                    top_right=world_point(o_u_end, o_v_start),\n                    top_left=world_point(o_u_start, o_v_start),\n                )\n                cell = CellInfo(\n                    id=generate_panel_cell_id(wall_id, panel_index, \"SCC\", cell_idx),\n                    cell_type=\"SCC\",\n                    u_start=o_u_start,\n                    u_end=o_u_end,\n                    v_start=0,\n                    v_end=o_v_start,\n                    corners=corners,\n                    opening_id=o_id,\n                    panel_id=panel_id,\n                )\n                cells.append(cell)\n                srf = create_cell_surface(corners)\n                if srf:\n                    surfaces.append(srf)\n                type_labels.append(\"SCC\")\n                cell_idx += 1\n\n            current_u = o_u_end\n\n        # Final stud cell after last opening\n        if current_u < panel_u_end:\n            corners = CellCorners(\n                bottom_left=world_point(current_u, 0),\n                bottom_right=world_point(panel_u_end, 0),\n                top_right=world_point(panel_u_end, wall_height),\n                top_left=world_point(current_u, wall_height),\n            )\n            cell = CellInfo(\n                id=generate_panel_cell_id(wall_id, panel_index, \"SC\", cell_idx),\n                cell_type=\"SC\",\n                u_start=current_u,\n                u_end=panel_u_end,\n                v_start=0,\n                v_end=wall_height,\n                corners=corners,\n                panel_id=panel_id,\n            )\n            cells.append(cell)\n            srf = create_cell_surface(corners)\n            if srf:\n                surfaces.append(srf)\n            type_labels.append(\"SC\")\n\n    cell_data = CellData(\n        wall_id=wall_id,\n        cells=cells,\n        metadata={\n            'wall_length': wall_dict.get('wall_length', 0),\n            'wall_height': wall_height,\n            'panel_id': panel_id,\n            'panel_u_start': panel_u_start,\n            'panel_u_end': panel_u_end,\n        }\n    )\n\n    return cell_data, surfaces, type_labels\n\n\ndef decompose_wall_json_to_cells(wall_dict, wall_index, seg_start=None, seg_end=None, seg_idx=None):\n    \"\"\"Decompose a single wall (or wall segment) from JSON to cells (legacy mode).\n\n    When *seg_start*/*seg_end* are provided, cells are created within\n    those bounds instead of the full ``[0, wall_length]`` range.  This\n    supports framing-segment-aware decomposition where junction\n    adjustments extend, trim, or split the wall's framing domain.\n\n    Args:\n        wall_dict: Wall data dictionary from JSON.\n        wall_index: Index for this wall.\n        seg_start: Optional framing segment start U in feet.\n            Defaults to 0 when ``None``.\n        seg_end: Optional framing segment end U in feet.\n            Defaults to ``wall_length`` when ``None``.\n        seg_idx: Optional segment index for multi-segment walls.\n            When not ``None``, added to cell IDs and CellData metadata.\n\n    Returns:\n        Tuple of (CellData, list of surfaces, list of type labels)\n    \"\"\"\n    wall_id = wall_dict.get('wall_id', f'wall_{wall_index}')\n    wall_length = wall_dict.get('wall_length', 0)\n    wall_height = wall_dict.get('wall_height', 0)\n    base_elevation = wall_dict.get('base_elevation', 0)\n\n    # Effective framing bounds (may differ from 0 / wall_length)\n    eff_start = seg_start if seg_start is not None else 0\n    eff_end = seg_end if seg_end is not None else wall_length\n\n    base_plane = wall_dict.get('base_plane', {})\n    origin = base_plane.get('origin', {'x': 0, 'y': 0, 'z': 0})\n    x_axis = base_plane.get('x_axis', {'x': 1, 'y': 0, 'z': 0})\n\n    # ID prefix — include segment index when multi-segment\n    id_prefix = f\"{wall_id}_seg{seg_idx}\" if seg_idx is not None else wall_id\n\n    cells = []\n    surfaces = []\n    type_labels = []\n    all_openings = wall_dict.get('openings', [])\n\n    # Filter openings to those overlapping this segment\n    openings = [\n        o for o in all_openings\n        if o.get('u_end', 0) > eff_start and o.get('u_start', 0) < eff_end\n    ]\n\n    log_debug(f\"Wall {wall_id} seg=[{eff_start:.3f}, {eff_end:.3f}]: \"\n              f\"H={wall_height:.2f}, {len(openings)}/{len(all_openings)} openings\")\n\n    if not openings:\n        corners = CellCorners(\n            bottom_left=Point3D(\n                origin['x'] + x_axis['x'] * eff_start,\n                origin['y'] + x_axis['y'] * eff_start,\n                base_elevation),\n            bottom_right=Point3D(\n                origin['x'] + x_axis['x'] * eff_end,\n                origin['y'] + x_axis['y'] * eff_end,\n                base_elevation\n            ),\n            top_right=Point3D(\n                origin['x'] + x_axis['x'] * eff_end,\n                origin['y'] + x_axis['y'] * eff_end,\n                base_elevation + wall_height\n            ),\n            top_left=Point3D(\n                origin['x'] + x_axis['x'] * eff_start,\n                origin['y'] + x_axis['y'] * eff_start,\n                base_elevation + wall_height),\n        )\n        cell = CellInfo(\n            id=f\"{id_prefix}_SC_0\",\n            cell_type=\"SC\",\n            u_start=eff_start,\n            u_end=eff_end,\n            v_start=0,\n            v_end=wall_height,\n            corners=corners,\n        )\n        cells.append(cell)\n        srf = create_cell_surface(corners)\n        if srf:\n            surfaces.append(srf)\n        type_labels.append(\"SC\")\n    else:\n        sorted_openings = sorted(openings, key=lambda o: o.get('u_start', 0))\n        current_u = eff_start\n        cell_idx = 0\n\n        for opening in sorted_openings:\n            o_u_start = opening.get('u_start', 0)\n            o_u_end = opening.get('u_end', 0)\n            o_v_start = opening.get('v_start', 0)\n            o_v_end = opening.get('v_end', 0)\n            o_type = opening.get('opening_type', 'window')\n            o_id = opening.get('id', f'opening_{cell_idx}')\n\n            # Stud cell before opening\n            if current_u < o_u_start:\n                corners = CellCorners(\n                    bottom_left=Point3D(\n                        origin['x'] + x_axis['x'] * current_u,\n                        origin['y'] + x_axis['y'] * current_u,\n                        base_elevation\n                    ),\n                    bottom_right=Point3D(\n                        origin['x'] + x_axis['x'] * o_u_start,\n                        origin['y'] + x_axis['y'] * o_u_start,\n                        base_elevation\n                    ),\n                    top_right=Point3D(\n                        origin['x'] + x_axis['x'] * o_u_start,\n                        origin['y'] + x_axis['y'] * o_u_start,\n                        base_elevation + wall_height\n                    ),\n                    top_left=Point3D(\n                        origin['x'] + x_axis['x'] * current_u,\n                        origin['y'] + x_axis['y'] * current_u,\n                        base_elevation + wall_height\n                    ),\n                )\n                cell = CellInfo(\n                    id=f\"{id_prefix}_SC_{cell_idx}\",\n                    cell_type=\"SC\",\n                    u_start=current_u,\n                    u_end=o_u_start,\n                    v_start=0,\n                    v_end=wall_height,\n                    corners=corners,\n                )\n                cells.append(cell)\n                srf = create_cell_surface(corners)\n                if srf:\n                    surfaces.append(srf)\n                type_labels.append(\"SC\")\n                cell_idx += 1\n\n            # Header cripple cell (above opening)\n            if o_v_end < wall_height:\n                corners = CellCorners(\n                    bottom_left=Point3D(\n                        origin['x'] + x_axis['x'] * o_u_start,\n                        origin['y'] + x_axis['y'] * o_u_start,\n                        base_elevation + o_v_end\n                    ),\n                    bottom_right=Point3D(\n                        origin['x'] + x_axis['x'] * o_u_end,\n                        origin['y'] + x_axis['y'] * o_u_end,\n                        base_elevation + o_v_end\n                    ),\n                    top_right=Point3D(\n                        origin['x'] + x_axis['x'] * o_u_end,\n                        origin['y'] + x_axis['y'] * o_u_end,\n                        base_elevation + wall_height\n                    ),\n                    top_left=Point3D(\n                        origin['x'] + x_axis['x'] * o_u_start,\n                        origin['y'] + x_axis['y'] * o_u_start,\n                        base_elevation + wall_height\n                    ),\n                )\n                cell = CellInfo(\n                    id=f\"{id_prefix}_HCC_{cell_idx}\",\n                    cell_type=\"HCC\",\n                    u_start=o_u_start,\n                    u_end=o_u_end,\n                    v_start=o_v_end,\n                    v_end=wall_height,\n                    corners=corners,\n                    opening_id=o_id,\n                )\n                cells.append(cell)\n                srf = create_cell_surface(corners)\n                if srf:\n                    surfaces.append(srf)\n                type_labels.append(\"HCC\")\n                cell_idx += 1\n\n            # Opening cell\n            corners = CellCorners(\n                bottom_left=Point3D(\n                    origin['x'] + x_axis['x'] * o_u_start,\n                    origin['y'] + x_axis['y'] * o_u_start,\n                    base_elevation + o_v_start\n                ),\n                bottom_right=Point3D(\n                    origin['x'] + x_axis['x'] * o_u_end,\n                    origin['y'] + x_axis['y'] * o_u_end,\n                    base_elevation + o_v_start\n                ),\n                top_right=Point3D(\n                    origin['x'] + x_axis['x'] * o_u_end,\n                    origin['y'] + x_axis['y'] * o_u_end,\n                    base_elevation + o_v_end\n                ),\n                top_left=Point3D(\n                    origin['x'] + x_axis['x'] * o_u_start,\n                    origin['y'] + x_axis['y'] * o_u_start,\n                    base_elevation + o_v_end\n                ),\n            )\n            cell = CellInfo(\n                id=f\"{id_prefix}_OC_{cell_idx}\",\n                cell_type=\"OC\",\n                u_start=o_u_start,\n                u_end=o_u_end,\n                v_start=o_v_start,\n                v_end=o_v_end,\n                corners=corners,\n                opening_id=o_id,\n                opening_type=o_type,\n            )\n            cells.append(cell)\n            srf = create_cell_surface(corners)\n            if srf:\n                surfaces.append(srf)\n            type_labels.append(\"OC\")\n            cell_idx += 1\n\n            # Sill cripple cell (below window)\n            if o_v_start > 0 and o_type == 'window':\n                corners = CellCorners(\n                    bottom_left=Point3D(\n                        origin['x'] + x_axis['x'] * o_u_start,\n                        origin['y'] + x_axis['y'] * o_u_start,\n                        base_elevation\n                    ),\n                    bottom_right=Point3D(\n                        origin['x'] + x_axis['x'] * o_u_end,\n                        origin['y'] + x_axis['y'] * o_u_end,\n                        base_elevation\n                    ),\n                    top_right=Point3D(\n                        origin['x'] + x_axis['x'] * o_u_end,\n                        origin['y'] + x_axis['y'] * o_u_end,\n                        base_elevation + o_v_start\n                    ),\n                    top_left=Point3D(\n                        origin['x'] + x_axis['x'] * o_u_start,\n                        origin['y'] + x_axis['y'] * o_u_start,\n                        base_elevation + o_v_start\n                    ),\n                )\n                cell = CellInfo(\n                    id=f\"{id_prefix}_SCC_{cell_idx}\",\n                    cell_type=\"SCC\",\n                    u_start=o_u_start,\n                    u_end=o_u_end,\n                    v_start=0,\n                    v_end=o_v_start,\n                    corners=corners,\n                    opening_id=o_id,\n                )\n                cells.append(cell)\n                srf = create_cell_surface(corners)\n                if srf:\n                    surfaces.append(srf)\n                type_labels.append(\"SCC\")\n                cell_idx += 1\n\n            current_u = o_u_end\n\n        # Final stud cell after last opening\n        if current_u < eff_end:\n            corners = CellCorners(\n                bottom_left=Point3D(\n                    origin['x'] + x_axis['x'] * current_u,\n                    origin['y'] + x_axis['y'] * current_u,\n                    base_elevation\n                ),\n                bottom_right=Point3D(\n                    origin['x'] + x_axis['x'] * eff_end,\n                    origin['y'] + x_axis['y'] * eff_end,\n                    base_elevation\n                ),\n                top_right=Point3D(\n                    origin['x'] + x_axis['x'] * eff_end,\n                    origin['y'] + x_axis['y'] * eff_end,\n                    base_elevation + wall_height\n                ),\n                top_left=Point3D(\n                    origin['x'] + x_axis['x'] * current_u,\n                    origin['y'] + x_axis['y'] * current_u,\n                    base_elevation + wall_height\n                ),\n            )\n            cell = CellInfo(\n                id=f\"{id_prefix}_SC_{cell_idx}\",\n                cell_type=\"SC\",\n                u_start=current_u,\n                u_end=eff_end,\n                v_start=0,\n                v_end=wall_height,\n                corners=corners,\n            )\n            cells.append(cell)\n            srf = create_cell_surface(corners)\n            if srf:\n                surfaces.append(srf)\n            type_labels.append(\"SC\")\n\n    # Build metadata — include segment info when applicable\n    meta = {\n        'wall_length': wall_length,\n        'wall_height': wall_height,\n        'segment_u_start': eff_start,\n        'segment_u_end': eff_end,\n    }\n    if seg_idx is not None:\n        meta['segment_index'] = seg_idx\n\n    cell_data = CellData(\n        wall_id=wall_id,\n        cells=cells,\n        metadata=meta,\n    )\n\n    return cell_data, surfaces, type_labels\n\n\ndef _decompose_wall_by_segments(wall_dict, wall_idx):\n    \"\"\"Decompose a wall into cells, iterating framing segments if present.\n\n    Reads the ``framing_segments`` field (injected by Junction Analyzer)\n    and calls :func:`decompose_wall_json_to_cells` once per segment.\n    Falls back to the full ``[0, wall_length]`` range when the field is\n    absent — fully backward compatible.\n\n    Args:\n        wall_dict: Wall data dictionary from JSON.\n        wall_idx: Index for this wall.\n\n    Returns:\n        List of ``(CellData, surfaces, type_labels)`` tuples, one per\n        framing segment.\n    \"\"\"\n    segments = wall_dict.get('framing_segments')\n    results = []\n\n    if segments and len(segments) > 1:\n        # Multi-segment wall (e.g., X-crossing splits)\n        for si, (seg_s, seg_e) in enumerate(segments):\n            results.append(decompose_wall_json_to_cells(\n                wall_dict, wall_idx,\n                seg_start=seg_s, seg_end=seg_e, seg_idx=si,\n            ))\n    elif segments and len(segments) == 1:\n        # Single segment — bounds may differ from [0, wall_length]\n        seg_s, seg_e = segments[0]\n        results.append(decompose_wall_json_to_cells(\n            wall_dict, wall_idx,\n            seg_start=seg_s, seg_end=seg_e,\n        ))\n    else:\n        # No framing_segments — default full wall (backward compatible)\n        results.append(decompose_wall_json_to_cells(wall_dict, wall_idx))\n\n    return results\n\n\ndef process_decomposition(wall_list, panels_data):\n    \"\"\"Process all walls/panels through decomposition.\n\n    Args:\n        wall_list: List of wall dictionaries\n        panels_data: List of panel result dictionaries or None\n\n    Returns:\n        Tuple of (all_cell_data, cell_srf_tree, cell_types_tree, log_lines)\n    \"\"\"\n    all_cell_data = []\n    cell_srf = DataTree[object]()\n    cell_types = DataTree[object]()\n    log_lines = []\n    tree_idx = 0\n\n    if panels_data:\n        log_lines.append(\"=== PANEL-AWARE MODE ===\")\n        log_lines.append(f\"Processing {len(wall_list)} walls with panel decomposition\")\n    else:\n        log_lines.append(\"=== LEGACY MODE (no panels) ===\")\n        log_lines.append(f\"Processing {len(wall_list)} walls\")\n\n    for wall_idx, wall_dict in enumerate(wall_list):\n        wall_id = wall_dict.get('wall_id', f'wall_{wall_idx}')\n\n        try:\n            if panels_data:\n                wall_panels = get_panels_for_wall(panels_data, wall_id)\n\n                if not wall_panels:\n                    log_lines.append(f\"Wall {wall_idx} ({wall_id}): No panels, using segment mode\")\n                    seg_results = _decompose_wall_by_segments(wall_dict, wall_idx)\n                    for cell_data, surfaces, type_labels in seg_results:\n                        all_cell_data.append(cell_data)\n                        for j, srf in enumerate(surfaces):\n                            cell_srf.Add(srf, GH_Path(tree_idx, j))\n                        for j, label in enumerate(type_labels):\n                            cell_types.Add(label, GH_Path(tree_idx, j))\n                        log_lines.append(f\"  Segment: {len(cell_data.cells)} cells\")\n                        tree_idx += 1\n                else:\n                    log_lines.append(f\"Wall {wall_idx} ({wall_id}): {len(wall_panels)} panels\")\n\n                    # Read framing_segments so we can inject segment bounds\n                    # into panel cell metadata for the Framing Generator.\n                    framing_segs = wall_dict.get('framing_segments')\n\n                    for panel_idx, panel in enumerate(wall_panels):\n                        panel_id = panel.get('id', f'{wall_id}_panel_{panel_idx}')\n                        cell_data, surfaces, type_labels = decompose_panel_to_cells(\n                            wall_dict, panel, wall_idx, panel_idx\n                        )\n\n                        # Inject framing segment bounds into cell metadata.\n                        # The Framing Generator reads segment_u_start/segment_u_end\n                        # to build the WBC with junction-adjusted boundaries.\n                        if framing_segs:\n                            p_u_start = panel.get('u_start', 0)\n                            p_u_end = panel.get('u_end', wall_dict.get('wall_length', 0))\n                            # Find which segment contains this panel's midpoint\n                            p_mid = (p_u_start + p_u_end) / 2.0\n                            for seg_s, seg_e in framing_segs:\n                                if seg_s - 0.01 <= p_mid <= seg_e + 0.01:\n                                    cell_data.metadata['segment_u_start'] = seg_s\n                                    cell_data.metadata['segment_u_end'] = seg_e\n                                    break\n\n                        all_cell_data.append(cell_data)\n\n                        for j, srf in enumerate(surfaces):\n                            cell_srf.Add(srf, GH_Path(tree_idx, j))\n                        for j, label in enumerate(type_labels):\n                            cell_types.Add(label, GH_Path(tree_idx, j))\n\n                        log_lines.append(f\"  Panel {panel_idx}: {len(cell_data.cells)} cells\")\n                        tree_idx += 1\n            else:\n                seg_results = _decompose_wall_by_segments(wall_dict, wall_idx)\n                for cell_data, surfaces, type_labels in seg_results:\n                    all_cell_data.append(cell_data)\n                    for j, srf in enumerate(surfaces):\n                        cell_srf.Add(srf, GH_Path(tree_idx, j))\n                    for j, label in enumerate(type_labels):\n                        cell_types.Add(label, GH_Path(tree_idx, j))\n\n                    seg_info = cell_data.metadata.get('segment_index', '-')\n                    log_lines.append(\n                        f\"Wall {wall_idx} ({wall_id}) seg {seg_info}: \"\n                        f\"{len(cell_data.cells)} cells\"\n                    )\n                    tree_idx += 1\n\n        except Exception as e:\n            log_lines.append(f\"Wall {wall_idx}: ERROR - {str(e)}\")\n            log_lines.append(traceback.format_exc())\n\n    return all_cell_data, cell_srf, cell_types, log_lines\n\n# =============================================================================\n# Main Function\n# =============================================================================\n\ndef main():\n    \"\"\"Main entry point for the component.\n\n    Returns:\n        tuple: (cell_json, cell_srf, cell_types, debug_info)\n    \"\"\"\n    setup_component()\n\n    # Initialize outputs\n    cell_json = \"[]\"\n    cell_srf = DataTree[object]()\n    cell_types = DataTree[object]()\n    log_lines = []\n\n    try:\n        # Unwrap Grasshopper list wrappers\n        wall_json_input = wall_json\n        if isinstance(wall_json, (list, tuple)):\n            wall_json_input = wall_json[0] if wall_json else None\n\n        panels_json_input = panels_json if panels_json else None\n        if isinstance(panels_json, (list, tuple)):\n            panels_json_input = panels_json[0] if panels_json else None\n\n        # Validate inputs\n        is_valid, panels_valid, error_msg = validate_inputs(wall_json_input, panels_json_input, run)\n        if not is_valid:\n            if error_msg and \"not running\" not in error_msg.lower():\n                log_warning(error_msg)\n            return cell_json, cell_srf, cell_types, error_msg\n\n        log_info(f\"Validation complete: walls_valid={is_valid}, panels_valid={panels_valid}\")\n\n        # Parse inputs\n        wall_list = json.loads(wall_json_input)\n        panels_data = parse_panels_json(panels_json_input) if panels_json_input else None\n\n        log_lines.append(f\"Cell Decomposer v1.1\")\n        log_lines.append(f\"Walls: {len(wall_list)}\")\n\n        # Debug: Show what panels_json contains\n        log_lines.append(f\"DEBUG panels_json type: {type(panels_json)}\")\n        log_lines.append(f\"DEBUG panels_json_input type: {type(panels_json_input)}\")\n        if panels_json_input:\n            log_lines.append(f\"DEBUG panels_json_input length: {len(panels_json_input)}\")\n            log_lines.append(f\"DEBUG panels_json_input first 200 chars: {str(panels_json_input)[:200]}\")\n        else:\n            log_lines.append(f\"DEBUG panels_json_input is None or empty\")\n        log_lines.append(f\"DEBUG panels_data: {type(panels_data)}, len={len(panels_data) if panels_data else 0}\")\n        log_lines.append(\"\")\n\n        # Process decomposition\n        all_cell_data, cell_srf, cell_types, process_log = process_decomposition(\n            wall_list, panels_data\n        )\n        log_lines.extend(process_log)\n\n        # Serialize to JSON\n        if all_cell_data:\n            cell_dicts = [asdict(cd) for cd in all_cell_data]\n            cell_json = json.dumps(cell_dicts, cls=FramingJSONEncoder, indent=2)\n\n            total_cells = sum(len(cd.cells) for cd in all_cell_data)\n            log_lines.append(\"\")\n            log_lines.append(f\"=== SUMMARY ===\")\n            log_lines.append(f\"Total entries: {len(all_cell_data)}\")\n            log_lines.append(f\"Total cells: {total_cells}\")\n\n    except Exception as e:\n        log_error(f\"Unexpected error: {str(e)}\")\n        log_lines.append(f\"ERROR: {str(e)}\")\n        log_lines.append(traceback.format_exc())\n\n    return cell_json, cell_srf, cell_types, \"\\n\".join(log_lines)\n\n# =============================================================================\n# Execution\n# =============================================================================\n\n# Debug: Print actual input NickNames\nprint(\"[PARAM DEBUG] Input parameter NickNames:\")\nfor i, param in enumerate(ghenv.Component.Params.Input):\n    print(f\"  Input {i}: NickName='{param.NickName}', Name='{param.Name}'\")\n\n# Debug: Check globals vs locals for panels_json\nprint(\"[SCOPE DEBUG] Checking globals() for input variables:\")\nprint(f\"  'panels_json' in globals(): {'panels_json' in globals()}\")\nprint(f\"  'wall_json' in globals(): {'wall_json' in globals()}\")\nprint(f\"  'run' in globals(): {'run' in globals()}\")\nif 'panels_json' in globals():\n    print(f\"  globals()['panels_json'] type: {type(globals()['panels_json'])}\")\n    print(f\"  globals()['panels_json'] value: {repr(globals()['panels_json'])[:200]}\")\n\n# Set default values for optional inputs\n# Track whether variables were defined by GH or set by fallback\n_panels_json_from_gh = False\n\ntry:\n    wall_json\nexcept NameError:\n    wall_json = None\n\n# WORKAROUND: panels_json not being injected into globals - read directly from component\ntry:\n    panels_json\n    _panels_json_from_gh = True\nexcept NameError:\n    panels_json = None\n    _panels_json_from_gh = False\n\n# If panels_json is still None, try reading directly from the component parameter\nif panels_json is None:\n    try:\n        panels_param = ghenv.Component.Params.Input[1]  # Index 1 = panels_json\n        if panels_param.VolatileDataCount > 0:\n            # Get the first item from the volatile data\n            branch = panels_param.VolatileData.Branch(0)\n            if branch and len(branch) > 0:\n                raw_value = branch[0]\n                # Extract the actual value (might be wrapped in GH_String or similar)\n                if hasattr(raw_value, 'Value'):\n                    panels_json = raw_value.Value\n                else:\n                    panels_json = str(raw_value)\n                print(f\"[WORKAROUND] Read panels_json directly from param: {type(panels_json)}, len={len(panels_json) if panels_json else 0}\")\n    except Exception as e:\n        print(f\"[WORKAROUND] Failed to read panels_json from param: {e}\")\n\ntry:\n    run\nexcept NameError:\n    run = False\n\n# Debug: Print immediately to see what GH passed\nprint(f\"[INIT DEBUG] panels_json defined by GH: {_panels_json_from_gh}\")\nprint(f\"[INIT DEBUG] panels_json value type: {type(panels_json)}\")\nprint(f\"[INIT DEBUG] panels_json is None: {panels_json is None}\")\nif panels_json is not None:\n    print(f\"[INIT DEBUG] panels_json length: {len(panels_json) if hasattr(panels_json, '__len__') else 'N/A'}\")\n\n# Execute main\nif __name__ == \"__main__\":\n    cell_json, cell_srf, cell_types, debug_info = main()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}