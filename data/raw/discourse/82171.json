{
  "source_url": "https://discourse.mcneel.com/t/truss-script-in-python/82171",
  "topic_id": 82171,
  "title": "Truss script in python",
  "question": "Hello,\n\n\nIm kinda new to scripting with python and I would like to convert my messy GH script into python. What I want to do is to convert truss geometry below into python script.\n\n\n\n\nimage\n1585×557 6.32 KB\n\n\n\n\nI’ve spend some time searching and trying but it seems I got stuck pretty much in the first steps \n\n\n\n\nimage\n1321×703 31.9 KB\n\n\n\n\nimport rhinoscriptsyntax as rs\n\n#import start & end point of truss, height of truss, segmentation count\npt1 = rs.coerce3dpoint(start)\npt2 = rs.coerce3dpoint(end)\n\nsegments = division\n\nheight = -height\n\n#create bottom chord line\nline = rs.AddLine(pt1,pt2)\n\n#divide bottom chord\ndivision_points = rs.DivideCurve(line,segments,True,True)\n\n#copy points to defined height of truss\nheight_point = rs.CreatePoint(0,0,height)\ntranslation_top = pt1-height_point\ntop_chord = rs.CopyObjects(division_points,translation_top)\n\n\n\na = line\nb = division_points\nc = top_chord\n\n\n\nI have no idea how to proceed and I would like to ask you guys for some help. Anybody willing to share some thougths on how to make such geometry? Ive tried to search for references but with no results. Thank to anybody willing to help!\n\n\nEDIT:\n\n\nGH files attached. (Original one and python one)\n\n\nTruss_Python_v00.gh\n (6.1 KB)\n\n\nTruss_v04.gh\n (28.0 KB)\n\n\nDan.",
  "code_blocks": [
    {
      "code": "import rhinoscriptsyntax as rs\n\n#import start & end point of truss, height of truss, segmentation count\npt1 = rs.coerce3dpoint(start)\npt2 = rs.coerce3dpoint(end)\n\nsegments = division\n\n#height = -height\n\n#create bottom chord line\nline = rs.AddLine(pt1,pt2)\n\n\n#divide bottom chord\nbottom_points = rs.DivideCurve(line, segments, True, True)\ntop_points = [] # empty list for the top chord points\n\n# Create the top chord points\nfor i in range(len(bottom_points)):\n    x = bottom_points[i].X # new x-coordinate\n    y = bottom_points[i].Y + height # new y-coordinate\n    z = bottom_points[i].Z # new z-coordinate\n    top_point = rs.AddPoint((x, y, z)) # new top point as GUID\n    top_points.append(top_point) # save new top point into list\n\n# Create the lines\nbottom_chord_members = [] # empty list for the bottom chord line segements\ntop_chord_members = [] # empty list for the top chord line segements\nvertical_members = [] # empty list for the vertical line segements\ndiagonal_members = [] # empty list for the diagonal line segements\n\nfor i in range(len(bottom_points)):\n    # Create the vertical line segments\n    vertical_line = rs.AddLine(top_points[i], bottom_points[i])\n    vertical_members.append(vertical_line)\n    if i > 0:\n        # Create the bottom and top chord line segments\n        bottom_line = rs.AddLine(bottom_points[i-1], bottom_points[i])\n        bottom_chord_members.append(bottom_line)\n        top_line = rs.AddLine(top_points[i-1], top_points[i])\n        top_chord_members.append(top_line)\n        \n        # Create the diagonal line segments\n        if len(bottom_points) % 2 == 1: # case for even amount of horizontal chord segments\n            mid_point_index = int(len(bottom_points) / 2)\n            # Create top right to bottom left diagonals\n            if i <= mid_point_index:\n                diagonal_line_a = rs.AddLine(top_points[i-1], bottom_points[i])\n                diagonal_members.append(diagonal_line_a)\n            # Create bottom left to top right diagonals\n            if i >= mid_point_index and i < len(bottom_points) - 1:\n                diagonal_line_b = rs.AddLine(bottom_points[i], top_points[i+1])\n                diagonal_members.append(diagonal_line_b)\n        \n        else: # case for odd amount of horizontal chord segments\n            mid_point_index_a = int(len(bottom_points) / 2) - 1\n            mid_point_index_b = int(len(bottom_points) / 2)\n            # Create bottom left to top right diagonals\n            if i <= mid_point_index_a + 1:\n                diagonal_line_a = rs.AddLine(top_points[i-1], bottom_points[i])\n                diagonal_members.append(diagonal_line_a)\n            # Create bottom left to top right diagonals\n            if i >= mid_point_index_b - 1 and i < len(bottom_points) - 1:\n                diagonal_line_b = rs.AddLine(bottom_points[i], top_points[i+1])\n                diagonal_members.append(diagonal_line_b)\n            \n\n# Outputs\na = top_chord_members\nb = bottom_chord_members\nc = vertical_members\nd = diagonal_members # don't forget to add this component output",
      "language": "python",
      "author": "diff-arch",
      "post_number": 5,
      "is_solution": false
    },
    {
      "code": "__author__ = \"Dan\"\n__version__ = \"2019.04.19\"\n\n#import libraries\nimport rhinoscriptsyntax as rs\nimport math\n\n#start point & end point of truss\npt1 = rs.coerce3dpoint(start)\npt2 = rs.coerce3dpoint(end)\n\n#calculation of span length & division count & segment length = length increment\nspan = rs.Distance(pt1, pt2)\nsegments = int(segments)\nlength_increment = span/segments\n\n#slope calculation from percentage to degrees\nslope_perc = slope\nslope_ang = math.atan(slope/100)\n\n#calculation of height increment\nheight_increment = (span/segments)*math.tan(slope_ang)\nn = height\nheight_step = height_increment\nlength_step = length_increment\n\n#empty variables\na = []\nb = []\nc = []\nd = []\ne = []\n\n#slope calculation\nslope_perc = slope\nslope_ang = math.atan(slope/100)\n\n#generation of bot chord points\nj = 0\nfor i in range(segments+1):\n    j = j + length_step\n    bot = rs.AddPoint(j-length_step,0,0)\n    b.append(bot)\n\n#generation of top chord points\nj = 0\nfor i in range(segments+1):\n#    print (n)\n    if i <= segments/2:\n        n = n + height_step\n        j = j + length_step\n        top = rs.AddPoint(j - length_step,0,n - height_step)\n    else:\n        n = n - height_step\n        top = rs.AddPoint(j,0,n - height_step)\n        j = j + length_step\n    a.append(top)\n\n#assigning variables\ntop_pt = a\nbot_pt = b\n\n#generation of diagonals_1\nj = 0\nfor i in range(segments):\n    diagonal = rs.AddLine(bot_pt[j],top_pt[j+1])\n    j = j + 1\n    c.append(diagonal)\n\n#generation of diagonals_2\nj = 0\nfor i in range(segments):\n    diagonal = rs.AddLine(bot_pt[j+1],top_pt[j])\n    j = j + 1\n    d.append(diagonal)\n\n#generation of bottom chord and top chords\nbot_ch = rs.AddLine(bot_pt[0],bot_pt[segments])\ntop_ch = [rs.AddLine(top_pt[0],top_pt[int(segments/2)]), rs.AddLine(top_pt[int(segments/2)],top_pt[segments])]\n\n#generation of verticals\nj = 0\nfor i in range(segments+1):\n    vertical = rs.AddLine(bot_pt[j],top_pt[j])\n    j = j + 1\n    e.append(vertical)\n\n#assigning variables\ndia_1 = c\ndia_2 = d\nvert = e\n\nprint(truss_type)\n\n#Warren\nif truss_type == 0:\n    if segments/2 % 2 == 1:\n        dia_11 = dia_2[slice(1, int(segments/2),2)] + dia_1[slice(int(segments/2+1), int(segments),2)]\n        dia_12 = dia_1[slice(0, int(segments/2),2)] + dia_2[slice(int(segments/2), int(segments),2)]\n    else:\n        dia_11 = dia_2[slice(1, int(segments/2),2)] + dia_1[slice(int(segments/2), int(segments),2)]\n        dia_12 = dia_1[slice(0, int(segments/2),2)] + dia_2[slice(int(segments/2+1), int(segments),2)]\n#Warren Flipped\nif truss_type == 1:\n    if segments/2 % 2 == 1:\n        dia_11 = dia_2[slice(0, int(segments/2),2)] + dia_1[slice(int(segments/2), int(segments),2)]\n        dia_12 = dia_1[slice(1, int(segments/2),2)] + dia_2[slice(int(segments/2+1), int(segments),2)]\n    else:\n        dia_11 = dia_2[slice(0, int(segments/2),2)] + dia_1[slice(int(segments/2+1), int(segments),2)]\n        dia_12 = dia_1[slice(1, int(segments/2),2)] + dia_2[slice(int(segments/2), int(segments),2)]\n#Howe\nif truss_type == 2:\n    if edge_diagonals < segments/2:\n        dia_11 = dia_1[slice(0, int(edge_diagonals))] + dia_2[slice(int(segments-edge_diagonals), int(segments))]\n        dia_12 = dia_1[slice(int(edge_diagonals), int(segments/2))] + dia_2[slice(int(segments/2), int(segments-edge_diagonals))]\n    else:\n        dia_11 = dia_1[slice(0, int(segments/2))] + dia_2[slice(int(segments/2), int(segments))]\n        dia_12 = []\n#Pratt\nif truss_type == 3:\n    if edge_diagonals < segments/2:\n        dia_11 = dia_2[slice(0, int(edge_diagonals))] + dia_1[slice(int(segments-edge_diagonals), int(segments))]\n        dia_12 = dia_2[slice(int(edge_diagonals), int(segments/2))] + dia_1[slice(int(segments/2), int(segments-edge_diagonals))]\n    else:\n        dia_11 = dia_2[slice(0, int(segments/2))] + dia_1[slice(int(segments/2), int(segments))]\n        dia_12 = []",
      "language": "python",
      "author": "daniel.c",
      "post_number": 7,
      "is_solution": false
    },
    {
      "code": "import rhinoscriptsyntax as rs\n\n#import start & end point of truss, height of truss, segmentation count\npt1 = rs.coerce3dpoint(start)\npt2 = rs.coerce3dpoint(end)\n\nsegments = division\n\nheight = -height\n\n#create bottom chord line\nline = rs.AddLine(pt1,pt2)\n\n#divide bottom chord\ndivision_points = rs.DivideCurve(line,segments,True,True)\n\n#copy points to defined height of truss\nheight_point = rs.CreatePoint(0,0,height)\ntranslation_top = pt1-height_point\ntop_chord = rs.CopyObjects(division_points,translation_top)\n\n\n\na = line\nb = division_points\nc = top_chord",
      "language": "python",
      "author": "daniel.c",
      "post_number": 1,
      "is_solution": false
    }
  ],
  "tags": [
    "file-io",
    "geometry",
    "python",
    "rhinoscriptsyntax"
  ],
  "has_accepted_answer": false,
  "category_id": 11,
  "posts_count": 13,
  "views": 4189
}