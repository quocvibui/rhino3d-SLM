{
  "source_url": "https://github.com/Nihawl/DC-TowerProject/blob/c7c313efa7c772023ea11650ad3fe5b7f14b282c/Tower-Project-Module02.py",
  "repo": "Nihawl/DC-TowerProject",
  "repo_stars": 0,
  "repo_description": "Tower Skin 3D Model in Python - Part of \"Design Computing\" Course in Coursera ",
  "license": "MIT",
  "filepath": "Tower-Project-Module02.py",
  "instruction": "3D SURFACE MATRIX import modules",
  "code": " #3D SURFACE MATRIX\r\n#import modules\r\nimport rhinoscriptsyntax as rs\r\nimport random as rnd\r\n\r\ndef SurfacePoints(STRSRF, INTU, INTV):\r\n    #create empty dictionary\r\n    ptMTX = {}\r\n    srfNorm01 = {}\r\n    srfNorm02 = {}\r\n    \r\n    #find surface domain\r\n    Udomain = rs.SurfaceDomain(STRSRF,0)\r\n    Vdomain = rs.SurfaceDomain(STRSRF,1)\r\n    \r\n    #find step size\r\n    UStep = (Udomain[1] - Udomain[0])/ INTU\r\n    VStep = (Vdomain[1] - Vdomain[0])/ INTV\r\n    \r\n    #find exponential step value\r\n    expStep = DivideExponentially((Udomain[1]-Udomain[0]), INTU)\r\n    \r\n    #PLOT POINTS ON SURFACE\r\n    for i in range(INTU+1):\r\n        for j in range(INTV+1):\r\n            #define u and v in terms of i and j\r\n            #u = Udomain[0] + UStep*i\r\n            u = expStep[i]\r\n            v = Vdomain[0] + VStep*j\r\n            \r\n            #evaluate surface\r\n            point = rs.EvaluateSurface(STRSRF, u,v)\r\n            #print point\r\n            ptMTX[(i,j)] = point\r\n            \r\n            #find surface normals\r\n            vecNorm = rs.SurfaceNormal(STRSRF, (u,v))\r\n            print vecNorm\r\n            #unitize vector for scaling\r\n            vecNorm = rs.VectorUnitize(vecNorm)\r\n            #make scale a factor of distance from plane\r\n            plane = rs.WorldXYPlane()\r\n            distance = rs.DistanceToPlane(plane, point)\r\n            vecNorm = rs.VectorScale(vecNorm, 1.4)\r\n            #add to srfNorm01\r\n            srfNorm01[(i,j)] = rs.PointAdd(vecNorm,point)\r\n            #unitize and scale vector\r\n            vecNorm= rs.VectorUnitize(vecNorm)\r\n            vecNorm = rs.VectorScale(vecNorm, 1)\r\n            #add to srfNorm02\r\n            srfNorm02[(i,j)] = rs.PointAdd(vecNorm,point)\r\n            \r\n    #call function to generate geometry\r\n    GenerateGeometry(ptMTX, srfNorm02, srfNorm01, INTU, INTV)\r\n\r\ndef   GenerateGeometry(ptMTX, srfNorm02, srfNorm01, INTU, INTV):\r\n    #LOOP TO GENERATE GEOMETRY\r\n        for i in range(INTU + 1):\r\n            for j in range(INTV + 1):\r\n                if i > 0 and  j > 0 :\r\n                    ### Create firstCrv Curve ### \r\n                    firstCrv = rs.AddCurve((ptMTX[(i,j-1)],ptMTX[(i,j)],ptMTX[(i-1,j)],\r\n                    ptMTX[(i-1,j-1)],ptMTX[(i,j-1)]),1)\r\n                    ### Create secondCrv ###\r\n                    #create construction surface to get grid of points\r\n                    srf = rs.AddSrfPt((srfNorm01[(i,j-1)],srfNorm01[(i,j)],srfNorm01[(i-1,j)],\r\n                    srfNorm01[(i-1,j-1)]))\r\n                    #create grid of points, rebuild to get (3x3) grid\r\n                    rs.RebuildSurface(srf, (3,3), (4,4))\r\n                    #extract points from surface\r\n                    pts = rs.SurfacePoints(srf)\r\n                    rs.DeleteObject(srf)\r\n                    #create curves\r\n                    midpoint01 = MidPt(pts[1], pts[6])\r\n                    midpoint02 = MidPt(pts[13], pts[10])\r\n                    centroid = MidPt(pts[6], pts[9])\r\n                    secondCrv = rs.AddCurve((pts[5], pts[9], midpoint02,pts[10],\r\n                    pts[6],midpoint01, pts[5]),3)\r\n                    #scale curve\r\n                    secondCrv =rs.ScaleObject(secondCrv,centroid ,(1.2,1.2,1.2))\r\n                    ### Create thirdCrv ###\r\n                    #create construction surface\r\n                    srf = rs.AddSrfPt((srfNorm02[(i,j-1)],srfNorm02[(i,j)],srfNorm02[(i-1,j)],\r\n                    srfNorm02[(i-1,j-1)]))\r\n                    #rebuild to get (3x3) grid\r\n                    rs.RebuildSurface(srf, (3,3), (4,4))\r\n                    #extract points from surface\r\n                    pts = rs.SurfacePoints(srf)\r\n                    rs.DeleteObject(srf)\r\n                    #create curves\r\n                    midpoint01 = MidPt(pts[1], pts[6])\r\n                    midpoint02 = MidPt(pts[13], pts[10])\r\n                    centroid = MidPt(pts[6], pts[9])\r\n                    thirdCrv = rs.AddCurve((pts[5], pts[9], midpoint02,pts[10],\r\n                    pts[6],midpoint01, pts[5]),3)\r\n                    #scale curve\r\n                    thirdCurve = rs.ScaleObject(thirdCrv, centroid,(0.7,0.7,0.7))\r\n                    ### CREATE MODULE USING LOFT ###\r\n                    #flip direction of curves\r\n                    #rs.ReverseCurve(firstCrv)\r\n                    #rs.ReverseCurve(secondCrv)\r\n                    #rs.ReverseCurve(thirdCrv)\r\n                    #loft curves to create surfaces\r\n                    module = rs.AddLoftSrf((firstCrv,secondCrv,thirdCrv), None, None,1,0)\r\n                    \r\n                    #add color to module\r\n                    #rs.ObjectColor(module, (255/INTU*i, 255-(255/INTU)*i,255/INTU*i))\r\n                    \r\n                    rs.DeleteObjects((firstCrv,secondCrv,thirdCurve))\r\n\r\ndef MidPt(PT01, PT02):\r\n    \r\n    point = None\r\n    point = [(PT01[0] + PT02[0])/2,(PT01[1] + PT02[1])/2,(PT01[2] + PT02[2])/2]\r\n    return point\r\n\r\ndef DivideExponentially(maxLength, Divisions):\r\n    #set-up lists\r\n    point = []\r\n    yVal = []\r\n    \r\n    #create point where x is .72 of Vdomain and y and z are 0 (point[0])\r\n    pt = ([(maxLength*.72), 0, 0])\r\n    #rs.AddPoint(pt)\r\n    point.append(pt)\r\n    \r\n    #create point where x and y are .12 of model curve length and z is 0 (point[1])\r\n    pt = ([(maxLength*.12), (maxLength*.12), 0])\r\n    #rs.AddPoint(pt)\r\n    point.append(pt)\r\n    \r\n    #create point where y is model curve length and x and z are 0 (point[2])\r\n    pt = ([0, maxLength, 0])\r\n    #rs.AddPoint(pt)\r\n    point.append(pt)\r\n    \r\n    #draw a curve between the three points (GRAPHcrvGUID)\r\n    GRAPHcrvGUID = rs.AddCurve(point)\r\n    \r\n    #divide (GRAPHcrvGUID)\r\n    GRAPHpoints = rs.DivideCurve(GRAPHcrvGUID, Divisions, False, True)\r\n    \r\n    #delete curve\r\n    rs.DeleteObject(GRAPHcrvGUID)\r\n    \r\n    #collect y values in a list\r\n    for i in range(len(GRAPHpoints)):\r\n        yVal.append(GRAPHpoints[i][1])\r\n        \r\n    return yVal\r\n                  \r\ndef main():\r\n    #collect data\r\n    #strSRF = rs.GetObject('select surface', rs.filter.surface)\r\n    strSRFs = rs.GetObjects('select surfaces', rs.filter.surface)\r\n    intU = rs.GetInteger('how many U intervals?', 8)\r\n    intV = rs.GetInteger('how many V intervals?', 2)\r\n    #    rs.HideObject(strSRF)\r\n    #    #call function\r\n    #    rs.EnableRedraw(False)\r\n    #    SurfacePoints(strSRF, intU, intV)\r\n    #    rs.EnableRedraw(True)\r\n    \r\n    #call function with multiple surfaces\r\n    rs.EnableRedraw(False)\r\n    for strSRF in strSRFs:\r\n        rs.HideObject(strSRF)\r\n        #call function\r\n        SurfacePoints(strSRF, intU, intV)\r\n    rs.EnableRedraw(True)\r\n\r\nmain()",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}