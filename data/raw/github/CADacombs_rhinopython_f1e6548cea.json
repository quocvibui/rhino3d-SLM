{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Crv_convertToPiecewiseBeziers.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Crv_convertToPiecewiseBeziers.py",
  "instruction": "This script will convert a curve in a Piecewise-Bezier NurbsCurve and set all\r\nspan domains so that consecutive spans have parametrically-matched domains as so:\r\n\r\nStarting with the second...",
  "code": "\"\"\"\r\nThis script will convert a curve in a Piecewise-Bezier NurbsCurve and set all\r\nspan domains so that consecutive spans have parametrically-matched domains as so:\r\n\r\nStarting with the second span/segment (M), with R as the previous span/segment,\r\nthis script will match the domain of M so that \r\nD(M) = D(R) * (L(M) / L(R))\r\nwhere\r\nD is the end span domain length\r\nL is the distance between the end control point and next control point\r\n\r\nThe resultant NurbsCurve will allow knot removal with less curve deviation than\r\na non-domain matched version.\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n#! python 2\r\n\r\n\"\"\"\r\n240107: Created.\r\n240116: Bug fix.\r\n240813: Raised tolerance threshold before parameter matching.\r\n240814: Now can output PolyCurves or individual Bezier (single-spanned) NurbsCurves.\r\n\r\nTODO: Add option for resultant curve to be a PolyCurve instead of a NurbsCurve.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\n\r\n\r\nclass Opts():\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bExplode'; keys.append(key)\r\n    values[key] = True\r\n    # names[key] = 'ExplodeToBeziers'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bNurbs_NotPoly'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'Curve'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Poly', 'Nurbs')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDeleteInput'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get curve with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select curves\")\r\n\r\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Curve\r\n    go.GeometryAttributeFilter = ri.Custom.GeometryAttributeFilter.WireCurve\r\n\r\n    idxs_Opt = {}\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        addOption('bExplode')\r\n        if not Opts.values['bExplode']:\r\n            addOption('bNurbs_NotPoly')\r\n        addOption('bDeleteInput')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef formatDistance(fDistance, iPrecision=15):\r\n    if fDistance is None: return \"(No deviation provided)\"\r\n    \r\n    if fDistance < 0.01:\r\n        return \"{:.{}e}\".format(fDistance, iPrecision)\r\n    \r\n    if fDistance < 0.1:\r\n        return \"{:.{}g}\".format(fDistance, iPrecision+1)\r\n    \r\n    return \"{:.{}g}\".format(fDistance, iPrecision)\r\n\r\n\r\ndef createCrvs(rgCrv_In, bExplode, bNurbs_NotPoly, bDebug=False):\r\n    \"\"\"\r\n    Returns on success: rg.NurbsCurve, None\r\n    Returns on fail: None, str(Log)\r\n    \"\"\"\r\n\r\n    if isinstance(rgCrv_In, rg.PolyCurve):\r\n        rgC_WIP = rgCrv_In.CleanUp()\r\n        if rgC_WIP is None:\r\n            rgC_WIP = rgCrv_In.DuplicateCurve()\r\n    else:\r\n        rgC_WIP = rgCrv_In.DuplicateCurve()\r\n\r\n    if isinstance(rgC_WIP, (rg.ArcCurve, rg.LineCurve, rg.PolylineCurve)):\r\n        rgC_WIP.Dispose()\r\n        return None, \"{} was skipped.\".format(rgC_WIP.GetType().Name)\r\n\r\n    if rgC_WIP.SpanCount == 1:\r\n        rgC_WIP.Dispose()\r\n        return None, \"{} with single span skipped.\".format(rgC_WIP.GetType().Name)\r\n\r\n\r\n    # Only PolyCurves and multi-span NurbsCurves should remain.\r\n\r\n    # Check whether PolyCurve has consecutive NurbsCurves.\r\n    if isinstance(rgC_WIP, rg.NurbsCurve):\r\n        nc_WIP = rgC_WIP\r\n    elif isinstance(rgC_WIP, rg.PolyCurve):\r\n        idx_LastNurbs = None\r\n        for i in range(rgC_WIP.SegmentCount):\r\n            seg = rgC_WIP.SegmentCurve(i)\r\n            if isinstance(seg, rg.NurbsCurve):\r\n                if seg.SpanCount > 1:\r\n                    break # out of for loop.\r\n                else:\r\n                    if idx_LastNurbs is None:\r\n                        idx_LastNurbs = i\r\n                    else:\r\n                        if idx_LastNurbs == (i - 1):\r\n                            # Consecutive NurbsCurves found.\r\n                            break # out of for loop.\r\n        else:\r\n            rgC_WIP.Dispose()\r\n            return None, \"No segments in PolyCurve are multi-span NURBS.\"\r\n        nc_WIP = rgC_WIP.ToNurbsCurve()\r\n        rgC_WIP.Dispose()\r\n    else:\r\n        raise Exception(\"{}!\".format(rgC_WIP.GetType().Name))\r\n\r\n    # nc_WIP is now a multi-span NurbsCurve.\r\n\r\n    ncs_Beziers = [bc.ToNurbsCurve() for bc in rg.BezierCurve.CreateBeziers(nc_WIP)]\r\n\r\n\r\n    for i in range(1, len(ncs_Beziers)):\r\n        nc_R = ncs_Beziers[i-1] # Reference.\r\n        nc_M = ncs_Beziers[i] # To modify.\r\n\r\n        deg_R = nc_R.Degree\r\n        deg_M = nc_M.Degree\r\n\r\n        #sEval = \"deg_R\"; print(sEval+':',eval(sEval))\r\n        #sEval = \"deg_M\"; print(sEval+':',eval(sEval))\r\n\r\n        domain_R = nc_R.Domain\r\n        idxCp_Pos_R = nc_R.Points.Count - 1\r\n        idxCp_Tan_R = nc_R.Points.Count - 2\r\n        pt_Pos_R = nc_R.Points[idxCp_Pos_R].Location\r\n        pt_Tan_R = nc_R.Points[idxCp_Tan_R].Location\r\n        fDist_CPs_R = pt_Pos_R.DistanceTo(pt_Tan_R)\r\n\r\n        domain_M_Pre = nc_M.Domain\r\n        idxCp_Pos_M = 0\r\n        idxCp_Tan_M = 1\r\n        pt_Pos_M = nc_M.Points[idxCp_Pos_M].Location\r\n        pt_Tan_M = nc_M.Points[idxCp_Tan_M].Location\r\n        fDist_CPs_M = pt_Pos_M.DistanceTo(pt_Tan_M)\r\n\r\n\r\n        # D(A) = D(R) * (L(A) / L(R))\r\n\r\n        m = (\r\n            (domain_R.Length / domain_M_Pre.Length) * \r\n            (fDist_CPs_M / fDist_CPs_R)\r\n            )\r\n\r\n        if bDebug:\r\n            sEval = \"m\"; print(\"{}: {}\".format(sEval, formatDistance(eval(sEval))))\r\n            sEval = \"m - 1.0\"; print(\"{}: {}\".format(sEval, formatDistance(eval(sEval))))\r\n\r\n        if abs(m - 1.0) == 0.0:\r\n            if bDebug: print(\"Domains already exactly match.\")\r\n            continue\r\n        if abs(m - 1.0) <= 2**-53:\r\n            if bDebug:\r\n                print(\"Domains already match within {} (machine epsilon/2.0).\".format(\r\n                    formatDistance(2**-53)))\r\n            continue\r\n        if abs(m - 1.0) <= 2**-52:\r\n            if bDebug:\r\n                print(\"Domains already match within {} (machine epsilon).\".format(\r\n                    formatDistance(2**-52)))\r\n            continue\r\n        if abs(m - 1.0) <= 2**-51:\r\n            if bDebug:\r\n                print(\"Domains already match within {}.\".format(\r\n                    formatDistance(2**-51)))\r\n            continue\r\n        if abs(m - 1.0) <= 2**-50:\r\n            if bDebug:\r\n                print(\"Domains already match within {}.\".format(\r\n                    formatDistance(2**-50)))\r\n            continue\r\n        #if abs(m - 1.0) <= Rhino.RhinoMath.ZeroTolerance:\r\n        #    if bDebug:\r\n        #        print(\"Domains already match within {}.\".format(\r\n        #            formatDistance(abs(m - 1.0))))\r\n        #    continue\r\n\r\n        if bDebug:\r\n            print(\"Domain length multiplier to apply: {}\".format(\r\n                formatDistance(m)))\r\n\r\n        length_Domain_M_Out = domain_M_Pre.Length * m\r\n        nc_M.Domain = rg.Interval(0.0, length_Domain_M_Out)\r\n        domain_M_Post = nc_M.Domain\r\n\r\n    if bExplode:\r\n        return ncs_Beziers, None\r\n\r\n    pcs = rg.Curve.JoinCurves(ncs_Beziers, joinTolerance=1e-6, preserveDirection=True)\r\n\r\n    if len(pcs) != 1:\r\n        raise Exception(\"{} curves returned from Curve.JoinCurves.\".format(len(pcs)))\r\n\r\n    pc_Res = pcs[0]\r\n\r\n    if not bNurbs_NotPoly:\r\n        return [pc_Res], None\r\n\r\n    nc_Out = pc_Res.ToNurbsCurve()\r\n    pc_Res.Dispose()\r\n\r\n    return [nc_Out], None\r\n\r\n\r\ndef processCurveObject(rhCrv_In, bExplode, bNurbs_NotPoly, bDeleteInput, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    rdCrv_In = rs.coercerhinoobject(rhCrv_In) # IsDocumentControlled.\r\n    rgCrv_In = rdCrv_In.Geometry # IsDocumentControlled.\r\n\r\n    cs_Res, sLog = createCrvs(\r\n        rgCrv_In,\r\n        bExplode=bExplode,\r\n        bNurbs_NotPoly=bNurbs_NotPoly,\r\n        bDebug=bDebug,\r\n        )\r\n    if not cs_Res:\r\n        return None, sLog\r\n\r\n    gOuts = []\r\n    sOuts = []\r\n\r\n    bAllAddSuccess = True\r\n\r\n    if bDeleteInput:\r\n        if len(cs_Res) == 1:\r\n            if not sc.doc.Objects.Replace(objectId=rdCrv_In.Id, curve=cs_Res[0]):\r\n                sOut = \"Replace failed.\"\r\n                if bEcho: print(sOut)\r\n                return None, sOut\r\n            sOuts.append(\"Curve was replaced\")\r\n        else:\r\n            for c in cs_Res:\r\n                gOut = sc.doc.Objects.AddCurve(c)\r\n                if gOut != gOut.Empty:\r\n                    gOuts.append(gOut)\r\n                    sOuts.append(\"Curve was added.\")\r\n                else:\r\n                    bAllAddSuccess = False\r\n                    sOuts.append(\"AddCurve failed.\")\r\n            if bAllAddSuccess:\r\n                sc.doc.Objects.Delete(rdCrv_In)\r\n                # sOut = \"Curve was replaced.\"\r\n    else:\r\n        # bDeleteInput == False\r\n        for c in cs_Res:\r\n            gOut = sc.doc.Objects.AddCurve(c)\r\n            if gOut != gOut.Empty:\r\n                gOuts.append(gOut)\r\n                sOuts.append(\"Curve was added.\")\r\n            else:\r\n                bAllAddSuccess = False\r\n                sOuts.append(\"AddCurve failed.\")\r\n\r\n    if not bAllAddSuccess:\r\n        return gOuts, sOuts\r\n\r\n    # if sc.doc.Objects.Select(gOut):\r\n    #     sOut += \" and is selected.\"\r\n    # else:\r\n    #     sOut += \" but could not be selected.\"\r\n\r\n    # if bEcho: print(sOut)\r\n\r\n    return gOuts, sOuts\r\n\r\n\r\ndef main():\r\n\r\n    objrefs = getInput()\r\n    if objrefs is None: return\r\n\r\n    bExplode = Opts.values['bExplode']\r\n    bNurbs_NotPoly = Opts.values['bNurbs_NotPoly']\r\n    bDeleteInput = Opts.values['bDeleteInput']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    gCrvs_Res = []\r\n    sLogs = []\r\n\r\n    for objref in objrefs:\r\n        rc = processCurveObject(\r\n            objref,\r\n            bExplode=bExplode,\r\n            bNurbs_NotPoly=bNurbs_NotPoly,\r\n            bDeleteInput=bDeleteInput,\r\n            bEcho=bEcho if len(objrefs) == 1 else False,\r\n            bDebug=bDebug,\r\n            )\r\n        if rc is None: continue\r\n        gCrvs_Res.extend(rc[0])\r\n        sLogs.extend(rc[1])\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n    if bEcho and sLogs:\r\n        if len(sLogs) == 1:\r\n            print(sLogs[0])\r\n        else:\r\n            for sLog in set(sLogs):\r\n                print(\"[{}] {}\".format(sLogs.count(sLog), sLog))\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}