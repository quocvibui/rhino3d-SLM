{
  "source_url": "https://github.com/0000onoff/Projekt-HS24/blob/8a5cd818ae9ed6e0128f64dcd94d646e8e797503/ironpython-stubs-master/release/stubs.min/Rhino/Input/Custom.py",
  "repo": "0000onoff/Projekt-HS24",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "ironpython-stubs-master/release/stubs.min/Rhino/Input/Custom.py",
  "instruction": "NamespaceTracker represent a CLS namespace.",
  "code": "# encoding: utf-8\n# module Rhino.Input.Custom calls itself Custom\n# from RhinoCommon,Version=5.1.30000.16,Culture=neutral,PublicKeyToken=552281e97c755530\n# by generator 1.145\n\"\"\" NamespaceTracker represent a CLS namespace. \"\"\"\n# no imports\n\n# no functions\n# classes\n\nclass CommandLineOption(object):\n # no doc\n @staticmethod\n def IsValidOptionName(optionName):\n  \"\"\"\n  IsValidOptionName(optionName: str) -> bool\n\n  \n\n   Test a string to see if it can be used as an option name in any of the \n\n    RhinoGet::AddCommandOption...() functions.\n\n  \n\n  \n\n   optionName: The string to be tested.\n\n   Returns: true if string can be used as an option name.\n  \"\"\"\n  pass\n @staticmethod\n def IsValidOptionValueName(optionValue):\n  \"\"\"\n  IsValidOptionValueName(optionValue: str) -> bool\n\n  \n\n   Test a string to see if it can be used as an option value in RhinoGet::AddCommandOption,\n\n      \n\n      RhinoGet::AddCommandOptionToggle,or RhinoGet::AddCommandOptionList.\n\n  \n\n  \n\n   optionValue: The string to be tested.\n\n   Returns: true if string can be used as an option value.\n  \"\"\"\n  pass\n CurrentListOptionIndex=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: CurrentListOptionIndex(self: CommandLineOption) -> int\n\n\n\n\"\"\"\n\n EnglishName=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: EnglishName(self: CommandLineOption) -> str\n\n\n\n\"\"\"\n\n Index=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: Index(self: CommandLineOption) -> int\n\n\n\n\"\"\"\n\n\n\nclass GeometryAttributeFilter(Enum,IComparable,IFormattable,IConvertible):\n \"\"\"\n If an object passes the geometry TYPE filter,then the geometry ATTRIBUTE\n\n    filter is applied.\n\n \n\n enum (flags) GeometryAttributeFilter,values: AcceptAllAttributes (4294967295),BoundaryEdge (384),BoundaryInnerLoop (2097152),BoundaryOuterLoop (8388608),ClosedCurve (4),ClosedMesh (524288),ClosedPolysrf (131072),ClosedSurface (512),EdgeCurve (2),InnerLoop (6291456),ManifoldEdge (32),ManifoldPolysrf (32768),MatedEdge (112),MatedInnerLoop (4194304),MatedOuterLoop (16777216),NonmanifoldEdge (64),NonmanifoldPolysrf (65536),OpenCurve (8),OpenMesh (1048576),OpenPolysrf (262144),OpenSurface (1024),OuterLoop (25165824),SeamEdge (16),SpecialLoop (33554432),SubSurface (8192),SurfaceBoundaryEdge (128),TopSurface (16384),TrimmedSurface (2048),TrimmingBoundaryEdge (256),UntrimmedSurface (4096),WireCurve (1)\n \"\"\"\n def __eq__(self,*args):\n  \"\"\" x.__eq__(y) <==> x==yx.__eq__(y) <==> x==yx.__eq__(y) <==> x==y \"\"\"\n  pass\n def __format__(self,*args):\n  \"\"\" __format__(formattable: IFormattable,format: str) -> str \"\"\"\n  pass\n def __ge__(self,*args):\n  pass\n def __gt__(self,*args):\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __le__(self,*args):\n  pass\n def __lt__(self,*args):\n  pass\n def __ne__(self,*args):\n  pass\n def __reduce_ex__(self,*args):\n  pass\n def __str__(self,*args):\n  pass\n AcceptAllAttributes=None\n BoundaryEdge=None\n BoundaryInnerLoop=None\n BoundaryOuterLoop=None\n ClosedCurve=None\n ClosedMesh=None\n ClosedPolysrf=None\n ClosedSurface=None\n EdgeCurve=None\n InnerLoop=None\n ManifoldEdge=None\n ManifoldPolysrf=None\n MatedEdge=None\n MatedInnerLoop=None\n MatedOuterLoop=None\n NonmanifoldEdge=None\n NonmanifoldPolysrf=None\n OpenCurve=None\n OpenMesh=None\n OpenPolysrf=None\n OpenSurface=None\n OuterLoop=None\n SeamEdge=None\n SpecialLoop=None\n SubSurface=None\n SurfaceBoundaryEdge=None\n TopSurface=None\n TrimmedSurface=None\n TrimmingBoundaryEdge=None\n UntrimmedSurface=None\n value__=None\n WireCurve=None\n\n\nclass GetBaseClass(object,IDisposable):\n \"\"\"\n Base class for GetObject,GetPoint,GetSphere,etc.\n\n    \n\n    You will never directly create a GetBaseClass but you will use its member\n\n    functions after calling GetObject.Gets(),GetPoint.Get(),and so on.\n\n    \n\n    Provides tools to set command prompt,set command options,and specify\n\n    if the \"get\" can optionally accept numbers,nothing (pressing enter),\n\n    and undo.\n \"\"\"\n def AcceptColor(self,enable):\n  \"\"\"\n  AcceptColor(self: GetBaseClass,enable: bool)\n\n   If you want to allow the user to be able to type in a color r,g,b or name\n\n     during \n\n    GetPoint.Get(),GetObject::GetObjects(),etc.,then call AcceptColor(true)\n\n     before \n\n    calling GetPoint()/GetObject(). If the user chooses to type in a color,\n\n     then the \n\n    result code GetResult.Color is returned and you can use RhinoGet.Color()\n\n     to get the \n\n    value of the color.  If the get accepts points,then the user will not\n\n     be able to \n\n    type in r,g,b colors but will be able to type color names.\n\n  \n\n  \n\n   enable: true if user is able to type a color.\n  \"\"\"\n  pass\n def AcceptCustomMessage(self,enable):\n  \"\"\" AcceptCustomMessage(self: GetBaseClass,enable: bool) \"\"\"\n  pass\n def AcceptNothing(self,enable):\n  \"\"\"\n  AcceptNothing(self: GetBaseClass,enable: bool)\n\n   If you want to allow the user to be able to press enter in order to\n\n     skip selecting \n\n    a something in GetPoint.Get(),GetObject::GetObjects(),\n\n     etc.,then call \n\n    AcceptNothing( true ) beforehand.\n\n  \n\n  \n\n   enable: true if user is able to press enter in order to skip selecting.\n  \"\"\"\n  pass\n def AcceptNumber(self,enable,acceptZero):\n  \"\"\"\n  AcceptNumber(self: GetBaseClass,enable: bool,acceptZero: bool)\n\n   If you want to allow the user to be able to type in a number during GetPoint.Get(),\n\n     \n\n    GetObject::GetObjects(),etc.,then call AcceptNumber() beforehand.\n\n     If the user \n\n    chooses to type in a number,then the result code GetResult.Number is\n\n     returned and \n\n    you can use RhinoGet.Number() to get the value of the number. If you\n\n     are using \n\n    GetPoint and you want \"0\" to return (0,0,0) instead of the number zero,\n\n     then set \n\n    acceptZero=false.\n\n  \n\n  \n\n   enable: true if user is able to type a number.\n\n   acceptZero: If you are using GetPoint and you want \"0\" to return (0,0,0) instead of the number zero,\n\n     \n\n       then set acceptZero=false.\n  \"\"\"\n  pass\n def AcceptPoint(self,enable):\n  \"\"\"\n  AcceptPoint(self: GetBaseClass,enable: bool)\n\n   If you want to allow the user to be able to type in a point then call AcceptPoint(true)\n\n    \n\n     before calling GetPoint()/GetObject(). If the user chooses to type in a number,then\n\n      \n\n      the result code GetResult.Point is returned and you can use RhinoGet.Point()\n\n     \n\n    to get the value of the point.\n\n  \n\n  \n\n   enable: true if user is able to type in a point.\n  \"\"\"\n  pass\n def AcceptString(self,enable):\n  \"\"\"\n  AcceptString(self: GetBaseClass,enable: bool)\n\n   If you want to allow the user to be able to type in a string during GetPoint.Get(),\n\n     \n\n    GetObject::GetObjects(),etc.,then call AcceptString(true) before calling\n\n     \n\n    GetPoint()/GetObject(). If the user chooses to type in a string,then the result code\n\n      \n\n      GetResult.String is returned and you can use RhinoGet.String() to get the value of the string.\n\n  \n\n  \n\n   enable: true if user is able to type a string.\n  \"\"\"\n  pass\n def AcceptUndo(self,enable):\n  \"\"\"\n  AcceptUndo(self: GetBaseClass,enable: bool)\n\n   If you want to allow the user to have an 'undo' option in GetPoint.Get(),\n\n     \n\n    GetObject.GetObjects(),etc.,then call AcceptUndo(true) beforehand.\n\n  \n\n  \n\n   enable: true if user is able to choose the 'Undo' option.\n  \"\"\"\n  pass\n def AddOption(self,*__args):\n  \"\"\"\n  AddOption(self: GetBaseClass,optionName: LocalizeStringPair) -> int\n\n  \n\n   Adds a command line option.\n\n  \n\n   optionName: Must only consist of letters and numbers (no characters list periods,spaces,or dashes)\n\n   Returns: option index value (>0) or 0 if option cannot be added.\n\n  AddOption(self: GetBaseClass,optionName: LocalizeStringPair,optionValue: LocalizeStringPair) -> int\n\n  \n\n   Adds a command line option.\n\n  \n\n   optionName: Must only consist of letters and numbers (no characters list periods,spaces,or dashes)\n\n   optionValue: The localized value visualized after an equality sign.\n\n   Returns: option index value (>0) or 0 if option cannot be added.\n\n  AddOption(self: GetBaseClass,englishOption: str) -> int\n\n  \n\n   Adds a command line option.\n\n  \n\n   englishOption: Must only consist of letters and numbers (no characters list periods,spaces,or dashes)\n\n   Returns: option index value (>0) or 0 if option cannot be added.\n\n  AddOption(self: GetBaseClass,englishOption: str,englishOptionValue: str) -> int\n\n  \n\n   Adds a command line option.\n\n  \n\n   englishOption: Must only consist of letters and numbers (no characters list periods,spaces,or dashes)\n\n   englishOptionValue: The option value in English,visualized after an equality sign.\n\n   Returns: Option index value (>0) or 0 if option cannot be added.\n  \"\"\"\n  pass\n def AddOptionColor(self,*__args):\n  \"\"\"\n  AddOptionColor(self: GetBaseClass,englishName: str,colorValue: OptionColor,prompt: str) -> (int,OptionColor)\n\n  \n\n   Add a command line option to get colors and automatically save the value.\n\n  \n\n   englishName: option description\n\n   colorValue: The current color value.\n\n   prompt: The command prompt will show this during picking.\n\n   Returns: option index value (>0) or 0 if option cannot be added.\n\n  AddOptionColor(self: GetBaseClass,englishName: str,colorValue: OptionColor) -> (int,OptionColor)\n\n  \n\n   Add a command line option to get colors and automatically save the value.\n\n  \n\n   englishName: option description\n\n   colorValue: The current color value.\n\n   Returns: option index value (>0) or 0 if option cannot be added.\n\n  AddOptionColor(self: GetBaseClass,optionName: LocalizeStringPair,colorValue: OptionColor,prompt: str) -> (int,OptionColor)\n\n  \n\n   Add a command line option to get colors and automatically save the value.\n\n  \n\n   optionName: option description.\n\n   colorValue: The current color value.\n\n   prompt: option prompt shown if the user selects this option\n\n   Returns: option index value (>0) or 0 if option cannot be added.\n\n  AddOptionColor(self: GetBaseClass,optionName: LocalizeStringPair,colorValue: OptionColor) -> (int,OptionColor)\n\n  \n\n   Add a command line option to get colors and automatically save the value.\n\n  \n\n   optionName: option description\n\n   colorValue: The current color value.\n\n   Returns: option index value (>0) or 0 if option cannot be added.\n  \"\"\"\n  pass\n def AddOptionDouble(self,*__args):\n  \"\"\"\n  AddOptionDouble(self: GetBaseClass,englishName: str,numberValue: OptionDouble) -> (int,OptionDouble)\n\n  \n\n   Adds a command line option to get numbers and automatically save the value.\n\n  \n\n   englishName: Must only consist of letters and numbers (no characters list periods,spaces,or dashes)\n\n   numberValue: The current number value.\n\n   Returns: Option index value (>0) or 0 if option cannot be added.\n\n  AddOptionDouble(self: GetBaseClass,optionName: LocalizeStringPair,numberValue: OptionDouble) -> (int,OptionDouble)\n\n  \n\n   Adds a command line option to get numbers and automatically save the value.\n\n  \n\n   optionName: Must only consist of letters and numbers (no characters list periods,spaces,or dashes)\n\n   numberValue: The current number value.\n\n   Returns: option index value (>0) or 0 if option cannot be added.\n\n  AddOptionDouble(self: GetBaseClass,englishName: str,numberValue: OptionDouble,prompt: str) -> (int,OptionDouble)\n\n  \n\n   Adds a command line option to get numbers and automatically save the value.\n\n  \n\n   englishName: Must only consist of letters and numbers (no characters list periods,spaces,or dashes)\n\n   numberValue: Current value.\n\n   prompt: option prompt shown if the user selects this option.  If null or empty,then the\n\n     \n\n    option name is used as the get number prompt.\n\n  \n\n   Returns: option index value (>0) or 0 if option cannot be added.\n\n  AddOptionDouble(self: GetBaseClass,optionName: LocalizeStringPair,numberValue: OptionDouble,prompt: str) -> (int,OptionDouble)\n\n  \n\n   Adds a command line option to get numbers and automatically saves the value.\n\n  \n\n   optionName: Must only consist of letters and numbers (no characters list periods,spaces,or dashes)\n\n   numberValue: The current number value.\n\n   prompt: option prompt shown if the user selects this option.  If null or empty,then the\n\n     \n\n    option name is used as the get number prompt.\n\n  \n\n   Returns: option index value (>0) or 0 if option cannot be added.\n  \"\"\"\n  pass\n def AddOptionEnumList(self,englishOptionName,defaultValue):\n  \"\"\" AddOptionEnumList[T](self: GetBaseClass,englishOptionName: str,defaultValue: T) -> int \"\"\"\n  pass\n def AddOptionEnumSelectionList(self,englishOptionName,enumSelection,listCurrentIndex):\n  \"\"\" AddOptionEnumSelectionList[T](self: GetBaseClass,englishOptionName: str,enumSelection: IEnumerable[T],listCurrentIndex: int) -> int \"\"\"\n  pass\n def AddOptionInteger(self,*__args):\n  \"\"\"\n  AddOptionInteger(self: GetBaseClass,englishName: str,intValue: OptionInteger) -> (int,OptionInteger)\n\n  \n\n   Adds a command line option to get integers and automatically save the value.\n\n  \n\n   englishName: Must only consist of letters and numbers (no characters list periods,spaces,or dashes)\n\n   intValue: The current integer value.\n\n   Returns: option index value (>0) or 0 if option cannot be added.\n\n  AddOptionInteger(self: GetBaseClass,optionName: LocalizeStringPair,intValue: OptionInteger) -> (int,OptionInteger)\n\n  \n\n   Adds a command line option to get integers and automatically save the value.\n\n  \n\n   optionName: Must only consist of letters and numbers (no characters list periods,spaces,or dashes)\n\n   intValue: The current integer value.\n\n   Returns: option index value (>0) or 0 if option cannot be added.\n\n  AddOptionInteger(self: GetBaseClass,englishName: str,intValue: OptionInteger,prompt: str) -> (int,OptionInteger)\n\n  \n\n   Adds a command line option to get integers and automatically save the value.\n\n  \n\n   englishName: Must only consist of letters and numbers (no characters list periods,spaces,or dashes)\n\n   intValue: The current integer value.\n\n   prompt: option prompt shown if the user selects this option.  If null or empty,then the\n\n     \n\n    option name is used as the get number prompt.\n\n  \n\n   Returns: option index value (>0) or 0 if option cannot be added.\n\n  AddOptionInteger(self: GetBaseClass,optionName: LocalizeStringPair,intValue: OptionInteger,prompt: str) -> (int,OptionInteger)\n\n  \n\n   Adds a command line option to get integers and automatically save the value.\n\n  \n\n   optionName: Must only consist of letters and numbers (no characters list periods,spaces,or dashes)\n\n   intValue: The current integer value.\n\n   prompt: option prompt shown if the user selects this option.  If null or empty,then the\n\n     \n\n    option name is used as the get number prompt.\n\n  \n\n   Returns: option index value (>0) or 0 if option cannot be added.\n  \"\"\"\n  pass\n def AddOptionList(self,*__args):\n  \"\"\"\n  AddOptionList(self: GetBaseClass,optionName: LocalizeStringPair,listValues: IEnumerable[LocalizeStringPair],listCurrentIndex: int) -> int\n\n  AddOptionList(self: GetBaseClass,englishOptionName: str,listValues: IEnumerable[str],listCurrentIndex: int) -> int\n  \"\"\"\n  pass\n def AddOptionToggle(self,*__args):\n  \"\"\"\n  AddOptionToggle(self: GetBaseClass,optionName: LocalizeStringPair,toggleValue: OptionToggle) -> (int,OptionToggle)\n\n  \n\n   Adds a command line option to toggle a setting.\n\n  \n\n   optionName: Must only consist of letters and numbers (no characters list periods,spaces,or dashes)\n\n   toggleValue: The current toggle value.\n\n   Returns: option index value (>0) or 0 if option cannot be added.\n\n  AddOptionToggle(self: GetBaseClass,englishName: str,toggleValue: OptionToggle) -> (int,OptionToggle)\n\n  \n\n   Adds a command line option to toggle a setting.\n\n  \n\n   englishName: Must only consist of letters and numbers (no characters list periods,spaces,or dashes)\n\n   toggleValue: The current toggle value.\n\n   Returns: option index value (>0) or 0 if option cannot be added.\n  \"\"\"\n  pass\n def ClearCommandOptions(self):\n  \"\"\"\n  ClearCommandOptions(self: GetBaseClass)\n\n   Clear all command options.\n  \"\"\"\n  pass\n def ClearDefault(self):\n  \"\"\"\n  ClearDefault(self: GetBaseClass)\n\n   Clears any defaults set using SetDefaultPoint,SetDefaultNumber,SetDefaultString,or \n\n    SetCommandPromptDefault.\n  \"\"\"\n  pass\n def Color(self):\n  \"\"\"\n  Color(self: GetBaseClass) -> Color\n\n  \n\n   Gets a color if Get*() returns GetResult.Color.\n\n   Returns: The color chosen by the user.\n  \"\"\"\n  pass\n def CommandResult(self):\n  \"\"\"\n  CommandResult(self: GetBaseClass) -> Result\n\n  \n\n   Helper method for getting command result value from getter results.\n\n   Returns: The converted command result.\n  \"\"\"\n  pass\n def CustomMessage(self):\n  \"\"\" CustomMessage(self: GetBaseClass) -> object \"\"\"\n  pass\n def Dispose(self):\n  \"\"\" Dispose(self: GetBaseClass) \"\"\"\n  pass\n def EnableTransparentCommands(self,enable):\n  \"\"\"\n  EnableTransparentCommands(self: GetBaseClass,enable: bool)\n\n   Control the availability of transparent commands during the get.\n\n  \n\n   enable: If true,then transparent commands can be run during the get.\n\n     If false,then \n\n    transparent commands cannot be run during the get.\n  \"\"\"\n  pass\n def GetSelectedEnumValue(self):\n# Error generating skeleton for function GetSelectedEnumValue: Method must be called on a Type for which Type.IsGenericParameter is false.\n\n def GetSelectedEnumValueFromSelectionList(self,selectionList):\n# Error generating skeleton for function GetSelectedEnumValueFromSelectionList: Method must be called on a Type for which Type.IsGenericParameter is false.\n\n def GotDefault(self):\n  \"\"\"\n  GotDefault(self: GetBaseClass) -> bool\n\n  \n\n   Returns true if user pressed Enter to accept a default point,number,\n\n     or string set \n\n    using SetDefaultPoint,SetDefaultNumber,or SetDefaultString.\n\n  \n\n   Returns: true if the result if the default point,number or string set. Otherwise,false.\n  \"\"\"\n  pass\n def Line2d(self):\n  \"\"\"\n  Line2d(self: GetBaseClass) -> Array[Point]\n\n  \n\n   Returns two points defining the location in the view window of the 2d line selected\n\n     \n\n    in GetPoint::Get2dLine().\n\n     (0,0)=upper left corner of window.\n\n  \n\n   Returns: An array with two 2D points.\n  \"\"\"\n  pass\n def Number(self):\n  \"\"\"\n  Number(self: GetBaseClass) -> float\n\n  \n\n   Gets a number if GetPoint.Get(),GetObject.GetObjects(),etc.,returns GetResult.Number.\n\n   Returns: The number chosen by the user.\n  \"\"\"\n  pass\n def Option(self):\n  \"\"\" Option(self: GetBaseClass) -> CommandLineOption \"\"\"\n  pass\n def OptionIndex(self):\n  \"\"\" OptionIndex(self: GetBaseClass) -> int \"\"\"\n  pass\n def PickRectangle(self):\n  \"\"\"\n  PickRectangle(self: GetBaseClass) -> Rectangle\n\n  \n\n   If the get was a GetObjects() and the mouse was used to select the objects,\n\n     then \n\n    the returned rect has left < right and top < bottom. This rect\n\n     is the Windows GDI \n\n    screen coordinates of the picking rectangle.\n\n     RhinoViewport.GetPickXform( pick_rect,\n\n    pick_xform )\n\n     will calculate the picking transformation that was used.\n\n     \n\n    In all other cases,left=right=top=bottom=0;\n\n  \n\n   Returns: The picking rectangle; or 0 in the specified cases.\n  \"\"\"\n  pass\n def Point(self):\n  \"\"\"\n  Point(self: GetBaseClass) -> Point3d\n\n  \n\n   Gets a point if Get*() returns GetResult.Point.\n\n   Returns: The point chosen by the user.\n  \"\"\"\n  pass\n def Point2d(self):\n  \"\"\"\n  Point2d(self: GetBaseClass) -> Point\n\n  \n\n   Returns location in view of point in selected in GetPoint::Get() or GetPoint::Get2dPoint().\n\n   \n\n      (0,0)=upper left corner of window.\n\n  \n\n   Returns: The location.\n  \"\"\"\n  pass\n @staticmethod\n def PostCustomMessage(messageData):\n  \"\"\" PostCustomMessage(messageData: object) \"\"\"\n  pass\n def Rectangle2d(self):\n  \"\"\"\n  Rectangle2d(self: GetBaseClass) -> Rectangle\n\n  \n\n   Returns the location in the view of the 2d rectangle selected in GetPoint::Get2dRectangle().\n\n     \n\n       rect.left < rect.right and rect.top < rect.bottom\n\n     (0,0)=upper left \n\n    corner of window.\n\n  \n\n   Returns: The rectangle.\n  \"\"\"\n  pass\n def Result(self):\n  \"\"\"\n  Result(self: GetBaseClass) -> GetResult\n\n  \n\n   Returns result of the Get*() call.\n\n   Returns: The result of the last Get*() call.\n  \"\"\"\n  pass\n def SetCommandPrompt(self,prompt):\n  \"\"\"\n  SetCommandPrompt(self: GetBaseClass,prompt: str)\n\n   Sets prompt message that appears in the command prompt window.\n\n  \n\n   prompt: command prompt message.\n  \"\"\"\n  pass\n def SetCommandPromptDefault(self,defaultValue):\n  \"\"\"\n  SetCommandPromptDefault(self: GetBaseClass,defaultValue: str)\n\n   Sets message that describes what default value will be used if the user presses enter.\n\n     \n\n    This description appears in angle brackets <> in the command prompt window. You do\n\n      \n\n      not need to provide a default value description unless you explicity enable AcceptNothing.\n\n  \n\n  \n\n   defaultValue: description of default value.\n  \"\"\"\n  pass\n def SetDefaultColor(self,defaultColor):\n  \"\"\"\n  SetDefaultColor(self: GetBaseClass,defaultColor: Color)\n\n   Sets a color as default value that will be returned if the user presses ENTER key during the get.\n\n  \n\n   defaultColor: value for default color.\n  \"\"\"\n  pass\n def SetDefaultInteger(self,defaultValue):\n  \"\"\"\n  SetDefaultInteger(self: GetBaseClass,defaultValue: int)\n\n   Sets a number as default value that will be returned if the user presses ENTER key during the \n\n    get.\n\n  \n\n  \n\n   defaultValue: value for default number.\n  \"\"\"\n  pass\n def SetDefaultNumber(self,defaultNumber):\n  \"\"\"\n  SetDefaultNumber(self: GetBaseClass,defaultNumber: float)\n\n   Sets a number as default value that will be returned if the user presses ENTER key during the \n\n    get.\n\n  \n\n  \n\n   defaultNumber: value for default number.\n  \"\"\"\n  pass\n def SetDefaultPoint(self,point):\n  \"\"\"\n  SetDefaultPoint(self: GetBaseClass,point: Point3d)\n\n   Sets a point as default value that will be returned if the user presses the ENTER key during the \n\n    get.\n\n  \n\n  \n\n   point: value for default point.\n  \"\"\"\n  pass\n def SetDefaultString(self,defaultValue):\n  \"\"\"\n  SetDefaultString(self: GetBaseClass,defaultValue: str)\n\n   Sets a string as default value that will be returned\n\n     if the user presses ENTER key \n\n    during the get.\n\n  \n\n  \n\n   defaultValue: value for default string.\n  \"\"\"\n  pass\n def SetWaitDuration(self,milliseconds):\n  \"\"\"\n  SetWaitDuration(self: GetBaseClass,milliseconds: int)\n\n   Sets the wait duration (in milliseconds) of the getter. If the duration passes without \n\n    \n\n     the user making a decision,the GetResult.Timeout code is returned.\n\n  \n\n  \n\n   milliseconds: Number of milliseconds to wait.\n  \"\"\"\n  pass\n def StringResult(self):\n  \"\"\"\n  StringResult(self: GetBaseClass) -> str\n\n  \n\n   Gets a string if GetPoint.Get(),GetObject.GetObjects(),etc.,returns GetResult.String.\n\n   Returns: The string chosen by the user.\n  \"\"\"\n  pass\n def Vector(self):\n  \"\"\"\n  Vector(self: GetBaseClass) -> Vector3d\n\n  \n\n   Gets a direction if Get*() returns GetResult.Point (Set by some digitizers,but in general it's \n\n    (0,0,0).\n\n  \n\n   Returns: The vector chosen by the user.\n  \"\"\"\n  pass\n def View(self):\n  \"\"\"\n  View(self: GetBaseClass) -> RhinoView\n\n  \n\n   Gets a view the user clicked in during GetPoint.Get(),GetObject.GetObjects(),etc.\n\n   Returns: The view chosen by the user.\n  \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n\nclass GetFileNameMode(Enum,IComparable,IFormattable,IConvertible):\n \"\"\" enum GetFileNameMode,values: Attach (8),Export (14),Import (7),Open (0),OpenImage (2),OpenRhinoOnly (3),OpenTemplate (1),OpenTextFile (5),OpenWorksession (6),Save (10),SaveImage (13),SaveSmall (11),SaveTemplate (12),SaveTextFile (17),SaveWorksession (18) \"\"\"\n def __eq__(self,*args):\n  \"\"\" x.__eq__(y) <==> x==yx.__eq__(y) <==> x==yx.__eq__(y) <==> x==y \"\"\"\n  pass\n def __format__(self,*args):\n  \"\"\" __format__(formattable: IFormattable,format: str) -> str \"\"\"\n  pass\n def __ge__(self,*args):\n  pass\n def __gt__(self,*args):\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __le__(self,*args):\n  pass\n def __lt__(self,*args):\n  pass\n def __ne__(self,*args):\n  pass\n def __reduce_ex__(self,*args):\n  pass\n def __str__(self,*args):\n  pass\n Attach=None\n Export=None\n Import=None\n Open=None\n OpenImage=None\n OpenRhinoOnly=None\n OpenTemplate=None\n OpenTextFile=None\n OpenWorksession=None\n Save=None\n SaveImage=None\n SaveSmall=None\n SaveTemplate=None\n SaveTextFile=None\n SaveWorksession=None\n value__=None\n\n\nclass GetInteger(GetBaseClass,IDisposable):\n \"\"\"\n Used to get integer numbers.\n\n \n\n GetInteger()\n \"\"\"\n def Dispose(self):\n  \"\"\" Dispose(self: GetBaseClass,disposing: bool) \"\"\"\n  pass\n def Get(self):\n  \"\"\"\n  Get(self: GetInteger) -> GetResult\n\n  \n\n   Call to get an integer.\n\n   Returns: If the user chose a number,then Rhino.Input.GetResult.Number; another enumeration value \n\n    otherwise.\n  \"\"\"\n  pass\n def Number(self):\n  \"\"\" Number(self: GetInteger) -> int \"\"\"\n  pass\n def SetLowerLimit(self,lowerLimit,strictlyGreaterThan):\n  \"\"\"\n  SetLowerLimit(self: GetInteger,lowerLimit: int,strictlyGreaterThan: bool)\n\n   Sets a lower limit on the number that can be returned.\n\n     By default there is no lower \n\n    limit.\n\n  \n\n  \n\n   lowerLimit: smallest acceptable number.\n\n   strictlyGreaterThan: If true,then the returned number will be > lower_limit.\n  \"\"\"\n  pass\n def SetUpperLimit(self,upperLimit,strictlyLessThan):\n  \"\"\"\n  SetUpperLimit(self: GetInteger,upperLimit: int,strictlyLessThan: bool)\n\n   Sets an upper limit on the number that can be returned.\n\n     By default there is no \n\n    upper limit.\n\n  \n\n  \n\n   upperLimit: largest acceptable number.\n\n   strictlyLessThan: If true,then the returned number will be < upper_limit.\n  \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n\nclass GetLine(object,IDisposable):\n \"\"\"\n Use to interactively get a line.  The Rhino \"Line\" command uses GetLine.\n\n \n\n GetLine()\n \"\"\"\n def Dispose(self):\n  \"\"\"\n  Dispose(self: GetLine)\n\n   Actively reclaims unmanaged resources that this instance uses.\n  \"\"\"\n  pass\n def EnableAllVariations(self,on):\n  \"\"\"\n  EnableAllVariations(self: GetLine,on: bool)\n\n   If true,then all line variations are shown if the default line mode is used\n  \"\"\"\n  pass\n def EnableFromBothSidesOption(self,on):\n  \"\"\"\n  EnableFromBothSidesOption(self: GetLine,on: bool)\n\n   If true,then the \"BothSides\" option shows up when the\n\n     start point is inteactively \n\n    picked.\n  \"\"\"\n  pass\n def EnableFromMidPointOption(self,on):\n  \"\"\"\n  EnableFromMidPointOption(self: GetLine,on: bool)\n\n   If true,the the \"MidPoint\" options shows up\n  \"\"\"\n  pass\n def Get(self,line):\n  \"\"\"\n  Get(self: GetLine) -> (Result,Line)\n\n  \n\n   Perform the 'get' operation.\n  \"\"\"\n  pass\n def SetFirstPoint(self,point):\n  \"\"\"\n  SetFirstPoint(self: GetLine,point: Point3d)\n\n   Use SetFirstPoint to specify the line's starting point and skip\n\n     the start point \n\n    interactive picking\n  \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n AcceptZeroLengthLine=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Controls whether or not a zero length line is acceptable.\n\n   The default is to require the user to keep picking the end\n\n   point until we get a point different than the start point.\n\n\n\nGet: AcceptZeroLengthLine(self: GetLine) -> bool\n\n\n\nSet: AcceptZeroLengthLine(self: GetLine)=value\n\n\"\"\"\n\n FeedbackColor=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"If set,the feedback color is used to draw the dynamic\n\n   line when the second point is begin picked.  If not set,\n\n   the active layer color is used.\n\n\n\nGet: FeedbackColor(self: GetLine) -> Color\n\n\n\nSet: FeedbackColor(self: GetLine)=value\n\n\"\"\"\n\n FirstPointPrompt=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Prompt when getting first point\n\n\n\nGet: FirstPointPrompt(self: GetLine) -> str\n\n\n\nSet: FirstPointPrompt(self: GetLine)=value\n\n\"\"\"\n\n FixedLength=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"If FixedLength > 0,the line must have the specified length\n\n\n\nGet: FixedLength(self: GetLine) -> float\n\n\n\nSet: FixedLength(self: GetLine)=value\n\n\"\"\"\n\n GetLineMode=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Mode used\n\n\n\nGet: GetLineMode(self: GetLine) -> GetLineMode\n\n\n\nSet: GetLineMode(self: GetLine)=value\n\n\"\"\"\n\n HaveFeedbackColor=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"If true,the feedback color is used to draw the dynamic\n\n   line when the second point is begin picked.  If false,\n\n   the active layer color is used.\n\n\n\nGet: HaveFeedbackColor(self: GetLine) -> bool\n\n\n\n\"\"\"\n\n MidPointPrompt=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Prompt when getting midpoint\n\n\n\nGet: MidPointPrompt(self: GetLine) -> str\n\n\n\nSet: MidPointPrompt(self: GetLine)=value\n\n\"\"\"\n\n SecondPointPrompt=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Prompt when getting second point\n\n\n\nGet: SecondPointPrompt(self: GetLine) -> str\n\n\n\nSet: SecondPointPrompt(self: GetLine)=value\n\n\"\"\"\n\n\n\nclass GetLineMode(Enum,IComparable,IFormattable,IConvertible):\n \"\"\" enum GetLineMode,values: Angled (2),Bisector (5),CPlaneNormalVector (9),CurveEnd (8),FourPoint (4),Perpendicular (6),SurfaceNormal (1),Tangent (7),TwoPoint (0),Vertical (3) \"\"\"\n def __eq__(self,*args):\n  \"\"\" x.__eq__(y) <==> x==yx.__eq__(y) <==> x==yx.__eq__(y) <==> x==y \"\"\"\n  pass\n def __format__(self,*args):\n  \"\"\" __format__(formattable: IFormattable,format: str) -> str \"\"\"\n  pass\n def __ge__(self,*args):\n  pass\n def __gt__(self,*args):\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __le__(self,*args):\n  pass\n def __lt__(self,*args):\n  pass\n def __ne__(self,*args):\n  pass\n def __reduce_ex__(self,*args):\n  pass\n def __str__(self,*args):\n  pass\n Angled=None\n Bisector=None\n CPlaneNormalVector=None\n CurveEnd=None\n FourPoint=None\n Perpendicular=None\n SurfaceNormal=None\n Tangent=None\n TwoPoint=None\n value__=None\n Vertical=None\n\n\nclass GetNumber(GetBaseClass,IDisposable):\n \"\"\"\n Used to get double precision numbers.\n\n \n\n GetNumber()\n \"\"\"\n def Dispose(self):\n  \"\"\" Dispose(self: GetBaseClass,disposing: bool) \"\"\"\n  pass\n def Get(self):\n  \"\"\"\n  Get(self: GetNumber) -> GetResult\n\n  \n\n   Call to get a number.\n\n   Returns: If the user chose a number,then Rhino.Input.GetResult.Number; another enumeration value \n\n    otherwise.\n  \"\"\"\n  pass\n def SetLowerLimit(self,lowerLimit,strictlyGreaterThan):\n  \"\"\"\n  SetLowerLimit(self: GetNumber,lowerLimit: float,strictlyGreaterThan: bool)\n\n   Sets a lower limit on the number that can be returned.\n\n     By default there is no lower \n\n    limit.\n\n  \n\n  \n\n   lowerLimit: smallest acceptable number.\n\n   strictlyGreaterThan: If true,then the returned number will be > lower_limit.\n  \"\"\"\n  pass\n def SetUpperLimit(self,upperLimit,strictlyLessThan):\n  \"\"\"\n  SetUpperLimit(self: GetNumber,upperLimit: float,strictlyLessThan: bool)\n\n   Sets an upper limit on the number that can be returned.\n\n     By default there is no \n\n    upper limit.\n\n  \n\n  \n\n   upperLimit: largest acceptable number.\n\n   strictlyLessThan: If true,then the returned number will be < upper_limit.\n  \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n\nclass GetObject(GetBaseClass,IDisposable):\n \"\"\"\n The GetObject class is the tool commands use to interactively select objects.\n\n \n\n GetObject()\n \"\"\"\n def CustomGeometryFilter(self,rhObject,geometry,componentIndex):\n  \"\"\"\n  CustomGeometryFilter(self: GetObject,rhObject: RhinoObject,geometry: GeometryBase,componentIndex: ComponentIndex) -> bool\n\n  \n\n   Checks geometry to see if it can be selected.\n\n     Override to provide fancy filtering.\n\n  \n\n   rhObject: parent object being considered.\n\n   geometry: geometry being considered.\n\n   componentIndex: if >= 0,geometry is a proper sub-part of object->Geometry() with componentIndex.\n\n   Returns: The default returns true unless you've set a custom geometry filter. If a custom\n\n     \n\n    filter has been set,that delegate is called\n  \"\"\"\n  pass\n def DisablePreSelect(self):\n  \"\"\" DisablePreSelect(self: GetObject) \"\"\"\n  pass\n def Dispose(self):\n  \"\"\" Dispose(self: GetBaseClass,disposing: bool) \"\"\"\n  pass\n def EnableClearObjectsOnEntry(self,enable):\n  \"\"\"\n  EnableClearObjectsOnEntry(self: GetObject,enable: bool)\n\n   By default the picked object list is cleared when GetObject.GetObjects() is called.\n\n     \n\n    If you are reusing a GetObject class and do not want the existing object list\n\n     \n\n    cleared when you call Input,then call EnableClearObjectsOnEntry(false) before\n\n     \n\n    calling GetObjects().\n\n  \n\n  \n\n   enable: The state to set.\n  \"\"\"\n  pass\n def EnableHighlight(self,enable):\n  \"\"\"\n  EnableHighlight(self: GetObject,enable: bool)\n\n   By default,any object post-pick selected by GetObjects() is highlighted.\n\n     If you \n\n    want to post-pick objects and not have them automatically highlight,\n\n     then call \n\n    EnableHighlight=false.\n  \"\"\"\n  pass\n def EnableIgnoreGrips(self,enable):\n  \"\"\"\n  EnableIgnoreGrips(self: GetObject,enable: bool)\n\n   By default,post selection will select objects with grips on. If you do\n\n     not want to \n\n    be able to post select objects with grips on,then call\n\n     EnableIgnoreGrips=false. \n\n    The ability to preselect an object with grips\n\n     on is determined by the value \n\n    returned by the virtual\n\n     RhinoObject.IsSelectableWithGripsOn.\n  \"\"\"\n  pass\n def EnablePostSelect(self,enable):\n  \"\"\"\n  EnablePostSelect(self: GetObject,enable: bool)\n\n   Control the availability of post selection in GetObjects.\n  \"\"\"\n  pass\n def EnablePreSelect(self,enable,ignoreUnacceptablePreselectedObjects):\n  \"\"\"\n  EnablePreSelect(self: GetObject,enable: bool,ignoreUnacceptablePreselectedObjects: bool)\n\n   Control the pre selection behavior GetObjects.\n\n  \n\n   enable: if true,pre-selection is enabled.\n\n   ignoreUnacceptablePreselectedObjects: If true and some acceptable objects are pre-selected,then any unacceptable\n\n     \n\n    pre-selected objects are ignored. If false and any unacceptable are pre-selected,\n\n     \n\n    then the user is forced to post-select.\n  \"\"\"\n  pass\n def EnablePressEnterWhenDonePrompt(self,enable):\n  \"\"\"\n  EnablePressEnterWhenDonePrompt(self: GetObject,enable: bool)\n\n   By default,when GetObject.GetObjects is called with minimumNumber > 0\n\n     and \n\n    maximumNumber=0,the command prompt automatically includes \"Press Enter\n\n     when \n\n    done\" after the user has selected at least minimumNumber of objects. If\n\n     you want to \n\n    prohibit the addition of the \"Press Enter when done\",then call\n\n     \n\n    EnablePressEnterWhenDonePrompt=false;\n  \"\"\"\n  pass\n def EnableSelPrevious(self,enable):\n  \"\"\"\n  EnableSelPrevious(self: GetObject,enable: bool)\n\n   By default,any object selected during a command becomes part of the\n\n     \"previous \n\n    selection set\" and can be reselected by the SelPrev command.\n\n     If you need to select \n\n    objects but do not want them to be selected by\n\n     a subsquent call to SelPrev,then \n\n    call EnableSelPrev=false.\n  \"\"\"\n  pass\n def EnableUnselectObjectsOnExit(self,enable):\n  \"\"\"\n  EnableUnselectObjectsOnExit(self: GetObject,enable: bool)\n\n   By default any objects in the object list are unselected when GetObject.GetObjects()\n\n       \n\n     exits with any return code besides Object. If you want to leave the objects\n\n     \n\n    selected when non-object input is returned,then call EnableUnselectObjectsOnExit(false)\n\n      \n\n      before calling GetObjects().\n\n  \n\n  \n\n   enable: The state to set.\n  \"\"\"\n  pass\n def Get(self):\n  \"\"\"\n  Get(self: GetObject) -> GetResult\n\n  \n\n   Call to select a single object.\n\n   Returns: Success - objects selected.\n\n     Cancel - user pressed ESCAPE to cancel the get.\n\n      \n\n      See GetResults for other possible values that may be returned when options,numbers,\n\n     \n\n       etc.,are acceptable responses.\n  \"\"\"\n  pass\n def GetMultiple(self,minimumNumber,maximumNumber):\n  \"\"\"\n  GetMultiple(self: GetObject,minimumNumber: int,maximumNumber: int) -> GetResult\n\n  \n\n   Call to select objects.\n\n  \n\n   minimumNumber: minimum number of objects to select.\n\n   maximumNumber: maximum number of objects to select.\n\n     If 0,then the user must press enter to finish \n\n    object selection.\n\n     If -1,then object selection stops as soon as there are at least \n\n    minimumNumber of object selected.\n\n     If >0,then the picking stops when there are \n\n    maximumNumber objects.  If a window pick,crossing\n\n     pick,or Sel* command attempts \n\n    to add more than maximumNumber,then the attempt is ignored.\n\n  \n\n   Returns: Success - objects selected.\n\n     Cancel - user pressed ESCAPE to cancel the get.\n\n      \n\n      See GetResults for other possible values that may be returned when options,numbers,\n\n     \n\n       etc.,are acceptable responses.\n  \"\"\"\n  pass\n def Object(self,index):\n  \"\"\" Object(self: GetObject,index: int) -> ObjRef \"\"\"\n  pass\n def Objects(self):\n  \"\"\" Objects(self: GetObject) -> Array[ObjRef] \"\"\"\n  pass\n def PassesGeometryAttributeFilter(self,rhObject,geometry,componentIndex):\n  \"\"\"\n  PassesGeometryAttributeFilter(self: GetObject,rhObject: RhinoObject,geometry: GeometryBase,componentIndex: ComponentIndex) -> bool\n\n  \n\n   Checks geometry to see if it passes the basic GeometryAttributeFilter.\n\n  \n\n   rhObject: parent object being considered.\n\n   geometry: geometry being considered.\n\n   componentIndex: if >= 0,geometry is a proper sub-part of object->Geometry() with componentIndex.\n\n   Returns: true if the geometry passes the filter returned by GeometryAttributeFilter().\n  \"\"\"\n  pass\n def SetCustomGeometryFilter(self,filter):\n  \"\"\"\n  SetCustomGeometryFilter(self: GetObject,filter: GetObjectGeometryFilter)\n\n   Set filter callback function that will be called by the CustomGeometryFilter\n  \"\"\"\n  pass\n def SetPressEnterWhenDonePrompt(self,prompt):\n  \"\"\"\n  SetPressEnterWhenDonePrompt(self: GetObject,prompt: str)\n\n   The default prompt when EnablePressEnterWhenDonePrompt is enabled is \"Press Enter\n\n     \n\n    when done\". Use this function to specify a different string to be appended.\n\n  \n\n  \n\n   prompt: The text that will be displayed just after the prompt,\n\n     after the selection has been \n\n    made.\n  \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n AlreadySelectedObjectSelect=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Allow selecting objects that are already selected. By default,GetObjects() disallows\n\n   selection of objects that are already selected to avoid putting the same object\n\n   in the selection set more than once. Calling EnableAlreadySelectedObjectSelect=true\n\n   overrides that restriction and allows selected objects to be selected and\n\n   returned by GetObjects. This is useful because,coupled with the return immediately\n\n   mode of GetObjects(1,-1),it is possible to select a selected object to deselect\n\n   when the selected objects are being managed outside GetObjects() as in the case of\n\n   CRhinoPolyEdge::GetEdge().\n\n\n\nGet: AlreadySelectedObjectSelect(self: GetObject) -> bool\n\n\n\nSet: AlreadySelectedObjectSelect(self: GetObject)=value\n\n\"\"\"\n\n BottomObjectPreference=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"By default,if a call to Input is permitted to select different parts of\n\n   the same object,like a polysurface,a surface and an edge,then the\n\n   top-most object is prefered. (polysurface beats face beats edge). If\n\n   you want the bottom most object to be prefered,then call \n\n   EnableBottomObjectPreference=true before calling GetObjects().\n\n\n\nGet: BottomObjectPreference(self: GetObject) -> bool\n\n\n\nSet: BottomObjectPreference(self: GetObject)=value\n\n\"\"\"\n\n ChooseOneQuestion=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"By default,if a call to Input is permitted to select different parts\n\n   of the same object,like a polysurface and an edge of that polysurface,\n\n   then the top-most object is automatically selected. If you want the\n\n   choose-one-object mechanism to include pop up in these cases,then call\n\n   EnableChooseOneQuestion=true before calling GetObjects().\n\n\n\nGet: ChooseOneQuestion(self: GetObject) -> bool\n\n\n\nSet: ChooseOneQuestion(self: GetObject)=value\n\n\"\"\"\n\n DeselectAllBeforePostSelect=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"true if pre-selected input will be deselected before\n\n   post-selection begins when no pre-selected input is valid.\n\n\n\nGet: DeselectAllBeforePostSelect(self: GetObject) -> bool\n\n\n\nSet: DeselectAllBeforePostSelect(self: GetObject)=value\n\n\"\"\"\n\n GeometryAttributeFilter=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"The geometry attribute filter provides a secondary filter that\n\n   can be used to restrict which objects can be selected. Control\n\n   of the type of geometry (points,curves,surfaces,meshes,etc.)\n\n   is provided by GetObject.SetGeometryFilter. The geometry attribute\n\n   filter is used to require the selected geometry to have certain\n\n   attributes (open,closed,etc.). The default attribute filter\n\n   permits selection of all types of geometry.\n\n\n\nGet: GeometryAttributeFilter(self: GetObject) -> GeometryAttributeFilter\n\n\n\nSet: GeometryAttributeFilter(self: GetObject)=value\n\n\"\"\"\n\n GeometryFilter=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"The geometry type filter controls which types of geometry\n\n   (points,curves,surfaces,meshes,etc.) can be selected.\n\n   The default geometry type filter permits selection of all\n\n   types of geometry.\n\n   NOTE: the filter can be a bitwise combination of multiple ObjectTypes.\n\n\n\nGet: GeometryFilter(self: GetObject) -> ObjectType\n\n\n\nSet: GeometryFilter(self: GetObject)=value\n\n\"\"\"\n\n GroupSelect=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"By default,groups are ignored in GetObject. If you want your call to\n\n   GetObjects() to select every object in a group that has any objects\n\n   selected,then enable group selection.\n\n\n\nGet: GroupSelect(self: GetObject) -> bool\n\n\n\nSet: GroupSelect(self: GetObject)=value\n\n\"\"\"\n\n InactiveDetailPickEnabled=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"By default,objects in inactive details are not permitted to be picked.\n\n   In a few rare cases this is used (ex. picking circles during DimRadius)\n\n\n\nGet: InactiveDetailPickEnabled(self: GetObject) -> bool\n\n\n\nSet: InactiveDetailPickEnabled(self: GetObject)=value\n\n\"\"\"\n\n ObjectCount=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets the number of objects that were selected.\n\n\n\nGet: ObjectCount(self: GetObject) -> int\n\n\n\n\"\"\"\n\n ObjectsWerePreselected=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: ObjectsWerePreselected(self: GetObject) -> bool\n\n\n\n\"\"\"\n\n OneByOnePostSelect=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"In one-by-one post selection,the user is forced\n\n   to select objects by post picking them one at a time.\n\n\n\nGet: OneByOnePostSelect(self: GetObject) -> bool\n\n\n\nSet: OneByOnePostSelect(self: GetObject)=value\n\n\"\"\"\n\n ReferenceObjectSelect=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"By default,reference objects can be selected. If you do not want to be\n\n   able to select reference objects,then call EnableReferenceObjectSelect=false.\n\n\n\nGet: ReferenceObjectSelect(self: GetObject) -> bool\n\n\n\nSet: ReferenceObjectSelect(self: GetObject)=value\n\n\"\"\"\n\n SerialNumber=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Each instance of GetObject has a unique runtime serial number that\n\n   is used to identify object selection events associated with that instance.\n\n\n\nGet: SerialNumber(self: GetObject) -> UInt32\n\n\n\n\"\"\"\n\n SubObjectSelect=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"By default,GetObject.Input will permit a user to select\n\n   sub-objects (like a curve in a b-rep or a curve in a group).\n\n   If you only want the user to select \"top\" level objects,\n\n   then call EnableSubObjectSelect=false.\n\n\n\nGet: SubObjectSelect(self: GetObject) -> bool\n\n\n\nSet: SubObjectSelect(self: GetObject)=value\n\n\"\"\"\n\n\n\nclass GetObjectGeometryFilter(MulticastDelegate,ICloneable,ISerializable):\n \"\"\" GetObjectGeometryFilter(object: object,method: IntPtr) \"\"\"\n def BeginInvoke(self,rhObject,geometry,componentIndex,callback,object):\n  \"\"\" BeginInvoke(self: GetObjectGeometryFilter,rhObject: RhinoObject,geometry: GeometryBase,componentIndex: ComponentIndex,callback: AsyncCallback,object: object) -> IAsyncResult \"\"\"\n  pass\n def CombineImpl(self,*args):\n  \"\"\"\n  CombineImpl(self: MulticastDelegate,follow: Delegate) -> Delegate\n\n  \n\n   Combines this System.Delegate with the specified System.Delegate to form a new delegate.\n\n  \n\n   follow: The delegate to combine with this delegate.\n\n   Returns: A delegate that is the new root of the System.MulticastDelegate invocation list.\n  \"\"\"\n  pass\n def DynamicInvokeImpl(self,*args):\n  \"\"\"\n  DynamicInvokeImpl(self: Delegate,args: Array[object]) -> object\n\n  \n\n   Dynamically invokes (late-bound) the method represented by the current delegate.\n\n  \n\n   args: An array of objects that are the arguments to pass to the method represented by the current \n\n    delegate.-or- null,if the method represented by the current delegate does not require \n\n    arguments.\n\n  \n\n   Returns: The object returned by the method represented by the delegate.\n  \"\"\"\n  pass\n def EndInvoke(self,result):\n  \"\"\" EndInvoke(self: GetObjectGeometryFilter,result: IAsyncResult) -> bool \"\"\"\n  pass\n def GetMethodImpl(self,*args):\n  \"\"\"\n  GetMethodImpl(self: MulticastDelegate) -> MethodInfo\n\n  \n\n   Returns a static method represented by the current System.MulticastDelegate.\n\n   Returns: A static method represented by the current System.MulticastDelegate.\n  \"\"\"\n  pass\n def Invoke(self,rhObject,geometry,componentIndex):\n  \"\"\" Invoke(self: GetObjectGeometryFilter,rhObject: RhinoObject,geometry: GeometryBase,componentIndex: ComponentIndex) -> bool \"\"\"\n  pass\n def RemoveImpl(self,*args):\n  \"\"\"\n  RemoveImpl(self: MulticastDelegate,value: Delegate) -> Delegate\n\n  \n\n   Removes an element from the invocation list of this System.MulticastDelegate that is equal to \n\n    the specified delegate.\n\n  \n\n  \n\n   value: The delegate to search for in the invocation list.\n\n   Returns: If value is found in the invocation list for this instance,then a new System.Delegate without \n\n    value in its invocation list; otherwise,this instance with its original invocation list.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n @staticmethod\n def __new__(self,object,method):\n  \"\"\" __new__(cls: type,object: object,method: IntPtr) \"\"\"\n  pass\n def __reduce_ex__(self,*args):\n  pass\n\nclass GetOption(GetBaseClass,IDisposable):\n \"\"\"\n If you want to explicitly get string input,then use GetString class with\n\n    options. If you only want to get options,then use this class (GetOption)\n\n \n\n GetOption()\n \"\"\"\n def Dispose(self):\n  \"\"\" Dispose(self: GetBaseClass,disposing: bool) \"\"\"\n  pass\n def Get(self):\n  \"\"\"\n  Get(self: GetOption) -> GetResult\n\n  \n\n   Call to get an option. A return value of \"option\" means the user selected\n\n     a valid \n\n    option. Use Option() the determine which option.\n\n  \n\n   Returns: If the user chose an option,then Rhino.Input.GetResult.Option; another enumeration value \n\n    otherwise.\n  \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n\nclass GetPoint(GetBaseClass,IDisposable):\n \"\"\" GetPoint() \"\"\"\n def AddConstructionPoint(self,point):\n  \"\"\"\n  AddConstructionPoint(self: GetPoint,point: Point3d) -> int\n\n  \n\n   Adds a point to the list of construction points.\n\n  \n\n   point: A point to be added.\n\n   Returns: Total number of construction points.\n  \"\"\"\n  pass\n def AddConstructionPoints(self,points):\n  \"\"\"\n  AddConstructionPoints(self: GetPoint,points: Array[Point3d]) -> int\n\n  \n\n   Adds points to the list of construction points.\n\n  \n\n   points: An array of points to be added.\n\n   Returns: Total number of construction points.\n  \"\"\"\n  pass\n def AddSnapPoint(self,point):\n  \"\"\"\n  AddSnapPoint(self: GetPoint,point: Point3d) -> int\n\n  \n\n   Adds a point to the list of osnap points.\n\n  \n\n   point: A point.\n\n   Returns: Total number of snap points.\n  \"\"\"\n  pass\n def AddSnapPoints(self,points):\n  \"\"\"\n  AddSnapPoints(self: GetPoint,points: Array[Point3d]) -> int\n\n  \n\n   Adds points to the list of osnap points.\n\n  \n\n   points: An array of points to snap onto.\n\n   Returns: Total number of snap points.\n  \"\"\"\n  pass\n def ClearConstraints(self):\n  \"\"\"\n  ClearConstraints(self: GetPoint)\n\n   Removes any explicit constraints added by calls to GetPoint::Constraint() and enable\n\n       \n\n     the built-in constraint options.\n  \"\"\"\n  pass\n def ClearConstructionPoints(self):\n  \"\"\"\n  ClearConstructionPoints(self: GetPoint)\n\n   Remove all construction points.\n  \"\"\"\n  pass\n def ClearSnapPoints(self):\n  \"\"\"\n  ClearSnapPoints(self: GetPoint)\n\n   Remove all snap points.\n  \"\"\"\n  pass\n def Constrain(self,*__args):\n  \"\"\"\n  Constrain(self: GetPoint,curve: Curve,allowPickingPointOffObject: bool) -> bool\n\n  \n\n   Constrains the picked point to lie on a curve.\n\n  \n\n   curve: A curve to use as constraint.\n\n   allowPickingPointOffObject: defines whether the point pick is allowed to happen off object. When false,\n\n     a \"no \n\n    no\" cursor is shown when the cursor is not on the object. When true,\n\n     a normal point \n\n    picking cursor is used and the marker is visible also when\n\n     the cursor is not on the \n\n    object.\n\n  \n\n   Returns: true if constraint could be applied.\n\n  Constrain(self: GetPoint,cylinder: Cylinder) -> bool\n\n  \n\n   Constrains the picked point to lie on a cylinder.\n\n  \n\n   cylinder: A cylinder to use as constraint.\n\n   Returns: true if constraint could be applied.\n\n  Constrain(self: GetPoint,surface: Surface,allowPickingPointOffObject: bool) -> bool\n\n  \n\n   Constrains the picked point to lie on a surface.\n\n  \n\n   surface: A surface to use as constraint.\n\n   allowPickingPointOffObject: defines whether the point pick is allowed to happen off object. When false,\n\n     a \"no \n\n    no\" cursor is shown when the cursor is not on the object. When true,\n\n     a normal point \n\n    picking cursor is used and the marker is visible also when\n\n     the cursor is not on the \n\n    object.\n\n  \n\n   Returns: true if constraint could be applied.\n\n  Constrain(self: GetPoint,mesh: Mesh,allowPickingPointOffObject: bool) -> bool\n\n  \n\n   Constrains the picked point to lie on a mesh.\n\n  \n\n   mesh: A mesh to use as constraint.\n\n   allowPickingPointOffObject: defines whether the point pick is allowed to happen off object. When false,\n\n     a \"no \n\n    no\" cursor is shown when the cursor is not on the object. When true,\n\n     a normal point \n\n    picking cursor is used and the marker is visible also when\n\n     the cursor is not on the \n\n    object.\n\n  \n\n   Returns: true if constraint could be applied.\n\n  Constrain(self: GetPoint,brep: Brep,wireDensity: int,faceIndex: int,allowPickingPointOffObject: bool) -> bool\n\n  \n\n   Constrains the picked point to lie on a brep.\n\n  \n\n   brep: A brep to use as constraint.\n\n   wireDensity: When wire_density<0,isocurve intersection snapping is turned off,when wire_density>=0,the \n\n    value\n\n     defines the isocurve density used for isocurve intersection snapping.\n\n  \n\n   faceIndex: When face_index <0,constrain to whole brep. When face_index >=0,constrain to individual face.\n\n   allowPickingPointOffObject: defines whether the point pick is allowed to happen off object. When false,\n\n     a \"no \n\n    no\" cursor is shown when the cursor is not on the object. When true,\n\n     a normal point \n\n    picking cursor is used and the marker is visible also when\n\n     the cursor is not on the \n\n    object.\n\n  \n\n   Returns: true if constraint could be applied.\n\n  Constrain(self: GetPoint,sphere: Sphere) -> bool\n\n  \n\n   Constrains the picked point to lie on a sphere.\n\n  \n\n   sphere: A sphere to use as constraint.\n\n   Returns: true if constraint could be applied.\n\n  Constrain(self: GetPoint,line: Line) -> bool\n\n  \n\n   Constrains the picked point to lie on a line.\n\n  \n\n   line: A line to use as constraint.\n\n   Returns: true if constraint could be applied.\n\n  Constrain(self: GetPoint,from: Point3d,to: Point3d) -> bool\n\n  \n\n   Constrains the picked point to lie on a line.\n\n  \n\n   from: The start point of constraint.\n\n   to: The end point of constraint.\n\n   Returns: true if constraint could be applied.\n\n  Constrain(self: GetPoint,arc: Arc) -> bool\n\n  \n\n   Constrains the picked point to lie on an arc.\n\n  \n\n   arc: An arc to use as constraint.\n\n   Returns: true if constraint could be applied.\n\n  Constrain(self: GetPoint,plane: Plane,allowElevator: bool) -> bool\n\n  \n\n   constrain the picked point to lie on a plane.\n\n  \n\n   plane: A plane to use as constraint.\n\n   allowElevator: true if elevator mode should be allowed at user request.\n\n   Returns: true if constraint could be applied.\n\n  Constrain(self: GetPoint,circle: Circle) -> bool\n\n  \n\n   Constrains the picked point to lie on a circle.\n\n  \n\n   circle: A circle to use as constraint.\n\n   Returns: true if constraint could be applied.\n  \"\"\"\n  pass\n def ConstrainDistanceFromBasePoint(self,distance):\n  \"\"\"\n  ConstrainDistanceFromBasePoint(self: GetPoint,distance: float)\n\n   Sets distance constraint from base point.\n\n  \n\n   distance: pass UnsetValue to clear this constraint. Pass 0.0 to disable the\n\n     ability to set \n\n    this constraint by typing a number during GetPoint.\n  \"\"\"\n  pass\n def ConstrainToConstructionPlane(self,throughBasePoint):\n  \"\"\"\n  ConstrainToConstructionPlane(self: GetPoint,throughBasePoint: bool) -> bool\n\n  \n\n   If enabled,the picked point is constrained to be on the active construction plane.\n\n     \n\n    If the base point is set,then the point is constrained to be on the plane that contains\n\n      \n\n      the base point and is parallel to the active construction plane. By default this\n\n      \n\n      constraint is enabled.\n\n  \n\n  \n\n   throughBasePoint: true if the base point should be used as compulsory level reference.\n\n   Returns: If true and the base point is set,then the point is constrained to be on the plane parallel\n\n     \n\n       to the construction plane that passes through the base point,even when planar mode is \n\n    off.\n\n     If throughBasePoint is false,then the base point shift only happens if planar \n\n    mode is on.\n  \"\"\"\n  pass\n def ConstrainToTargetPlane(self):\n  \"\"\"\n  ConstrainToTargetPlane(self: GetPoint)\n\n   Constrains point to lie on a plane that is parallel to the\n\n     viewing plane and passes \n\n    through the view's target point.\n  \"\"\"\n  pass\n def ConstrainToVirtualCPlaneIntersection(self,plane):\n  \"\"\"\n  ConstrainToVirtualCPlaneIntersection(self: GetPoint,plane: Plane) -> bool\n\n  \n\n   If enabled,the picked point is constrained to be on the \n\n     intersection of the plane \n\n    and the virtual CPlane going through\n\n     the plane origin.\n\n     If the planes \n\n    are parallel,the constraint works just like planar constraint.\n\n  \n\n  \n\n   plane: The plane used for the plane - virtual CPlane intersection.\n\n   Returns: true if the operation succeeded; false otherwise.\n  \"\"\"\n  pass\n def Dispose(self):\n  \"\"\" Dispose(self: GetBaseClass,disposing: bool) \"\"\"\n  pass\n def DrawLineFromPoint(self,startPoint,showDistanceInStatusBar):\n  \"\"\"\n  DrawLineFromPoint(self: GetPoint,startPoint: Point3d,showDistanceInStatusBar: bool)\n\n   Use DrawLineFromPoint() if you want a dynamic line drawn from a point to the point being picked.\n\n  \n\n   startPoint: The line is drawn from startPoint to the point being picked. If the base\n\n     point has \n\n    not been set,then it is set to startPoint.\n\n  \n\n   showDistanceInStatusBar: if true,the distance from the basePoint to the point begin picked is shown in the status bar.\n  \"\"\"\n  pass\n def EnableCurveSnapArrow(self,drawDirectionArrowAtSnapPoint,reverseArrow):\n  \"\"\"\n  EnableCurveSnapArrow(self: GetPoint,drawDirectionArrowAtSnapPoint: bool,reverseArrow: bool)\n\n   Controls display of the curve snap arrow icon.\n\n  \n\n   drawDirectionArrowAtSnapPoint: true to draw arrow icon whenever GetPoint snaps to a curve.\n\n   reverseArrow: true if arrow icon direction should be the reverse of the first derivative direction.\n  \"\"\"\n  pass\n def EnableCurveSnapPerpBar(self,drawPerpBarAtSnapPoint,drawEndPoints):\n  \"\"\"\n  EnableCurveSnapPerpBar(self: GetPoint,drawPerpBarAtSnapPoint: bool,drawEndPoints: bool)\n\n   Controls display of the curve snap perpendicular bar icon.\n\n  \n\n   drawPerpBarAtSnapPoint: true to draw a tangent bar icon  whenever GetPoint snaps to a curve.\n\n   drawEndPoints: true to draw points at the end of the tangent bar.\n  \"\"\"\n  pass\n def EnableCurveSnapTangentBar(self,drawTangentBarAtSnapPoint,drawEndPoints):\n  \"\"\"\n  EnableCurveSnapTangentBar(self: GetPoint,drawTangentBarAtSnapPoint: bool,drawEndPoints: bool)\n\n   Controls display of the curve snap tangent bar icon.\n\n  \n\n   drawTangentBarAtSnapPoint: true to draw a tangent bar icon whenever GetPoint snaps to a curve.\n\n   drawEndPoints: true to draw points at the end of the tangent bar.\n  \"\"\"\n  pass\n def EnableDrawLineFromPoint(self,enable):\n  \"\"\"\n  EnableDrawLineFromPoint(self: GetPoint,enable: bool)\n\n   Controls drawing of dynamic a line from the start point.\n\n  \n\n   enable: if true,a dynamic line is drawn from the DrawLineFromPoint startPoint to the point being picked.\n  \"\"\"\n  pass\n def EnableSnapToCurves(self,enable):\n  \"\"\"\n  EnableSnapToCurves(self: GetPoint,enable: bool)\n\n   If you want GetPoint() to try to snap to curves when the mouse is near a curve\n\n     \n\n    (like the center point in the Circle command when the AroundCurve option is on),\n\n     \n\n    then enable the snap to curves option.\n\n  \n\n  \n\n   enable: Whether points should be enabled.\n  \"\"\"\n  pass\n def Get(self,onMouseUp=None,get2DPoint=None):\n  \"\"\"\n  Get(self: GetPoint) -> GetResult\n\n  \n\n   After setting up options and so on,call GetPoint::Get to get a 3d point. The\n\n     point \n\n    is retrieved when the mouse goes down.\n\n  \n\n  Get(self: GetPoint,onMouseUp: bool,get2DPoint: bool) -> GetResult\n\n  \n\n   After setting up options and so on,call this method to get a 2d or 3d point.\n\n  \n\n   onMouseUp: If false,the point is returned when the left mouse button goes down.\n\n     If true,the \n\n    point is returned when the left mouse button goes up.\n\n  \n\n   get2DPoint: If true then get a 2d point otherwise get a 2d point\n\n   Returns: Rhino.Input.GetResult.Point if the user chose a 3d point; Rhino.Input.GetResult.Point2d if the \n\n    user chose a 2d point; other enumeration value otherwise.\n\n  \n\n  Get(self: GetPoint,onMouseUp: bool) -> GetResult\n\n  \n\n   After setting up options and so on,call this method to get a 3d point.\n\n  \n\n   onMouseUp: If false,the point is returned when the left mouse button goes down.\n\n     If true,the \n\n    point is returned when the left mouse button goes up.\n\n  \n\n   Returns: Rhino.Input.GetResult.Point if the user chose a point; other enumeration value otherwise.\n  \"\"\"\n  pass\n def GetConstructionPoints(self):\n  \"\"\"\n  GetConstructionPoints(self: GetPoint) -> Array[Point3d]\n\n  \n\n   Gets current construction points.\n\n   Returns: An array of points.\n  \"\"\"\n  pass\n def GetSnapPoints(self):\n  \"\"\"\n  GetSnapPoints(self: GetPoint) -> Array[Point3d]\n\n  \n\n   Gets current snap points.\n\n   Returns: An array of points.\n  \"\"\"\n  pass\n def InterruptMouseMove(self):\n  \"\"\"\n  InterruptMouseMove(self: GetPoint) -> bool\n\n  \n\n   If you have lengthy computations in OnMouseMove() and/or DymanicDraw()\n\n     overrides,\n\n    then periodically call InterruptMouseMove() to see if you\n\n     should interrupt your \n\n    work because the mouse has moved again.\n\n  \n\n   Returns: true if you should interrupt your work; false otherwise.\n  \"\"\"\n  pass\n def OnDynamicDraw(self,*args):\n  \"\"\"\n  OnDynamicDraw(self: GetPoint,e: GetPointDrawEventArgs)\n\n   Default calls the DynamicDraw event.\n\n  \n\n   e: Current argument for the event.\n  \"\"\"\n  pass\n def OnMouseDown(self,*args):\n  \"\"\"\n  OnMouseDown(self: GetPoint,e: GetPointMouseEventArgs)\n\n   Default calls the MouseDown event.\n\n  \n\n   e: Current argument for the event.\n  \"\"\"\n  pass\n def OnMouseMove(self,*args):\n  \"\"\"\n  OnMouseMove(self: GetPoint,e: GetPointMouseEventArgs)\n\n   Calls the Rhino.Input.Custom.GetPoint.MouseMove event and can/should be called by overriding \n\n    implementation.\n\n  \n\n  \n\n   e: Current argument for the event.\n  \"\"\"\n  pass\n def OnPostDrawObjects(self,*args):\n  \"\"\"\n  OnPostDrawObjects(self: GetPoint,e: DrawEventArgs)\n\n   In the \"rare\" case that you need to draw some depth buffered geometry during\n\n     a \n\n    GetPoint operation,override the OnPostDrawObjects function.\n\n     NOTE!! Overriding this \n\n    function comes with a significant performance penalty because the\n\n     scene needs to be \n\n    fully regenerated every frame where the standard\n\n     DynamicDraw event draws temporary \n\n    decorations (geometry) on top of a static scene.\n\n  \n\n  \n\n   e: Current argument for the event.\n  \"\"\"\n  pass\n def PermitConstraintOptions(self,permit):\n  \"\"\"\n  PermitConstraintOptions(self: GetPoint,permit: bool)\n\n   Control the availability of the built-in linear,planar,curve,and surface\n\n     \n\n    constraint options like \"Along\",\"AlongPerp\",\"AlongTan\",\"AlongParallel\",\n\n     \n\n    \"Between\",\"OnCrv\",\"OnSrf\",\".x\",\".y\",\".z\",\".xy\",etc.\n\n  \n\n  \n\n   permit: if true,then the built-in contraint options are automatically avaiable in GetPoint.\n  \"\"\"\n  pass\n def PermitElevatorMode(self,permitMode):\n  \"\"\"\n  PermitElevatorMode(self: GetPoint,permitMode: int)\n\n   Permits the use of the control key to define a line constraint.\n\n  \n\n   permitMode: 0: no elevator modes are permitted\n\n     1: fixed plane elevator mode (like the Line \n\n    command)\n\n     2: cplane elevator mode (like object dragging)\n  \"\"\"\n  pass\n def PermitFromOption(self,permit):\n  \"\"\"\n  PermitFromOption(self: GetPoint,permit: bool)\n\n   Control the availability of the built-in \"From\" option. By default,the \"From\" option is enabled.\n\n  \n\n   permit: if true,then the \"From\" option is automatically avaiable in GetPoint.\n  \"\"\"\n  pass\n def PermitObjectSnap(self,permit):\n  \"\"\"\n  PermitObjectSnap(self: GetPoint,permit: bool)\n\n   By default,object snaps like \"end\",\"near\",etc. are controled by the user.\n\n     If you \n\n    want to disable this ability,then call PermitObjectSnap(false).\n\n  \n\n  \n\n   permit: true to permit snapping to objects.\n  \"\"\"\n  pass\n def PermitOrthoSnap(self,permit):\n  \"\"\"\n  PermitOrthoSnap(self: GetPoint,permit: bool)\n\n   Controls availability of ortho snap. Default is true.\n\n  \n\n   permit: if true,then GetPoint pays attention to the Rhino \"ortho snap\" and \"planar snap\" settings\n\n    \n\n     reported by ModelAidSettings.Ortho and ModelAidSettings.Planar.\n  \"\"\"\n  pass\n def PermitTabMode(self,permit):\n  \"\"\"\n  PermitTabMode(self: GetPoint,permit: bool)\n\n   Permits the use of the tab key to define a line constraint.\n\n  \n\n   permit: If true,then the built-in tab key mode is available.\n  \"\"\"\n  pass\n def PointOnCurve(self,t):\n  \"\"\"\n  PointOnCurve(self: GetPoint) -> (Curve,float)\n\n  \n\n   Use to determine is point was on a curve.\n\n   Returns: A curve at a specified parameter value.\n  \"\"\"\n  pass\n def PointOnObject(self):\n  \"\"\"\n  PointOnObject(self: GetPoint) -> ObjRef\n\n  \n\n   Call this function to see if the point was on an object. If the point was\n\n     on an \n\n    object an ObjRef is returned; otherwise null is returned.\n\n  \n\n   Returns: A point object reference.\n  \"\"\"\n  pass\n def SetBasePoint(self,basePoint,showDistanceInStatusBar):\n  \"\"\"\n  SetBasePoint(self: GetPoint,basePoint: Point3d,showDistanceInStatusBar: bool)\n\n   Sets a base point used by ortho snap,from snap,planar snap,etc.\n\n  \n\n   basePoint: The new base point.\n\n   showDistanceInStatusBar: If true,then the distance from base_point to the current point will be in the\n\n     \n\n    status bar distance pane.\n  \"\"\"\n  pass\n def SetCursor(self,cursor):\n  \"\"\" SetCursor(self: GetPoint,cursor: Cursor) \"\"\"\n  pass\n def TryGetBasePoint(self,basePoint):\n  \"\"\" TryGetBasePoint(self: GetPoint) -> (bool,Point3d) \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n DynamicDrawColor=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Color used by CRhinoGetPoint::DynamicDraw to draw the current point and\n\n   the line from the base point to the current point.\n\n\n\nGet: DynamicDrawColor(self: GetPoint) -> Color\n\n\n\nSet: DynamicDrawColor(self: GetPoint)=value\n\n\"\"\"\n\n FullFrameRedrawDuringGet=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"In the \"RARE\" case that you need to draw some depth buffered geometry during\n\n   a Get() operation,setting this value to true will force entire frames to be redrawn\n\n   while the user moves the mouse. This allows DisplayPipeline events to be triggered\n\n   as well as OnPostDrawObjects\n\n   NOTE!! Setting this value to true comes with a significant performance penalty because the\n\n   scene needs to be fully regenerated every frame where the standard\n\n   DynamicDraw event draws temporary decorations (geometry) on top of a static scene.\n\n\n\nGet: FullFrameRedrawDuringGet(self: GetPoint) -> bool\n\n\n\nSet: FullFrameRedrawDuringGet(self: GetPoint)=value\n\n\"\"\"\n\n Tag=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Gets or sets an arbitrary object that can be attached to this Rhino.Input.Custom.GetPoint instance.\n\n   Useful for passing some/ information that you may need in a DynamicDraw event since you can get at this Tag from\n\n   the GetPointDrawEventArgs.\n\n\n\nGet: Tag(self: GetPoint) -> object\n\n\n\nSet: Tag(self: GetPoint)=value\n\n\"\"\"\n\n\n DynamicDraw=None\n MouseDown=None\n MouseMove=None\n PostDrawObjects=None\n\n\nclass GetPointDrawEventArgs(DrawEventArgs):\n # no doc\n CurrentPoint=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: CurrentPoint(self: GetPointDrawEventArgs) -> Point3d\n\n\n\n\"\"\"\n\n Source=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"GetPoint class that this draw event originated from.\n\n\n\nGet: Source(self: GetPointDrawEventArgs) -> GetPoint\n\n\n\n\"\"\"\n\n\n\nclass GetPointMouseEventArgs(EventArgs):\n # no doc\n ControlKeyDown=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: ControlKeyDown(self: GetPointMouseEventArgs) -> bool\n\n\n\n\"\"\"\n\n LeftButtonDown=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: LeftButtonDown(self: GetPointMouseEventArgs) -> bool\n\n\n\n\"\"\"\n\n MiddleButtonDown=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: MiddleButtonDown(self: GetPointMouseEventArgs) -> bool\n\n\n\n\"\"\"\n\n Point=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: Point(self: GetPointMouseEventArgs) -> Point3d\n\n\n\n\"\"\"\n\n RightButtonDown=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: RightButtonDown(self: GetPointMouseEventArgs) -> bool\n\n\n\n\"\"\"\n\n ShiftKeyDown=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: ShiftKeyDown(self: GetPointMouseEventArgs) -> bool\n\n\n\n\"\"\"\n\n Source=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: Source(self: GetPointMouseEventArgs) -> GetPoint\n\n\n\n\"\"\"\n\n Viewport=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: Viewport(self: GetPointMouseEventArgs) -> RhinoViewport\n\n\n\n\"\"\"\n\n WindowPoint=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: WindowPoint(self: GetPointMouseEventArgs) -> Point\n\n\n\n\"\"\"\n\n\n\nclass GetString(GetBaseClass,IDisposable):\n \"\"\" GetString() \"\"\"\n def Dispose(self):\n  \"\"\" Dispose(self: GetBaseClass,disposing: bool) \"\"\"\n  pass\n def Get(self):\n  \"\"\"\n  Get(self: GetString) -> GetResult\n\n  \n\n   Returns the string that the user typed. By default,space stops the string input.\n\n   Returns: The result type. If the user typed a string,this is Rhino.Input.GetResult.String.\n  \"\"\"\n  pass\n def GetLiteralString(self):\n  \"\"\"\n  GetLiteralString(self: GetString) -> GetResult\n\n  \n\n   Returns the string that the user typed. By default,space does not stop input.\n\n   Returns: The result type. If the user typed a string,this is Rhino.Input.GetResult.String.\n  \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n\nclass GetTransform(GetPoint,IDisposable):\n # no doc\n def AddTransformObjects(self,list):\n  \"\"\"\n  AddTransformObjects(self: GetTransform,list: TransformObjectList)\n\n   Adds any objects you want transformed and grips you want transformed.\n\n     Make sure no \n\n    duplicates are in the list and that no grip ownwers are\n\n     passed in as objects.\n\n  \n\n  \n\n   list: A custom transform object list.\n  \"\"\"\n  pass\n def CalculateTransform(self,viewport,point):\n  \"\"\"\n  CalculateTransform(self: GetTransform,viewport: RhinoViewport,point: Point3d) -> Transform\n\n  \n\n   Retrieves the final transformation.\n\n     Override this virtual function to provide your \n\n    own custom transformation method.\n\n  \n\n  \n\n   viewport: A Rhino viewport that the user is using.\n\n   point: A point that the user is selecting.\n\n   Returns: A transformation matrix value.\n  \"\"\"\n  pass\n def Dispose(self):\n  \"\"\" Dispose(self: GetBaseClass,disposing: bool) \"\"\"\n  pass\n def GetXform(self):\n  \"\"\"\n  GetXform(self: GetTransform) -> GetResult\n\n  \n\n   Gets the Transformation.\n\n     Call this after having set up options and so on.\n\n   Returns: The result based on user choice.\n  \"\"\"\n  pass\n def OnDynamicDraw(self,*args):\n  \"\"\"\n  OnDynamicDraw(self: GetPoint,e: GetPointDrawEventArgs)\n\n   Default calls the DynamicDraw event.\n\n  \n\n   e: Current argument for the event.\n  \"\"\"\n  pass\n def OnMouseDown(self,*args):\n  \"\"\"\n  OnMouseDown(self: GetPoint,e: GetPointMouseEventArgs)\n\n   Default calls the MouseDown event.\n\n  \n\n   e: Current argument for the event.\n  \"\"\"\n  pass\n def OnMouseMove(self,*args):\n  \"\"\"\n  OnMouseMove(self: GetPoint,e: GetPointMouseEventArgs)\n\n   Calls the Rhino.Input.Custom.GetPoint.MouseMove event and can/should be called by overriding \n\n    implementation.\n\n  \n\n  \n\n   e: Current argument for the event.\n  \"\"\"\n  pass\n def OnPostDrawObjects(self,*args):\n  \"\"\"\n  OnPostDrawObjects(self: GetPoint,e: DrawEventArgs)\n\n   In the \"rare\" case that you need to draw some depth buffered geometry during\n\n     a \n\n    GetPoint operation,override the OnPostDrawObjects function.\n\n     NOTE!! Overriding this \n\n    function comes with a significant performance penalty because the\n\n     scene needs to be \n\n    fully regenerated every frame where the standard\n\n     DynamicDraw event draws temporary \n\n    decorations (geometry) on top of a static scene.\n\n  \n\n  \n\n   e: Current argument for the event.\n  \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n HaveTransform=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: HaveTransform(self: GetTransform) -> bool\n\n\n\nSet: HaveTransform(self: GetTransform)=value\n\n\"\"\"\n\n ObjectList=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: ObjectList(self: GetTransform) -> TransformObjectList\n\n\n\n\"\"\"\n\n Transform=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: Transform(self: GetTransform) -> Transform\n\n\n\nSet: Transform(self: GetTransform)=value\n\n\"\"\"\n\n\n\nclass OptionColor(object,IDisposable):\n \"\"\" OptionColor(initialValue: Color) \"\"\"\n def Dispose(self):\n  \"\"\" Dispose(self: OptionColor) \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n @staticmethod\n def __new__(self,initialValue):\n  \"\"\" __new__(cls: type,initialValue: Color) \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n CurrentValue=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: CurrentValue(self: OptionColor) -> Color\n\n\n\nSet: CurrentValue(self: OptionColor)=value\n\n\"\"\"\n\n InitialValue=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: InitialValue(self: OptionColor) -> Color\n\n\n\n\"\"\"\n\n\n\nclass OptionDouble(object,IDisposable):\n \"\"\"\n OptionDouble(initialValue: float)\n\n OptionDouble(initialValue: float,lowerLimit: float,upperLimit: float)\n\n OptionDouble(initialValue: float,setLowerLimit: bool,limit: float)\n \"\"\"\n def Dispose(self):\n  \"\"\" Dispose(self: OptionDouble) \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n @staticmethod\n def __new__(self,initialValue,*__args):\n  \"\"\"\n  __new__(cls: type,initialValue: float)\n\n  __new__(cls: type,initialValue: float,lowerLimit: float,upperLimit: float)\n\n  __new__(cls: type,initialValue: float,setLowerLimit: bool,limit: float)\n  \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n CurrentValue=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: CurrentValue(self: OptionDouble) -> float\n\n\n\nSet: CurrentValue(self: OptionDouble)=value\n\n\"\"\"\n\n InitialValue=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: InitialValue(self: OptionDouble) -> float\n\n\n\n\"\"\"\n\n\n\nclass OptionInteger(object,IDisposable):\n \"\"\"\n OptionInteger(initialValue: int)\n\n OptionInteger(initialValue: int,lowerLimit: int,upperLimit: int)\n\n OptionInteger(initialValue: int,setLowerLimit: bool,limit: int)\n \"\"\"\n def Dispose(self):\n  \"\"\" Dispose(self: OptionInteger) \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n @staticmethod\n def __new__(self,initialValue,*__args):\n  \"\"\"\n  __new__(cls: type,initialValue: int)\n\n  __new__(cls: type,initialValue: int,lowerLimit: int,upperLimit: int)\n\n  __new__(cls: type,initialValue: int,setLowerLimit: bool,limit: int)\n  \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n CurrentValue=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: CurrentValue(self: OptionInteger) -> int\n\n\n\nSet: CurrentValue(self: OptionInteger)=value\n\n\"\"\"\n\n InitialValue=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: InitialValue(self: OptionInteger) -> int\n\n\n\n\"\"\"\n\n\n\nclass OptionToggle(object,IDisposable):\n \"\"\"\n OptionToggle(initialValue: bool,offValue: str,onValue: str)\n\n OptionToggle(initialValue: bool,offValue: LocalizeStringPair,onValue: LocalizeStringPair)\n \"\"\"\n def Dispose(self):\n  \"\"\" Dispose(self: OptionToggle) \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n @staticmethod\n def __new__(self,initialValue,offValue,onValue):\n  \"\"\"\n  __new__(cls: type,initialValue: bool,offValue: str,onValue: str)\n\n  __new__(cls: type,initialValue: bool,offValue: LocalizeStringPair,onValue: LocalizeStringPair)\n  \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n CurrentValue=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: CurrentValue(self: OptionToggle) -> bool\n\n\n\nSet: CurrentValue(self: OptionToggle)=value\n\n\"\"\"\n\n InitialValue=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: InitialValue(self: OptionToggle) -> bool\n\n\n\n\"\"\"\n\n\n\nclass PickContext(object,IDisposable):\n \"\"\"\n Provides storage for picking operations.\n\n \n\n PickContext()\n \"\"\"\n def Dispose(self):\n  \"\"\" Dispose(self: PickContext) \"\"\"\n  pass\n def PickFrustumTest(self,*__args):\n  \"\"\"\n  PickFrustumTest(self: PickContext,curve: NurbsCurve) -> (bool,float,float,float)\n\n  PickFrustumTest(self: PickContext,bezier: BezierCurve) -> (bool,float,float,float)\n\n  PickFrustumTest(self: PickContext,mesh: Mesh,pickStyle: MeshPickStyle) -> (bool,Point3d,float,float,MeshHitFlag,int)\n\n  PickFrustumTest(self: PickContext,mesh: Mesh,pickStyle: MeshPickStyle) -> (bool,Point3d,Point2d,Point2d,float,float,MeshHitFlag,int)\n\n  PickFrustumTest(self: PickContext,line: Line) -> (bool,float,float,float)\n\n  PickFrustumTest(self: PickContext,point: Point3d) -> (bool,float,float)\n\n  \n\n   Utility for picking 3d point\n\n   Returns: true if there is a hit\n\n  PickFrustumTest(self: PickContext,box: BoundingBox) -> (bool,bool)\n\n  \n\n   Fast test to check if a bounding box intersects a pick frustum.\n\n   Returns: False if bbox is invalid or box does not intersect the pick frustum\n\n  PickFrustumTest(self: PickContext,cloud: PointCloud) -> (bool,int,float,float)\n\n  PickFrustumTest(self: PickContext,points: Array[Point3d]) -> (bool,int,float,float)\n  \"\"\"\n  pass\n def PickMeshTopologyVertices(self,mesh):\n  \"\"\"\n  PickMeshTopologyVertices(self: PickContext,mesh: Mesh) -> Array[int]\n\n  \n\n   Utility for picking mesh vertices\n\n   Returns: indices of mesh topology vertices that were picked\n  \"\"\"\n  pass\n def SetPickTransform(self,transform):\n  \"\"\" SetPickTransform(self: PickContext,transform: Transform) \"\"\"\n  pass\n def UpdateClippingPlanes(self):\n  \"\"\"\n  UpdateClippingPlanes(self: PickContext)\n\n   Updates the clipping plane information in pick region. The\n\n     SetClippingPlanes and \n\n    View fields must be called before calling\n\n     UpdateClippingPlanes().\n  \"\"\"\n  pass\n def __enter__(self,*args):\n  \"\"\"\n  __enter__(self: IDisposable) -> object\n\n  \n\n   Provides the implementation of __enter__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __exit__(self,*args):\n  \"\"\"\n  __exit__(self: IDisposable,exc_type: object,exc_value: object,exc_back: object)\n\n   Provides the implementation of __exit__ for objects which implement IDisposable.\n  \"\"\"\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __repr__(self,*args):\n  \"\"\" __repr__(self: object) -> str \"\"\"\n  pass\n GetObjectUsed=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: GetObjectUsed(self: PickContext) -> GetObject\n\n\n\n\"\"\"\n\n PickGroupsEnabled=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Thue if GroupObjects should be added to the pick list\n\n\n\nGet: PickGroupsEnabled(self: PickContext) -> bool\n\n\n\nSet: PickGroupsEnabled(self: PickContext)=value\n\n\"\"\"\n\n PickLine=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"pick chord starts on near clipping plane and ends on far clipping plane.\n\n\n\nGet: PickLine(self: PickContext) -> Line\n\n\n\nSet: PickLine(self: PickContext)=value\n\n\"\"\"\n\n PickMode=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: PickMode(self: PickContext) -> PickMode\n\n\n\nSet: PickMode(self: PickContext)=value\n\n\"\"\"\n\n PickStyle=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"Get: PickStyle(self: PickContext) -> PickStyle\n\n\n\nSet: PickStyle(self: PickContext)=value\n\n\"\"\"\n\n SubObjectSelectionEnabled=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"True if the user had activated subobject selection\n\n\n\nGet: SubObjectSelectionEnabled(self: PickContext) -> bool\n\n\n\nSet: SubObjectSelectionEnabled(self: PickContext)=value\n\n\"\"\"\n\n View=property(lambda self: object(),lambda self,v: None,lambda self: None)\n \"\"\"This view can be a model view or a page view. When view is a page view,\n\n   then you need to distingish between the viewports MainViewport() and\n\n   ActiveViewport().  When m_view is a model view,both MainViewport() and\n\n   ActiveViewport() return the world view's viewport.\n\n\n\nGet: View(self: PickContext) -> RhinoView\n\n\n\nSet: View(self: PickContext)=value\n\n\"\"\"\n\n\n MeshHitFlag=None\n MeshPickStyle=None\n\n\nclass PickMode(Enum,IComparable,IFormattable,IConvertible):\n \"\"\"\n Picking can happen in wireframe or shaded display mode\n\n \n\n enum PickMode,values: Shaded (2),Wireframe (1)\n \"\"\"\n def __eq__(self,*args):\n  \"\"\" x.__eq__(y) <==> x==yx.__eq__(y) <==> x==yx.__eq__(y) <==> x==y \"\"\"\n  pass\n def __format__(self,*args):\n  \"\"\" __format__(formattable: IFormattable,format: str) -> str \"\"\"\n  pass\n def __ge__(self,*args):\n  pass\n def __gt__(self,*args):\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __le__(self,*args):\n  pass\n def __lt__(self,*args):\n  pass\n def __ne__(self,*args):\n  pass\n def __reduce_ex__(self,*args):\n  pass\n def __str__(self,*args):\n  pass\n Shaded=None\n value__=None\n Wireframe=None\n\n\nclass PickStyle(Enum,IComparable,IFormattable,IConvertible):\n \"\"\"\n Provides picking values that describe common CAD picking behavior.\n\n \n\n enum PickStyle,values: CrossingPick (3),None (0),PointPick (1),WindowPick (2)\n \"\"\"\n def __eq__(self,*args):\n  \"\"\" x.__eq__(y) <==> x==yx.__eq__(y) <==> x==yx.__eq__(y) <==> x==y \"\"\"\n  pass\n def __format__(self,*args):\n  \"\"\" __format__(formattable: IFormattable,format: str) -> str \"\"\"\n  pass\n def __ge__(self,*args):\n  pass\n def __gt__(self,*args):\n  pass\n def __init__(self,*args):\n  \"\"\" x.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signaturex.__init__(...) initializes x; see x.__class__.__doc__ for signature \"\"\"\n  pass\n def __le__(self,*args):\n  pass\n def __lt__(self,*args):\n  pass\n def __ne__(self,*args):\n  pass\n def __reduce_ex__(self,*args):\n  pass\n def __str__(self,*args):\n  pass\n CrossingPick=None\n None=None\n PointPick=None\n value__=None\n WindowPick=None\n\n\n",
  "language": "python",
  "imports": [
    "RhinoCommon"
  ],
  "has_docstring": true
}