{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/scripts/gh_mep_route_visualizer.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "scripts/gh_mep_route_visualizer.py",
  "instruction": "MEP Route Visualizer for Grasshopper.",
  "code": "# File: scripts/gh_mep_route_visualizer.py\n\"\"\"MEP Route Visualizer for Grasshopper.\n\nConverts MEP route JSON from the OAHS routing algorithm into visual Rhino\ngeometry for display and inspection. This component is the visualization\nendpoint of the MEP routing pipeline.\n\nKey Features:\n1. Route Visualization\n   - Converts route segments to Line/Curve geometry\n   - Supports system-type based color coding\n   - Creates junction/Steiner point markers\n\n2. System Color Coding\n   - Distinct colors for each MEP system type\n   - sanitary_drain (Brown), sanitary_vent (Gray)\n   - dhw (Red), dcw (Blue), power (Yellow)\n   - data (Orange), lighting (White)\n\n3. DataTree Output\n   - One branch per route for curves and points\n   - Enables per-route selection and analysis\n   - Compatible with downstream visualization tools\n\nEnvironment:\n    Rhino 8\n    Grasshopper\n    Python component (CPython 3)\n\nDependencies:\n    - Rhino.Geometry: Core geometry creation (via RhinoCommonFactory)\n    - Grasshopper: DataTree and component framework\n    - System.Drawing: Color definitions for visualization\n    - json: Parsing route data from upstream components\n    - timber_framing_generator: RhinoCommonFactory for assembly-safe geometry\n\nPerformance Considerations:\n    - Linear scaling with number of routes and segments\n    - Geometry creation via factory adds minimal overhead\n    - For >100 routes, consider filtering by system type\n\nUsage:\n    1. Connect routes_json from MEP Router component\n    2. Optionally toggle color_by_system for system-type coloring\n    3. Optionally toggle show_junctions to display junction points\n    4. Set run=True to execute visualization\n    5. Connect curves output to Preview or other display components\n\nInput Requirements:\n    Routes JSON (routes_json) - str:\n        JSON string containing computed routes from OAHS router.\n        Must have \"routes\" array with route objects containing\n        \"segments\" (with start/end coords) and optional \"junctions\".\n        Required: Yes\n        Access: Item\n\n    Color by System (color_by_system) - bool:\n        Enable system-type based color coding for route curves.\n        Required: No (defaults to True)\n        Access: Item\n\n    Show Junctions (show_junctions) - bool:\n        Display junction/Steiner points as Point3d geometry.\n        Required: No (defaults to True)\n        Access: Item\n\n    Run (run) - bool:\n        Trigger to execute visualization. Set True to process.\n        Required: Yes\n        Access: Item\n\nOutputs:\n    Curves (curves) - DataTree[Curve]:\n        Route curves as LineCurves, one branch per route.\n        Connect to Preview component for visualization.\n\n    Colors (colors) - List[System.Drawing.Color]:\n        Color list matching curves for system-type visualization.\n        Use with Custom Preview for colored display.\n\n    Points (points) - DataTree[Point3d]:\n        Junction/Steiner points, one branch per route.\n        Useful for debugging routing decisions.\n\n    Info (info) - str:\n        Diagnostic information string with processing summary.\n\nTechnical Details:\n    - Uses RhinoCommonFactory for all geometry creation\n    - Colors use System.Drawing.Color for GH compatibility\n    - DataTrees preserve route-level grouping for selection\n    - Empty/invalid JSON returns empty outputs gracefully\n\nError Handling:\n    - Invalid JSON logs warning and returns empty outputs\n    - Missing fields in route data are skipped with warning\n    - Geometry creation failures logged but don't halt processing\n    - run=False returns immediately with \"Disabled\" info message\n\nAuthor: Fernando Maytorena\nVersion: 1.0.0\n\"\"\"\n\n# =============================================================================\n# Imports\n# =============================================================================\n\n# Standard library\nimport sys\nimport json\nimport traceback\n\n# .NET / CLR\nimport clr\nclr.AddReference(\"Grasshopper\")\nclr.AddReference(\"RhinoCommon\")\nclr.AddReference(\"System.Drawing\")\n\nfrom System import Array\nfrom System.Collections.Generic import List\nfrom System.Drawing import Color\n\n# Rhino / Grasshopper\nimport Rhino\nimport Rhino.Geometry as rg\nimport Grasshopper\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\n\n# =============================================================================\n# Constants\n# =============================================================================\n\nCOMPONENT_NAME = \"MEP Route Visualizer\"\nCOMPONENT_NICKNAME = \"MEP-Viz\"\nCOMPONENT_MESSAGE = \"v1.0.0\"\nCOMPONENT_CATEGORY = \"TimberFraming\"\nCOMPONENT_SUBCATEGORY = \"MEP\"\n\n# System color mapping: system_type -> (R, G, B)\nSYSTEM_COLORS = {\n    \"sanitary_drain\": (139, 90, 43),      # Brown\n    \"sanitary_vent\": (128, 128, 128),     # Gray\n    \"dhw\": (255, 0, 0),                   # Red\n    \"dcw\": (0, 0, 255),                   # Blue\n    \"power\": (255, 255, 0),               # Yellow\n    \"data\": (255, 165, 0),                # Orange\n    \"lighting\": (255, 255, 255),          # White\n    \"default\": (0, 255, 0),               # Green\n}\n\n# =============================================================================\n# Logging Utilities\n# =============================================================================\n\ndef log_message(message, level=\"info\"):\n    \"\"\"Log to console and optionally add GH runtime message.\n\n    Args:\n        message: The message to log\n        level: One of \"info\", \"debug\", \"warning\", \"error\", \"remark\"\n    \"\"\"\n    # Always print to console (captured by 'out' parameter and log files)\n    print(f\"[{level.upper()}] {message}\")\n\n    # Add to GH component UI for warnings and errors\n    if level == \"warning\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning, message)\n    elif level == \"error\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Error, message)\n    elif level == \"remark\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Remark, message)\n\n\ndef log_debug(message):\n    \"\"\"Log debug message (console only).\"\"\"\n    print(f\"[DEBUG] {message}\")\n\n\ndef log_info(message):\n    \"\"\"Log info message (console only).\"\"\"\n    print(f\"[INFO] {message}\")\n\n\ndef log_warning(message):\n    \"\"\"Log warning message (console + GH UI).\"\"\"\n    log_message(message, \"warning\")\n\n\ndef log_error(message):\n    \"\"\"Log error message (console + GH UI).\"\"\"\n    log_message(message, \"error\")\n\n# =============================================================================\n# Component Setup\n# =============================================================================\n\ndef setup_component():\n    \"\"\"Initialize and configure the Grasshopper component.\n\n    This function handles:\n    1. Setting component metadata (name, category, etc.)\n    2. Configuring input parameter names, descriptions, and access\n    3. Configuring output parameter names and descriptions\n\n    Note: Output[0] is reserved for GH's internal 'out' - start from Output[1]\n\n    IMPORTANT: Type Hints cannot be set programmatically in Rhino 8.\n    They must be configured via UI: Right-click input -> Type hint -> Select type\n    \"\"\"\n    # Component metadata\n    ghenv.Component.Name = COMPONENT_NAME\n    ghenv.Component.NickName = COMPONENT_NICKNAME\n    ghenv.Component.Message = COMPONENT_MESSAGE\n    ghenv.Component.Category = COMPONENT_CATEGORY\n    ghenv.Component.SubCategory = COMPONENT_SUBCATEGORY\n\n    # Configure inputs\n    # IMPORTANT: In GHPython, the NickName becomes the Python variable name!\n    # Format: (DisplayName, variable_name, Description, Access)\n    # - Name: Human-readable display name (shown in tooltips)\n    # - NickName: MUST be valid Python identifier - this IS the variable name in code\n    # - Access: item, list, or tree\n    #\n    # NOTE: Type Hints must be set via GH UI (right-click -> Type hint)\n    # They cannot be set programmatically from within the script.\n    inputs = ghenv.Component.Params.Input\n\n    input_config = [\n        # (DisplayName, variable_name, Description, Access)\n        (\"Routes JSON\", \"routes_json\", \"JSON string with computed routes from OAHS router\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Color by System\", \"color_by_system\", \"Enable system-type color coding (default True)\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Show Junctions\", \"show_junctions\", \"Display junction/Steiner points (default True)\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Run\", \"run\", \"Boolean to trigger execution\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n    ]\n\n    for i, (name, nick, desc, access) in enumerate(input_config):\n        if i < inputs.Count:\n            inputs[i].Name = name\n            inputs[i].NickName = nick\n            inputs[i].Description = desc\n            inputs[i].Access = access\n\n    # Configure outputs (start from index 1, as 0 is reserved for 'out')\n    # IMPORTANT: NickName becomes the Python variable name - must match code!\n    outputs = ghenv.Component.Params.Output\n\n    output_config = [\n        # (DisplayName, variable_name, Description) - indices start at 1\n        (\"Curves\", \"curves\", \"Route curves as LineCurves (DataTree, one branch per route)\"),\n        (\"Colors\", \"colors\", \"System.Drawing.Color list matching curves\"),\n        (\"Points\", \"points\", \"Junction/Steiner points (DataTree, one branch per route)\"),\n        (\"Info\", \"info\", \"Diagnostic information string\"),\n    ]\n\n    for i, (name, nick, desc) in enumerate(output_config):\n        idx = i + 1  # Skip Output[0]\n        if idx < outputs.Count:\n            outputs[idx].Name = name\n            outputs[idx].NickName = nick\n            outputs[idx].Description = desc\n\n# =============================================================================\n# Helper Functions\n# =============================================================================\n\ndef get_factory():\n    \"\"\"Get RhinoCommonFactory instance for geometry creation.\n\n    Returns:\n        RhinoCommonFactory instance\n\n    Raises:\n        ImportError: If timber_framing_generator is not installed\n    \"\"\"\n    from src.timber_framing_generator.utils.geometry_factory import get_factory as _get_factory\n    return _get_factory()\n\n\ndef get_system_color(system_type, color_by_system=True):\n    \"\"\"Get System.Drawing.Color for a system type.\n\n    Args:\n        system_type: MEP system type string (e.g., \"sanitary_drain\", \"dhw\")\n        color_by_system: If False, return default green for all systems\n\n    Returns:\n        System.Drawing.Color instance\n    \"\"\"\n    if not color_by_system:\n        rgb = SYSTEM_COLORS[\"default\"]\n    else:\n        # Normalize system type (lowercase, strip whitespace)\n        system_key = system_type.lower().strip() if system_type else \"default\"\n        rgb = SYSTEM_COLORS.get(system_key, SYSTEM_COLORS[\"default\"])\n\n    return Color.FromArgb(255, rgb[0], rgb[1], rgb[2])\n\n\ndef validate_inputs(routes_json_input, run_input):\n    \"\"\"Validate component inputs.\n\n    Args:\n        routes_json_input: Routes JSON string to validate\n        run_input: Run boolean input\n\n    Returns:\n        tuple: (is_valid, error_message)\n    \"\"\"\n    if not run_input:\n        return False, \"Set run=True to execute visualization\"\n\n    if not routes_json_input:\n        return False, \"Missing routes_json input\"\n\n    # Validate JSON parsing\n    try:\n        data = json.loads(routes_json_input)\n        if not isinstance(data, dict):\n            return False, \"routes_json must be a JSON object\"\n        if \"routes\" not in data:\n            return False, \"routes_json missing 'routes' key\"\n    except json.JSONDecodeError as e:\n        return False, f\"Invalid routes_json: {e}\"\n\n    return True, None\n\n\ndef parse_routes(routes_json_str):\n    \"\"\"Parse routes from JSON string.\n\n    Args:\n        routes_json_str: JSON string with routes data\n\n    Returns:\n        List of route dictionaries\n    \"\"\"\n    data = json.loads(routes_json_str)\n    return data.get(\"routes\", [])\n\n\ndef create_route_curves(route, factory):\n    \"\"\"Create LineCurve geometry for route segments.\n\n    Args:\n        route: Route dictionary with \"segments\" list\n        factory: RhinoCommonFactory instance\n\n    Returns:\n        List of LineCurve objects from RhinoCommon assembly\n    \"\"\"\n    curves = []\n    segments = route.get(\"segments\", [])\n\n    for seg in segments:\n        start_coords = seg.get(\"start\")\n        end_coords = seg.get(\"end\")\n\n        if not start_coords or not end_coords:\n            log_debug(f\"Skipping segment with missing start/end in route {route.get('route_id', 'unknown')}\")\n            continue\n\n        if len(start_coords) < 3 or len(end_coords) < 3:\n            log_debug(f\"Skipping segment with incomplete coordinates\")\n            continue\n\n        try:\n            # Use factory to create LineCurve (ensures RhinoCommon assembly)\n            line_curve = factory.create_line_curve(\n                tuple(start_coords[:3]),\n                tuple(end_coords[:3])\n            )\n            if line_curve is not None:\n                curves.append(line_curve)\n        except Exception as e:\n            log_debug(f\"Error creating line curve: {e}\")\n            continue\n\n    return curves\n\n\ndef create_junction_points(route, factory):\n    \"\"\"Create Point3d geometry for route junctions.\n\n    Args:\n        route: Route dictionary with \"junctions\" list\n        factory: RhinoCommonFactory instance\n\n    Returns:\n        List of Point3d objects from RhinoCommon assembly\n    \"\"\"\n    points = []\n    junctions = route.get(\"junctions\", [])\n\n    for junction in junctions:\n        if not junction or len(junction) < 3:\n            log_debug(f\"Skipping junction with incomplete coordinates\")\n            continue\n\n        try:\n            # Use factory to create Point3d (ensures RhinoCommon assembly)\n            pt = factory.create_point3d(\n                float(junction[0]),\n                float(junction[1]),\n                float(junction[2])\n            )\n            if pt is not None:\n                points.append(pt)\n        except Exception as e:\n            log_debug(f\"Error creating junction point: {e}\")\n            continue\n\n    return points\n\n\ndef process_routes(routes_json_str, color_by_system, show_junctions):\n    \"\"\"Process route data and generate visualization geometry.\n\n    Args:\n        routes_json_str: JSON string with routes data\n        color_by_system: Enable system-type color coding\n        show_junctions: Include junction points in output\n\n    Returns:\n        tuple: (curves_tree, colors_list, points_tree, info_string)\n    \"\"\"\n    log_info(\"Starting route visualization processing\")\n\n    # Get geometry factory\n    try:\n        factory = get_factory()\n    except ImportError as e:\n        log_error(f\"Could not import geometry factory: {e}\")\n        return DataTree[object](), [], DataTree[object](), f\"Import error: {e}\"\n\n    # Parse routes\n    routes = parse_routes(routes_json_str)\n    log_info(f\"Parsed {len(routes)} routes\")\n\n    # Initialize output structures\n    curves_tree = DataTree[object]()\n    points_tree = DataTree[object]()\n    colors_list = []\n\n    # Track statistics\n    total_curves = 0\n    total_points = 0\n    system_counts = {}\n\n    # Process each route\n    for route_idx, route in enumerate(routes):\n        route_id = route.get(\"route_id\", f\"route_{route_idx}\")\n        system_type = route.get(\"system_type\", \"default\")\n\n        log_debug(f\"Processing route {route_id} (system: {system_type})\")\n\n        # Track system counts\n        system_counts[system_type] = system_counts.get(system_type, 0) + 1\n\n        # Create path for this route\n        path = GH_Path(route_idx)\n\n        # Create route curves\n        route_curves = create_route_curves(route, factory)\n        for curve in route_curves:\n            curves_tree.Add(curve, path)\n            # Add color for each curve\n            colors_list.append(get_system_color(system_type, color_by_system))\n        total_curves += len(route_curves)\n\n        # Create junction points if requested\n        if show_junctions:\n            route_points = create_junction_points(route, factory)\n            for pt in route_points:\n                points_tree.Add(pt, path)\n            total_points += len(route_points)\n\n    # Build info string\n    info_lines = [\n        f\"Routes processed: {len(routes)}\",\n        f\"Total curve segments: {total_curves}\",\n        f\"Total junction points: {total_points}\",\n        \"System breakdown:\",\n    ]\n    for sys_type, count in sorted(system_counts.items()):\n        info_lines.append(f\"  - {sys_type}: {count} routes\")\n\n    info_string = \"\\n\".join(info_lines)\n    log_info(f\"Visualization complete: {total_curves} curves, {total_points} points\")\n\n    return curves_tree, colors_list, points_tree, info_string\n\n# =============================================================================\n# Main Function\n# =============================================================================\n\ndef main():\n    \"\"\"Main entry point for the component.\n\n    Coordinates the overall workflow:\n    1. Setup component metadata\n    2. Validate inputs\n    3. Process route data\n    4. Return visualization geometry\n\n    Returns:\n        tuple: (curves, colors, points, info) or empty outputs on failure\n    \"\"\"\n    # Setup component\n    setup_component()\n\n    # Initialize empty outputs\n    empty_curves = DataTree[object]()\n    empty_colors = []\n    empty_points = DataTree[object]()\n\n    try:\n        # Get inputs (these come from GH component inputs)\n        # Use globals() to check if variables are defined\n        routes_json_input = routes_json if 'routes_json' in dir() else None\n        color_by_system_input = color_by_system if 'color_by_system' in dir() else True\n        show_junctions_input = show_junctions if 'show_junctions' in dir() else True\n        run_input = run if 'run' in dir() else False\n\n        # Handle None/unset boolean inputs with defaults\n        if color_by_system_input is None:\n            color_by_system_input = True\n        if show_junctions_input is None:\n            show_junctions_input = True\n\n        # Validate inputs\n        is_valid, error_msg = validate_inputs(routes_json_input, run_input)\n        if not is_valid:\n            if error_msg and \"run=True\" not in error_msg:\n                log_warning(error_msg)\n            return empty_curves, empty_colors, empty_points, error_msg or \"Disabled\"\n\n        # Process routes\n        curves_tree, colors_list, points_tree, info_string = process_routes(\n            routes_json_input,\n            color_by_system_input,\n            show_junctions_input\n        )\n\n        return curves_tree, colors_list, points_tree, info_string\n\n    except Exception as e:\n        log_error(f\"Unexpected error: {str(e)}\")\n        log_debug(traceback.format_exc())\n        return empty_curves, empty_colors, empty_points, f\"Error: {str(e)}\"\n\n# =============================================================================\n# Execution\n# =============================================================================\n\nif __name__ == \"__main__\":\n    # Execute main and assign to output variables\n    # These variable names must match your GH component outputs\n    curves, colors, points, info = main()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}