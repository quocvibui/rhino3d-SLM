{
  "source_url": "https://github.com/led-ufc/carcara/blob/f1238d304b65c989cc2af829bc49fc5a2fe589eb/carcara/modules/carcara_geometry.py",
  "repo": "led-ufc/carcara",
  "repo_stars": 3,
  "repo_description": null,
  "license": "MIT",
  "filepath": "carcara/modules/carcara_geometry.py",
  "instruction": "Carcara Geometry - WKT and Grasshopper Geometry Conversion Module\r\n\r\nThis module provides bidirectional conversion between Well-Known Text (WKT) format\r\nand Grasshopper/Rhino geometry objects....",
  "code": "\"\"\"Carcara Geometry - WKT and Grasshopper Geometry Conversion Module\r\n\r\nThis module provides bidirectional conversion between Well-Known Text (WKT) format\r\nand Grasshopper/Rhino geometry objects. Supports points, lines, polygons, and their\r\nmulti-part variants. Also includes polygon analysis utilities like point-in-polygon\r\ntesting and pole of inaccessibility calculation.\r\n\r\nWKT to Grasshopper:\r\n    - parse_wkt: Parse WKT string to Shapely geometry\r\n    - construct_gh_geom: Convert WKT to Grasshopper geometry\r\n    - create_gh_point, create_gh_linestring, create_gh_polygon: Individual converters\r\n\r\nGrasshopper to WKT:\r\n    - construct_wkt: Convert Grasshopper geometry to WKT\r\n    - gh_point_to_wkt, gh_linestring_to_wkt, gh_polygon_to_wkt: Individual converters\r\n    - gh_multipolygon_to_wkt, gh_multilinestring_to_wkt: Multi-part converters\r\n\r\nPolygon Analysis:\r\n    - point_in_polygon: Ray casting point-in-polygon test\r\n    - point_to_polygon_distance: Distance from point to polygon boundary\r\n    - polygon_centroid: Calculate geometric centroid\r\n    - polylabel: Find pole of inaccessibility (farthest interior point from edges)\r\n    - find_interior_point: Combined centroid/polylabel strategy\r\n\r\nVersion: 1.0\r\nDate: 2025/10/16\r\nRequires: rhinoscriptsyntax, Rhino.Geometry, shapely\r\n\"\"\"\r\n\r\nimport re\r\nimport math\r\nimport rhinoscriptsyntax as rs\r\nimport Rhino.Geometry as rg\r\nfrom shapely.wkt import loads\r\nfrom shapely.geometry import (\r\n    Point, MultiPoint, \r\n    LineString, MultiLineString, \r\n    Polygon, MultiPolygon\r\n)\r\n\r\n\r\n###############################################################################\r\n# HELPER FUNCTIONS\r\n###############################################################################\r\n\r\ndef _to_point3d(pt):\r\n    \"\"\"\r\n    Ensure that pt is a Point3d.\r\n    \r\n    Args:\r\n        pt: Point object (Point3d or object with Location attribute)\r\n    \r\n    Returns:\r\n        Point3d: Converted point\r\n    \r\n    Raises:\r\n        ValueError: If conversion fails\r\n    \"\"\"\r\n    if isinstance(pt, rg.Point3d):\r\n        return pt\r\n    elif hasattr(pt, \"Location\"):\r\n        return pt.Location\r\n    else:\r\n        raise ValueError(\"Cannot convert {} to Point3d.\".format(type(pt)))\r\n\r\n\r\n###############################################################################\r\n# WKT TO GRASSHOPPER CONVERSION\r\n###############################################################################\r\n\r\ndef parse_wkt(wkt_str):\r\n    \"\"\"\r\n    Parse WKT string and return Shapely geometry object.\r\n    \r\n    Args:\r\n        wkt_str (str): Well-Known Text string\r\n    \r\n    Returns:\r\n        shapely.geometry: Parsed geometry object\r\n    \r\n    Raises:\r\n        ValueError: If WKT parsing fails\r\n    \"\"\"\r\n    try:\r\n        geometry = loads(wkt_str)\r\n        return geometry\r\n    except Exception as e:\r\n        raise ValueError(\"Failed to parse WKT string: {}\".format(wkt_str))\r\n\r\n\r\ndef create_gh_point(x, y, z=0.0):\r\n    \"\"\"\r\n    Create 3D point in Grasshopper.\r\n    \r\n    Args:\r\n        x (float): X coordinate\r\n        y (float): Y coordinate\r\n        z (float, optional): Z coordinate. Defaults to 0.0\r\n    \r\n    Returns:\r\n        Point: Grasshopper point object\r\n    \"\"\"\r\n    return rs.AddPoint((x, y, z))\r\n\r\n\r\ndef create_gh_multipoint(points):\r\n    \"\"\"\r\n    Create list of 3D points in Grasshopper.\r\n    \r\n    Args:\r\n        points: List of Shapely Point objects\r\n    \r\n    Returns:\r\n        list: List of Grasshopper point objects\r\n    \"\"\"\r\n    return [create_gh_point(p.x, p.y, p.z if p.has_z else 0.0) for p in points]\r\n\r\n\r\ndef create_gh_linestring(coords):\r\n    \"\"\"\r\n    Create polyline in Grasshopper from coordinates.\r\n    \r\n    Args:\r\n        coords: List of coordinate tuples\r\n    \r\n    Returns:\r\n        PolylineCurve: Grasshopper polyline\r\n    \"\"\"\r\n    return rs.AddPolyline([\r\n        (c[0], c[1], c[2] if len(c) > 2 else 0.0) for c in coords\r\n    ])\r\n\r\n\r\ndef create_gh_multilinestring(lines):\r\n    \"\"\"\r\n    Create list of polylines in Grasshopper.\r\n    \r\n    Args:\r\n        lines: List of Shapely LineString objects\r\n    \r\n    Returns:\r\n        list: List of Grasshopper polylines\r\n    \"\"\"\r\n    return [create_gh_linestring(line.coords) for line in lines]\r\n\r\n\r\ndef create_gh_polygon(exterior, interiors=None):\r\n    \"\"\"\r\n    Create closed polyline(s) in Grasshopper for polygon.\r\n    \r\n    Args:\r\n        exterior: Shapely LinearRing (exterior boundary)\r\n        interiors: List of Shapely LinearRing objects (holes), optional\r\n    \r\n    Returns:\r\n        PolylineCurve or list: Closed polyline(s)\r\n    \"\"\"\r\n    exterior_coords = [\r\n        (c[0], c[1], c[2] if len(c) > 2 else 0.0) for c in exterior.coords\r\n    ]\r\n    exterior_polyline = rs.AddPolyline(exterior_coords + [exterior_coords[0]])\r\n    \r\n    if interiors:\r\n        interior_polylines = []\r\n        for interior in interiors:\r\n            int_coords = [\r\n                (c[0], c[1], c[2] if len(c) > 2 else 0.0) for c in interior.coords\r\n            ]\r\n            int_polyline = rs.AddPolyline(int_coords + [int_coords[0]])\r\n            interior_polylines.append(int_polyline)\r\n        return [exterior_polyline] + interior_polylines\r\n    else:\r\n        return exterior_polyline\r\n\r\n\r\ndef create_gh_multipolygon(polygons):\r\n    \"\"\"\r\n    Create list of closed polylines in Grasshopper for multipolygon.\r\n    \r\n    Args:\r\n        polygons: List of Shapely Polygon objects\r\n    \r\n    Returns:\r\n        list: List of closed polylines (including holes)\r\n    \"\"\"\r\n    polylines = []\r\n    for poly in polygons:\r\n        exterior_coords = [\r\n            (c[0], c[1], c[2] if len(c) > 2 else 0.0) \r\n            for c in poly.exterior.coords\r\n        ]\r\n        exterior_polyline = rs.AddPolyline(exterior_coords + [exterior_coords[0]])\r\n        polylines.append(exterior_polyline)\r\n        \r\n        if poly.interiors:\r\n            for interior in poly.interiors:\r\n                int_coords = [\r\n                    (c[0], c[1], c[2] if len(c) > 2 else 0.0) \r\n                    for c in interior.coords\r\n                ]\r\n                int_polyline = rs.AddPolyline(int_coords + [int_coords[0]])\r\n                polylines.append(int_polyline)\r\n    \r\n    return polylines\r\n\r\n\r\ndef construct_gh_geom(wkt_str):\r\n    \"\"\"\r\n    Construct Grasshopper geometry from WKT string.\r\n    \r\n    Args:\r\n        wkt_str (str): Well-Known Text string\r\n    \r\n    Returns:\r\n        Grasshopper geometry object(s)\r\n    \r\n    Raises:\r\n        ValueError: If geometry type is unsupported\r\n    \"\"\"\r\n    geometry = parse_wkt(wkt_str)\r\n    \r\n    if isinstance(geometry, Point):\r\n        return create_gh_point(\r\n            geometry.x, \r\n            geometry.y, \r\n            geometry.z if geometry.has_z else 0.0\r\n        )\r\n    elif isinstance(geometry, MultiPoint):\r\n        return create_gh_multipoint(geometry.geoms)\r\n    elif isinstance(geometry, LineString):\r\n        return create_gh_linestring(geometry.coords)\r\n    elif isinstance(geometry, MultiLineString):\r\n        return create_gh_multilinestring(geometry.geoms)\r\n    elif isinstance(geometry, Polygon):\r\n        return create_gh_polygon(geometry.exterior, geometry.interiors)\r\n    elif isinstance(geometry, MultiPolygon):\r\n        return create_gh_multipolygon(geometry.geoms)\r\n    else:\r\n        raise ValueError(\"Unsupported geometry type: {}\".format(type(geometry)))\r\n\r\n\r\n###############################################################################\r\n# GRASSHOPPER TO WKT CONVERSION\r\n###############################################################################\r\n\r\ndef gh_point_to_wkt(point):\r\n    \"\"\"\r\n    Convert Grasshopper point to WKT POINT string.\r\n    \r\n    Only X and Y coordinates are included.\r\n    \r\n    Args:\r\n        point: Point3d or object with Location attribute\r\n    \r\n    Returns:\r\n        str: WKT POINT representation\r\n    \"\"\"\r\n    p = _to_point3d(point)\r\n    return \"POINT ({:.6f} {:.6f})\".format(p.X, p.Y)\r\n\r\n\r\ndef gh_linestring_to_wkt(linestring):\r\n    \"\"\"\r\n    Convert Grasshopper linestring to WKT LINESTRING string.\r\n    \r\n    Handles LineCurve, NurbsCurve, PolylineCurve, Polyline, and lists.\r\n    \r\n    Args:\r\n        linestring: Curve object or list of points\r\n    \r\n    Returns:\r\n        str: WKT LINESTRING representation\r\n    \"\"\"\r\n    pts = []\r\n    \r\n    if isinstance(linestring, rg.LineCurve):\r\n        start = linestring.PointAt(linestring.Domain.T0)\r\n        end = linestring.PointAt(linestring.Domain.T1)\r\n        pts = [_to_point3d(start), _to_point3d(end)]\r\n    \r\n    elif isinstance(linestring, rg.NurbsCurve):\r\n        for i in range(linestring.Points.Count):\r\n            cp = linestring.Points[i]\r\n            if hasattr(cp, \"Location\"):\r\n                pts.append(_to_point3d(cp.Location))\r\n            else:\r\n                pts.append(_to_point3d(cp))\r\n    \r\n    elif hasattr(linestring, \"ToPolyline\") and isinstance(linestring, (rg.PolylineCurve, rg.Polyline)):\r\n        poly = linestring.ToPolyline()\r\n        pts = [_to_point3d(pt) for pt in poly]\r\n    \r\n    elif isinstance(linestring, list):\r\n        pts = [_to_point3d(pt) for pt in linestring]\r\n    \r\n    else:\r\n        try:\r\n            pts = [_to_point3d(pt) for pt in linestring]\r\n        except:\r\n            pts = [_to_point3d(linestring)]\r\n    \r\n    pts_str = \", \".join(\"{:.6f} {:.6f}\".format(pt.X, pt.Y) for pt in pts)\r\n    return \"LINESTRING ({})\".format(pts_str)\r\n\r\n\r\ndef gh_polygon_to_wkt(polygon):\r\n    \"\"\"\r\n    Convert Grasshopper polygon to WKT POLYGON string.\r\n    \r\n    Only X and Y coordinates are included.\r\n    \r\n    Args:\r\n        polygon: Closed PolylineCurve or Polyline\r\n    \r\n    Returns:\r\n        str: WKT POLYGON representation\r\n    \r\n    Raises:\r\n        ValueError: If no points found\r\n    \"\"\"\r\n    pts = []\r\n    if hasattr(polygon, \"ToPolyline\"):\r\n        poly = polygon.ToPolyline()\r\n        pts = [_to_point3d(pt) for pt in poly]\r\n    else:\r\n        pts = [_to_point3d(pt) for pt in polygon]\r\n    \r\n    if not pts:\r\n        raise ValueError(\"No points found in the polygon geometry.\")\r\n    \r\n    if pts[0] != pts[-1]:\r\n        pts.append(pts[0])\r\n    \r\n    pts_str = \", \".join(\"{:.6f} {:.6f}\".format(pt.X, pt.Y) for pt in pts)\r\n    return \"POLYGON (({}))\".format(pts_str)\r\n\r\n\r\ndef gh_multipolygon_to_wkt(gh_geom_list):\r\n    \"\"\"\r\n    Convert list of Grasshopper polygons to WKT MULTIPOLYGON string.\r\n    \r\n    Args:\r\n        gh_geom_list (list): List of polygon geometries\r\n    \r\n    Returns:\r\n        str: WKT MULTIPOLYGON representation\r\n    \r\n    Raises:\r\n        ValueError: If geometry list is empty\r\n    \"\"\"\r\n    if not gh_geom_list:\r\n        raise ValueError(\"The geometry list is empty.\")\r\n    \r\n    polygon_wkts = []\r\n    for poly in gh_geom_list:\r\n        poly_wkt = gh_polygon_to_wkt(poly)\r\n        inner = poly_wkt.replace(\"POLYGON\", \"\").strip()\r\n        if inner.startswith(\"(\") and inner.endswith(\")\"):\r\n            inner = inner[1:-1].strip()\r\n        polygon_wkts.append(\"({})\".format(inner))\r\n    \r\n    return \"MULTIPOLYGON ({})\".format(\", \".join(polygon_wkts))\r\n\r\n\r\ndef gh_multilinestring_to_wkt(gh_geom_list):\r\n    \"\"\"\r\n    Convert list of curves to WKT MULTILINESTRING string.\r\n    \r\n    Only X and Y coordinates are included.\r\n    \r\n    Args:\r\n        gh_geom_list (list): List of open curve geometries\r\n    \r\n    Returns:\r\n        str: WKT MULTILINESTRING representation\r\n    \"\"\"\r\n    ls_parts = []\r\n    for crv in gh_geom_list:\r\n        wkt = gh_linestring_to_wkt(crv)\r\n        inner = wkt.replace(\"LINESTRING\", \"\").strip()\r\n        if inner.startswith(\"(\") and inner.endswith(\")\"):\r\n            inner = inner[1:-1].strip()\r\n        ls_parts.append(\"({})\".format(inner))\r\n    \r\n    return \"MULTILINESTRING ({})\".format(\", \".join(ls_parts))\r\n\r\n\r\ndef construct_wkt(gh_geom):\r\n    \"\"\"\r\n    Convert Grasshopper geometry to WKT string.\r\n    \r\n    Args:\r\n        gh_geom: Single geometry or list of geometries\r\n    \r\n    Returns:\r\n        str: WKT representation\r\n    \r\n    Raises:\r\n        ValueError: If geometry type is unsupported or list is empty\r\n    \"\"\"\r\n    if isinstance(gh_geom, list):\r\n        if len(gh_geom) == 0:\r\n            raise ValueError(\"Empty geometry list provided.\")\r\n        elif len(gh_geom) == 1:\r\n            return construct_wkt(gh_geom[0])\r\n        else:\r\n            # All points -> MULTIPOINT\r\n            if all(hasattr(g, \"X\") or hasattr(g, \"Location\") for g in gh_geom):\r\n                pts = [_to_point3d(g) for g in gh_geom]\r\n                pts_str = \", \".join(\"{:.6f} {:.6f}\".format(pt.X, pt.Y) for pt in pts)\r\n                return \"MULTIPOINT ({})\".format(pts_str)\r\n            \r\n            # All curves -> check if closed\r\n            elif all(isinstance(g, (rg.PolylineCurve, rg.Polyline, rg.LineCurve, rg.NurbsCurve)) for g in gh_geom):\r\n                if hasattr(gh_geom[0], \"IsClosed\") and gh_geom[0].IsClosed:\r\n                    return gh_multipolygon_to_wkt(gh_geom)\r\n                else:\r\n                    return gh_multilinestring_to_wkt(gh_geom)\r\n            else:\r\n                converted = [construct_wkt(g) for g in gh_geom]\r\n                return \", \".join(converted)\r\n    else:\r\n        if isinstance(gh_geom, rg.Point3d) or hasattr(gh_geom, \"Location\"):\r\n            return gh_point_to_wkt(gh_geom)\r\n        elif isinstance(gh_geom, (rg.PolylineCurve, rg.Polyline)):\r\n            if hasattr(gh_geom, \"IsClosed\") and gh_geom.IsClosed:\r\n                return gh_polygon_to_wkt(gh_geom)\r\n            else:\r\n                return gh_linestring_to_wkt(gh_geom)\r\n        elif isinstance(gh_geom, (rg.LineCurve, rg.NurbsCurve)):\r\n            return gh_linestring_to_wkt(gh_geom)\r\n        else:\r\n            raise ValueError(\"Unsupported geometry type: {}\".format(type(gh_geom)))\r\n\r\n\r\n###############################################################################\r\n# POLYGON ANALYSIS FUNCTIONS\r\n###############################################################################\r\n\r\ndef point_in_polygon(x, y, vertices):\r\n    \"\"\"\r\n    Ray casting algorithm to test if point is inside polygon.\r\n    \r\n    Args:\r\n        x (float): Point X coordinate\r\n        y (float): Point Y coordinate\r\n        vertices (list): List of (x, y) tuples defining polygon\r\n    \r\n    Returns:\r\n        bool: True if point is inside polygon\r\n    \"\"\"\r\n    n = len(vertices)\r\n    inside = False\r\n    \r\n    p1x, p1y = vertices[0]\r\n    for i in range(1, n + 1):\r\n        p2x, p2y = vertices[i % n]\r\n        if y > min(p1y, p2y):\r\n            if y <= max(p1y, p2y):\r\n                if x <= max(p1x, p2x):\r\n                    if p1y != p2y:\r\n                        xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\r\n                    if p1x == p2x or x <= xinters:\r\n                        inside = not inside\r\n        p1x, p1y = p2x, p2y\r\n    \r\n    return inside\r\n\r\n\r\ndef point_to_polygon_distance(x, y, vertices):\r\n    \"\"\"\r\n    Calculate minimum distance from point to polygon boundary.\r\n    \r\n    Args:\r\n        x (float): Point X coordinate\r\n        y (float): Point Y coordinate\r\n        vertices (list): List of (x, y) tuples defining polygon\r\n    \r\n    Returns:\r\n        float: Minimum distance to polygon boundary\r\n    \"\"\"\r\n    min_dist = float('inf')\r\n    \r\n    for i in range(len(vertices) - 1):\r\n        x1, y1 = vertices[i]\r\n        x2, y2 = vertices[i + 1]\r\n        \r\n        dx = x2 - x1\r\n        dy = y2 - y1\r\n        \r\n        if dx == 0 and dy == 0:\r\n            dist = math.sqrt((x - x1)**2 + (y - y1)**2)\r\n        else:\r\n            t = max(0, min(1, ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy)))\r\n            proj_x = x1 + t * dx\r\n            proj_y = y1 + t * dy\r\n            dist = math.sqrt((x - proj_x)**2 + (y - proj_y)**2)\r\n        \r\n        min_dist = min(min_dist, dist)\r\n    \r\n    return min_dist\r\n\r\n\r\ndef polygon_centroid(vertices):\r\n    \"\"\"\r\n    Calculate geometric centroid of polygon.\r\n    \r\n    Args:\r\n        vertices (list): List of (x, y) tuples defining polygon\r\n    \r\n    Returns:\r\n        tuple: (x, y) coordinates of centroid\r\n    \"\"\"\r\n    unique_vertices = vertices[:-1] if vertices[0] == vertices[-1] else vertices\r\n    \r\n    if not unique_vertices:\r\n        return (0, 0)\r\n    \r\n    sum_x = sum(v[0] for v in unique_vertices)\r\n    sum_y = sum(v[1] for v in unique_vertices)\r\n    \r\n    return (sum_x / len(unique_vertices), sum_y / len(unique_vertices))\r\n\r\n\r\ndef polylabel(vertices, precision=0.01):\r\n    \"\"\"\r\n    Find pole of inaccessibility using grid search.\r\n    \r\n    Returns the point inside polygon that is farthest from all edges.\r\n    \r\n    Args:\r\n        vertices (list): List of (x, y) tuples defining polygon\r\n        precision (float, optional): Grid cell size precision. Defaults to 0.01\r\n    \r\n    Returns:\r\n        tuple: ((x, y), distance) where (x, y) is the pole and distance is the distance to nearest edge\r\n    \"\"\"\r\n    xs = [v[0] for v in vertices[:-1]]\r\n    ys = [v[1] for v in vertices[:-1]]\r\n    min_x, max_x = min(xs), max(xs)\r\n    min_y, max_y = min(ys), max(ys)\r\n    \r\n    width = max_x - min_x\r\n    height = max_y - min_y\r\n    cell_size = max(min(width, height) / 20, precision)\r\n    \r\n    best_point = None\r\n    best_distance = -1\r\n    \r\n    y = min_y\r\n    while y <= max_y:\r\n        x = min_x\r\n        while x <= max_x:\r\n            if point_in_polygon(x, y, vertices):\r\n                distance = point_to_polygon_distance(x, y, vertices)\r\n                if distance > best_distance:\r\n                    best_distance = distance\r\n                    best_point = (x, y)\r\n            x += cell_size\r\n        y += cell_size\r\n    \r\n    if best_point is None:\r\n        best_point = ((min_x + max_x) / 2, (min_y + max_y) / 2)\r\n        best_distance = 0\r\n    \r\n    return best_point, best_distance\r\n\r\n\r\ndef find_interior_point(vertices, precision=0.01):\r\n    \"\"\"\r\n    Find point inside polygon using centroid-first strategy.\r\n    \r\n    Tries centroid first (fastest), falls back to polylabel if outside.\r\n    \r\n    Args:\r\n        vertices (list): List of (x, y) tuples defining polygon\r\n        precision (float, optional): Precision for polylabel. Defaults to 0.01\r\n    \r\n    Returns:\r\n        tuple: ((x, y), method) where method is \"centroid\" or \"polylabel\"\r\n    \"\"\"\r\n    centroid = polygon_centroid(vertices)\r\n    \r\n    if point_in_polygon(centroid[0], centroid[1], vertices):\r\n        return centroid, \"centroid\"\r\n    \r\n    point, distance = polylabel(vertices, precision)\r\n    return point, \"polylabel\"\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}