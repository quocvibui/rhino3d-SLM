{
  "source_url": "https://github.com/JobdeVogel/Solar-Irradiation-Prediction/blob/ce25b61727edaaaeb0e965bb821506de01cb0dcc/dataset/load_3dbag/meshing.py",
  "repo": "JobdeVogel/Solar-Irradiation-Prediction",
  "repo_stars": 0,
  "repo_description": "Graduation repository for Master Building Technology",
  "license": "unknown",
  "filepath": "dataset/load_3dbag/meshing.py",
  "instruction": "Meshing",
  "code": "import Rhino.Geometry as rg\nimport System\nimport math\nimport random\nimport sys\nimport time\n\nimport Rhino\nimport json\n\nfrom parameters.params import MAX_CONTAINMENT_ITERATIONS, _REDUCE_SEGMENTS_TOLERANCE, _MESH_SPLITTER_BBOX_HEIGHT, _ANGLE_TOLERANCE_POSTP_MESH, _DIAGONAL_LENGTH_RATIO_POSTP_MESH\n#import cProfile\n  \ndef temp_save(meshes, path):  \n    options = Rhino.FileIO.SerializationOptions()\n    data = []\n    \n    for mesh in meshes:\n        data.append(mesh.ToJSON(options))\n    \n    with open(path, \"w\") as file:\n        json.dump(data, file)  \n  \n  \ndef postprocess_mesh(mesh, check=False):\n    \"\"\"Postprocess a mesh such that there are no invalid faces or vertices\n\n    Args:\n        mesh (rg.Mesh): mesh\n        check (bool, optional): Check if the mesh is valid. Defaults to False.\n\n    Returns:\n        mesh (rg.Mesh): postprocessd mesh\n    \"\"\"\n    \n    # Convert triangle faces to quad\n    mesh.Faces.ConvertTrianglesToQuads(_ANGLE_TOLERANCE_POSTP_MESH, _DIAGONAL_LENGTH_RATIO_POSTP_MESH)\n    \n    # Get vertices and faces    \n    vertices = mesh.Vertices\n    faces = mesh.Faces\n    \n    # Initialize a rebuild mesh\n    rebuild_mesh = rg.Mesh()\n\n    # Add the mesh vertices and faces to the rebuild mesh\n    rebuild_mesh.Vertices.AddVertices(vertices)\n    rebuild_mesh.Faces.AddFaces(faces)\n    \n    # Compute the normals\n    rebuild_mesh.Normals.ComputeNormals()\n        \n    # Transform the mesh to a compact shape\n    rebuild_mesh.Compact()\n        \n    # Cull degenerate faces\n    rebuild_mesh.Faces.CullDegenerateFaces()\n    \n    # Delete zero area mesh faces\n    indices =  rebuild_mesh.Faces.GetZeroAreaFaces()[1]\n    rebuild_mesh.Faces.DeleteFaces(indices, True)\n        \n    indices =  rebuild_mesh.Faces.GetZeroAreaFaces()[2]\n    rebuild_mesh.Faces.DeleteFaces(indices, True)\n        \n    return rebuild_mesh\n\ndef get_random_face_center(mesh):\n    \"\"\"Extract a random face center from a mesh\n\n    Args:\n        mesh (rg.Mesh): mesh\n\n    Returns:\n        checkpoint (rg.Point3d): random face center\n    \"\"\"\n    \n    # Random index\n    idx = random.randint(0, len(mesh.Faces))\n    \n    # Get the vertices from the face\n    vertices = mesh.Faces.GetFaceVertices(idx)[1:]\n    \n    # Compute the center of the face\n    center_x = sum(p.X for p in vertices) / len(vertices)\n    center_y = sum(p.Y for p in vertices) / len(vertices)\n    center_z = sum(p.Z for p in vertices) / len(vertices)\n\n    # Generate a point\n    checkpoint = rg.Point3d(center_x, center_y, center_z)   \n    \n    return checkpoint\n    \ndef is_inside(mesh, curves, max_iterations=MAX_CONTAINMENT_ITERATIONS, logger=False, std=False):\n    \"\"\"Check if a planar mesh is inside any curve in a set of curves. This procedure works by taking a\n    mesh face center and then checking if this center is inside the curve. In some special\n    cases, this point intersects with the curve. In that case the multiple random faces centers\n    are taken until a point does not intersect, or the max containment iterations is reached.\n    If it still intersects, it is assumed that the mesh is inside the curve.\n\n    Args:\n        mesh (rg.Mesh): planar mesh\n        curves (list(rg.NurbsCurve)): list of planar curves\n        max_iterations (int, optional): Number of maximum containment iterations. Defaults to MAX_CONTAINMENT_ITERATIONS.\n\n    Returns:\n        inside (bool): indicates if inside one of the cuves\n    \"\"\"\n      \n    # Generate an intial checkpoint\n    checkpoint = get_random_face_center(mesh)\n        \n    # Bool indicating if mesh is inside the curve\n    inside = False\n    \n    # Find a quad mesh and get the face center\n    checkpoint = None\n    for i, face in enumerate(mesh.Faces):\n        if face.IsQuad:\n            checkpoint = mesh.Faces.GetFaceCenter(i)\n            break\n    \n    # The mesh does not have quad faces (outlier situation)\n    if not isinstance(checkpoint, rg.Point3d):\n        # Generate an intial checkpoint\n        checkpoint = get_random_face_center(mesh) \n    \n    # Iterate over the curves\n    for curve in curves:\n        # Iterate over the max iterations\n        for i in range(max_iterations):\n            # Check if the curve contains the checkpoint\n            \n            if curve.Contains(checkpoint, rg.Plane.WorldXY, tolerance=1e-8) == rg.PointContainment.Inside:\n                inside = True\n                break\n            elif curve.Contains(checkpoint, rg.Plane.WorldXY, tolerance=1e-8) == rg.PointContainment.Coincident:\n                inside = True\n            \n                # Generate a new checkpoint\n                checkpoint = get_random_face_center(mesh)\n                    \n                if i == max_iterations - 1:\n                    if logger:\n                        logger.warning('Point containment coincident')\n                break\n    if std:\n        print((checkpoint.X, checkpoint.Y, checkpoint.Z))\n\n    return inside\n\ndef project_outlines_to_world_xy(outlines):\n    \"\"\"Project polylines to the world XY plane, returns both a polyline and curves format\n\n    Args:\n        outlines (list[list[rg.Polyline]]): building outulines as polylines\n        \n    Returns:\n        polylines (list[list[rg.Polyline]]): projected polylines\n        curves (list[rg.NurbsCurve]): projected curves    \n    \"\"\"\n    \n    # Store the projected polylines and curves as lists\n    polylines = []\n    curves = []\n    \n    # Project the building outlines on the mesh plane\n    for outline_set in outlines:\n        # Store projections per building\n        temp_polylines = []\n        temp_curves = []\n        \n        # Iterate over the polylines used in the building outlines\n        for polyline in outline_set:\n            # Reduce the number of segments in the polyline\n            polyline.ReduceSegments(_REDUCE_SEGMENTS_TOLERANCE)\n            \n            # Convert a duplicate polyline to a nurbscurve\n            curve = polyline.Duplicate().ToNurbsCurve()\n            \n            # Project the curve on the mesh plane\n            projected_curve = curve.ProjectToPlane(curve, rg.Plane.WorldXY)\n            \n            # Generate a polyline from the curve\n            projected_polyline = projected_curve.TryGetPolyline()[1]\n            \n            # Append the building polylines and curves to all polylines and curves\n            temp_polylines.append(projected_polyline)\n            temp_curves.append(projected_curve)\n        \n        polylines.append(temp_polylines)\n        curves.append(temp_curves)    \n        \n    return polylines, curves\n\ndef compute_area(ground, roofs):\n    ground_area = rg.AreaMassProperties.Compute(ground).Area\n    building_area = sum([rg.AreaMassProperties.Compute(building).Area for building in roofs])\n    \n    return ground_area, building_area\n\ndef remesh_rough(mesh):\n    rough_mesh = mesh.Duplicate()\n    \n    rough_mesh.Reduce(100, False, 3, False, False)\n\n    return rough_mesh\n\ndef polyline_isclockwise(polyline):\n    \"\"\"Check if the vertices of a polyline are clockwise\n\n    Args:\n        polyline (rg.Polyline): polyline\n\n    Returns:\n        bool: True if clockwise\n    \"\"\"\n    \n    # Connvert to duplicate nurbscurve to avoid in-place changes\n    curve = polyline.Duplicate().ToNurbsCurve()\n    return curve.ClosedCurveOrientation() == rg.CurveOrientation.Clockwise\n\ndef mesh_extrude_polyline(polyline, height, grid_size):\n    \"\"\"Extrude a polyline to a mesh\n\n    Args:\n        polyline (rg.Polyline): polyline\n        height (float): height of the building\n        grid_size (float): approximate size of the mesh faces\n\n    Returns:\n        meshh (rg.Mesh): wall mesh\n    \"\"\"\n    vertices = []\n    faces = []\n    \n    # Reduce the number of segments to a minimum\n    polyline.ReduceSegments(_REDUCE_SEGMENTS_TOLERANCE)\n    \n    # Extract the segments to a list\n    segments = polyline.GetSegments()\n    \n    # Get the lengths of each segment\n    lengths = [segment.Length for segment in segments]\n    \n    # Compute how many faces each segment should have in horizonal direction\n    num_segments = [int(math.ceil(length / grid_size)) for length in lengths]\n    \n    # Compute how many faces each segment should have in vertical directioin\n    levels = int(math.ceil(height / grid_size))\n    \n    # Total number of faces in horizontal directtion\n    num_p = sum(num_segments)\n    \n    # Vertices on the ground level\n    base_vertices = []\n    \n    # Vertices all together\n    vertices = []\n    \n    # Iterate over the segments\n    for segment, num_segment in zip(segments, num_segments):\n        \n        # Iterate over the number of segments\n        for i in range(num_segment):\n            parameter = i * (1 / num_segment)\n            \n            # Add the vertex to the base vertices\n            base_vertices.append(segment.PointAt(parameter))\n    \n    # Iterate over the vertical levels\n    for j in range(levels + 1):\n        parameter = j * (height / levels)\n        \n        # Iterate over the base vertices\n        for vertex in base_vertices:\n            # Add a base vertex at each level\n            vertices.append(rg.Point3d(vertex.X, vertex.Y, vertex.Z + parameter))\n    \n    # Generate the mesh faces\n    faces = System.Array[rg.MeshFace]([\n        rg.MeshFace(i + j * num_p, i + (j + 1) * num_p, (i + 1) % num_p + (j + 1) * num_p, (i + 1) % num_p + j * num_p)\n        for j in range(levels)\n        for i in range(num_p)\n    ])\n    \n    # Initialize a new mesh\n    mesh = rg.Mesh()\n    \n    # Add the vertices and faces to the mesh\n    mesh.Vertices.AddVertices(System.Array[rg.Point3d](vertices))\n    mesh.Faces.AddFaces(faces)\n    \n    return mesh\n\ndef generate_vertical(building_outlines, courtyard_outlines, heights, grid_size, logger=False):\n    \"\"\"_summary_\n\n    Args:\n        building_outlines (list[list[rg.Polyline]]): List of building outlines\n        courtyard_outlines (list[list[rg.Polyline]]): Inner courtyard polylines of the buildings\n        heights (list[float]): heigths of the buildings\n        grid_size (float): grid size\n\n    Returns:\n        meshes (list[rg.Mesh]): walls for the buildings based on the outlines\n        outlines (list[rg.Polyline]): outlines of the buildings, possibly reversed direction\n    \"\"\"\n    \n    # Store the outputs in lists\n    meshes = []\n\n    # Iterate over the buildings\n    for building, courtyard, height in zip(building_outlines, courtyard_outlines, heights):\n        # Store courtyard and building walls in one temp mesh\n        temp_mesh = rg.Mesh()\n        \n        # Reverse direction of outlines if necessary\n        for outline in building:\n            # Reverse direction if necessary\n            if not polyline_isclockwise(outline):\n                outline.Reverse()\n            \n            # Extrude the polyline in z direction based on height\n            mesh = mesh_extrude_polyline(outline, height, grid_size)\n            \n            # Append the results to list variables\n            temp_mesh.Append(mesh)\n        \n        # Iterate over courtyards\n        for outline in courtyard:\n            # Reverse directtion if necessary\n            if polyline_isclockwise(outline):\n                outline.Reverse()\n            \n            # Appeend the results to list variables\n            mesh = mesh_extrude_polyline(outline, height, grid_size)\n            temp_mesh.Append(mesh)\n        \n        # Append the building walls processed, as a single mesh        \n        meshes.append(postprocess_mesh(temp_mesh))\n\n    if logger:\n        logger.debug(f'Generated {len(meshes)} meshes and outlines.')\n    return meshes\n\ndef extrude(polyline):\n    lower_polyline = rg.Polyline(\n        [p + rg.Vector3d(0,0,-1) for p in polyline]\n    )\n    \n    mesh = rg.Mesh()\n    for pt in lower_polyline:\n        mesh.Vertices.Add(pt)\n        mesh.Vertices.Add(pt + rg.Vector3d(0,0,2))\n    \n    for i in range(len(polyline) - 1):\n        mesh.Faces.AddFace(i * 2, i * 2 + 1, (i + 1) * 2 + 1, (i + 1) * 2)\n    \n    mesh.Vertices.CullUnused()\n    mesh.Vertices.CombineIdentical(True, True)\n    mesh.RebuildNormals()\n    \n    return mesh\n\ndef generate_horizontal(ground_outline, building_polylines, courtyard_polylines, building_curves, courtyard_curves, heights, grid_size, size, logger=False):\n    \"\"\"Generate ground and roofs by splitting a mesh plane\n\n    Args:\n        ground_outline (rg.Rectangle3d): ground patch outline\n        building_outlines (list[list[rg.NurbsCurve]]): outlines for buildings\n        courtyard_outlines (list[list[rg.NurbsCurve]]): outlines for courtyards\n        heights (list[float]): building heights\n        grid_size (float): grid size\n\n    Returns:\n        ground (rg.Mesh): 2D mesh for ground\n        roofs (list[rg.Mesh]): roof meshes\n        valid (list[bool]): indicates if a roof mesh is valid\n    \"\"\"\n    \n    # Generate plane parameters\n    box_interval = rg.Box(ground_outline.BoundingBox)\n    plane_width = rg.Interval(box_interval.X[0], box_interval.X[1])\n    plane_height = rg.Interval(box_interval.Y[0], box_interval.Y[1])\n    plane = rg.Plane.WorldXY\n\n    # Compute the number of face divisions for the mesh plane    \n    width_divisions = System.Int32(int(plane_width.Length / grid_size))\n    length_divisions = System.Int32(int(plane_height.Length / grid_size))\n    \n    # Generate the mesh plane\n    mesh_plane = rg.Mesh.CreateFromPlane(plane, plane_width, plane_height, width_divisions, length_divisions)   \n    \n    # Generate the splitters from the inner and outer polylines\n    params = rg.MeshingParameters.QualityRenderMesh\n    bbox = rg.BoundingBox(0,0,-_MESH_SPLITTER_BBOX_HEIGHT,size,size,_MESH_SPLITTER_BBOX_HEIGHT)\n    \n    # Store the splitters in a list\n    splitters = []\n    valid = []\n    \n    # Iterate over the buildings\n    for outline_set in building_curves:\n        # Store the splitters per building\n        temp_splitters = []\n        \n        # Iterate over the outlines\n        for curve in outline_set:\n            # Create a duplicate curve\n            temp_curve = curve.Duplicate()\n            \n            # Translate the curve to z = -1\n            temp_curve.Translate(0,0,-1)\n            \n            # Generate a mesh splitter (extra unit on -z side)\n            splitter = rg.Mesh.CreateFromCurveExtrusion(temp_curve, rg.Vector3d(0,0,1), params, bbox)\n            \n            # Add the splitter to all splitters for this specific building\n            temp_splitters.append(splitter)\n        \n        # Add the building splitters to all building splitters\n        splitters.append(temp_splitters)\n    \n    # Store the splitters in a list\n    roofs = []\n\n    # Iterate over the splitters and buildings\n    for sample, (splitter_set, building_curve_set, courtyard_curve_set) in enumerate(zip(splitters, building_curves, courtyard_curves)):\n        \n        # Store the roof meshes for a single building in a temp mesh\n        temp_roofs = rg.Mesh()\n        \n        # Iterate over the building outlines\n        for splitter, building_curve in zip(splitter_set, building_curve_set):\n            success = False\n            \n            # Split the mesh\n            # ----- WARNING: VERY TIME CONSUMING! -----\n            elements = mesh_plane.Split(splitter)\n            \n            # Postprocess the mesh elements\n            elements = [postprocess_mesh(element) for element in elements]\n            \n            # If more than one splitting elements returned\n            if len(elements) > 1:\n                success = True\n                \n                # Check if the element is inside the building or outside (part of the ground)\n                relations = [is_inside(element, [building_curve]) for element in elements]\n                                \n                # Generate a roof mesh\n                roof = rg.Mesh()\n                \n                # Generate a ground elements mesh\n                ground_elements = rg.Mesh()\n                \n                # Iterate over the splitted elements and the relations\n                for element, relation in zip(elements, relations):\n                    # If the element is inside the roof outline\n                    if relation:\n                        # Add the element to the roof mesh\n                        roof.Append(element)\n                    else:\n                        # Add the element to the ground mesh\n                        ground_elements.Append(element)\n                    \n                # Add the roof mesh to the temp roofs for this building\n                temp_roofs.Append(roof)\n                \n                # Overwrite the mesh plane to the ground elements\n                mesh_plane = ground_elements\n            else:\n                if logger:\n                    logger.warning(\"Splitting did not result in multiple elements\")\n        \n        # Check if this building has courtyards\n        if len(courtyard_curve_set) > 0 and success:\n            # Iterate over the polylines in the courtyards\n            for i, courtyard_curve in enumerate(courtyard_curve_set):\n                # Generate a splitter for the courtyard\n                splitter = rg.Mesh.CreateFromCurveExtrusion(courtyard_curve, rg.Vector3d(0,0,2), params, bbox)\n                \n                # Split the roofs of this building by the courtyard splitter\n                elements = temp_roofs.Split(splitter)\n\n                # If the splitting resulted in more than one mesh\n                if len(elements) > 1:\n                    # Check if the element is inside the courtyard or outside (part of the roof)     \n                    relations = [is_inside(element, [courtyard_curve]) for element in elements]\n                    \n                    # Generate a new roof mesh\n                    roof = rg.Mesh()\n                    \n                    # Store the courtyard elements\n                    courtyard_elements = rg.Mesh()\n                    \n                    # Iterate over the splitted elements from the roof\n                    for element, relation in zip(elements, relations):\n                        # If the roof is inside the courtyard\n                        if relation:\n                            # Add to the courtyard elements\n                            courtyard_elements.Append(element)\n                        else:\n                            # Add to the roof elements\n                            roof.Append(element)\n                            temp_roofs = element\n                    \n                    # Add the courtyard elements to the mesh plane\n                    mesh_plane.Append(courtyard_elements)\n                else:\n                    if logger:\n                        logger.warning(\"Splitting did not result in multiple elements\")\n        \n        if success:\n            # Add the roof to the list of roofs\n            roofs.append(roof)\n            valid.append(True)\n        else:\n           valid.append(False)\n   \n    # Postprocess the ground mesh plane mesh\n    ground = postprocess_mesh(mesh_plane)\n    \n    heights = [height for i, height in enumerate(heights) if valid[i]]\n\n    # Iterate over the roof meshes to translate to the correct height\n    for i, (mesh, height) in enumerate(zip(roofs, heights)):\n        # Generate a duplicate translated mesh\n        translated_mesh = mesh.Duplicate()\n        \n        # Create a transform based on the height\n        transform = rg.Transform.Translation(System.Double(0.0),System.Double(0.0),System.Double(height))\n        \n        # Move the mesh\n        translated_mesh.Transform(transform)\n        \n        # Set the translated mesh after postprocessing\n        roofs[i] = postprocess_mesh(translated_mesh)\n    \n    for i, roof in enumerate(roofs):\n        if len(roof.Vertices) < 3:\n            valid[i] = False\n        elif len(roof.Faces) == 0:\n            valid[i] = False\n\n    invalid_idxs = []\n    for i, val in enumerate(valid):\n        if not val:\n            invalid_idxs.append(i)\n\n    return ground, roofs, invalid_idxs\n\n'''\nREMESHING FUNCTIONS\n'''\n\ndef remesh_horizontal(mesh):\n    \"\"\"Remesh horizontal mesh elements\n\n    Args:\n        mesh (rg.Mesh): horizontal mesh\n\n    Returns:\n        rough_mesh (rg.Mesh): reduced\n    \"\"\"\n    \n    rough_mesh = mesh.Duplicate()\n    \n    rough_mesh.Reduce(100, False, 3, False, False)\n\n    return rough_mesh\n\ndef remesh_vertical(curve, height):\n    \"\"\"Mesh vertical elements by using outlines and height\n\n    Args:\n        outlines (list[rg.Polyline]): building outlines\n        height (list[float]): heights of the buildings\n    Returns:\n        mesh (rg.Mesh): reduced mesh\n    \"\"\"\n    if curve.ClosedCurveOrientation() == rg.CurveOrientation.Clockwise:\n        curve.Reverse()\n    \n    extrusion = rg.Extrusion.Create(curve, height, False)\n    \n    params = rg.MeshingParameters.QualityRenderMesh\n    \n    return rg.Mesh.CreateFromSurface(extrusion, params)\n\ndef triangulate_quad(quad_mesh):\n    tri_mesh = quad_mesh.Duplicate()\n    tri_mesh.Faces.ConvertQuadsToTriangles()\n    return tri_mesh\n\ndef generate_mesh(patch_outline, building_outlines, courtyard_outlines, building_heights, grid_size, size, rough=False, logger=False):\n    \"\"\"Generate a patch mesh based on a patch outline, building polylines and courtyard outlines\n\n    Args:\n        patch_outline (rg.Rectangle3d): ground patch outline\n        building_outlines (list[list[rg.Polyline]]): building outline polylines\n        courtyard_outlines (list[list[rg.Polyline]]): courtyard outline polylines\n        building_heights (list[float]): heights per building\n        grid_size (float): grid size\n        size (float): size of patch\n        rough (bool, optional): Indicate if function should also return rough meshes. Defaults to False.\n\n    Returns:\n        mesh_plane (rg.Mesh): ground mesh plane\n        walls (list[rg.Mesh]): walls\n        roofs (list[rg.Mesh]): roofs\n        rough_ground (rg.Mesh, optional), rough ground mesh\n        rough_walls (list[rg.Mesh], optional): rough walls\n        rough_roofs (list(rg.Mesh), optional): rough roofs\n    \"\"\"\n    \n    building_polylines, building_curves = project_outlines_to_world_xy(building_outlines)\n    courtyard_polylines, courtyard_curves = project_outlines_to_world_xy(courtyard_outlines)\n    \n    if logger:\n        logger.info(f'Generating roofs and ground for mesh patch')\n    \n#    ground_mesh, building_meshes, building_polylines, courtyard_polylines, all_heights = _generate_horizontal(patch_outline, building_polylines, courtyard_polylines, building_heights, grid_size, size)\n    mesh_plane, roofs, valid = generate_horizontal(patch_outline, building_polylines, courtyard_polylines, building_curves, courtyard_curves, building_heights, grid_size, size)\n    \n    # Overwite invalid outlines and heights\n    building_polylines = [i for j, i in enumerate(building_polylines) if j not in valid]\n    building_curves = [i for j, i in enumerate(building_curves) if j not in valid]\n    courtyard_polylines = [i for j, i in enumerate(courtyard_polylines) if j not in valid]\n    courtyard_curves = [i for j, i in enumerate(courtyard_curves) if j not in valid]\n    building_heights = [i for j, i in enumerate(building_heights) if j not in valid]\n    \n    if logger:\n        logger.info(f'Generating walls for mesh patch')\n    \n    # Generate the walls for the building outlines and compute corresponding heights\n    # Requires outlines in format polylines\n    walls = generate_vertical(building_polylines, courtyard_polylines, building_heights, grid_size)\n    \n    # Compute the mesh plane for the ground and roofs\n    # Requires outlines in format curves    \n    if rough:\n        if logger:\n            logger.info(f'Generating rough meshes')\n            \n        rough_ground = remesh_horizontal(mesh_plane)\n        rough_roofs = [remesh_horizontal(roof) for roof in roofs]\n        \n        rough_walls = []\n        for building, courtyard, height in zip(building_curves, courtyard_curves, building_heights):\n            mesh = rg.Mesh()\n            \n            for curve in building:\n                mesh.Append(remesh_vertical(curve, height))\n            \n            for curve in courtyard:\n                mesh.Append(remesh_vertical(curve, height))\n                \n            rough_walls.append(mesh)\n        \n        return mesh_plane, walls, roofs, rough_ground, rough_walls, rough_roofs\n    else:\n        return mesh_plane, walls, roofs, None, None, None",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}