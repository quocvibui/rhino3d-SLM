{
  "source_url": "https://github.com/design-group/ignition-gateway-utilities/blob/439579bd13394bccdf9d7f1b7d1d5dc3c9dc2d07/projects/gateway-utilities/ignition/script-python/General/Multithreading/code.py",
  "repo": "design-group/ignition-gateway-utilities",
  "repo_stars": 14,
  "repo_description": "A Collection of Gateway Utility Scripts and functions to streamline development and integration",
  "license": "MIT",
  "filepath": "projects/gateway-utilities/ignition/script-python/General/Multithreading/code.py",
  "instruction": "General.Multithreading",
  "code": "\"\"\"\nGeneral.Multithreading\n\nThis module contains functions for multithreading in Ignition.\n\"\"\"\n\nimport traceback\nfrom ast import literal_eval\nfrom java.lang import Thread\nfrom java.lang import Runnable\nfrom java.lang import Exception as JavaException\nfrom java.util.concurrent import Executors\nfrom java.util.concurrent import ThreadFactory\nfrom java.util.concurrent import TimeUnit\nfrom java.util.concurrent import ConcurrentHashMap\n\nfrom com.inductiveautomation.ignition.common.script import ScriptContext\nfrom com.inductiveautomation.ignition.common.execution import TPC\n\nLOGGER = system.util.getLogger(\"General.Multithreading\")\nMULTITHREADING_SYSTEM_NAME = \"Multithreading\"\n\n\nclass MultiThreadTimeoutError(Exception):\n\t\"\"\" Indicates that a multithreaded operation has timed out.\"\"\"\n\n\tdef __init__(self, message=\"Multithreaded operation timed out\"):\n\t\tself.message = message\n\t\tLOGGER.error(self.message)\n\t\tsuper(MultiThreadTimeoutError, self).__init__(self.message)\n\n\nclass FunctionWrapper(Runnable):\n\t\"\"\"\n\tDESCRIPTION: A java.lang.Runnable that will wrap around functions to execute them in a thread.\n\t\"\"\"\n\n\tdef __init__(self, func, kwargs=None):\n\t\t\"\"\"\n\t\tDESCRIPTION: This function initializes the FunctionWrapper class\n\t\t\"\"\"\n\t\tself.kwargs = {} if not kwargs else kwargs\n\t\tself.func = func\n\t\tfunction_name = General.Utilities.get_function_qualified_path(func)\n\t\tkwargs_text = ', '.join(['{}={!r}'.format(k, v) for k, v in self.kwargs.items()])\n\t\tScriptContext.setDescription(\"Asynchronous execution of: %s%s\" % (function_name, kwargs_text))\n\n\tdef run(self):\n\t\t\"\"\"\n\t\tDESCRIPTION: This function overrides the run() function of the threading.Thread class, to execute the function with kwargs\n\t\t\"\"\"\n\t\tself.func(**self.kwargs)\n\n\nclass ResultCapturingWrapper(Runnable):\n\t\"\"\"\n\tDESCRIPTION: A java.lang.Runnable that captures function results in a thread-safe map.\n\t\"\"\"\n\n\tdef __init__(self, func, index, results_map, args=None, kwargs=None):\n\t\t\"\"\"\n\t\tDESCRIPTION: This function initializes the ResultCapturingWrapper class\n\t\t\"\"\"\n\t\tself.func = func\n\t\tself.index = index\n\t\tself.results_map = results_map\n\t\tself.args = args if args is not None else ()\n\t\tself.kwargs = kwargs if kwargs is not None else {}\n\n\t\tfunction_name = General.Utilities.get_function_qualified_path(func)\n\t\tif kwargs:\n\t\t\tkwargs_text = ', '.join(['{}={!r}'.format(k, v) for k, v in kwargs.items()])\n\t\t\tdescription = \"Asynchronous execution of: %s(%s)\" % (function_name, kwargs_text)\n\t\telif args:\n\t\t\targs_text = ', '.join(['{!r}'.format(arg) for arg in args])\n\t\t\tdescription = \"Asynchronous execution of: %s(%s)\" % (function_name, args_text)\n\t\telse:\n\t\t\tdescription = \"Asynchronous execution of: %s()\" % function_name\n\t\tScriptContext.setDescription(description)\n\n\tdef run(self):\n\t\t\"\"\"\n\t\tDESCRIPTION: This function executes the function and stores the result\n\t\t\"\"\"\n\t\ttry:\n\t\t\tif self.kwargs:\n\t\t\t\tresult = self.func(**self.kwargs)\n\t\t\telif self.args:\n\t\t\t\tresult = self.func(*self.args)\n\t\t\telse:\n\t\t\t\tresult = self.func()\n\t\t\tself.results_map.put(self.index, result)\n\t\texcept (Exception, JavaException) as e:\n\t\t\t# Capture the full traceback for debugging\n\t\t\tLOGGER.warn(\"Exception in thread %d: %s\" % (self.index, traceback.format_exc()))\n\t\t\terror_with_traceback = {'exception': e, 'traceback': traceback.format_exc(), 'thread_index': self.index}\n\t\t\tself.results_map.put(self.index, error_with_traceback)\n\t\t\t# Don't re-raise - we've captured the error for processing in the main thread\n\n\nclass AsyncThreadFactory(ThreadFactory):\n\t\"\"\"\n\tDESCRIPTION: A java.util.concurrent.ThreadFactory that will create threads with a name.\n\t\"\"\"\n\n\tdef __init__(self, name, exception_handler):\n\t\tself.name = name\n\t\tself.exception_handler = exception_handler\n\t\tself.thread_factory = TPC.newThreadFactory(self.name, MULTITHREADING_SYSTEM_NAME)\n\n\t#NOTE: This is a java function, so we have to ignore the invalid name\n\tdef newThread(self, runnable):  # pylint: disable=invalid-name\n\t\t\"\"\"\n\t\tDESCRIPTION: Creates the new thread, and customizes it to properly bubble back up to Ignition.\n\t\t\"\"\"\n\t\tthread = self.thread_factory.newThread(runnable)\n\t\tthread.setName(self.name)\n\t\tthread.setUncaughtExceptionHandler(self.exception_handler)\n\t\treturn thread\n\n\nclass MultiThreadedException(Exception):\n\t\"\"\"\n\tDESCRIPTION: This exception will take a list of exceptions, and will print them all out when raised.\n\tPARAMETERS: exceptions (REQ, list[Exception]) - A list of exceptions that were raised\n\t\"\"\"\n\n\tdef __init__(self, exceptions):\n\t\t\"\"\"\n\t\tDESCRIPTION: This function initializes the MultiThreadedException class\n\t\tPARAMETERS: exceptions (REQ, list[(str, Exception)]) - A list of names and exception tuples that were raised per thread\n\t\t\"\"\"\n\t\tself.exceptions = exceptions\n\t\tif len(self.exceptions) > 1:\n\t\t\tself.message = \"Multiple exceptions were raised while multithreading\"\n\t\telse:\n\t\t\tself.message = \"An exception was raised while multithreading\"\n\n\t\tsuper(MultiThreadedException, self).__init__(self.message)\n\n\tdef __str__(self):\n\t\t\"\"\"\n\t\tDESCRIPTION: This function overrides the str() function to print out the exceptions\n\t\t\"\"\"\n\t\treturn \"%s: %s\" % (self.message, self.exceptions)\n\n\nclass ThreadExecutionException(Exception):\n\t\"\"\"\n\tDESCRIPTION: Exception that preserves original traceback from thread execution\n\t\"\"\"\n\n\tdef __init__(self, original_exception, thread_traceback, thread_index):\n\t\tself.original_exception = original_exception\n\t\tself.thread_traceback = thread_traceback\n\t\tself.thread_index = thread_index\n\n\t\t# Create a comprehensive error message\n\t\tmessage = \"Exception in thread %d: %s\\n\\nOriginal traceback:\\n%s\" % (\n\t\t\tthread_index, str(original_exception), thread_traceback\n\t\t)\n\t\tsuper(ThreadExecutionException, self).__init__(message)\n\n\tdef __str__(self):\n\t\treturn \"Exception in thread %d: %s\\n\\nOriginal traceback:\\n%s\" % (\n\t\t\tself.thread_index, str(self.original_exception), self.thread_traceback\n\t\t)\n\n\ndef wait_for_async_execution(func, kwargs_list=None, args_list=None, max_threads=-1, timeout_seconds=10):\n\t\"\"\"\n\tDESCRIPTION: Executes the function func asynchronously with the parameters and returns all results\n\tPARAMETERS: func (REQ, function) - The function to be executed\n\t\t\t\tkwargs_list (OPT, list) - A list of dictionaries with keyword arguments to be passed to the function\n\t\t\t\targs_list (OPT, list) - A list of tuples/lists with positional arguments to be passed to the function\n\t\t\t\tmax_threads (OPT, int) - The maximum number of threads to be used.\n\t\t\t\t\t\t\t\t\t\t If -1, it will just execute with as many threads as it can\n\t\t\t\ttimeout_seconds (OPT, int) - The maximum number of seconds to wait for the threads to finish\n\tRETURNS: list - Results from all function executions in the same order as input parameters\n\t\"\"\"\n\n\t#NOTE: If our function showed up as a name, we would have to use the following line to get the actual function\n\tif not callable(func):\n\t\tif General.Utilities.is_valid_variable_name(func):\n\t\t\tfunc = literal_eval(func)\n\n\t# Determine which parameter list to use and validate input\n\tif kwargs_list is not None and args_list is not None:\n\t\traise ValueError(\"Cannot specify both kwargs_list and args_list. Choose one.\")\n\telif kwargs_list is not None:\n\t\tparam_list = kwargs_list\n\t\tuse_kwargs = True\n\telif args_list is not None:\n\t\tparam_list = args_list\n\t\tuse_kwargs = False\n\telse:\n\t\t# If no parameters provided, execute function once with no arguments\n\t\tparam_list = [None]\n\t\tuse_kwargs = True\n\n\t#NOTE: If the number of threads is -1, we will use the number of parameter options provided\n\tif max_threads == -1:\n\t\tmax_threads = len(param_list)\n\n\t#NOTE: Define containers for exceptions and results\n\texceptions = []\n\t# Use Java ConcurrentHashMap for thread-safe result storage\n\tresults_map = ConcurrentHashMap()\n\n\tclass AsyncExceptionHandler(Thread.UncaughtExceptionHandler):\n\t\t\"\"\" Handles uncaught exceptions in threads using the native Java UncaughtExceptionHandler interface.\"\"\"\n\n\t\t#NOTE: This is a java function, so we have to ignore the invalid name\n\t\tdef uncaughtException(self, thread, exception):  # pylint: disable=invalid-name\n\t\t\t# Capture more detailed exception information\n\t\t\texception_info = {\n\t\t\t\t'thread': thread,\n\t\t\t\t'exception': exception,\n\t\t\t\t'thread_name': thread.getName(),\n\t\t\t\t'traceback': traceback.format_exc()\n\t\t\t}\n\t\t\texceptions.append(exception_info)\n\t\t\tLOGGER.error(\"Uncaught exception in thread %s: %s\" % (thread.getName(), traceback.format_exc()))\n\n\tfunction_name = General.Utilities.get_function_qualified_path(func)\n\t#NOTE: Execute the function in parallel with at most the number of threads in the pool,\n\t#NOTE: and wait for all of them to finish\n\texecutor = Executors.newFixedThreadPool(max_threads, AsyncThreadFactory(function_name, AsyncExceptionHandler()))\n\n\t# Submit all tasks with their respective parameters\n\tfor i in range(len(param_list)):\n\t\tif use_kwargs:\n\t\t\twrapper = ResultCapturingWrapper(func, i, results_map, kwargs=param_list[i])\n\t\telse:\n\t\t\twrapper = ResultCapturingWrapper(func, i, results_map, args=param_list[i])\n\n\t\texecutor.execute(wrapper)\n\n\texecutor.shutdown()\n\tfinished_in_time = executor.awaitTermination(timeout_seconds, TimeUnit.SECONDS)\n\n\t# Check if all tasks completed within timeout\n\tif not finished_in_time:\n\t\texecutor.shutdownNow()  # Force shutdown remaining tasks\n\t\traise MultiThreadTimeoutError(\"Not all tasks completed within \" + str(timeout_seconds) + \" seconds\")\n\n\t# If there were exceptions during execution, raise them\n\tif exceptions:\n\t\traise MultiThreadedException(exceptions)\n\n\t# Convert results map back to ordered list\n\tresults = []\n\tfor i in range(len(param_list)):\n\t\tresult = results_map.get(i)\n\t\tif isinstance(result, Exception):\n\t\t\traise result\n\t\telif isinstance(result, dict) and 'exception' in result:\n\t\t\t# Handle error with traceback information\n\t\t\terror_info = result\n\t\t\toriginal_exception = error_info['exception']\n\t\t\tthread_traceback = error_info['traceback']\n\t\t\tthread_index = error_info['thread_index']\n\n\t\t\t# Raise a new exception that preserves the original traceback\n\t\t\traise ThreadExecutionException(original_exception, thread_traceback, thread_index)\n\t\tresults.append(result)\n\n\treturn results\n",
  "language": "python",
  "imports": [],
  "has_docstring": true
}