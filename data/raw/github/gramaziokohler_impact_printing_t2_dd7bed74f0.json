{
  "source_url": "https://github.com/gramaziokohler/impact_printing_t2/blob/bb6fd1dcfd0612314cfe67c12fc3543531e7b0aa/src/design.py",
  "repo": "gramaziokohler/impact_printing_t2",
  "repo_stars": 4,
  "repo_description": null,
  "license": "NOASSERTION",
  "filepath": "src/design.py",
  "instruction": "Design",
  "code": "import Rhino.Geometry as rg  #to install in the compas conda environment use pip install Rhino-stubs\nimport Grasshopper as gh # https://pypi.org/project/Grasshopper-stubs/\n\nfrom compas.geometry import Curve, Point\n\n\nclass GlobalDesign(object):\n    \"\"\"A global design class\n\n    Attributes:\n        name (str): Name of the design.\n        layers (:obj:`list` of :obj:`Layer`): list of Layer objects.\n\n    \"\"\"\n\n    def __init__(self, layers, name):\n\n        self.name = name\n        if not layers == None:\n            self.layers = layers\n\n\n    def generate_uid_for_all_parts(self):\n        for layer in self.layers:\n            for path in layer.paths:\n                for part in path.parts:\n                    part.generate_uid(layer.index, path.index)\n\n    @classmethod\n    def design_from_curve(cls, curve, h_spacing, height, default_layer_height = 40, name = \"defaultName\"):\n        ts = curve.DivideByCount(int(round(curve.GetLength()/h_spacing*2)), True)\n\n        flip_alternating = True if not curve.IsClosed else False\n\n        layers = []\n        for index in range(int(height/default_layer_height)):\n            #since only one path on each layer path index : 0\n            path = [Part(rg.Point3d(curve.PointAt(t).X,  curve.PointAt(t).Y,  index*default_layer_height), i) for i,t in enumerate(ts[index%2::2])]\n\n            if flip_alternating and index % 2 == 0:\n                path.reverse()\n\n            paths = [Path(path,0)]\n            layers.append(Layer(paths, index))\n\n        design = cls(layers, name)\n\n        return design\n\n    def design_from_curve_legacy(self, curve, h_spacing, height, default_layer_height = 40):\n        \"\"\"single layer curve extrusion structure\"\"\"\n\n        self.curve = curve\n        self.curve_domain = self.curve.Domain\n        self.nurbs_curve = self.curve.ToNurbsCurve(self.curve_domain)\n        self.layer_height = default_layer_height\n        self.no_layers = no_layers\n\n        self.curves = curve_series_extrusion(self.curve, self.layer_height, self.no_layers)\n\n    def create_layers_simple_extrusion(self):\n\n        self.layers = []\n\n        index = 0\n        for curve in self.curves:\n\n            new_layer = Layer(curve, index, self.layer_height)\n            self.layers.append(new_layer)\n            index = index + 1\n\n    def create_targets_from_design(self, dist):\n        self.dist = dist\n        self.targets_as_points = []\n\n        for layer in self.layers:\n            layer.make_parts()\n            self.targets_as_points.extend(layer.points)\n\n    def visualize(self):\n        design_pts = []\n        for layer in self.layers:\n            layer_pts = []\n            for path in layer.paths:\n                path_pts = []\n                for part in path.parts:\n                    path_pts.append(part.position)\n                layer_pts.append(path_pts)\n            design_pts.append(layer_pts)\n        return design_pts\n\n\nclass Layer(object):\n    \"\"\"A class for each layer, which could consist of multiple paths\n\n    Attributes:\n        index (:obj:`int`): Layer index in a design.\n        paths (:obj:`list` of :obj:`Path`): List of paths on one layer.\n        height (:obj:`float`): Height in `mm` of the layer.\n\n    \"\"\"\n    def __init__(self, paths, index,  height = 40):\n        self.paths = paths\n        self.index = index\n        self.height = height\n\n\n\nclass Path(object):\n    \"\"\"A class for each path within a layer\n\n    Attributes:\n        index (:obj:`int`): Index of path within a layer.\n        parts (:obj:`list` of :obj:`Part`): List of parts on the path.\n        curve (:obj:`compas.geometry.Curve`): Curve for the path\n\n    \"\"\"\n    def __init__(self, parts, index = 0, curve = None):\n        self.parts = parts\n        self.index = index\n        self.curve = curve\n\n\nclass Part(object):\n    \"\"\"A class for each part\n\n    Attributes:\n        position (:obj:`compas.geometry.Point`): Description of `attr3`.\n        index (:obj:`int`): Index of path within a layer.\n        shoot (:obj:`bool`): Shooting on/off information.\n\n\n    \"\"\"\n    def __init__(self, position, index, shoot = True):\n        self.position = position\n        self.index = index\n        self.shoot = shoot\n        self.layer_index = None\n        self.path_index = None\n\n    def generate_uid(self, layer_index, path_index):\n        self.uid = \"0%i-0%i-0%i\"%(layer_index, path_index, self.index)\n        self.layer_index = layer_index\n        self.path_index = path_index\n\ndef get_points_from_control_points(control_points):\n    points = []\n\n    for control_point in control_points:\n        point = control_point.Location\n        points.append (point)\n    return points\n\n\ndef curve_series_extrusion(design_curve, default_layer_height = 40, no_layers= 10):\n    domain = design_curve.Domain\n    nurbsCurve = design_curve.ToNurbsCurve(domain )\n\n    nurbsPoints = nurbsCurve.Points\n    points = get_points_from_control_points(nurbsPoints)\n\n\n    curves = []\n\n    offset_vector = rg.Vector3d.Multiply(rg.Vector3d(0,0,1), default_layer_height)\n    new_curves = []\n\n    for i in range(no_layers):\n        new_points = []\n        for point in points:\n            new_point =point.Add(point, offset_vector)\n            new_points.append(new_point)\n\n        #handle case of line line curve\n        if len(new_points) <3:\n            new_curve = rg.Line(new_points[0], new_points[1])\n            new_curve  = new_curve.ToNurbsCurve()\n        else:\n            new_curve = rg.NurbsCurve.Create(False, 3, new_points)\n\n        points = new_points\n\n        new_curves.append(new_curve)\n    return new_curves\n\n\ndef make_points_from_curve(crv, dist):\n\n    domain = crv.Domain\n    nurbsCurve = crv.ToNurbsCurve(domain )\n\n    crv = nurbsCurve\n\n    length = crv.GetLength()\n    div  = int(length / dist)\n    updated_dist= length/div\n\n    params = crv.DivideByCount(div, True)\n    params2 = crv.DivideByLength(updated_dist, True)\n    points = [crv.PointAt(p) for p in params2]\n    return points\n\ndef make_alternate_points_from_curve(crv, dist):\n\n    length = crv.GetLength()\n    div  = int(length / dist)\n\n    updated_dist = length/div # new distance between parts\n    pointsHalf = rg.Curve.DivideByLength(crv, updated_dist/2, True)\n\n    domain = crv.Domain\n    newInterval =rg.Interval(pointsHalf[1], pointsHalf[-2])\n    newcrv = crv.Trim(newInterval)\n\n    params =newcrv.DivideByCount(div-1, True)\n    points = [newcrv.PointAt(p) for p in params]\n\n    return newcrv, points\n\n\ndef make_all_points(crvs, dist):\n    \"\"\" Make all points on a curve series through divisions \"\"\"\n    allPoints = []\n\n    i = 0\n    for i in range(len(crvs)):\n        if i%2 == 0:\n            points = make_points_from_curve(crvs[i], dist)\n            allPoints.extend(points)\n        else:\n            points = make_alternate_points_from_curve(crvs[i], dist) [1]\n            allPoints.extend(points)\n    return allPoints\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}