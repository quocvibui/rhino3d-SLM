{
  "source_url": "https://github.com/fstwn/cockatoo/blob/d952ac5d2148ec29fba52e8eb75f0f43770c74ca/usrobj_src/Cockatoo_NodesByRegion.py",
  "repo": "fstwn/cockatoo",
  "repo_stars": 38,
  "repo_description": "Cockatoo is a prototypical open-source software toolkit for generating (3d-)knitting patterns from NURBS surface and mesh geometry directly inside Grasshopper.",
  "license": "MIT",
  "filepath": "usrobj_src/Cockatoo_NodesByRegion.py",
  "instruction": "Select KnitNetwork Nodes by testing for containment within a specified region\ncurve.\n    Inputs:\n        KnitNetwork: The KnitNetwork to select nodes from.\n                     {item,...",
  "code": "\"\"\"\nSelect KnitNetwork Nodes by testing for containment within a specified region\ncurve.\n    Inputs:\n        KnitNetwork: The KnitNetwork to select nodes from.\n                     {item, KnitNetworkBase}\n        RegionCurves: Curve for proximity search.\n                      {list, point3d}\n        UseReference: If True, will use the normal plane at each node of the \n                      networks reference geometry to determine the region \n                      inclusion of the node. Otherwise, will use the\n                      RegionPlane. If no reference geometry is set for the\n                      network, will also fall back to the RegionPlane.\n                      Defaults to False.\n                      {item, bool}\n        RegionPlane: Plane for region containment query. The UseReference\n                     parameter will overwrite this plane if True!\n                     Defaults to World XY Plane.\n                     {item, plane}\n    Outputs:\n        NodeIndices: The indices (identifiers) of the found nodes within the\n                     network.\n                     {list, int}\n        Nodes: The found nodes as node-2-tuples consisting of (index, data).\n               {list, nodes}\n        NodePoints: The Point3d geometry of the selected nodes within the\n                    network.\n                    {list, point3d}\n    Remarks:\n        Author: Max Eschenbach\n        License: MIT License\n        Version: 200705\n\"\"\"\n\n# PYTHON STANDARD LIBRARY IMPORTS\nfrom __future__ import division\n\n# GHPYTHON SDK IMPORTS\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport Grasshopper, GhPython\nimport System\nimport Rhino\nimport rhinoscriptsyntax as rs\n\n# GHENV COMPONENT SETTINGS\nghenv.Component.Name = \"NodesByRegion\"\nghenv.Component.NickName =\"NBR\"\nghenv.Component.Category = \"Cockatoo\"\nghenv.Component.SubCategory = \"07 KnitNetwork Editing\"\n\n# LOCAL MODULE IMPORTS\ntry:\n    import cockatoo\nexcept ImportError:\n    errMsg = \"The Cockatoo python module seems to be not correctly \" + \\\n             \"installed! Please make sure the module is in you search \" + \\\n             \"path, see README for instructions!.\"\n    raise ImportError(errMsg)\n\nclass NodesByRegion(component):\n    \n    def __init__(self):\n        super(NodesByRegion, self).__init__()\n        \n        self.region_plane = None\n    \n    def is_point_in_region(self, data_tuple):\n        node, region_crvs, nrm = data_tuple\n        for j, region in enumerate(region_crvs):\n            if nrm:\n                plane = Rhino.Geometry.Plane(node[1][\"geo\"], nrm[node[0]])\n            else:\n                plane = self.region_plane\n            tol = Rhino.RhinoDoc.ActiveDoc.ModelAbsoluteTolerance\n            pc = region.Contains(node[1][\"geo\"], plane, tol)\n            if not (pc == Rhino.Geometry.PointContainment.Inside \\\n                    or pc == Rhino.Geometry.PointContainment.Coincident):\n                    continue\n            return True\n        return False\n    \n    def RunScript(self, KnitNetwork, RegionCurves, UseReference, RegionPlane):\n        \n        # set defaults\n        if UseReference == None:\n            UseReference = False\n        if RegionPlane != None:\n            self.region_plane = RegionPlane\n        else:\n            self.region_plane = Rhino.Geometry.Plane.WorldXY\n        if not RegionCurves or RegionCurves == [None for x in RegionCurves]:\n            RegionCurves = None\n        \n        # initialize outputs\n        NodeIndices = Grasshopper.DataTree[object]()\n        Nodes = Grasshopper.DataTree[object]()\n        NodePoints = Grasshopper.DataTree[object]()\n        \n        # filter nodes according to input\n        if KnitNetwork and RegionCurves:\n            \n            # get all the nodes of the network\n            network_nodes = KnitNetwork.nodes(data=True)\n            \n            if UseReference:\n                try:\n                    reference_geometry = KnitNetwork.graph[\"reference_geometry\"]\n                except KeyError:\n                    reference_geometry = None\n                \n                if not reference_geometry:\n                    cbp = None\n                    nrm = None\n                    errMsg = \"KnitNetwork has no reference geometry \" + \\\n                             \"attached! Fallback to RegionPlane.\"\n                    rml = self.RuntimeMessageLevel.Warning\n                    self.AddRuntimeMessage(rml, errMsg)\n                elif isinstance(reference_geometry, Rhino.Geometry.Mesh):\n                    cbp = {network_nodes[k][0]: reference_geometry.ClosestMeshPoint(\n                           network_nodes[k][1][\"geo\"], 0) for k in range(len(network_nodes))}\n                    nrm = {k: reference_geometry.NormalAt(cbp[k]) \\\n                           for k in cbp.keys()}\n                elif isinstance(reference_geometry, Rhino.Geometry.NurbsSurface):\n                    cbp = {network_nodes[k][0]: reference_geometry.ClosestPoint(\n                           network_nodes[k][1][\"geo\"], 0) for k in network_nodes}\n                    nrm = {k: reference_geometry.NormalAt(cbp[k][0], cbp[k][1]) \\\n                           for k in cbp.keys()}\n            else:\n                cbp = None\n                nrm = None\n            \n            # prepare for parallel execution\n            data_list = []\n            for i, node in enumerate(network_nodes):\n                data_tuple = (node, RegionCurves, nrm)\n                data_list.append(data_tuple)\n            \n            # run parallel and collect results\n            results = GhPython.ScriptHelpers.Parallel.Run(\n                                        self.is_point_in_region,\n                                        data_list,\n                                        False)\n            \n            # route results to outputs\n            Nodes = [network_nodes[i] for i, val in enumerate(results) if val]\n            NodeIndices = [n[0] for n in Nodes]\n            NodePoints = [n[1][\"geo\"] for n in Nodes]\n        \n        # catch missing inputs\n        if not KnitNetwork:\n            errMsg = \"No KnitNetwork input!\"\n            rml = self.RuntimeMessageLevel.Warning\n            self.AddRuntimeMessage(rml, errMsg)\n        if not RegionCurves:\n            errMsg = \"No RegionCurves input!\"\n            rml = self.RuntimeMessageLevel.Warning\n            self.AddRuntimeMessage(rml, errMsg)\n        \n        # return results\n        return NodeIndices, Nodes, NodePoints\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}