{
  "source_url": "https://github.com/localcode/rhinopythonscripts/blob/34c5314a276e9d4d79a62da6bed96a8112552c2f/IntersectionTools.py",
  "repo": "localcode/rhinopythonscripts",
  "repo_stars": 62,
  "repo_description": "A place to dump and share python scripts for use in McNeel's Rhino and Grasshopper",
  "license": "unknown",
  "filepath": "IntersectionTools.py",
  "instruction": "Intersection tools",
  "code": "from System.Collections.Generic import List\n\nimport Rhino\nimport scriptcontext\nfrom Smart import SmartFeature\nimport RangeTools\n\nfrom Rhino.Geometry import Vector3d, Point3d, Plane, Curve\n\ndef smartPointProject(smartPoints, brep, vector=Vector3d(0.0,0.0,1.0), tolerance=0.001):\n    resultSet = []\n    # project everything\n    for smartPt in smartPoints:\n        result = Rhino.Geometry.Intersect.Intersection.ProjectPointsToBreps([brep],\n                [smartPt.geom],\n                vector, tolerance)\n        if len(result) > 0:\n            smartPt.geom = result[0]\n            resultSet.append(smartPt)\n    return resultSet\n\ndef smartPointLayerProject(pointLayerName, surfaceLayerName,\n        objectAttributes=None, vector=Vector3d(0.0,0.0,1.0),\n        tolerance=0.001):\n    '''Project a layer contining only points onto a layer containing a surface,\n    and maintain UserString associations between the original and projected points.\n    ObjectAttributes can be passed in to predetermine a layer or other data. Returns\n    a list of (Geometry, ObjAttributes) pairs, with user keys set. If anything fails,\n    should print an error message and return an empty set.'''\n    objs = scriptcontext.doc.Objects.FindByLayer(pointLayerName)\n    if len(objs) == 0:\n        print 'No Curves found on %s' % pointLayerName\n        return []\n    # get the surface(s)\n    srfObjs = scriptcontext.doc.Objects.FindByLayer(surfaceLayerName)\n    if len(srfObjs) == 0:\n        print 'No Surfaces found on %s' % surfaceLayerName\n        return []\n    else:\n        srf = srfObjs[0].Geometry\n    # deal with ObjectAttributes\n    if objectAttributes:\n        att = objectAttributes\n    else:\n        att = Rhino.DocObjects.ObjectAttributes()\n    resultSet = []\n    # project everything\n    for ptObj in objs:\n        smartPt = SmartFeature(ptObj)\n        smartAtt = smartPt.objAttributes(att)\n        projPoints = Rhino.Geometry.Intersect.Intersection.ProjectPointsToBreps([srf],\n                [smartPt.geom],\n                vector,\n                tolerance)\n        for pt in projPoints:\n            smartPair = (pt, smartAtt)\n            resultSet.append(smartPair)\n    return resultSet\n\ndef smartCurveLayerProject(curveLayerName, surfaceLayerName,\n        objectAttributes=None, vector=Vector3d(0.0,0.0,1.0),\n        tolerance=0.001):\n    '''Project a layer contining only curves onto a layer containing a surface,\n    and maintain UserString associations between the original and projected curves.\n    ObjectAttributes can be passed in to predetermine a layer or other data. Returns\n    a list of (Geometry, ObjAttributes) pairs, with user keys set. If anything fails,\n    should print an error message and return an empty set.'''\n    # get the curves\n    objs = scriptcontext.doc.Objects.FindByLayer(curveLayerName)\n    if len(objs) == 0:\n        print 'No Curves found on that layer'\n        return []\n    # get the surface(s)\n    srfObjs = scriptcontext.doc.Objects.FindByLayer(surfaceLayerName)\n    if len(srfObjs) == 0:\n        print 'no surfaces found on that layer'\n        return []\n    else:\n        srf = srfObjs[0].Geometry\n    # deal with ObjectAttributes\n    if objectAttributes:\n        att = objectAttributes\n    else:\n        att = Rhino.DocObjects.ObjectAttributes()\n    resultSet = []\n    # project everything\n    for crvObj in objs:\n        smartCurve = SmartFeature(crvObj)\n        smartAtt = smartCurve.objAttributes(att)\n        projCurves = smartCurve.geom.ProjectToBrep(smartCurve.geom,\n                                                srf,\n                                                vector,\n                                                tolerance)\n        for crv in projCurves:\n            smartPair = (crv, smartAtt)\n            resultSet.append(smartPair)\n\n    return resultSet\n\n\ndef interpolatePointsToTerrainMesh(points, terrainMesh):\n    out = []\n    for pt in points:\n        pts = [pt]\n        meshes = [terrainMesh]\n        vect = Vector3d(0.0,0.0, 1.0)\n        tol = 0.001\n        intResult = Rhino.Geometry.Intersect.Intersection.ProjectPointsToMeshes(meshes, pts, vect, tol)\n        if len(intResult) == 1: # it hit, and just once\n            out.append(intResult[0]) # add the result\n        elif len(intResult) < 1: # it missed\n            # approximate the z value\n            line = Rhino.Geometry.Line(pt, vect)\n            closPt = terrainMesh.ClosestPoint(pt)\n            roughPt = line.ClosestPoint(closPt, False)\n            closestTerrain = terrainMesh.ClosestPoint(roughPt)\n            roughPt.Z = closestTerrain.Z\n            out.append(roughPt)\n        else: # it hit twice??!!\n            # this appears to happen often.\n            out.append(intResult[0]) # use the first intersection anyway\n    return out\n\n\ndef contourBrepInZ(brep, stepSize):\n    # get the upper and lower limits\n    bbox = brep.GetBoundingBox(True)\n    zMin, zMax = bbox.Min.Z, bbox.Max.Z\n    zRange = zMax-zMin\n    vect = Vector3d(0.0,0.0,1.0)\n    # the next line is dense\n    planes = [Plane(Point3d(0.0, 0.0, z), vect) for z in RangeTools.drange(zMin,zMax, 0.5)]\n    resultList = []\n    for plane in planes:\n        curves = brep.CreateContourCurves(brep, plane)\n        resultList.append(curves)\n    return resultList\n\n\n\n\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": false
}