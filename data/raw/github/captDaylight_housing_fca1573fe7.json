{
  "source_url": "https://github.com/captDaylight/housing/blob/7069a37c2a077bf98f6325651212760f9b7b5ddc/building.py",
  "repo": "captDaylight/housing",
  "repo_stars": 0,
  "repo_description": "randomly generate housing projects. rhinopython",
  "license": "unknown",
  "filepath": "building.py",
  "instruction": "Building",
  "code": "import rhinoscriptsyntax as rs\nimport math\nimport random\n# Test to draw a cube\nstart_location = [0,0,0]\nmax_dist = 4\nmin_dist = 1\nmove_dist = 800\nfloor_height = 30\ncubeSide = 100\ncubeHeight = 5\nfloorAmountMin = 4\nfloorAmountMax = 30\ncubeList = [[0,0,0],[cubeSide,0,0],[cubeSide,cubeSide,0],[0,cubeSide,0],[0,0,cubeHeight],[cubeSide,0,cubeHeight],[cubeSide,cubeSide,cubeHeight],[0,cubeSide,cubeHeight]]\n\ndef Building():\n\tx = 0\n\twhile x < 10:\n\t\ty = 0\n\t\twhile y < 10:\n\t\t\tsweeper = MakeFloor()\n\t\t\tbuilding = ExtrudeFloor(sweeper)\n\t\t\trs.MoveObjects(building, [x*move_dist,y*move_dist,0])\n# \t\t\tfloors = DuplicateFloors(floor)\n# \t\t\tfor f in floors:\n# \t\t\t\trs.MoveObjects(f, [x*move_dist,y*move_dist,0])\n\t\t\ty = y + 1\n\t\t\tprint 'made a building'\n\t\tx = x + 1\n\n\t\n# \tfloors = ExtrudeFloors(floor)\n# \treturn floors\n\t\t\ndef MakeFloor():\n\tlengths = GenerateLengths()\n\tpositive = True # whether the path is traveling positive or negative along the axis\n\ttravelingX = True # whether the path is traveling along the x or y axis\n\tposition = [0,0,0]\n\tpts = []\n\tlines = []\n\tfloorTiles = []\n\tfor l in lengths:\n\t\tcount = 0\n\t\twhile count < l:\n\t\t\tpts.append(rs.AddPoint((position[0],position[1],position[2])))\n\t\t\tif(travelingX):\n\t\t\t\tif(positive):\n\t\t\t\t\tposition[0] = position[0] + cubeSide\n\t\t\t\telse:\n\t\t\t\t\tposition[0] = position[0] - cubeSide\n\t\t\telse:\n\t\t\t\tif(positive):\n\t\t\t\t\tposition[1] = position[1] + cubeSide\n\t\t\t\telse:\n\t\t\t\t\tposition[1] = position[1] - cubeSide\n\t\t\t#rs.MoveObject(cube, position)\n\t\t\tcount = count + 1\t\t\n\t\t# toggle axis\n\t\ttravelingX = not travelingX\n\t\t# get a random direction on the axis\n\t\tpositive = random.choice([True, False])\n\n\t# create the initial path from the points generated\t\n\tlines.append(rs.AddPolyline(pts))\n\n\n# \tfor p in pts:\n# \t\trs.AddText('paul', p,20)\n\n\trs.DeleteObjects(pts)\n\t#offset the newly generated line and create another\n\tlines.append(rs.OffsetCurve(lines[0],[0,0,0], cubeSide/2))\n\tlines.append(rs.OffsetCurve(lines[0],[0,0,0], -cubeSide/2))\t\n\t# cap the two lines by getting their end points\n\tstart_pts = [rs.CurveStartPoint(lines[2]), rs.CurveStartPoint(lines[1]) ]\n\tend_pts = [rs.CurveEndPoint(lines[2]), rs.CurveEndPoint(lines[1])]\n \n\tlines.append(rs.AddPolyline(start_pts))\n\tlines.append(rs.AddPolyline(end_pts))\n\t\n\t\n# \tfloor = rs.AddPlanarSrf(lines)\n\trs.DeleteObjects(lines[0])\n\tlines.pop(0)\n\t\n\tsweeper = rs.JoinCurves(lines)\n\t\n\tsweep_segs = rs.CurvePoints(sweeper)\n\n\tfound_end = False\n\twhile found_end == False:\n\t\tcount  = 0\n\t\tfor x in sweep_segs:\n\t\t\tif count > 1:\n\t\t\t\t#check if sweeper segments are on the same line\n\t\t\t\tif (CheckPtsInLine(sweep_segs[count], sweep_segs[count-1], sweep_segs[count-2])):\n\t\t\t\t\t# if so, pop that point out\n\t\t\t\t\tsweep_segs.pop(count-1)\n\t\t\t\t\tbreak\n\t\t\tcount = count + 1\n\t\t\tif count == len(sweep_segs):\n\t\t\t\tfound_end = True\n\t\n\t#check to see if first and last point are in line\n\tif(CheckPtsInLine(sweep_segs[0], sweep_segs[1], sweep_segs[len(sweep_segs)-2])):\n\t\t#delete the first and last elements\n\t\tsweep_segs.pop(0)\n\t\tsweep_segs.pop(len(sweep_segs)-1)\n\t\tprint 'here'\n\telse:\n\t\tsweep_segs.pop(len(sweep_segs)-1)\n\t\t\n\t\n\tcount = 1\n\tfor p in sweep_segs:\n\t\trs.AddText(count, p, 20)\n\t\tcount = count + 1\n\trs.DeleteObjects(lines)\n# \tpaul = rs.AddLine((0,0,0),(0,0,100))\n# \trs.AddSweep1(paul,total)\n\treturn sweeper\n\ndef CheckPtsInLine(pt1, pt2, pt3):\n\tif (pt1[0] == pt2[0] and pt1[0] == pt3[0]):\n\t\treturn True\n\telif (pt1[1] == pt2[1] and pt1[1] == pt3[1]):\n\t\treturn True\n\telse:\n\t\treturn False\n\n\t\t\ndef GenerateLengths():\n\t# maximum three segments\n\tsegments = 0\n\tlengths = []\n\twhile segments < 4:\n\t\tif(segments == 0):\n\t\t\tlengths.append(random.randint(min_dist, max_dist))\n\t\telse:\n\t\t\t# 3/4 chance of adding another length to the building\n\t\t\tif(random.random() < .75):\n\t\t\t\tlengths.append(random.randint(min_dist, max_dist))\n\t\tsegments = segments + 1\n\treturn lengths\n\ndef ExtrudeFloor(sweeper):\n\tfloorAmount = random.randint(floorAmountMin,floorAmountMax)\n\textrudeAmount = floor_height * floorAmount\n\trail = rs.AddLine((0,0,0),(0,0,extrudeAmount))\n\tbuilding = []\n\tbuilding.append(rs.AddSweep1(rail, sweeper))\n\tfloor = rs.AddPlanarSrf(sweeper)\n\trs.MoveObject(floor, (0,0,extrudeAmount))\n\trs.DeleteObjects([rail,sweeper])\n\tbuilding.append(floor)\n\treturn building\n\ndef DuplicateFloors(floor):\n\tfloorAmount = random.randint(floorAmountMin,floorAmountMax)\n\tcount = 0\n\tfloors = [floor]\n\twhile count < floorAmount:\n\t\tnew_floor = rs.CopyObjects(floor, [0,0,floor_height*(count+1)])\n\t\tfloors.append(new_floor)\n\t\tcount = count + 1\n\treturn floors\n\t\n# Check to see if this file is being executed as the \"main\" python\n# script instead of being used as a module by some other python script\n# This allows us to use the module which ever way we want.\nif( __name__ == '__main__' ):\n    #call function defined above\n    Building()\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}