{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/xCurve_sortCurvesOnSurface.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "xCurve_sortCurvesOnSurface.py",
  "instruction": "200520-23: Created, starting with another script.\r\n200526: Bug fix.  Modified a function description.\r\n200619: Import-related update.\r\n200629: Now checks and rejects curves completely on surface/face...",
  "code": "\"\"\"\r\n200520-23: Created, starting with another script.\r\n200526: Bug fix.  Modified a function description.\r\n200619: Import-related update.\r\n200629: Now checks and rejects curves completely on surface/face border.\r\n200810: Replaced some local code with a function from an import.\r\n210113: Trialing using more tolerance for checking curves against full surface borders.  See TODO.\r\n        Debugging bug fix.\r\n\r\nTODO: Add capability of tracking CurveObjects in main routine so that CurveObjects can be selected instead of duplicated.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom clr import StrongBox\r\nfrom System import Array\r\nfrom System import Guid\r\n\r\nimport xBrepFace\r\nimport xCurve\r\n\r\n\r\nclass Opts():\r\n    \r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    riAddOpts = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    def addOptionDouble(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionDouble(\r\n            getObj, englishName=names[key], numberValue=riOpts[key])\r\n\r\n\r\n    def addOptionInteger(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionInteger(\r\n            getObj, englishName=names[key], intValue=riOpts[key])\r\n\r\n\r\n    def addOptionList(key, names, listValues, values):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionList(\r\n            getObj,\r\n            englishOptionName=names[key],\r\n            listValues=listValues,\r\n            listCurrentIndex=values[key])\r\n\r\n\r\n    def addOptionToggle(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionToggle(\r\n            getObj, englishName=names[key], toggleValue=riOpts[key])\r\n\r\n\r\n    key = 'bProcessSegs'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bUnderlyingSrf'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fTolerance'; keys.append(key)\r\n    values[key] = 1.0 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    riAddOpts[key] = addOptionDouble(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bCompletelyOnSrfAndClosed'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bCompletelyOnSrfAndOpen'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bPartiallyOnSrf'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fSamplingResolution'; keys.append(key)\r\n    values[key] = 100.0 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    riAddOpts[key] = addOptionDouble(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bAdd'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def setValues(cls):\r\n        for key in cls.keys:\r\n            if key in cls.riOpts:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n\r\n\r\n    @classmethod\r\n    def saveSticky(cls):\r\n        for key in cls.stickyKeys:\r\n            if key in cls.riOpts:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.riOpts[key].CurrentValue\r\n            else:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput_Faces():\r\n    \"\"\"Get Brepface with optional input.\"\"\"\r\n    \r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select faces\")\r\n    \r\n    go.GeometryFilter = rd.ObjectType.Surface\r\n    \r\n    go.AcceptNumber(enable=True, acceptZero=True)\r\n    \r\n    idxs_Opts = {}\r\n\r\n    while True:\r\n        key = 'bProcessSegs'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bUnderlyingSrf'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'fTolerance'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bCompletelyOnSrfAndClosed'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bCompletelyOnSrfAndOpen'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bPartiallyOnSrf'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'fSamplingResolution'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bAdd'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bEcho'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bDebug'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        \r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n        \r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return tuple([objrefs] + [Opts.values[key] for key in Opts.keys])\r\n        elif res == ri.GetResult.Cancel:\r\n            return\r\n        \r\n        # An option was selected or a number was entered.\r\n        \r\n        if res == ri.GetResult.Number:\r\n            Opts.riOpts['fTolerance'].CurrentValue = go.Number()\r\n        \r\n        if Opts.riOpts['fTolerance'].CurrentValue < 0.0:\r\n            Opts.riOpts['fTolerance'].CurrentValue = Opts.riOpts['fTolerance'].InitialValue\r\n        \r\n        Opts.setValues()\r\n        Opts.saveSticky()\r\n        go.ClearCommandOptions()\r\n\r\n\r\ndef getInput_Curves(objrefs_Face):\r\n    \"\"\"\r\n    Get curves or edges with optional input.\r\n    \"\"\"\r\n\r\n\r\n    def getBrep(rhBrep):\r\n        if isinstance(rhBrep, rg.Brep):\r\n            return None, rhBrep\r\n        elif isinstance(rhBrep, rg.GeometryBase):\r\n            rdObj = None\r\n            rgObj = rhBrep\r\n        elif isinstance(rhBrep, rd.ObjRef):\r\n            rdObj = rhBrep.Object()\r\n            rgObj = rhBrep.Geometry()\r\n        elif isinstance(rhBrep, Guid):\r\n            rdObj = sc.doc.Objects.FindId(rhBrep) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(rhBrep)\r\n            rgObj = rdObj.Geometry\r\n        else:\r\n            return\r\n\r\n        if isinstance(rgObj, (rg.Brep, rg.BrepFace)):\r\n            return rdObj, rgObj\r\n\r\n\r\n    idxs_EdgesOfFaceToSplit = []\r\n    for objref_Face in objrefs_Face:\r\n        rdBrep_withFaceToSplit, rgBrep_withFaceToSplit = getBrep(objref_Face)\r\n        gBrep_withFaceToSplit = rdBrep_withFaceToSplit.Id\r\n        idxs_EdgesOfFaceToSplit.extend(objref_Face.Face().AdjacentEdges())\r\n\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select curves or edges\")\r\n    go.SetCommandPromptDefault(\"Enter for all normal wires and brep naked edges\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Curve\r\n    \r\n    def notEdgeOfFaceToSplit(rdObj, geom, compIdx):\r\n        #print rdObj, geom, compIdx\r\n        if isinstance(rdObj, rd.BrepObject) and rdObj.Id == gBrep_withFaceToSplit:\r\n            if geom.EdgeIndex in idxs_EdgesOfFaceToSplit:\r\n                print \"An edge of a face to split was picked and will not be used.\"\r\n                return False\r\n        return True\r\n    go.SetCustomGeometryFilter(notEdgeOfFaceToSplit)\r\n    \r\n    \r\n    go.AcceptNothing(True)\r\n    \r\n    go.AcceptNumber(enable=True, acceptZero=True)\r\n\r\n    go.AlreadySelectedObjectSelect = True\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False)\r\n    go.EnableUnselectObjectsOnExit(False)\r\n    \r\n    idxs_Opts = {}\r\n\r\n    while True:\r\n        key = 'bProcessSegs'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bUnderlyingSrf'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'fTolerance'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bCompletelyOnSrfAndClosed'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bCompletelyOnSrfAndOpen'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bPartiallyOnSrf'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'fSamplingResolution'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bAdd'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bEcho'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        key = 'bDebug'; idxs_Opts[key] = Opts.riAddOpts[key](go)[0]\r\n        \r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n        \r\n        if res == ri.GetResult.Cancel:\r\n            return\r\n        elif res == ri.GetResult.Nothing:\r\n            rdCrvs = []\r\n            rgEdges = []\r\n            settings = rd.ObjectEnumeratorSettings()\r\n            settings.NormalObjects = True\r\n            settings.LockedObjects = False\r\n            for rdObj in sc.doc.Objects.GetObjectList(settings):\r\n                if rdObj.ObjectType == rd.ObjectType.Curve:\r\n                    rdCrvs.append(rdObj)\r\n                elif rdObj.ObjectType == rd.ObjectType.Brep:\r\n                    rgBrep = rdObj.BrepGeometry\r\n                    # Structure of following conditional is to optimize speed.\r\n                    if rdObj.Id != gBrep_withFaceToSplit:\r\n                        for edge in rgBrep.Edges:\r\n                            if edge.Valence == rg.EdgeAdjacency.Naked:\r\n                                rgEdges.append(edge)\r\n                    else:\r\n                        for edge in rgBrep.Edges:\r\n                            if edge.EdgeIndex not in idxs_EdgesOfFaceToSplit:\r\n                                if edge.Valence == rg.EdgeAdjacency.Naked:\r\n                                    rgEdges.append(edge)\r\n                            else:\r\n                                if Opts.values['bDebug']:\r\n                                    print \"Skipped edge {}.\".format(edge.EdgeIndex)\r\n            return tuple([rdCrvs + rgEdges] + [Opts.values[key] for key in Opts.keys])\r\n        elif res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return tuple([objrefs] + [Opts.values[key] for key in Opts.keys])\r\n        \r\n        # An option was selected or a number was entered.\r\n        \r\n        if res == ri.GetResult.Number:\r\n            Opts.riOpts['fTolerance'].CurrentValue = go.Number()\r\n        \r\n        if Opts.riOpts['fTolerance'].CurrentValue < 0.0:\r\n            Opts.riOpts['fTolerance'].CurrentValue = Opts.riOpts['fTolerance'].InitialValue\r\n        \r\n        Opts.setValues()\r\n        Opts.saveSticky()\r\n        go.ClearCommandOptions()\r\n\r\n\r\ndef duplicateCurvesOnSurface(rgCrvs_In, rgSrf, fSamplingResolution=None, fTolerance=None, bDebug=False):\r\n    \"\"\"\r\n    Parameteters:\r\n        curves\r\n        rgSrf: Honors edges when this is a rg.BrepFace.\r\n        fSamplingResolution: float of curve division length.\r\n        fTolerance: float of distance from curve to surface.\r\n        bDebug\r\n    Returns:\r\n        (\r\n            list(Closed curves of rgCrvs_In completely on rgSrf),\r\n            list(Open curves of rgCrvs_In completely on rgSrf),\r\n            list(Curves of rgCrvs_In only partially on rgSrf)\r\n        )\r\n    \"\"\"\r\n\r\n\r\n    if fSamplingResolution is None:\r\n        fSamplingResolution = 100.0*sc.doc.ModelAbsoluteTolerance\r\n    if fTolerance is None:\r\n        fTolerance = sc.doc.ModelAbsoluteTolerance\r\n\r\n\r\n    def isCurveCompletelyOnFaceBorder(crv):\r\n\r\n        strongBox_points = StrongBox[Array[rg.Point3d]]()\r\n\r\n        rc = crv.DivideByLength(\r\n            fSamplingResolution,\r\n            includeEnds=True,\r\n            points=strongBox_points)\r\n\r\n        if rc:\r\n            pts = list(strongBox_points.Value)\r\n            #for pt in pts: sc.doc.Objects.AddPoint(pt)\r\n            #sc.doc.Views.Redraw(); 1/0\r\n            if len(pts) == 2:\r\n                rc = crv.DivideByCount(\r\n                    segmentCount=2,\r\n                    includeEnds=True,\r\n                    points=strongBox_points)\r\n                pts = list(strongBox_points.Value)\r\n        else:\r\n            crv_GetLength = crv.GetLength()\r\n            \r\n            if crv_GetLength <= sc.doc.ModelAbsoluteTolerance:\r\n                if bDebug:\r\n                    print \"No points for curve that is {} long.\".format(\r\n                        crv.GetLength())\r\n                    #sc.doc.Objects.AddCurve(crv)\r\n                return\r\n            else:\r\n                rc = crv.DivideByCount(\r\n                    segmentCount=2,\r\n                    includeEnds=True,\r\n                    points=strongBox_points)\r\n                pts = list(strongBox_points.Value)\r\n                #for pt in pts: sc.doc.Objects.AddPoint(pt)\r\n                #sc.doc.Views.Redraw(); 1/0\r\n\r\n        for pt in pts:\r\n            # TODO: Review the results of the following using more tolerance for natural surfaces.\r\n            rc = xBrepFace.is3dPointOnFace(\r\n                rgFace, pt, 1.5*fTolerance if rgB_Temp else fTolerance)\r\n\r\n            if rc != rg.PointFaceRelation.Boundary:\r\n                return False\r\n\r\n        return True\r\n\r\n\r\n    def isCrvCompletelyOnFace(crv):\r\n\r\n        # Quick check for False.\r\n        rc = xBrepFace.is3dPointOnFace(\r\n            rgFace, crv.PointAtStart, fTolerance)\r\n\r\n        if not rc:\r\n            # This includes None, False, and rg.PointFaceRelation.Exterior.\r\n            return False\r\n\r\n\r\n        # More thorough check.\r\n\r\n        strongBox_points = StrongBox[Array[rg.Point3d]]()\r\n\r\n        rc = crv.DivideByLength(\r\n            fSamplingResolution,\r\n            includeEnds=True,\r\n            points=strongBox_points)\r\n\r\n        if rc:\r\n            pts = list(strongBox_points.Value)\r\n            #for pt in pts: sc.doc.Objects.AddPoint(pt)\r\n            #sc.doc.Views.Redraw(); 1/0\r\n        else:\r\n            crv_GetLength = crv.GetLength()\r\n            \r\n            if crv_GetLength <= sc.doc.ModelAbsoluteTolerance:\r\n                if bDebug:\r\n                    print \"No points for curve that is {} long.\".format(\r\n                        crv.GetLength())\r\n                    #sc.doc.Objects.AddCurve(crv)\r\n                return\r\n            else:\r\n                rc = crv.DivideByCount(\r\n                    segmentCount=2,\r\n                    includeEnds=True,\r\n                    points=strongBox_points)\r\n                pts = list(strongBox_points.Value)\r\n                #for pt in pts: sc.doc.Objects.AddPoint(pt)\r\n                #sc.doc.Views.Redraw(); 1/0\r\n\r\n        for pt in pts:\r\n            rc = xBrepFace.is3dPointOnFace(\r\n                rgFace, pt, fTolerance)\r\n\r\n            if not rc:\r\n                # This includes None, False, and rg.PointFaceRelation.Exterior.\r\n                return False\r\n\r\n        return True\r\n\r\n\r\n    if isinstance(rgSrf, rg.BrepFace):\r\n        rgFace = rgSrf\r\n        rgB_Temp = None\r\n    else:\r\n        rgB_Temp = rgSrf.ToBrep()\r\n        rgFace = rgB_Temp.Faces[0]\r\n\r\n    #sc.doc.Objects.AddBrep(rgFace.Brep); sc.doc.Views.Redraw(); 1/0\r\n\r\n    # Full curves completely, not completely on Surface.\r\n    fulls_CompletelyOn, fulls_PartiallyOn = [], []\r\n    for c in rgCrvs_In:\r\n        if isCrvCompletelyOnFace(c):\r\n            if isCurveCompletelyOnFaceBorder(c):\r\n                continue\r\n            fulls_CompletelyOn.append(c.DuplicateCurve())\r\n        else:\r\n            fulls_PartiallyOn.append(c.DuplicateCurve())\r\n    #map(sc.doc.Objects.AddCurve, fulls_CompletelyOn); 1/0; return\r\n\r\n\r\n    if rgB_Temp: rgB_Temp.Dispose()\r\n\r\n\r\n    if not fulls_CompletelyOn:\r\n        return [], [], fulls_PartiallyOn\r\n\r\n    fulls_CompletelyOn_Closed = []\r\n    fulls_CompletelyOn_Open = []\r\n    for c in fulls_CompletelyOn:\r\n        if c.IsClosed:\r\n            fulls_CompletelyOn_Closed.append(c)\r\n        else:\r\n            fulls_CompletelyOn_Open.append(c)\r\n    return fulls_CompletelyOn_Closed, fulls_CompletelyOn_Open, fulls_PartiallyOn\r\n\r\n\r\ndef processRhinoObjects(rhObjects_BrepFace, rhObjects_CurveOrEdge, **kwargs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    bProcessSegs = getOpt('bProcessSegs')\r\n    bUnderlyingSrf = getOpt('bUnderlyingSrf')\r\n    fTolerance = getOpt('fTolerance')\r\n    bCompletelyOnSrfAndClosed = getOpt('bCompletelyOnSrfAndClosed')\r\n    bCompletelyOnSrfAndOpen = getOpt('bCompletelyOnSrfAndOpen')\r\n    bPartiallyOnSrf = getOpt('bPartiallyOnSrf')\r\n    fSamplingResolution = getOpt('fSamplingResolution')\r\n    bAdd = getOpt('bAdd')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    def getRhinoObject(rhObj):\r\n        \"\"\"\r\n        'Deleted objects cannot be found by id.'\r\n        (https://developer.rhino3d.com/api/RhinoCommon/html/M_Rhino_DocObjects_Tables_ObjectTable_FindId.htm)\r\n        \"\"\"\r\n        rdObj = None\r\n        if isinstance(rhObj, rd.RhinoObject):\r\n            rdObj = rhObj\r\n        elif isinstance(rhObj, rd.ObjRef):\r\n            rdObj = rhObj.Object()\r\n        elif isinstance(rhObj, Guid):\r\n            rdObj = sc.doc.Objects.FindId(rhObj) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(rhObj)\r\n        return rdObj\r\n\r\n\r\n    def getBrepObject(rhObj):\r\n        rdObj = getRhinoObject(rhObj)\r\n        if rdObj and (rdObj.ObjectType == rd.ObjectType.Brep):\r\n            return rdObj\r\n\r\n\r\n    def getSortedBrepIdsAndFaces(objrefs):\r\n        \"\"\"\r\n        Parameters:\r\n            list(objrefs)\r\n        Returns:\r\n            list(Brep GUIDs)\r\n            list(lists(integers of Face indices) per brep)\r\n        \"\"\"\r\n        \r\n        gBreps_In = []\r\n        idxs_Faces_perBrep = []\r\n    \r\n        for o in objrefs:\r\n            gBrep0 = o.ObjectId\r\n            rdBrep_In = o.Object()\r\n            rgBrep_In = o.Brep()\r\n        \r\n            if not rgBrep_In.IsValid:\r\n                print \"Brep {} is invalid.  Fix first.\".format(gBrep0)\r\n                rgBrep_In.Dispose()\r\n                continue\r\n        \r\n            idx_CompIdx = o.GeometryComponentIndex.Index\r\n            if idx_CompIdx == -1:\r\n                if gBrep0 in gBreps_In:\r\n                    idxs_Faces_perBrep[gBreps_In.index(gBrep0)] = range(rgBrep_In.Faces.Count)\r\n                else:\r\n                    gBreps_In.append(gBrep0)\r\n                    idxs_Faces_perBrep.append(range(rgBrep_In.Faces.Count))\r\n            else:\r\n                rgFace_Brep0 = o.Face()\r\n                if gBrep0 in gBreps_In:\r\n                    if rgFace_Brep0 in idxs_Faces_perBrep[gBreps_In.index(gBrep0)]:\r\n                        continue\r\n                    else:\r\n                        idxs_Faces_perBrep[gBreps_In.index(gBrep0)].append(rgFace_Brep0.FaceIndex)\r\n                else:\r\n                    gBreps_In.append(gBrep0)\r\n                    idxs_Faces_perBrep.append([rgFace_Brep0.FaceIndex])\r\n\r\n        return gBreps_In, idxs_Faces_perBrep\r\n\r\n\r\n    def getCurve(rhObj):\r\n        if isinstance(rhObj, rd.CurveObject):\r\n            return rhObj, rhObj.CurveGeometry\r\n\r\n        if isinstance(rhObj, rg.Curve):\r\n            return None, rhObj\r\n\r\n        if isinstance(rhObj, rg.GeometryBase):\r\n            rdObj = None\r\n            rgObj = rhObj\r\n        elif isinstance(rhObj, rd.ObjRef):\r\n            rdObj = rhObj.Object()\r\n            rgObj = rhObj.Geometry()\r\n        elif isinstance(rhObj, Guid):\r\n            rdObj = sc.doc.Objects.FindId(rhObj) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(rhObj)\r\n            rgObj = rdObj.Geometry\r\n        else:\r\n            return\r\n\r\n        if isinstance(rgObj, rg.Curve):\r\n            return rdObj, rgObj\r\n\r\n\r\n    gBreps_In, idxs_rgFace_perBrep = getSortedBrepIdsAndFaces(rhObjects_BrepFace)\r\n    if not gBreps_In: return\r\n\r\n\r\n    rdCrvs_In = []\r\n    rgCrvs_In = []\r\n    for o in rhObjects_CurveOrEdge:\r\n        rdCrv_In, rgCrv_In = getCurve(o)\r\n        if rdCrv_In:\r\n            rdCrvs_In.append(rdCrv_In)\r\n            rgCrvs_In.append(rgCrv_In)\r\n\r\n\r\n    if bProcessSegs:\r\n        rgCrvs_toSort = xCurve.duplicateSegments(\r\n            rgCrvs_In,\r\n            bExplodePolyCrvs=True)\r\n    else:\r\n        rgCrvs_toSort = rgCrvs_In\r\n\r\n\r\n\r\n    gCrvs_Ret = []\r\n\r\n    for iB, gBrep0 in enumerate(gBreps_In):\r\n        rdBrep_In = getBrepObject(gBrep0)\r\n        rgBrep_In = rdBrep_In.Geometry\r\n\r\n        idxFaces_TrimSuccess = []\r\n        rgBs_1F_Res = []\r\n\r\n        for iF, idxFace in enumerate(idxs_rgFace_perBrep[iB]):\r\n            if bUnderlyingSrf:\r\n                rgSrf_Ref = rgBrep_In.Faces[idxFace].UnderlyingSurface()\r\n            else:\r\n                rgSrf_Ref = rgBrep_In.Faces[idxFace]\r\n\r\n            rc = duplicateCurvesOnSurface(\r\n                    rgCrvs_toSort,\r\n                    rgSrf_Ref,\r\n                    fSamplingResolution=fSamplingResolution,\r\n                    fTolerance=fTolerance,\r\n                    bDebug=bDebug)\r\n\r\n            if not rc: continue\r\n            \r\n            (\r\n                cs_AllOnSrf_Closed,\r\n                cs_AllOnSrf_Open,\r\n                cs_PartiallyOnSrf,\r\n                ) = rc\r\n\r\n            if bCompletelyOnSrfAndClosed:\r\n                for c in cs_AllOnSrf_Closed:\r\n                    gCrv_Ret = sc.doc.Objects.AddCurve(c)\r\n                    if gCrv_Ret != Guid.Empty:\r\n                        gCrvs_Ret.append(gCrv_Ret)\r\n\r\n            if bCompletelyOnSrfAndOpen:\r\n                for c in cs_AllOnSrf_Open:\r\n                    gCrv_Ret = sc.doc.Objects.AddCurve(c)\r\n                    if gCrv_Ret != Guid.Empty:\r\n                        gCrvs_Ret.append(gCrv_Ret)\r\n\r\n            if bPartiallyOnSrf:\r\n                for c in cs_PartiallyOnSrf:\r\n                    gCrv_Ret = sc.doc.Objects.AddCurve(c)\r\n                    if gCrv_Ret != Guid.Empty:\r\n                        gCrvs_Ret.append(gCrv_Ret)\r\n\r\n    return gCrvs_Ret\r\n\r\n\r\ndef main():\r\n\r\n\r\n    rc = getInput_Faces()\r\n    if rc is None: return\r\n\r\n    objrefs_Face = rc[0]\r\n\r\n    rc = getInput_Curves(objrefs_Face)\r\n    if rc is None: return\r\n\r\n    rhObjects_CurveOrEdge = rc[0]\r\n\r\n    #sc.doc.Objects.UnselectAll()\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(\"Working ...\")\r\n\r\n    gCrvs_Ret = processRhinoObjects(\r\n        rhObjects_BrepFace=objrefs_Face,\r\n        rhObjects_CurveOrEdge=rhObjects_CurveOrEdge,\r\n        )\r\n\r\n    if gCrvs_Ret:\r\n        sc.doc.Objects.UnselectAll()\r\n        for gC in gCrvs_Ret:\r\n            sc.doc.Objects.Select(objectId=gC)\r\n\r\n    sc.doc.Views.Redraw()\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "scriptcontext"
  ],
  "has_docstring": true
}