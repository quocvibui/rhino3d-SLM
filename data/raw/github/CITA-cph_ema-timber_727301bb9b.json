{
  "source_url": "https://github.com/CITA-cph/ema-timber/blob/b2f26789718f40d78efa455d3238db0d8f850737/src/python/ema_timber/geometry/convert.py",
  "repo": "CITA-cph/ema-timber",
  "repo_stars": 0,
  "repo_description": null,
  "license": "Apache-2.0",
  "filepath": "src/python/ema_timber/geometry/convert.py",
  "instruction": "Convert",
  "code": "import logging\n\nimport rhino3dm\nimport specklepy\nfrom specklepy.objects import Base\nfrom specklepy.objects.geometry import Brep, Curve, Point, Line, Circle, Plane, Vector, Arc, Polyline\n\nfrom rhino3dm import Point3d, Point4d, Vector3d\nimport OCC\nfrom OCC.Core import gp\nfrom OCC.Core.BRepBuilderAPI import BRepBuilderAPI_MakeFace, BRepBuilderAPI_MakeWire, BRepBuilderAPI_MakeEdge\nfrom OCC.Core.BRepBuilderAPI import BRepBuilderAPI_MakeVertex, BRepBuilderAPI_MakeShell\nfrom OCC.Core.BRepOffsetAPI import BRepOffsetAPI_Sewing\nfrom OCC.Core.BRep import BRep_Tool, BRep_Builder\nfrom OCC.Core.BRepLib import breplib\nfrom OCC.Core.BRepPrim import BRepPrim_Builder\nfrom OCC.Core.GC import GC_MakeSegment, GC_MakeCircle, GC_MakeArcOfCircle \nfrom OCC.Core.GCE2d import GCE2d_MakeSegment, GCE2d_MakeCircle, GCE2d_MakeArcOfCircle \nfrom OCC.Core.TopoDS import TopoDS_Builder, TopoDS_Vertex, TopoDS_Edge, TopoDS_Wire, TopoDS_Face, TopoDS_Shell, TopoDS_Compound\nfrom OCC.Core.Convert import Convert_CircleToBSplineCurve\nfrom OCC.Core.GeomConvert import GeomConvert_CompCurveToBSplineCurve\nfrom OCC.Core.Geom2dConvert import Geom2dConvert_CompCurveToBSplineCurve\nfrom OCC.Core.ElCLib import elclib\n# from OCC.Core.GeomAPI import GeomAPI_Interpolate\n\n\nfrom OCC.Core.Geom import Geom_BSplineCurve, Geom_Line, Geom_TrimmedCurve, Geom_BSplineSurface\nfrom OCC.Core.Geom2d import Geom2d_Curve, Geom2d_BSplineCurve, Geom2d_TrimmedCurve\nfrom OCC.Core.gp import gp_Pnt, gp_Dir, gp_Ax2, gp_Vec\nfrom OCC.Core.gp import gp_Pnt2d, gp_Dir2d, gp_Ax22d, gp_Circ2d\nfrom OCC.Core.TColStd import TColStd_Array1OfReal, TColStd_Array2OfReal, TColStd_Array1OfInteger\nfrom OCC.Core.TColgp import TColgp_Array1OfPnt, TColgp_Array2OfPnt\nfrom OCC.Core.TColgp import TColgp_Array1OfPnt2d\n\nTOLERANCE = 1e-6\n\nclass RhinoToOcc:\n    def gp_Pnt_to_string(pt):\n        return f\"{pt.X():.3f} {pt.Y():.3f} {pt.Z():.3f}\"\n\n    def gp_Pnt2d_to_string(pt):\n        return f\"{pt.X():.3f} {pt.Y():.3f}\"\n\n    def to_rhino_curve(occ_curve : Geom_BSplineCurve):\n\n        degree = 3\n        Npts = 10\n\n        rcrv = rhino3dm.NurbsCurve(degree=degree, pointcount=Npts)\n\n        # Set points and weights\n        for i in range(Npts):\n            rcrv.Points[i] = Point4d(0,0,0,1)\n\n        # Set knots\n        for i in range(len(rcrv.Knots)):\n            rcrv.Knots[i] = 2.0\n\n        return rcrv\n\n    def to_rhino_brep(occ_brep : rhino3dm.Brep):\n\n        rbrep = rhino3dm.Brep()\n        #print(dir(rbrep))\n\n    def to_speckle_brep(occ_brep):\n        \"\"\"\n        Surfaces: List[Surface] = None\n        Curve3D: List[Base] = None\n        Curve2D: List[Base] = None\n        Vertices: List[Point] = None\n\n        Edges: List[BrepEdge] = None\n        Loops: List[BrepLoop] = None\n        Faces: List[BrepFace] = None\n        Trims: List[BrepTrim] = None\n        \"\"\"    \n\n\nclass SpeckleToOcc:\n\n    @staticmethod\n    def speckle_knots_to_occ(knots, degree):\n        \"\"\"\n        Speckle Curve knots to occ knots\n        \"\"\"\n        last_knot = knots[0]\n        current_knot = knots[1]\n\n        nknots = []\n        mults = []\n        mult = 1\n\n        epsilon = OCC.Core.gp.gp.Resolution()\n        for i in range(1, len(knots)):\n\n            current_knot = knots[i]\n            if abs(last_knot - current_knot) > epsilon:\n\n                nknots.append(last_knot)\n                mults.append(mult)\n\n                mult = 1\n                last_knot = current_knot\n            else:\n                mult += 1\n\n        nknots.append(current_knot)\n        mults.append(mult)\n\n        mults[0] = degree + 1\n        mults[-1] = degree + 1\n\n        return nknots, mults\n\n    @staticmethod\n    def point(speckle_point: Point):\n        return gp_Pnt(speckle_point.x, speckle_point.y, speckle_point.z)\n\n    @staticmethod\n    def point2d(speckle_point: Point):\n        return gp_Pnt2d(speckle_point.x, speckle_point.y)\n\n    @staticmethod\n    def direction(speckle_vector: Vector):\n        return gp_Dir(speckle_vector.x, speckle_vector.y, speckle_vector.z)\n\n    @staticmethod\n    def direction2d(speckle_vector: Vector):\n        return gp_Dir2d(speckle_vector.x, speckle_vector.y)\n\n    @staticmethod\n    def plane(speckle_plane: Plane):\n        return gp_Ax2(SpeckleToOcc.point(speckle_plane.origin), \n            SpeckleToOcc.direction(speckle_plane.normal),\n            SpeckleToOcc.direction(speckle_plane.xdir))\n\n    @staticmethod\n    def plane2d(speckle_plane: Plane):\n        return gp_Ax22d(SpeckleToOcc.point2d(speckle_plane.origin), \n            SpeckleToOcc.direction2d(speckle_plane.xdir))\n\n    @staticmethod\n    def circle(speckle_circle: Circle):\n        return GC_MakeCircle(SpeckleToOcc.plane(speckle_circle.plane), speckle_circle.radius).Value()\n        \n    @staticmethod\n    def circle2d(speckle_circle: Circle):\n        return GCE2d_MakeCircle(SpeckleToOcc.plane2d(speckle_circle.plane), speckle_circle.radius).Value()\n\n    @staticmethod\n    def line(speckle_line: Line):\n        start = gp_Pnt(speckle_line.start.x, speckle_line.start.y, speckle_line.start.z)\n        end = gp_Pnt(speckle_line.end.x, speckle_line.end.y, speckle_line.end.z)\n\n        return GC_MakeSegment(start, end).Value()\n\n    @staticmethod\n    def line2d(speckle_line: Line):\n        start = gp_Pnt2d(speckle_line.start.x, speckle_line.start.y)\n        end = gp_Pnt2d(speckle_line.end.x, speckle_line.end.y)\n\n        return GCE2d_MakeSegment(start, end).Value()\n\n    @staticmethod\n    def arc(speckle_arc: Arc):\n        return GC_MakeArcOfCircle(\n            SpeckleToOcc.point(speckle_arc.startPoint),\n            SpeckleToOcc.point(speckle_arc.midPoint),\n            SpeckleToOcc.point(speckle_arc.endPoint)).Value()\n\n\n    @staticmethod\n    def arc2d(speckle_arc: Arc, convert=False):\n        circle = GCE2d_MakeCircle(SpeckleToOcc.plane2d(speckle_arc.plane), speckle_arc.radius).Value()\n        start = SpeckleToOcc.point2d(speckle_arc.startPoint)\n        end = SpeckleToOcc.point2d(speckle_arc.endPoint)\n\n        c = circle.Circ2d()\n        logging.debug(f\"{dir(elclib)}\")\n        logging.debug(f\"{c}\")\n\n        alpha1 = elclib.Parameter(c, start)\n        alpha2 = elclib.Parameter(c, end)\n\n        '''\n        return Geom2d_TrimmedCurve(circle, alpha1, alpha2, True)\n\n        arc = GCE2d_MakeArcOfCircle(\n            SpeckleToOcc.point2d(speckle_arc.startPoint),\n            SpeckleToOcc.point2d(speckle_arc.midPoint),\n            SpeckleToOcc.point2d(speckle_arc.endPoint)).Value()\n        logging.debug(f\"arc: {arc.BasisCurve().Continuity()}\")\n        logging.debug(f\"{dir(arc)}\")\n        raise Exception(\"Fucking arcs, man...\")\n        return arc\n        '''\n        if convert:\n            conv = Convert_CircleToBSplineCurve(circle.Circ2d())\n            logging.debug(f\"CircleToBSplineCurve\")\n\n            logging.debug(f\"   NbPoles   {conv.NbPoles()}\")\n            logging.debug(f\"   NbKnots   {conv.NbKnots()}\")\n            logging.debug(f\"   Degree    {conv.Degree()}\")\n            logging.debug(f\"   Periodic  {conv.IsPeriodic()}\")\n\n            nKnots = conv.NbKnots()\n            nPoles = conv.NbPoles()\n\n            poles = TColgp_Array1OfPnt2d(1, nPoles)\n            for i in range(1, nPoles + 1):\n                logging.debug(f\"    Pole {i} {conv.Pole(i)}\")\n                poles.SetValue(i, conv.Pole(i))\n\n            weights = TColStd_Array1OfReal(1, nPoles)\n            for i in range(1, nPoles + 1):\n                logging.debug(f\"    Weight {i} {conv.Weight(i)}\")\n                weights.SetValue(i, conv.Weight(i))\n\n            knots = TColStd_Array1OfReal(1, nKnots)\n            for i in range(1, nKnots + 1):\n                logging.debug(f\"    Knot {i} {conv.Knot(i)}\")\n                knots.SetValue(i, conv.Knot(i))\n\n            mults = TColStd_Array1OfInteger(1, nKnots)\n            for i in range(1, nKnots + 1):\n                logging.debug(f\"    Multiplicity {i} {conv.Multiplicity(i)}\")\n                mults.SetValue(i, conv.Multiplicity(i))\n\n            bspline = Geom2d_BSplineCurve(poles, weights, knots, mults, conv.Degree(), conv.IsPeriodic())    \n\n            return Geom2d_TrimmedCurve(bspline, alpha1, alpha2, True)\n\n        else:\n            return GCE2d_MakeArcOfCircle(\n                SpeckleToOcc.point2d(speckle_arc.startPoint),\n                SpeckleToOcc.point2d(speckle_arc.midPoint),\n                SpeckleToOcc.point2d(speckle_arc.endPoint)).Value()\n\n    @staticmethod\n    def polyline(speckle_polyline: Polyline):\n        N = len(speckle_polyline.value) // 3\n        comp = GeomConvert_CompCurveToBSplineCurve()\n        for i in range(N - 1):\n            start = speckle_polyline.value[N * 3 : N * 3 + 3]\n            end = speckle_polyline.value[N * 3 : N * 3 + 3 + 3]\n            line = Line()\n            pt0 = Point()\n            pt0.x = start[0]\n            pt0.y = start[1]\n            pt0.z = start[2]\n            pt1 = Point()\n            pt1.x = start[0]\n            pt1.y = start[1]\n            pt1.z = start[2]\n            line.start = pt0\n            line.end = pt1\n            comp.Add(SpeckleToOcc.line(line), TOLERANCE)\n        return comp.BSplineCurve()\n\n    @staticmethod\n    def polyline2d(speckle_polyline: Polyline):\n        N = len(speckle_polyline.value) // 3\n        comp = Geom2dConvert_CompCurveToBSplineCurve()\n        for i in range(N - 3):\n            start = speckle_polyline.value[N * 3 : N * 3 + 3]\n            end = speckle_polyline.value[N * 3 : N * 3 + 3 + 3]\n            line = Line()\n            pt0 = Point()\n            pt0.x = start[0]\n            pt0.y = start[1]\n            pt0.z = start[2]\n            pt1 = Point()\n            pt1.x = start[0]\n            pt1.y = start[1]\n            pt1.z = start[2]\n            line.start = pt0\n            line.end = pt1\n            comp.Add(SpeckleToOcc.line(line), TOLERANCE)\n        return comp.BSplineCurve()\n\n    @staticmethod\n    def curve(speckle_curve : Curve):\n        \"\"\"\n        Speckle Curve to OCC Geom_BSplineCurve\n        \"\"\"\n        logging.debug(f\"Converting curve type {speckle_curve.speckle_type}\")\n\n        if speckle_curve.speckle_type.endswith(\"Line\"):\n            return SpeckleToOcc.line(speckle_curve)\n        elif speckle_curve.speckle_type.endswith(\"Circle\"):\n            return SpeckleToOcc.circle(speckle_curve)\n        elif speckle_curve.speckle_type.endswith(\"Arc\"):\n            return SpeckleToOcc.arc(speckle_curve)\n        elif speckle_curve.speckle_type.endswith(\"Polyline\"):\n            return SpeckleToOcc.polyline(speckle_curve)            \n        elif speckle_curve.speckle_type.endswith(\"Polycurve\"):\n            segments = speckle_curve.segments\n            comp = GeomConvert_CompCurveToBSplineCurve()\n            for seg in segments:\n                comp.Add(SpeckleToOcc.curve(seg), TOLERANCE)\n            return comp.BSplineCurve()\n\n        else:\n            degree = speckle_curve.degree\n            closed = bool(speckle_curve.closed)\n\n        N = len(speckle_curve.points) // 3\n\n        logging.debug(f\"num values {len(speckle_curve.points)}, num pts {N}\")\n        logging.debug(f\"num weights {len(speckle_curve.weights)}\")\n        logging.debug(f\"degree {degree}\")\n        logging.debug(f\"periodic {closed}\")\n\n        poles = TColgp_Array1OfPnt(1, N)\n\n        for i in range(N):\n            poles.SetValue(i + 1, gp_Pnt(\n                speckle_curve.points[i * 3 + 0], \n                speckle_curve.points[i * 3 + 1], \n                speckle_curve.points[i * 3 + 2]))\n\n        weights = TColStd_Array1OfReal(1, len(speckle_curve.weights))\n\n        for i, weight in enumerate(speckle_curve.weights, 1):\n            weights.SetValue(i, weight)\n\n        knots_data, mults_data = SpeckleToOcc.speckle_knots_to_occ(speckle_curve.knots, speckle_curve.degree)\n\n        knots = TColStd_Array1OfReal(1, len(knots_data))\n        for i, knot in enumerate(knots_data, 1):\n            knots.SetValue(i, knot)\n\n        mults = TColStd_Array1OfInteger(1, len(mults_data))\n        for i, mult in enumerate(mults_data, 1):\n            mults.SetValue(i, mult)\n\n        return Geom_BSplineCurve(poles, weights, knots, mults, degree, closed)\n\n    @staticmethod\n    def curve2d(speckle_curve : Curve, convert_circles = True):\n        \"\"\"\n        Speckle Curve to OCC Geom_BSplineCurve\n        \"\"\"\n        logging.debug(f\"Converting 2d curve type {speckle_curve.speckle_type}\")\n\n        if speckle_curve.speckle_type.endswith(\"Line\"):\n            return SpeckleToOcc.line2d(speckle_curve)\n        elif speckle_curve.speckle_type.endswith(\"Arc\"):\n            logging.debug(\"Got arc2d!\")\n            return SpeckleToOcc.arc2d(speckle_curve)   \n        elif speckle_curve.speckle_type.endswith(\"Circle\"):\n            circ = SpeckleToOcc.circle2d(speckle_curve)\n            if convert_circles:\n                conv = Convert_CircleToBSplineCurve(circ.Circ2d())\n\n                logging.debug(f\"   NbPoles   {conv.NbPoles()}\")\n                logging.debug(f\"   NbKnots   {conv.NbKnots()}\")\n                logging.debug(f\"   Degree    {conv.Degree()}\")\n                logging.debug(f\"   Periodic  {conv.IsPeriodic()}\")\n\n                nKnots = conv.NbKnots()\n                nPoles = conv.NbPoles()\n\n                poles = TColgp_Array1OfPnt2d(1, nPoles)\n                for i in range(1, nPoles + 1):\n                    logging.debug(f\"    Pole {i} {conv.Pole(i)}\")\n                    poles.SetValue(i, conv.Pole(i))\n\n                weights = TColStd_Array1OfReal(1, nPoles)\n                for i in range(1, nPoles + 1):\n                    logging.debug(f\"    Weight {i} {conv.Weight(i)}\")\n                    weights.SetValue(i, conv.Weight(i))\n\n                knots = TColStd_Array1OfReal(1, nKnots)\n                for i in range(1, nKnots + 1):\n                    logging.debug(f\"    Knot {i} {conv.Knot(i)}\")\n                    knots.SetValue(i, conv.Knot(i))\n\n                mults = TColStd_Array1OfInteger(1, nKnots)\n                for i in range(1, nKnots + 1):\n                    logging.debug(f\"    Multiplicity {i} {conv.Multiplicity(i)}\")\n                    mults.SetValue(i, conv.Multiplicity(i))\n\n                return Geom2d_BSplineCurve(poles, weights, knots, mults, conv.Degree(), conv.IsPeriodic())\n            else:\n                return circ\n        elif speckle_curve.speckle_type.endswith(\"Polyline\"):\n            return SpeckleToOcc.polyline2d(speckle_curve)  \n        elif speckle_curve.speckle_type.endswith(\"Polycurve\"):\n            segments = speckle_curve.segments\n            comp = Geom2dConvert_CompCurveToBSplineCurve()\n            for seg in segments:\n                comp.Add(SpeckleToOcc.curve2d(seg), TOLERANCE)\n\n            return comp.BSplineCurve()\n\n        else:\n            degree = speckle_curve.degree\n            closed = bool(speckle_curve.closed)\n\n\n        N = len(speckle_curve.points) // 3\n        logging.debug(f\"num values {len(speckle_curve.points)}, num pts {N}\")\n        logging.debug(f\"num weights {len(speckle_curve.weights)}\")\n        logging.debug(f\"degree {degree}\")\n        logging.debug(f\"periodic {closed}\")\n\n        poles = TColgp_Array1OfPnt2d(1, N)\n\n        for i in range(N):\n            poles.SetValue(i + 1, gp_Pnt2d(\n                speckle_curve.points[i * 3 + 0], \n                speckle_curve.points[i * 3 + 1]))\n\n        weights = TColStd_Array1OfReal(1, len(speckle_curve.weights))\n\n        for i, weight in enumerate(speckle_curve.weights, 1):\n            weights.SetValue(i, weight)\n\n        knots_data, mults_data = SpeckleToOcc.speckle_knots_to_occ(speckle_curve.knots, speckle_curve.degree)\n\n        knots = TColStd_Array1OfReal(1, len(knots_data))\n        for i, knot in enumerate(knots_data, 1):\n            knots.SetValue(i, knot)\n\n        mults = TColStd_Array1OfInteger(1, len(mults_data))\n        for i, mult in enumerate(mults_data, 1):\n            mults.SetValue(i, mult)\n\n        crv = Geom2d_BSplineCurve(poles, weights, knots, mults, degree, closed)\n        return crv\n\n    @staticmethod\n    def surface(srf):\n        poles = TColgp_Array2OfPnt(1, srf.countU, 1, srf.countV)\n        degreeU = srf.degreeU\n        degreeV = srf.degreeV\n        periodicU = srf.closedU\n        periodicV = srf.closedV\n\n        knotsU_data, multsU_data = SpeckleToOcc.speckle_knots_to_occ(srf.knotsU, srf.degreeU)\n        knotsV_data, multsV_data = SpeckleToOcc.speckle_knots_to_occ(srf.knotsV, srf.degreeV)\n\n        knotsU = TColStd_Array1OfReal(1, len(knotsU_data))\n        for i, knot in enumerate(knotsU_data):\n            knotsU.SetValue(i + 1, knot)\n\n        multsU = TColStd_Array1OfInteger(1, len(multsU_data))\n        for i, mult in enumerate(multsU_data):\n            multsU.SetValue(i + 1, mult)\n\n        knotsV = TColStd_Array1OfReal(1, len(knotsV_data))\n        for i, knot in enumerate(knotsV_data):\n            knotsV.SetValue(i + 1, knot)\n\n        multsV = TColStd_Array1OfInteger(1, len(multsV_data))\n        for i, mult in enumerate(multsV_data):\n            multsV.SetValue(i + 1, mult)\n\n        i = 0\n        #print(f\"processing surface {srf}\")\n        #for pdat in srf.pointData:\n        #    print(f\"    {pdat:.3f}\")\n\n        weights = TColStd_Array2OfReal(1, srf.countU, 1, srf.countV)\n        for u in range(srf.countU):\n            for v in range(srf.countV):\n                pt = gp_Pnt(srf.pointData[i], srf.pointData[i + 1], srf.pointData[i + 2])\n                poles.SetValue(u + 1, v + 1, pt)\n                weights.SetValue(u + 1, v + 1, srf.pointData[i + 3])\n\n                logging.debug(f\"{u+1}, {v+1} : {gp_Pnt_to_string(poles.Value(u + 1, v + 1))}\")\n                i += 4\n\n        return Geom_BSplineSurface(poles, weights, knotsU, knotsV, multsU, multsV, degreeU, degreeV, periodicU, periodicV)\n\n    @staticmethod\n    def brep2(speckle_brep):\n        logging.debug(f\"\\nSpeckle Brep stats\")\n        logging.debug(f\"   num vertices {len(speckle_brep.Vertices)}\")\n        logging.debug(f\"   num curve3d  {len(speckle_brep.Curve3D)}\")\n        logging.debug(f\"   num curve2d  {len(speckle_brep.Curve2D)}\")\n        logging.debug(f\"   num surfaces {len(speckle_brep.Surfaces)}\")\n        logging.debug(f\"   num edges    {len(speckle_brep.Edges)}\")\n        logging.debug(f\"   num faces    {len(speckle_brep.Faces)}\")\n\n        preci = breplib.Precision()\n        logging.debug(f\"   precision    {preci}\")\n\n        vertices = [BRepBuilderAPI_MakeVertex(gp_Pnt(p.x, p.y, p.z)).Vertex() for p in speckle_brep.Vertices]\n\n        curve3d = [SpeckleToOcc.curve(crv) for crv in speckle_brep.Curve3D]\n        curve2d = [SpeckleToOcc.curve2d(crv) for crv in speckle_brep.Curve2D]\n\n        #raise Exception(\"Stopping here.\")\n\n        logging.debug(f\"curve2d\")\n        for crv2d in curve2d:\n            logging.debug(f\"    {crv2d}\")\n        logging.debug(f\"curve3d\")\n        for crv3d in curve3d:\n            logging.debug(f\"    {crv3d}\")\n                     \n        surfaces = [SpeckleToOcc.surface(srf) for srf in speckle_brep.Surfaces]\n\n        builder = BRep_Builder()\n\n        logging.debug(\"\\nVertices ##############\\n\")\n        verts = []\n        for v in speckle_brep.Vertices:\n            vert = TopoDS_Vertex()\n            builder.MakeVertex(vert)\n            builder.UpdateVertex(vert, SpeckleToOcc.point(v), preci)\n            verts.append(vert)\n\n        logging.debug(\"\\nEdges #################\\n\")\n\n        edges = []\n        for speckle_edge in speckle_brep.Edges:\n            edge = TopoDS_Edge()\n            builder.MakeEdge(edge, curve3d[speckle_edge.Curve3dIndex], preci)\n            # builder.UpdateEdge(edge, curve3d[speckle_edge.Curve3dIndex], \n            #     verts[speckle_edge.StartIndex],\n            #     verts[speckle_edge.EndIndex])\n            edges.append(edge)\n\n        trims = []\n        for speckle_trim in speckle_brep.Trims:\n            edge = edges[speckle_trim.EdgeIndex]\n            builder.UpdateEdge(edge, curve2d[speckle_trim.CurveIndex], speckle_trim.FaceIndex)\n            trim = TopoDS_Edge()\n            builder.MakeEdge(trim, curve2d[speckle_trim.CurveIndex], preci)\n            trims.append(trim)\n\n        # loops = []\n        # for speckle_loop in speckle_brep.Loops:\n        #     wire = TopoDS_Wire()\n        #     builder.MakeWire(wire)\n\n        #     for ei in speckle_loop.TrimIndices:\n        #         edge = trims[ei]\n        #         # edge = edges[speckle_brep.Trims[ei].EdgeIndex]\n        #         builder.Add(wire, edge)\n\n        #     loops.append(wire)\n\n        faces = []\n        for speckle_face in speckle_brep.Faces:\n            face = TopoDS_Face()\n            builder.MakeFace(face, surfaces[speckle_face.SurfaceIndex], preci)\n\n            faces.append(face)\n            logging.debug(f\"face: {face}\")\n\n        # trims = []\n        # for speckle_trim in speckle_brep.Trims:\n        #     edge = edges[speckle_trim.EdgeIndex]\n        #     builder.UpdateEdge(edge, curve2d[speckle_trim.CurveIndex], faces[speckle_trim.FaceIndex], preci)\n\n\n        shell = TopoDS_Shell()\n        builder.MakeShell(shell)\n\n        for face in faces:\n            builder.Add(shell, face)\n\n        return edges[0]\n\n    @staticmethod\n    def brep(speckle_brep):\n\n        logging.debug(f\"\\nSpeckle Brep stats\")\n        logging.debug(f\"   num vertices {len(speckle_brep.Vertices)}\")\n        logging.debug(f\"   num curve3d  {len(speckle_brep.Curve3D)}\")\n        logging.debug(f\"   num curve2d  {len(speckle_brep.Curve2D)}\")\n        logging.debug(f\"   num surfaces {len(speckle_brep.Surfaces)}\")\n        logging.debug(f\"   num edges    {len(speckle_brep.Edges)}\")\n        logging.debug(f\"   num faces    {len(speckle_brep.Faces)}\")\n\n        vertices = [BRepBuilderAPI_MakeVertex(gp_Pnt(p.x, p.y, p.z)).Vertex() for p in speckle_brep.Vertices]\n\n        curve3d = [SpeckleToOcc.curve(crv) for crv in speckle_brep.Curve3D]\n        curve2d = [SpeckleToOcc.curve2d(crv) for crv in speckle_brep.Curve2D]\n\n        #raise Exception(\"Stopping here.\")\n\n        logging.debug(f\"curve2d\")\n        for crv2d in curve2d:\n            logging.debug(f\"    {crv2d}\")\n        logging.debug(f\"curve3d\")\n        for crv3d in curve3d:\n            logging.debug(f\"    {crv3d}\")\n                     \n        surfaces = [SpeckleToOcc.surface(srf) for srf in speckle_brep.Surfaces]\n\n\n\n        logging.debug(\"\\nEdges #################\\n\")\n        '''\n\n        edges = []\n        for be in speckle_brep.Edges:\n            crv3d = curve3d[be.Curve3dIndex]\n            startv = vertices[be.StartIndex]\n            endv = vertices[be.EndIndex]\n\n            logging.debug(\"edge\")\n            logging.debug(f\"    Curve3dIndex {be.Curve3dIndex}\")\n            logging.debug(f\"    StartIndex {be.StartIndex}\")\n            logging.debug(f\"    EndIndex {be.EndIndex}\")\n\n            # print(f\"{crv3d}\")\n            # print(f\"    crv first {gp_Pnt_to_string(crv3d.Value(crv3d.FirstParameter()))}\")\n            # print(f\"    crv last {gp_Pnt_to_string(crv3d.Value(crv3d.LastParameter()))}\")\n            # print(f\"    startv   {gp_Pnt_to_string(BRep_Tool.Pnt(startv))}\")\n            # print(f\"    endv   {gp_Pnt_to_string(BRep_Tool.Pnt(endv))}\")\n                #print(f\"{be.StartIndex}\")\n                #print(f\"{be.EndIndex}\")\n\n            logging.debug(f\"CURVE TYPE: {crv3d}\")\n\n            if be.StartIndex == be.EndIndex:\n                edge = BRepBuilderAPI_MakeEdge(crv3d)\n            else:\n                edge = BRepBuilderAPI_MakeEdge(crv3d, startv, endv)\n            edges.append(edge.Edge())\n        '''\n        logging.debug(\"\\nTrims #################\\n\")\n\n        trims = []\n        trim_count = 0\n        for t in speckle_brep.Trims:\n            face = speckle_brep.Faces[t.FaceIndex]\n\n            logging.debug(f\"trim\")\n            logging.debug(f\"    CurveIndex {t.CurveIndex}\")\n            logging.debug(f\"    EdgeIndex {t.EdgeIndex}\")\n            logging.debug(f\"    SurfaceIndex {face.SurfaceIndex}\")\n\n            tcurve = curve2d[t.CurveIndex]\n            logging.debug(f\"    {tcurve} : degree {tcurve.Degree()}\")\n\n            if isinstance(tcurve, Geom2d_Curve):\n                edge2d = BRepBuilderAPI_MakeEdge(tcurve, surfaces[face.SurfaceIndex])\n            else:\n                logging.debug(\"    3d curve...\")\n                edge2d = BRepBuilderAPI_MakeEdge(tcurve)\n\n            print(help(edge2d))\n            exit()\n\n            if edge2d.IsDone():\n                trims.append(edge2d.Edge())\n            else:\n                trims.append(None)\n            trim_count += 1\n            pass\n\n        logging.debug(\"\\nLoops / Wires #########\\n\")\n\n        wires = []\n\n        for loop in speckle_brep.Loops:\n            wire = BRepBuilderAPI_MakeWire()\n            logging.debug(f\"loop {loop}\")\n            logging.debug(f\"    TrimIndices {loop.TrimIndices}\")\n            for ti in loop.TrimIndices:\n                wire.Add(trims[ti])\n                logging.debug(f\"    added {ti}\")\n\n            if not wire.IsDone():\n                logging.debug(f\"Wire failed: {wire.Error()}\")\n                wires.append(None)\n                continue\n\n            wires.append(wire.Wire())\n\n        logging.debug(\"\\nFaces #################\\n\")\n\n        faces = []\n        for sface in speckle_brep.Faces:\n\n            logging.debug(f\"face\")\n            logging.debug(f\"    outerloop {sface.OuterLoopIndex}\")\n            logging.debug(f\"    surface   {sface.SurfaceIndex}\")\n            logging.debug(f\"    loop ids   {sface.LoopIndices}\")\n\n            if wires[sface.OuterLoopIndex] is None:\n                logging.debug(f\"Couldn't find loop {sface.OuterLoopIndex}\")\n                continue\n\n            face = BRepBuilderAPI_MakeFace(surfaces[sface.SurfaceIndex], wires[sface.OuterLoopIndex], False)\n\n            for hole in sface.LoopIndices:\n                if hole != sface.OuterLoopIndex:\n                    face.Add(wires[hole])\n\n            if not face.IsDone():\n                logging.debug(f\"face did not finish: {face.Error()}\")\n                continue\n\n            faces.append(face.Face())\n\n        logging.debug(\"\")\n        logging.debug(\"Shells #################\")\n        logging.debug(\"\")\n\n        shells = []\n        for srf in surfaces:\n            shell = BRepBuilderAPI_MakeShell(srf).Shell()\n            logging.debug(f\"Made shell: {shell}\")\n            shells.append(shell)\n\n\n\n        logging.debug(\"\")\n        logging.debug(\"Compound #################\")\n        logging.debug(\"\")\n\n\n        c = TopoDS_Compound()\n        topo = TopoDS_Builder()\n        topo.MakeCompound(c)\n\n        '''\n        sew = BRepOffsetAPI_Sewing(TOLERANCE, True, True, True, False)\n\n        for face in faces:\n            sew.Add(face)\n\n        sew.Perform()\n        logging.debug(f\"sew: {sew.Dump()}\")\n        logging.debug(f\"{sew.SewedShape()}\")\n\n        topo.Add(c, sew.SewedShape())        \n        '''\n\n        builder = BRep_Builder()\n        bprim = BRepPrim_Builder(builder)\n        shell = TopoDS_Shell()\n\n        bprim.MakeShell(shell)\n\n        for face in faces:\n            bprim.AddShellFace(shell, face)\n            #topo.Add(c, face)\n            pass\n\n        return shell\n\n        for s in shells:\n            if s is not None:\n                #topo.Add(c, s)\n            #break\n                pass\n\n        for i, trim in enumerate(trims):\n            #print(f\"    adding TRIM {i} {trim}\")\n            #topo.Add(c, trim)\n            pass\n\n        for wire in wires:\n            if wire is not None:\n                #topo.Add(c, wire)\n                pass\n\n        return c\n\n\ndef make_dummy_speckle_curve():\n    degree = 3\n    points = [\n        Point(x=0,y=0,z=0),\n        Point(x=500,y=0,z=0),\n        Point(x=1000,y=500,z=0),\n        Point(x=1500,y=500,z=0),\n        Point(x=2000,y=250,z=0),\n    ]\n    weights = [1.0, 1.0, 1.0, 1.0, 1.0]\n    knots = [1.0, 1.0, 1.0, 1.0, 3.0, 5.0, 5.0, 5.0, 5.0]\n\n    return Curve(degree=degree, points=points, weights=weights, knots=knots, closed=False)\n\ndef test_speckle_curve_to_occ():\n\n    crv = make_dummy_speckle_curve()\n    occ_crv = to_occ_curve(crv)\n    print(occ_crv)\n\n    return occ_crv\n\ndef test_occ_curve_to_speckle():\n\n    crv = make_dummy_speckle_curve()\n    occ_crv = to_occ_curve(crv)\n\n    speckle_curve = to_speckle_curve(occ_crv)\n\n    print(crv.__dict__)\n    print()\n    print(speckle_curve.__dict__)\n    print()\n\n    s0 = str(crv.__dict__)\n    s1 = str(speckle_curve.__dict__)\n    print(f\"equivalent: {s0 == s1}\")\n\n    return speckle_curve\n\ndef to_speckle_curve(occ_curve : Geom_BSplineCurve):\n    \"\"\"\n    OCC BSplineCurve to Speckle Curve\n    \"\"\"\n\n    degree = occ_curve.Degree()\n    closed = occ_curve.IsClosed()\n\n    poles = occ_curve.Poles()\n    points = []\n    weights = []\n\n    for i in range(poles.Length()):\n        pt = poles.Value(i + 1)\n        points.append(Point(x=pt.X(), y=pt.Y(), z=pt.Z()))\n        weights.append(occ_curve.Weight(i))\n\n    knots = []\n    for i in range(occ_curve.Knots().Length()):\n        knots.append(occ_curve.Knots().Value(i + 1))\n\n    mults = []\n    for i in range(occ_curve.Multiplicities().Length()):\n        mults.append(occ_curve.Multiplicities().Value(i + 1))\n\n    knots_flat = []\n    for i, m in enumerate(mults):\n        for j in range(m):\n            knots_flat.append(knots[i])\n\n    return Curve(degree=degree, points=points, weights=weights, knots=knots_flat, closed=closed)\n\n\ndef main():\n    RhinoToOcc.to_rhino_curve(\"test\")\n    RhinoToOcc.to_rhino_brep(\"test\")\n\n    test_occ_curve_to_speckle()\n\n\n\nif __name__==\"__main__\":\n    print(\"EMA timber conversion functions\")\n    #print(dir(OCC))\n    main()",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": false
}