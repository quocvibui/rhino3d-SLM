{
  "source_url": "https://github.com/gramaziokohler/integral_timber_joints/blob/d543a28ccfaeb8a56ff692a29d5510c3e649477f/src/integral_timber_joints/rhino/export_brep_no_clamp_holes.py",
  "repo": "gramaziokohler/integral_timber_joints",
  "repo_stars": 11,
  "repo_description": "Robotic Assembled Timber Structures with Integral Timber Joints",
  "license": "MIT",
  "filepath": "src/integral_timber_joints/rhino/export_brep_no_clamp_holes.py",
  "instruction": "Export brep no clamp holes",
  "code": "\nimport Rhino  # type: ignore\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport Rhino.Geometry as rg\n\nfrom integral_timber_joints.rhino.load import get_process, get_process_artist, process_is_none\nfrom integral_timber_joints.geometry import JointHalfLap, JointNonPlanarLap\nfrom integral_timber_joints.rhino.assembly_artist import AssemblyNurbsArtist\nfrom integral_timber_joints.assembly import BeamAssemblyMethod\nfrom integral_timber_joints.tools import Clamp, Screwdriver, Gripper\n\nfrom compas_rhino.utilities import clear_layer, delete_objects, draw_breps, draw_cylinders, draw_mesh\nfrom integral_timber_joints.rhino.artist import mesh_to_brep, vertices_and_faces_to_brep_struct, draw_shapes_as_brep_get_guids\n\nimport json\n\nfrom compas_rhino.utilities import clear_layer, delete_objects, draw_mesh\nfrom compas.data import DataEncoder\n\n\nfrom compas.geometry import Cylinder, Transformation\n\nadd_brep = sc.doc.Objects.AddBrep\nfind_object = sc.doc.Objects.Find\n\nTOL = sc.doc.ModelAbsoluteTolerance\n\ndef get_tool_features_on_beam(self, beam_id, include_screwdriver = True, include_clamp = True, include_gripper = True):\n    assembly = self.assembly\n    # * Retrieve Clamps and Screwdrivers attached to this beam\n    other_feature_shapes = []\n\n    assembly_method = self.assembly.get_assembly_method(beam_id)\n\n    def draw_drill_cylinders_of_tool_at_wcf(tool):\n        cylinders = []\n        t_world_tool_at_final = Transformation.from_frame(tool.current_frame)\n        for line in tool.gripper_drill_lines:\n            cylinder = Cylinder.from_line_radius(line, tool.gripper_drill_diameter/2.0)\n            cylinders.append(cylinder.transformed(t_world_tool_at_final))\n        return cylinders\n\n    # * Gripper (except if it is manually assembled)\n    if assembly_method != BeamAssemblyMethod.MANUAL_ASSEMBLY:\n        if self.assembly.get_beam_attribute(beam_id, \"gripper_tcp_in_ocf\") is None:\n            print(\"Warning: gripper_tcp_in_ocf is None while calling process.get_tool_features_on_beam(%s)\" % (beam_id))\n        else:\n            gripper = self.get_gripper_of_beam(beam_id)\n            print (type(gripper))\n            if include_gripper and type(gripper) == Gripper:\n                other_feature_shapes += draw_drill_cylinders_of_tool_at_wcf(gripper)\n            if include_screwdriver and type(gripper) == Screwdriver:\n                other_feature_shapes += draw_drill_cylinders_of_tool_at_wcf(gripper)\n\n    # * Clamps Attached to this beam - Need to check neighbour's assembly method\n    for neighbour_id in assembly.get_unbuilt_neighbors(beam_id):\n        if assembly.get_assembly_method(neighbour_id) == BeamAssemblyMethod.CLAMPED:\n            clamp = self.get_tool_of_joint((beam_id, neighbour_id))  # type: Clamp\n            if clamp is not None:\n                if include_clamp:\n                    other_feature_shapes += draw_drill_cylinders_of_tool_at_wcf(clamp)\n\n    # * Screwdrivers Attached to this beam\n    if assembly_method in BeamAssemblyMethod.screw_methods:\n        for neighbour_id in assembly.get_already_built_neighbors(beam_id):\n            screwdriver = self.get_tool_of_joint((neighbour_id, beam_id))\n            if screwdriver is not None:\n                if include_screwdriver:\n                    other_feature_shapes += draw_drill_cylinders_of_tool_at_wcf(screwdriver)\n    return other_feature_shapes\n\ndef draw_brep_without_screwdriver_holes(beam_id):\n\n    # Obtain tool features on Beam from Process\n    other_feature_shapes = get_tool_features_on_beam(process, beam_id, include_screwdriver=False)\n\n    rs.EnableRedraw(False)\n\n\n    # Positive geometry is the uncut beam mesh\n    mesh_box = assembly.beam(beam_id).draw_uncut_mesh()\n    positive_brep_guids = draw_breps(mesh_to_brep(mesh_box), join=True, redraw=False)\n\n    # Retrieve all the negative features\n    negative_shapes = assembly.get_beam_negative_shapes(beam_id)\n    negative_shapes += other_feature_shapes\n\n    guids = []  # Hold the guids of the final boolean result\n    if len(negative_shapes) > 0:\n        # Get the negative meshes from the features and convert them to nurbs\n        negative_brep_guids = draw_shapes_as_brep_get_guids(negative_shapes)\n\n        # Perform Boolean Difference\n        positive_breps = [rs.coercebrep(guid) for guid in positive_brep_guids]\n        negative_breps = [rs.coercebrep(guid) for guid in negative_brep_guids]\n\n        # Perform MergeCoplanarFaces before boolean to reduce chance of failure\n        [brep.MergeCoplanarFaces(sc.doc.ModelAbsoluteTolerance) for brep in negative_breps]\n\n        # print(\"negative_breps : %s\" % negative_breps)\n        # ! First attempt at boolean all objects together\n        boolean_result = rg.Brep.CreateBooleanDifference(positive_breps, negative_breps, TOL)\n\n        # ! Second attempt at boolean objects one by one\n        if boolean_result is None:\n            print(\"WARNING: AssemblyNurbArtist draw_beam(%s) Group Boolean Failure\" % beam_id)\n            pos = positive_breps\n            for neg in negative_breps:\n                pos = rg.Brep.CreateBooleanDifference(pos, [neg], TOL)\n                if pos is None:\n                    print(\"WARNING: AssemblyNurbArtist draw_beam(%s) Iterative Boolean Failure\" % beam_id)\n                    break\n            boolean_result = pos\n\n        if boolean_result is None:\n            print(\"ERROR: AssemblyNurbArtist draw_beam(%s) Boolean All Failure\" % beam_id)\n            # delete_objects(positive_brep_guids + negative_brep_guids, purge=True, redraw=False)\n            # delete_objects(negative_brep_guids, purge=True, redraw=False)\n            # [sc.doc.Objects.AddBrep(brep) for brep in negative_breps]\n        else:\n            for brep in boolean_result:\n                # Perform MergeCoplanarFaces after boolean to clean up\n                brep.MergeCoplanarFaces(sc.doc.ModelAbsoluteTolerance)\n                # New guids from boolean results\n                guid = add_brep(brep)\n                if guid:\n                    guids.append(guid)\n\n            # Delete the original boolean set geometries\n            delete_objects(positive_brep_guids + negative_brep_guids, purge=True, redraw=False)\n    else:\n        guids = positive_brep_guids\n\n    # Rename newly created object with beam_id\n    for guid in guids:\n        obj = find_object(guid)\n        attr = obj.Attributes\n        attr.Name = beam_id\n        obj.CommitChanges()\n\nprocess = get_process()\nassembly = process.assembly\nartist = get_process_artist()\n# beam_id = assembly.sequence[19]\n\n# Layer\nlayer = 'itj_export'\nrs.CurrentLayer(layer)\nclear_layer(layer)\nfor beam_id in assembly.sequence:\n    print (beam_id)\n    draw_brep_without_screwdriver_holes(beam_id)\n\n# Enable redraw\nrs.EnableRedraw(True)\n\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}