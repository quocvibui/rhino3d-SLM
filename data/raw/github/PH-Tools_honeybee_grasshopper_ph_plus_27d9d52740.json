{
  "source_url": "https://github.com/PH-Tools/honeybee_grasshopper_ph_plus/blob/b89f9887488d9c10eb732ffafe910cec70be0752/honeybee_ph_plus_rhino/gh_compo_io/reporting/build_floor_segments.py",
  "repo": "PH-Tools/honeybee_grasshopper_ph_plus",
  "repo_stars": 2,
  "repo_description": "Additional Honeybe-PH Grasshopper Components",
  "license": "GPL-3.0",
  "filepath": "honeybee_ph_plus_rhino/gh_compo_io/reporting/build_floor_segments.py",
  "instruction": "Functions for getting / sorting all the Honeybee-Model TFA Floor Surfaces.",
  "code": "# -*- coding: utf-8 -*-\n# -*- Python Version: 2.7 -*-\n\n\"\"\"Functions for getting / sorting all the Honeybee-Model TFA Floor Surfaces. \"\"\"\n\nfrom collections import OrderedDict, defaultdict\n\ntry:\n    from typing import Any, Callable, Dict, List, Optional, Tuple\nexcept ImportError:\n    pass  # Python 2.7\n\ntry:\n    from System.Drawing import Color  # type: ignore\nexcept ImportError:\n    pass  # Outside .NET\n\ntry:\n    from Rhino import DocObjects as rdo  # type: ignore\n    from Rhino import Geometry as rg  # type: ignore\n    from Rhino.DocObjects import ObjectAttributes  # type: ignore\n    from Rhino.Geometry import Brep, Line, Point3d  # type: ignore\nexcept ImportError:\n    pass  # Outside Rhino\n\ntry:\n    from honeybee import facetype, model, room\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import honeybee:\\n\\t{}\".format(e))\n\ntry:\n    from ladybug_rhino.fromgeometry import from_face3d, from_point3d\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import honeybee:\\n\\t{}\".format(e))\n\ntry:\n    from honeybee_ph import space\n    from honeybee_ph.properties.room import RoomPhProperties\n    from honeybee_ph.properties.space import SpacePhProperties\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import honeybee_ph:\\n\\t{}\".format(e))\n\ntry:\n    from ph_gh_component_io import gh_io\nexcept ImportError:\n    raise ImportError(\"Failed to import honeybee_ph_rhino\")\n\ntry:\n    from honeybee_ph_utils.input_tools import input_to_int\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import honeybee_ph_utils:\\n\\t{}\".format(e))\n\ntry:\n    from ph_units.converter import convert\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import ph_units:\\n\\t{}\".format(e))\n\ntry:\n    from honeybee_ph_plus_rhino.gh_compo_io.reporting.annotations import (\n        TextAnnotation,\n        TextAnnotationMaskAttributes,\n    )\n    from honeybee_ph_plus_rhino.gh_compo_io.reporting.create_clipping_plane_set import (\n        ClippingPlaneLocation,\n    )\nexcept ImportError as e:\n    raise ImportError(\"\\nFailed to import honeybee_ph_rhino:\\n\\t{}\".format(e))\n\n\n# -----------------------------------------------------------------------------\n# -- Styles\ndef color_by_TFA(_flr_seg, _space):\n    # type: (space.SpaceFloorSegment, space.Space) -> Color\n    \"\"\"Return a System.Drawing.Color based on the TFA Weighting factor of the SpaceFloorSegment.\"\"\"\n\n    if _flr_seg.weighting_factor > 0.6:\n        return Color.FromArgb(255, 252, 252, 139)  # Yellow\n    elif 0.5 < _flr_seg.weighting_factor <= 0.6:\n        return Color.FromArgb(255, 227, 201, 168)  # Brown\n    elif 0.3 < _flr_seg.weighting_factor <= 0.5:\n        return Color.FromArgb(255, 213, 247, 143)  # Green\n    elif 0.0 < _flr_seg.weighting_factor <= 0.3:\n        return Color.FromArgb(255, 173, 247, 223)  # Blue\n    else:\n        return Color.FromArgb(255, 252, 182, 252)  # Purple\n\n\ndef color_by_Vent(_flr_seg, _space):\n    # type: (space.SpaceFloorSegment, space.Space) -> Color\n    \"\"\"Return a System.Drawing.Color based on the Ventilation Air Flow Rate of the Space\"\"\"\n    space_prop_ph = getattr(_space.properties, \"ph\")  # type: SpacePhProperties\n    if (space_prop_ph._v_sup or 0 > 0) and (space_prop_ph._v_eta or 0 > 0):\n        return Color.FromArgb(255, 234, 192, 240)  # Balanced\n    elif space_prop_ph._v_sup or 0 > 0:\n        return Color.FromArgb(255, 183, 227, 238)  # Supply Only\n    elif space_prop_ph._v_eta or 0 > 0:\n        return Color.FromArgb(255, 246, 170, 154)  # Extract Only\n    else:\n        return Color.FromArgb(255, 235, 235, 235)  # No Vent Flow\n\n\ndef text_by_TFA(_space, _IGH, _units=\"SI\"):\n    # type: (space.Space, gh_io.IGH, str) -> str\n    \"\"\"Return the space data in a formatted block.\"\"\"\n\n    rhdoc_len_units = _IGH.get_rhino_unit_system_name()\n    rhdoc_area_units = _IGH.get_rhino_areas_unit_name()\n    rhdoc_vol_units = _IGH.get_rhino_volume_unit_name()\n\n    if str(_units).upper().strip() == \"IP\":\n        txt = [\n            \"ZONE: {}\".format(_space.host.display_name),\n            \"NAME: {}\".format(_space.full_name),\n            \"GROSS AREA: {:.01f} ft2\".format(\n                convert(_space.floor_area, rhdoc_area_units, \"FT2\")\n            ),\n            \"WEIGHTED AREA: {:.01f} ft2\".format(\n                convert(_space.weighted_floor_area, rhdoc_area_units, \"FT2\")\n            ),\n            \"Vn50: {:.01f} ft3\".format(\n                convert(_space.net_volume, rhdoc_vol_units, \"FT3\")\n            ),\n            \"CLG HEIGHT: {:.01f} ft\".format(\n                convert(_space.avg_clear_height, rhdoc_len_units, \"FT\")\n            ),\n        ]\n    else:\n        txt = [\n            \"ZONE: {}\".format(_space.host.display_name),\n            \"NAME: {}\".format(_space.full_name),\n            \"GROSS AREA: {:.01f} m2\".format(\n                convert(_space.floor_area, rhdoc_area_units, \"M2\")\n            ),\n            \"WEIGHTED AREA: {:.01f} m2\".format(\n                convert(_space.weighted_floor_area, rhdoc_area_units, \"M2\")\n            ),\n            \"Vn50: {:.01f} m3\".format(convert(_space.net_volume, rhdoc_vol_units, \"M3\")),\n            \"CLG HEIGHT: {:.01f} m\".format(\n                convert(_space.avg_clear_height, rhdoc_len_units, \"M\")\n            ),\n        ]\n\n    return \"\\n\".join(txt)\n\n\ndef text_by_Vent(_space, _IGH, _units=\"SI\"):\n    # type: (space.Space, gh_io.IGH, str) -> str\n    \"\"\"Return the space data in a formatted block.\"\"\"\n    space_prop_ph = getattr(_space.properties, \"ph\")  # type: SpacePhProperties\n\n    def format_vent_rate(_rate, _target_unit=\"M3/HR\"):\n        # type (float | str | None) -> str\n        # -- get the data cleanly, in case None\n        try:\n            return \"{:.0f}\".format(convert(_rate * 3600, \"M3/HR\", _target_unit))\n        except:\n            return \"-\"\n\n    rhdoc_len_units = _IGH.get_rhino_unit_system_name()\n    rhdoc_area_units = _IGH.get_rhino_areas_unit_name()\n    rhdoc_vol_units = _IGH.get_rhino_volume_unit_name()\n\n    if str(_units).upper().strip() == \"IP\":\n        txt = [\n            \"ZONE: {}\".format(_space.host.display_name),\n            \"NAME: {}\".format(_space.full_name),\n            \"GROSS AREA: {:.01f} ft2\".format(\n                convert(_space.floor_area, rhdoc_area_units, \"FT2\")\n            ),\n            \"NET AREA: {:.01f} ft2\".format(\n                convert(_space.net_floor_area, rhdoc_area_units, \"FT2\")\n            ),\n            \"SUP: {} cfm\".format(format_vent_rate(space_prop_ph._v_sup or 0.0, \"CFM\")),\n            \"ETA: {} cfm\".format(format_vent_rate(space_prop_ph._v_eta or 0.0, \"CFM\")),\n            \"TRAN: {} cfm\".format(format_vent_rate(space_prop_ph._v_tran or 0.0, \"CFM\")),\n        ]\n    else:\n        txt = [\n            \"ZONE: {}\".format(_space.host.display_name),\n            \"NAME: {}\".format(_space.full_name),\n            \"GROSS AREA: {:.01f} m2\".format(\n                convert(_space.floor_area, rhdoc_area_units, \"M2\")\n            ),\n            \"NET AREA: {:.01f} m2\".format(\n                convert(_space.net_floor_area, rhdoc_area_units, \"M2\")\n            ),\n            \"SUP: {} m3/hr\".format(\n                format_vent_rate(space_prop_ph._v_sup or 0.0, \"M3/HR\")\n            ),\n            \"ETA: {} m3/hr\".format(\n                format_vent_rate(space_prop_ph._v_eta or 0.0, \"M3/HR\")\n            ),\n            \"TRAN: {} m3/hr\".format(\n                format_vent_rate(space_prop_ph._v_tran or 0.0, \"M3/HR\")\n            ),\n        ]\n\n    return \"\\n\".join(txt)\n\n\n# -----------------------------------------------------------------------------\n\n\ndef _get_hbph_spaces(_hb_room_group):\n    # type: (List[room.Room]) -> List[space.Space]\n    \"\"\"Return a sorted list of all the HBPH-Spaces in a list of HB-Rooms.\"\"\"\n\n    spaces = {}\n    for room in _hb_room_group:\n        room_prop_ph = getattr(room.properties, \"ph\")  # type: RoomPhProperties\n        for space in room_prop_ph.spaces:\n            spaces[space.display_name] = space\n\n    return sorted(list(spaces.values()), key=lambda sp: sp.display_name)\n\n\ndef _sort_rooms_by_z_location(_hb_model):\n    # type: (model.Model) -> Dict[str, List[room.Room]]\n    \"\"\"Return a Dict with the HB-Rooms grouped by their floor's Z-height.\"\"\"\n\n    rooms_by_z_height = defaultdict(list)\n    for hb_room in _hb_model.rooms:\n        flr_srfcs = [f for f in hb_room.faces if (isinstance(f.type, facetype.Floor))]\n        floor_srfcs_min_z = round(min(hb_face.min.z for hb_face in flr_srfcs), 3)\n        rooms_by_z_height[str(floor_srfcs_min_z)].append(hb_room)\n\n    # -- Sort the room groups by their Key (which is their Z-dist)\n    sorted_rooms_grouped_by_story = OrderedDict()\n    for k in sorted(rooms_by_z_height.keys(), key=lambda k: float(k)):\n        sorted_rooms_grouped_by_story[k] = rooms_by_z_height[k]\n\n    return sorted_rooms_grouped_by_story\n\n\ndef _group_hb_rooms_by_story(_hb_model):\n    # type: (model.Model) -> Dict[str, List[room.Room]]\n    \"\"\"Return a Dict with the HB-Rooms grouped by their 'Story'.\n\n    If the HB-Story data is not applied, will attempt to sort the HB-Rooms based\n    on their Z-height instead.\n    \"\"\"\n\n    # -- If the model is missing 'Story' data, sort by floor Z-location\n    if not all(hb_room.story for hb_room in _hb_model.rooms):\n        print(\"Not all Rooms have a 'Story' assigned. Sorting by Z-location.\")\n        return _sort_rooms_by_z_location(_hb_model)\n\n    # -- If model has Story data, just use that instead.\n    print(\"Grouping Rooms by their 'Story'.\")\n    rooms_grouped_by_story = defaultdict(list)\n    for hb_room in _hb_model.rooms:\n        try:\n            rooms_grouped_by_story[\"{:02d}\".format(int(hb_room.story))].append(hb_room)\n        except:\n            rooms_grouped_by_story[hb_room.story].append(hb_room)\n\n    # -- Sort the room groups by their Key (which is their Story name)\n    sorted_rooms_grouped_by_story = OrderedDict()\n    for k in sorted(rooms_grouped_by_story.keys()):\n        sorted_rooms_grouped_by_story[k] = rooms_grouped_by_story[k]\n\n    print(\"Found {} Stories.\".format(len(sorted_rooms_grouped_by_story)))\n    print(\"Stories: {}\".format(sorted_rooms_grouped_by_story.keys()))\n    return sorted_rooms_grouped_by_story\n\n\ndef _build_rh_attrs(_IGH, _color, _weight=0.5, _draw_order=None):\n    # type: (gh_io.IGH, Color, float, Optional[int]) -> ObjectAttributes\n\n    new_attr_obj = rdo.ObjectAttributes()\n\n    new_attr_obj.ObjectColor = _color\n    new_attr_obj.PlotColor = _color\n    new_attr_obj.ColorSource = rdo.ObjectColorSource.ColorFromObject\n    new_attr_obj.PlotColorSource = rdo.ObjectPlotColorSource.PlotColorFromObject\n\n    new_attr_obj.PlotWeight = _weight\n    new_attr_obj.PlotWeightSource = rdo.ObjectPlotWeightSource.PlotWeightFromObject\n\n    if _draw_order:\n        new_attr_obj.DisplayOrder = _draw_order  # 1 = Front, -1 = Back\n\n    return new_attr_obj\n\n\ndef _get_flr_seg_data(_IGH, _get_color, _space):\n    # type: (gh_io.IGH, Callable, space.Space) -> Tuple[List, List]\n    \"\"\"Return a Tuple of Lists with the Geometry and the ObjectAttributes.\"\"\"\n\n    flr_seg_geom_ = []  # type: List[Optional[Brep]]\n    flr_sef_attrs_ = []  # type: List[ObjectAttributes]\n\n    # -- Build the outline curve attr\n    crv_attr = _build_rh_attrs(_IGH, Color.FromArgb(255, 40, 40, 40), 0.4)\n\n    for volume in _space.volumes:\n        for flr_seg in volume.floor.floor_segments:\n            # -- Object Attributes\n            rh_attr = _build_rh_attrs(_IGH, _get_color(flr_seg, _space))\n\n            # -- Geometry as Mesh\n            brp = from_face3d(flr_seg.geometry)\n            msh = _IGH.ghpythonlib_components.MeshColours(brp, rh_attr.ObjectColor)\n            flr_seg_geom_.append(msh)\n            flr_sef_attrs_.append(rh_attr)\n\n            # -- Boundary Edges\n            msh_edges = _IGH.ghpythonlib_components.MeshEdges(msh).naked_edges\n            msh_boundary = _IGH.ghpythonlib_components.JoinCurves(\n                msh_edges, preserve=False\n            )\n\n            # -- Sometimes Join Curves returns a list of items....\n            if isinstance(msh_boundary, list):\n                for crv in msh_boundary:\n                    flr_seg_geom_.append(crv)\n                    flr_sef_attrs_.append(crv_attr)\n            else:\n                flr_seg_geom_.append(msh_boundary)\n                flr_sef_attrs_.append(crv_attr)\n\n    return flr_seg_geom_, flr_sef_attrs_\n\n\ndef _get_clipping_plane_locations(_IGH, _room_group, _offset_up=0.25, _offset_down=0.25):\n    # type: (gh_io.IGH, List[room.Room], float, float) -> Tuple[ClippingPlaneLocation, ClippingPlaneLocation]\n    \"\"\"Return a pair of ClippingPlaneLocation objects. One pointing 'up' and the other 'down'.\n\n    These are used to clip the scene local to the floor-plan being printed.\n    \"\"\"\n\n    # -- Get the offset distance in the Rhino-document units\n\n    doc_units = _IGH.get_rhino_unit_system_name()\n    offset_up_in_doc_units = convert(_offset_up, \"M\", doc_units)\n    offset_down_in_doc_units = convert(_offset_down, \"M\", doc_units)\n\n    # -- Find the Min Z-location of the Floor-Faces of the Room-Group\n    # -- use both the space floor-segments and the Honeybee 'Floor' surfaces\n    space_floor_segments = [\n        face\n        for rm in _room_group\n        for sp in getattr(rm.properties, \"ph\").spaces\n        for faces in sp.floor_segment_surfaces\n        for face in faces\n    ]\n    hb_room_floor_srfcs = [\n        face\n        for rm in _room_group\n        for face in rm.faces\n        if (isinstance(face.type, facetype.Floor))\n    ]\n    flr_faces = space_floor_segments + hb_room_floor_srfcs\n    flr_level_min_z = min(hb_face.min.z for hb_face in flr_faces)\n    flr_level_max_z = max(hb_face.max.z for hb_face in flr_faces)\n\n    # --Create the clipping plane location objects up/down from that level.\n    upper_clipping_plane = ClippingPlaneLocation(\n        rg.Point3d(0, 0, flr_level_max_z + offset_up_in_doc_units),\n        rg.Vector3d(0, 0, -1),\n    )\n    lower_clipping_plane = ClippingPlaneLocation(\n        rg.Point3d(0, 0, flr_level_min_z - offset_down_in_doc_units),\n        rg.Vector3d(0, 0, 1),\n    )\n\n    return upper_clipping_plane, lower_clipping_plane\n\n\ndef _find_space_annotation_location(_IGH, _space):\n    # type: (gh_io.IGH, space.Space) -> Point3d\n    \"\"\"Returns a single geometric center point of a Space's Volumes.\"\"\"\n    return _IGH.ghpythonlib_components.Average(\n        [from_point3d(p) for p in _space.reference_points]\n    )\n\n\ndef _get_all_space_floor_segment_center_points(_IGH, space):\n    # type: (gh_io.IGH, space.Space) -> List[Point3d]\n    \"\"\"Return a list of all the SpaceFloorSegment center-points in the Space's Volumes.\"\"\"\n\n    return [\n        from_point3d(flr_seg.geometry.center)\n        for volume in space.volumes\n        for flr_seg in volume.floor.floor_segments\n    ]\n\n\ndef _build_annotation_leader_line(_IGH, _pt1, _pt2):\n    # type: (gh_io.IGH, Point3d, Point3d) -> Tuple[Line, ObjectAttributes]\n    \"\"\"Return a new LeaderLine and ObjectAttributes\"\"\"\n\n    rh_geom = rg.Line(_pt1, _pt2)\n    rh_attr = _build_rh_attrs(_IGH, Color.FromArgb(255, 0, 0, 0), 0.05)\n\n    return rh_geom, rh_attr\n\n\ndef _build_annotation_leader_marker(_IGH, _cp, _radius=0.0075):\n    # type: (gh_io.IGH, Point3d, float) -> Tuple\n    \"\"\"Return a new 'dot' mesh and ObjectAttributes\"\"\"\n\n    rh_attr = _build_rh_attrs(_IGH, Color.FromArgb(255, 0, 0, 0), 0.5, 1)\n\n    c = _IGH.ghpythonlib_components.Circle(_cp, _radius)\n    brp = _IGH.ghpythonlib_components.BoundarySurfaces(c)\n    rh_geom = _IGH.ghpythonlib_components.MeshColours(brp, rh_attr.ObjectColor)\n\n    return rh_geom, rh_attr\n\n\n# -----------------------------------------------------------------------------\n\n\nclass GHCompo_CreateFloorSegmentPDFGeometry(object):\n    def __init__(\n        self, _IGH, _hb_model, _drawing_type, _units_, _flr_anno_txt_size, *args, **kwargs\n    ):\n        # type: (gh_io.IGH, model.Model, str, str, float, *Any, **Any) -> None\n        self.IGH = _IGH\n        self.hb_model = _hb_model\n        self.units = _units_ or \"SI\"\n        self.flr_anno_txt_size = _flr_anno_txt_size or 1.0\n\n        drawing_type = input_to_int(_drawing_type, 1)\n        if drawing_type == 1:  # TFA-Plans\n            self.colors = color_by_TFA\n            self.text = text_by_TFA\n        elif drawing_type == 2:  # Ventilation Plans\n            self.colors = color_by_Vent\n            self.text = text_by_Vent\n        else:\n            self.IGH.error(\"Error: Plan type: {} is not supported?\".format(_drawing_type))\n\n    @property\n    def mask(self):\n        # type: () -> TextAnnotationMaskAttributes\n\n        return TextAnnotationMaskAttributes(\n            _show_mask=True,\n            _mask_color=Color.FromArgb(0, 0, 0, 0),\n            _mask_offset=self.flr_anno_txt_size * 2,\n            _frame_type=1,\n            _show_frame=True,\n        )\n\n    def run(self):\n        # type: () -> Tuple\n\n        # -- Output Trees\n        floor_names_ = self.IGH.DataTree(str)\n        clipping_plane_locations_ = self.IGH.DataTree()\n        floor_geom_ = self.IGH.DataTree()\n        floor_attributes_ = self.IGH.DataTree(ObjectAttributes)\n        floor_annotations_ = self.IGH.DataTree(TextAnnotation)\n        pth = self.IGH.GH_Path\n\n        if not self.hb_model:\n            return (\n                floor_names_,\n                clipping_plane_locations_,\n                floor_geom_,\n                floor_attributes_,\n                floor_annotations_,\n            )\n\n        # -- Find the floor levels\n        rooms_grouped_by_story = _group_hb_rooms_by_story(self.hb_model)\n\n        # -- Build the TextAnnotation objects\n        for i, item in enumerate(rooms_grouped_by_story.items()):\n            level_name, hb_rm_group = item\n            floor_names_.Add(level_name, pth(i))\n            clipping_plane_locations_.AddRange(\n                _get_clipping_plane_locations(self.IGH, hb_rm_group), pth(i)\n            )\n\n            # -- Create space floor Geometry and Annotation\n            spaces = _get_hbph_spaces(hb_rm_group)\n            for space in spaces:\n                #  -- Add the Floor segment geometry\n                flr_seg_geom, flr_seg_attrs = _get_flr_seg_data(\n                    self.IGH, self.colors, space\n                )\n                floor_geom_.AddRange(flr_seg_geom, pth(i))\n                floor_attributes_.AddRange(flr_seg_attrs, pth(i))\n\n                # -- Add Leader Lines from Annotation to each FloorSegment CenterPoint\n                anno_cp = _find_space_annotation_location(self.IGH, space)\n                flr_seg_cps = _get_all_space_floor_segment_center_points(self.IGH, space)\n                for flr_cp in flr_seg_cps:\n                    # -- add the leader line itself\n                    ldr, ldr_attr = _build_annotation_leader_line(\n                        self.IGH, anno_cp, flr_cp\n                    )\n                    floor_geom_.Add(ldr, pth(i))\n                    floor_attributes_.Add(ldr_attr, pth(i))\n\n                    # -- add a dot marker at the leader line end point\n                    marker_geom, marker_attrs = _build_annotation_leader_marker(\n                        self.IGH, flr_cp, 0.05\n                    )\n                    floor_geom_.Add(marker_geom, pth(i))\n                    floor_attributes_.Add(marker_attrs, pth(i))\n\n                # -- Add the text Annotation object\n                txt_annotation = TextAnnotation(\n                    self.IGH,\n                    _text=self.text(space, self.IGH, self.units),\n                    _size=self.flr_anno_txt_size,\n                    _location=anno_cp,\n                    _format=\"{}\",\n                    _justification=4,\n                    _mask=self.mask,\n                    _align_to_layout_view=True,\n                )\n                floor_annotations_.Add(txt_annotation, pth(i))\n\n        return (\n            floor_names_,\n            clipping_plane_locations_,\n            floor_geom_,\n            floor_attributes_,\n            floor_annotations_,\n        )\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}