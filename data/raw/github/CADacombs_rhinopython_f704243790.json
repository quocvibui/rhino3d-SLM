{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Knots_markPerContinuity.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Knots_markPerContinuity.py",
  "instruction": "Spb knots mark per continuity",
  "code": "\"\"\"\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n170902: Created.\r\n...\r\n210730: Now, printing of all knot values only happens in Debug mode.\r\n211002: Refactored main routines.  Bug fix.  Now, count of points added is printed.\r\n211126: Now, interior knot intersection of surfaces are included, not just along the edges.\r\n211226: Added dot output.  Now adds curves along surface isocurves at target knot.\r\n        Integers of min. and max. continuities to mark replaced bool input.\r\n        Removed an option for surface input.\r\n211127: Added preview.  Minor bug fixes.\r\n211229: Bug fixes in getInput.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System.Drawing import Color\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'iGCont_max'; keys.append(key)\r\n    values[key] = 1\r\n    names[key] = 'MaxGContToMark'\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key], lowerLimit=0, upperLimit=10)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDot'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iDotHt'; keys.append(key)\r\n    values[key] = 12\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key], setLowerLimit=True, limit=3)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAddObjs'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        if not idxOpt: print(\"Add option for {} failed.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fTolerance':\r\n            if cls.riOpts[key].CurrentValue <= 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < Rhino.RhinoMath.ZeroTolerance:\r\n                cls.riOpts[key].CurrentValue = Rhino.RhinoMath.ZeroTolerance\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput(gas):\r\n    \"\"\"\r\n    Get Curves or BrepFaces with optional input.\r\n    \"\"\"\r\n    \r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select curve or faces\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Curve | rd.ObjectType.Surface\r\n    \r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Do not clear objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False) # Do not unselect object when an option selected, a number is entered, etc.\r\n    \r\n    bPreselectedObjsChecked = False\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    go.AcceptNothing(True)\r\n\r\n    idxs_Opt = {}\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        addOption('iGCont_max')\r\n        addOption('bDot')\r\n        if Opts.values['bDot']:\r\n            addOption('iDotHt')\r\n        addOption('bAddObjs')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        if Opts.values['bAddObjs']:\r\n            go.SetCommandPromptDefault(\"Add objs\")\r\n        else:\r\n            go.SetCommandPromptDefault(\"Cancel\")\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        # Use bPreselectedObjsChecked so that only objects before the\r\n        # first call to go.GetMultiple is considered.\r\n        #        if not bPreselectedObjsChecked and go.ObjectsWerePreselected:\r\n        #            bPreselectedObjsChecked = True\r\n        #            go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n        #            continue\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Nothing:\r\n            go.Dispose()\r\n            return False\r\n\r\n        if res == ri.GetResult.Object:\r\n            geoms_In = []\r\n            for objref in go.Objects():\r\n                geom = objref.Curve()\r\n                if geom is None:\r\n                    geom = objref.Surface()\r\n                if geom: geoms_In.append(geom)\r\n            go.Dispose()\r\n            return geoms_In\r\n\r\n        if res == ri.GetResult.Number:\r\n            iNum = abs(int(go.Number()))\r\n            if iNum > 10:\r\n                print(\"Numeric input is invalid.  \"\r\n                        \"Geometric continuity checking is between 0 and 10.\")\r\n                continue\r\n            Opts.riOpts['iGCont_max'].CurrentValue = iNum\r\n            Opts.setValue('iGCont_max')\r\n            if gas:\r\n                return True\r\n            continue\r\n\r\n        # An option was selected.\r\n        idx = go.Option().Index\r\n        if idx in idxs_Opt.values():\r\n            key = idxs_Opt.keys()[idxs_Opt.values().index(idx)]\r\n            Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n            if key in ('iDotHt', 'bAddObjs', 'bEcho', 'bDebug'): continue\r\n            if gas: return True\r\n\r\n\r\ndef addPointsAtNurbsCrvKnots(nc, iGCont_max=1, bDot=False, iDotHt=11, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    if nc.SpanCount == 1:\r\n        nc.Dispose()\r\n        return\r\n\r\n    iK = 0 if nc.IsClosed else nc.Degree\r\n\r\n    gas = [] # Each is tuple(rg, attr)\r\n\r\n    while iK < (nc.Knots.Count - nc.Degree):\r\n        sc.escape_test()\r\n\r\n        tK = nc.Knots[iK]\r\n        mK = nc.Knots.KnotMultiplicity(iK)\r\n\r\n        if iGCont_max < (nc.Degree - mK):\r\n            iK += mK\r\n            continue\r\n\r\n        if bDebug: print(tK)\r\n\r\n        pt = nc.PointAt(tK)\r\n\r\n        if bDot:\r\n            dot = rg.TextDot(\"G{}\\nknot\".format(nc.Degree-mK), pt)\r\n            dot.FontHeight = iDotHt\r\n            gas.append((dot, None))\r\n            #sc.doc.Objects.AddTextDot(dot)\r\n        else:\r\n            gas.append((pt, None))\r\n            #sc.doc.Objects.AddPoint(pt)\r\n\r\n        iK += mK\r\n\r\n    return gas\r\n\r\n\r\ndef addPointsAtNurbsSrfKnots(ns, iGCont_max=1, bDot=False, iDotHt=12, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    def epsEquals(a, b, epsilon=2**(-52)):\r\n        return abs(a-b) <= epsilon\r\n\r\n\r\n    attr_Red = rd.ObjectAttributes()\r\n    attr_Red.LayerIndex = sc.doc.ActiveDoc.Layers.CurrentLayerIndex\r\n    attr_Red.ColorSource = rd.ObjectColorSource.ColorFromObject\r\n    attr_Red.ObjectColor = Color.Red\r\n\r\n    attr_Green = attr_Red.Duplicate()\r\n    attr_Green.ObjectColor = Color.Lime\r\n\r\n\r\n    gas = [] # Each is tuple(rg, attr)\r\n\r\n    tKs = [], []\r\n    mKs = [], []\r\n\r\n    # Accumulate data by traversing the knots once along U then once along V,\r\n    # not through all intersections since that would be redundant.\r\n    for iDir in 0,1:\r\n\r\n        if iDir == 0:\r\n            knots = ns.KnotsU\r\n            degree = ns.Degree(0)\r\n            domain = ns.Domain(0)\r\n            pointAt = lambda a, b: ns.PointAt(a, b)\r\n        else:\r\n            knots = ns.KnotsV\r\n            degree = ns.Degree(1)\r\n            domain = ns.Domain(1)\r\n            pointAt = lambda b, a: ns.PointAt(a, b)\r\n\r\n        iK = 0 if ns.IsClosed(iDir) else degree\r\n\r\n        while iK < (knots.Count - degree):\r\n            sc.escape_test()\r\n\r\n            tK = knots[iK]\r\n\r\n            if tK < ns.Domain(iDir).T0:\r\n                print(\"Skipped {}\".format(tK))\r\n                iK += 1\r\n                continue\r\n\r\n            if ns.IsClosed(iDir) and epsEquals(tK, ns.Domain(iDir).T1):\r\n                break\r\n\r\n            if tK > ns.Domain(iDir).T1:\r\n                print(\"Skipped {}\".format(tK))\r\n                break\r\n\r\n            mK = knots.KnotMultiplicity(iK)\r\n\r\n            if iGCont_max < (degree - mK):\r\n                iK += 1\r\n                continue\r\n\r\n            tKs[iDir].append(tK)\r\n            mKs[iDir].append(mK)\r\n\r\n            if bDot:\r\n                if iDir == 0:\r\n                    pt = ns.PointAt(tK, ns.Domain(1).T0)\r\n                else:\r\n                    pt = ns.PointAt(ns.Domain(0).T0, tK)\r\n\r\n                dot = rg.TextDot(\"G{}\\nknot\".format(degree-mK), pt)\r\n                dot.FontHeight = iDotHt\r\n                gas.append((dot, attr_Red if iDir == 1 else attr_Green))\r\n                #gOut = sc.doc.Objects.AddTextDot(\r\n                #    dot,\r\n                #    attributes=attr_Red if iDir == 1 else attr_Green)\r\n                #if gOut != gOut.Empty: gPts_Out.append(gOut)\r\n\r\n            if iDir == 1:\r\n                gas.append((ns.IsoCurve(0, tK), attr_Red))\r\n                #gOut = sc.doc.Objects.AddCurve(ns.IsoCurve(0, tK), attributes=attr_Red)\r\n            else:\r\n                gas.append((ns.IsoCurve(1, tK), attr_Green))\r\n                #gOut = sc.doc.Objects.AddCurve(ns.IsoCurve(1, tK), attributes=attr_Green)\r\n            #if gOut != gOut.Empty: gPts_Out.append(gOut)\r\n\r\n\r\n            iK += mK\r\n\r\n\r\n    #def isCornerPoint(ns, tU, tV):\r\n    #    return (\r\n    #        (epsEquals(tU, ns.Domain(0).T0) or epsEquals(tU, ns.Domain(0).T1)) and\r\n    #        (epsEquals(tV, ns.Domain(1).T0) or epsEquals(tV, ns.Domain(1).T1)) )\r\n\r\n\r\n    # Traverse all the knot isocurve intersections per accumulated data.\r\n    #for iU, (tU, mU) in enumerate(zip(tKs[0], mKs[0])):\r\n    #    for iV, (tV, mV) in enumerate(zip(tKs[1], mKs[0])):\r\n\r\n    #        if isCornerPoint(ns, tU, tV): continue\r\n\r\n    #        pt = ns.PointAt(tU, tV)\r\n\r\n    #        gOut = sc.doc.Objects.AddPoint(pt)\r\n\r\n    #        if gOut != gOut.Empty: gPts_Out.append(gOut)\r\n\r\n    return gas\r\n\r\n\r\ndef createGeoms(geoms_In, iGCont_max=1, bDot=False, iDotHt=12, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    outs = []\r\n\r\n    for rgObj in geoms_In:\r\n\r\n        if isinstance(rgObj, rg.Curve):\r\n            rgNurbsCrv = rgObj.Duplicate() if isinstance(rgObj, rg.NurbsCurve) else rgObj.ToNurbsCurve()\r\n            \r\n            rc = addPointsAtNurbsCrvKnots(\r\n                rgNurbsCrv,\r\n                iGCont_max=iGCont_max,\r\n                bDot=bDot,\r\n                iDotHt=iDotHt,\r\n                bEcho=bEcho,\r\n                bDebug=bDebug)\r\n\r\n            rgNurbsCrv.Dispose()\r\n\r\n            if rc: outs.extend(rc)\r\n\r\n        elif isinstance(rgObj, rg.Surface):\r\n            rgNurbsSrf = rgObj if isinstance(rgObj, rg.NurbsSurface) else rgObj.ToNurbsSurface()\r\n\r\n            rc = addPointsAtNurbsSrfKnots(\r\n                rgNurbsSrf,\r\n                iGCont_max=iGCont_max,\r\n                bDot=bDot,\r\n                iDotHt=iDotHt,\r\n                bEcho=bEcho,\r\n                bDebug=bDebug)\r\n\r\n            rgNurbsSrf.Dispose()\r\n\r\n            if rc: outs.extend(rc)\r\n\r\n    return outs\r\n\r\n\r\nclass DrawConduit(Rhino.Display.DisplayConduit):\r\n\r\n    def __init__(self):\r\n        self.gas = None\r\n        displayMode = Rhino.RhinoDoc.ActiveDoc.Views.ActiveView.ActiveViewport.DisplayMode\r\n        self.crv_thk = displayMode.DisplayAttributes.CurveThickness + 1\r\n\r\n    def CalculateBoundingBox(self, calculateBoundingBoxEventArgs):\r\n        if not self.gas: return\r\n\r\n        for ga in self.gas:\r\n            geom, attr = ga\r\n            self.bbox = geom.GetBoundingBox(accurate=False)\r\n            calculateBoundingBoxEventArgs.IncludeBoundingBox(self.bbox)\r\n\r\n    def PreDrawObjects(self, drawEventArgs):\r\n        if not self.gas: return\r\n\r\n        for ga in self.gas:\r\n            geom, attr = ga\r\n\r\n            if attr is None:\r\n                objColor = sc.doc.Layers.CurrentLayer.Color\r\n            else:\r\n                objColor = attr.ObjectColor\r\n\r\n            if isinstance(geom, rg.TextDot):\r\n                dot = geom\r\n                textColor = Color.Black if objColor != Color.Black else Color.White\r\n                drawEventArgs.Display.DrawDot(\r\n                    worldPosition=dot.Point,\r\n                    text=dot.Text,\r\n                    dotColor=objColor,\r\n                    textColor=textColor)\r\n            elif isinstance(geom, rg.Curve):\r\n                crv = geom\r\n                drawEventArgs.Display.DrawCurve(\r\n                    curve=crv,\r\n                    color=objColor,\r\n                    thickness=self.crv_thk)\r\n            elif isinstance(geom, rg.Point3d):\r\n                pt = geom\r\n                drawEventArgs.Display.DrawPoint(\r\n                    point=pt)\r\n\r\n\r\ndef main():\r\n\r\n    sk_conduit = 'conduit({})'.format(__file__)\r\n    if (sk_conduit in sc.sticky) and sc.sticky[sk_conduit]:\r\n        conduit = sc.sticky[sk_conduit]\r\n    else:\r\n        conduit = DrawConduit()\r\n        sc.sticky[sk_conduit] = conduit\r\n\r\n    conduit.Enabled = False\r\n    sc.doc.Views.Redraw()\r\n\r\n\r\n    gas = None # list(tuple(rg, attr))\r\n\r\n\r\n    while True:\r\n        rc = getInput(gas)\r\n        if rc is None:\r\n            conduit.Enabled = False\r\n            return\r\n\r\n        iGCont_max = Opts.values['iGCont_max']\r\n        bDot = Opts.values['bDot']\r\n        iDotHt = Opts.values['iDotHt']\r\n        bAddObjs = Opts.values['bAddObjs']\r\n        bEcho = Opts.values['bEcho']\r\n        bDebug = Opts.values['bDebug']\r\n\r\n        if not rc:\r\n            conduit.Enabled = False\r\n            break\r\n\r\n\r\n        try:\r\n            iter(rc)\r\n            geoms_In = rc\r\n        except:\r\n            pass\r\n\r\n        rc = createGeoms(\r\n            geoms_In=geoms_In,\r\n            iGCont_max=iGCont_max,\r\n            bDot=bDot,\r\n            iDotHt=iDotHt,\r\n            bEcho=bEcho,\r\n            bDebug=bDebug)\r\n        if rc is None:\r\n            conduit.Enabled = False\r\n            conduit = None\r\n            return\r\n\r\n        gas = rc\r\n\r\n        sc.doc.Objects.UnselectAll()\r\n\r\n        conduit.gas = gas\r\n        conduit.Enabled = True\r\n        sc.doc.Views.Redraw()\r\n\r\n\r\n    if bAddObjs:\r\n        gOuts = []\r\n        for geom, attr in gas:\r\n            if isinstance(geom, rg.Point3d):\r\n                gOut = sc.doc.Objects.AddPoint(geom)\r\n            else:\r\n                gOut = sc.doc.Objects.Add(geom, attr)\r\n            if gOut != gOut.Empty:\r\n                gOuts.append(gOut)\r\n        if bEcho:\r\n            print(\"{} objects added.\".format(len(gOuts)))\r\n\r\n        sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": false
}