{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_NurbsSrf_EdgeSrf.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_NurbsSrf_EdgeSrf.py",
  "instruction": "As an alternative to _EdgeSrf, this script:\r\n    1. Offers face-face continuity above G0 (as allowed by the input),\r\n        similar to using (a more restricted) _MatchSrf _MultipleMatches after an...",
  "code": "\"\"\"\r\nAs an alternative to _EdgeSrf, this script:\r\n    1. Offers face-face continuity above G0 (as allowed by the input),\r\n        similar to using (a more restricted) _MatchSrf _MultipleMatches after an _EdgeSrf.\r\n    2. Can create a surface from 3 input curves that form an open loop by calculating the missing (4th) curve.\r\n    3. Can create a surface from 2 input curves, like _ExtrudeCrvAlongCrv or _BlendEdge (_Loft with exactly 2 input curves/edges)\r\n\r\nDue to the accuracy of this script, the output surface may have more knot\r\nvectors than the result of _EdgeSrf (with the same input geometries).\r\n\r\nSend any questions, comments, or script development service needs to\r\n@spb on the McNeel Forums: https://discourse.mcneel.com/\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n#! python 2\r\n\r\n\"\"\"\r\n211013-25: Created.\r\n211102: Continuity can now be set per input curve.\r\n        Added options for single-click selection of continuity.\r\n211103: Bug fix when entering a number to modify continuity in getInput_Global.\r\n        Now, G2 is allowed for None IsoStatus from planar surfaces only.\r\n211105: Bug fix when adding missing multiplicity of knots at existing locations.\r\n        Bug fix in reducing continuity target from G2 when a tangency surface is used.\r\n230701, 1030: Modified some debugging code.  Import-related updates.\r\n231031-1101: Improved G1 point placement when either\r\n            1. Only 1 of the 2 reference surfaces at corner is planar.\r\n            2. Ends of both reference surfaces at corner are linear and intersect into created surface.\r\n231226: Bug fix in splitting of curve input that extend through adjacent input.\r\n240912: Big fix to allow G2 continuity for when the input are 2 adjacent edges (SumSurface).\r\n\r\nTODO:\r\n    Convert (some) rational input to non-rational degree 5?\r\n    Report to McNeel false positives of NurbsSurfaceKnotList.InsertKnot when value is > 2e-52 and < 2e-32.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nimport spb_NurbsSrf_MatchSrf_1Edge as spb\r\n\r\n\r\nW = rg.IsoStatus.West\r\nS = rg.IsoStatus.South\r\nE = rg.IsoStatus.East\r\nN = rg.IsoStatus.North\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bSetMaxContPerCrv'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'ApplyContTo'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'AllCrvs', 'NextCrv')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iContinuity'; keys.append(key)\r\n    values[key] = 1\r\n    #names[key] = 'CurrentCont'\r\n    listValues[key] = 'G0', 'G1', 'G2'\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        if not idxOpt: print(\"Add option for {} failed.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        #if key == 'fPatchTol':\r\n        #    if cls.riOpts[key].CurrentValue <= 1e-9:\r\n        #        print(\"Invalid input for scale value.\")\r\n        #        cls.riOpts[key].CurrentValue = cls.values[key]\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get edges or (wire) curves with optional input.\r\n    \"\"\"\r\n\r\n\r\n    def getInput_Global():\r\n        \"\"\"\r\n        Get edges or (wire) curves with optional input.\r\n        \"\"\"\r\n\r\n        go = ri.Custom.GetObject()\r\n\r\n        go.GeometryFilter = rd.ObjectType.Curve\r\n        go.GeometryAttributeFilter = go.GeometryAttributeFilter.OpenCurve\r\n\r\n        go.EnableUnselectObjectsOnExit(False) # Do not unselect object when an option selected, a number is entered, etc.\r\n\r\n        go.AcceptNumber(True, acceptZero=True)\r\n\r\n        idxs_Opt = {}\r\n\r\n        while True:\r\n            go.ClearCommandOptions()\r\n\r\n            idxs_Opt.clear()\r\n\r\n            def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n            key = 'G0'; idxs_Opt[key] = go.AddOption(key)\r\n            key = 'G1'; idxs_Opt[key] = go.AddOption(key)\r\n            key = 'G2'; idxs_Opt[key] = go.AddOption(key)\r\n            addOption('bSetMaxContPerCrv')\r\n            #Opts.names['iContinuity'] = 'CurrentCont'\r\n            #addOption('iContinuity')\r\n            addOption('bEcho')\r\n            addOption('bDebug')\r\n\r\n            #sc.doc.Views.Redraw()\r\n\r\n\r\n            sCmdPrompt = \"Select 2, 3, or 4 open curves\"\r\n            sCmdPrompt += \" (G{})\".format(Opts.values['iContinuity'])\r\n            go.SetCommandPrompt(sCmdPrompt)\r\n\r\n\r\n            res = go.GetMultiple(minimumNumber=2, maximumNumber=4)\r\n\r\n            if res == ri.GetResult.Cancel:\r\n                go.Dispose()\r\n                return\r\n\r\n            if res == ri.GetResult.Object:\r\n                objrefs = go.Objects()\r\n                go.Dispose()\r\n                return (\r\n                    objrefs,\r\n                    Opts.values['bSetMaxContPerCrv'],\r\n                    Opts.values['iContinuity'],\r\n                    Opts.values['bEcho'],\r\n                    Opts.values['bDebug'],\r\n                    )\r\n\r\n            # An option was selected.\r\n            go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n            go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n            go.EnableClearObjectsOnEntry(False) # Do not clear objects in go on repeats of While loop.\r\n\r\n            if res == ri.GetResult.Number:\r\n                if int(go.Number()) not in (0,1,2): continue\r\n                Opts.setValue('iContinuity', idxList=int(go.Number()))\r\n                continue\r\n\r\n            if go.Option().Index == idxs_Opt['G0']:\r\n                Opts.setValue('iContinuity', idxList=0)\r\n            elif go.Option().Index == idxs_Opt['G1']:\r\n                Opts.setValue('iContinuity', idxList=1)\r\n            elif go.Option().Index == idxs_Opt['G2']:\r\n                Opts.setValue('iContinuity', idxList=2)\r\n\r\n            for key in idxs_Opt:\r\n                if go.Option().Index == idxs_Opt[key]:\r\n                    Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                    break\r\n\r\n            if go.Option().Index == idxs_Opt['bSetMaxContPerCrv']:\r\n                go.Dispose()\r\n                return (\r\n                    None,\r\n                    Opts.values['bSetMaxContPerCrv'],\r\n                    Opts.values['iContinuity'],\r\n                    Opts.values['bEcho'],\r\n                    Opts.values['bDebug'],\r\n                    )\r\n\r\n\r\n    def getInput_PerCrv(objrefs_AlreadySel):\r\n        \"\"\"\r\n        Get edges or (wire) curves with optional input.\r\n        \"\"\"\r\n\r\n        go = ri.Custom.GetObject()\r\n\r\n        gObjs_AlreadySel = []\r\n        idxEs_AlreadySel = []\r\n        for o in objrefs_AlreadySel:\r\n            gObjs_AlreadySel.append(o.ObjectId)\r\n            if o.Edge() is None:\r\n                idxEs_AlreadySel.append(None)\r\n                o.Object().Highlight(True)\r\n            else:\r\n                idxEs_AlreadySel.append(o.Edge().EdgeIndex)\r\n                o.Object().HighlightSubObject(o.GeometryComponentIndex, highlight=True)\r\n\r\n\r\n        if gObjs_AlreadySel:\r\n            sc.doc.Views.Redraw()\r\n\r\n        go.GeometryFilter = rd.ObjectType.Curve\r\n\r\n\r\n        def customGeometryFilter(rdObj, geom, compIdx):\r\n            #print(rdObj, geom, compIdx.ComponentIndexType, compIdx.Index)\r\n\r\n            if not isinstance(geom, rg.Curve):\r\n                return False\r\n\r\n            if geom.IsClosed:\r\n                return False\r\n\r\n            if compIdx.ComponentIndexType == rg.ComponentIndexType.BrepEdge:\r\n                if rdObj.Id in gObjs_AlreadySel:\r\n                    for g, iE in zip(gObjs_AlreadySel, idxEs_AlreadySel):\r\n                        if rdObj.Id and compIdx.Index == iE:\r\n                            return False\r\n\r\n                return True\r\n\r\n            else:\r\n                if rdObj.Id not in gObjs_AlreadySel:\r\n                    return True\r\n\r\n            return False\r\n\r\n        go.SetCustomGeometryFilter(customGeometryFilter)\r\n\r\n        go.EnableUnselectObjectsOnExit(False) # Do not unselect object when an option selected, a number is entered, etc.\r\n\r\n        go.AcceptNothing(True)\r\n\r\n        go.AcceptNumber(True, acceptZero=True)\r\n\r\n        idxs_Opt = {}\r\n\r\n        while True:\r\n            go.ClearCommandOptions()\r\n\r\n            idxs_Opt.clear()\r\n\r\n            def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n            #addOption('iContinuity')\r\n            key = 'G0'; idxs_Opt[key] = go.AddOption(key)\r\n            key = 'G1'; idxs_Opt[key] = go.AddOption(key)\r\n            key = 'G2'; idxs_Opt[key] = go.AddOption(key)\r\n            Opts.names['iContinuity'] = 'NextCrvCont'\r\n            addOption('bSetMaxContPerCrv')\r\n            addOption('bEcho')\r\n            addOption('bDebug')\r\n\r\n            if len(objrefs_AlreadySel) == 0:\r\n                sCmdPrompt = \"Select first open curve\"\r\n            else:\r\n                sCmdPrompt = \"Select next open curve\"\r\n            sCmdPrompt += \" (G{})\".format(Opts.values['iContinuity'])\r\n\r\n            go.SetCommandPrompt(sCmdPrompt)\r\n\r\n            res = go.Get()\r\n\r\n            if res == ri.GetResult.Cancel:\r\n                go.Dispose()\r\n                return\r\n\r\n            if res == ri.GetResult.Nothing:\r\n                go.Dispose()\r\n                return (\r\n                    None,\r\n                    Opts.values['bSetMaxContPerCrv'],\r\n                    None,\r\n                    Opts.values['bEcho'],\r\n                    Opts.values['bDebug'],\r\n                    )\r\n\r\n\r\n            if res == ri.GetResult.Object:\r\n                objref = go.Object(0)\r\n                sc.doc.Objects.UnselectAll()\r\n                go.Dispose()\r\n                return (\r\n                    objref,\r\n                    Opts.values['bSetMaxContPerCrv'],\r\n                    Opts.values['iContinuity'],\r\n                    Opts.values['bEcho'],\r\n                    Opts.values['bDebug'],\r\n                    )\r\n\r\n            if res == ri.GetResult.Number:\r\n                if int(go.Number()) not in (0,1,2): continue\r\n                Opts.setValue('iContinuity', idxList=int(go.Number()))\r\n                continue\r\n\r\n            # An option was selected.\r\n            go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n            go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n            go.EnableClearObjectsOnEntry(False) # Do not clear objects in go on repeats of While loop.\r\n\r\n            if go.Option().Index == idxs_Opt['G0']:\r\n                Opts.setValue('iContinuity', idxList=0)\r\n            elif go.Option().Index == idxs_Opt['G1']:\r\n                Opts.setValue('iContinuity', idxList=1)\r\n            elif go.Option().Index == idxs_Opt['G2']:\r\n                Opts.setValue('iContinuity', idxList=2)\r\n\r\n            for key in idxs_Opt:\r\n                if go.Option().Index == idxs_Opt[key]:\r\n                    Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                    break\r\n\r\n            if go.Option().Index == idxs_Opt['bSetMaxContPerCrv']:\r\n                go.Dispose()\r\n                return (\r\n                    None,\r\n                    Opts.values['bSetMaxContPerCrv'],\r\n                    Opts.values['iContinuity'],\r\n                    Opts.values['bEcho'],\r\n                    Opts.values['bDebug'],\r\n                    )\r\n\r\n\r\n    while True:\r\n        if Opts.values['bSetMaxContPerCrv']:\r\n            objrefs = []\r\n            conts = []\r\n            while True:\r\n                rc = getInput_PerCrv(objrefs)\r\n\r\n\r\n                for o in objrefs:\r\n                    if o.Edge() is None:\r\n                        o.Object().Highlight(False)\r\n                    else:\r\n                        o.Object().HighlightSubObject(\r\n                            o.GeometryComponentIndex, highlight=False)\r\n\r\n\r\n                if rc is None: return\r\n                if isinstance(rc, tuple):\r\n                    (\r\n                        objref,\r\n                        bSetMaxContPerCrv,\r\n                        iContinuity,\r\n                        bEcho,\r\n                        bDebug,\r\n                        ) = rc\r\n\r\n                    if not bSetMaxContPerCrv:\r\n                        break # out of while loop.\r\n\r\n                    if objref is None:\r\n                        if len(objrefs) < 2:\r\n                            return\r\n\r\n                        return (\r\n                            objrefs,\r\n                            conts,\r\n                            bEcho,\r\n                            bDebug)\r\n\r\n                    objrefs.append(objref)\r\n                    conts.append(iContinuity)\r\n\r\n                    if len(objrefs) == 4:\r\n                        return (\r\n                            objrefs,\r\n                            conts,\r\n                            bEcho,\r\n                            bDebug)\r\n\r\n        else:\r\n            rc = getInput_Global()\r\n            if rc is None: return\r\n\r\n            (\r\n                objrefs,\r\n                bSetMaxContPerCrv,\r\n                iContinuity,\r\n                bEcho,\r\n                bDebug,\r\n                ) = rc\r\n\r\n            if bSetMaxContPerCrv:\r\n                sc.doc.Objects.UnselectAll()\r\n                continue # in main while loop.\r\n\r\n            return (\r\n                objrefs,\r\n                iContinuity,\r\n                bEcho,\r\n                bDebug,\r\n                )\r\n\r\n\r\ndef getFormattedDistance(fDistance):\r\n    if fDistance is None: return \"(No deviation provided)\"\r\n    if fDistance < 0.001:\r\n        return \"{:.2e}\".format(fDistance)\r\n    else:\r\n        return \"{:.{}f}\".format(fDistance, sc.doc.ModelDistanceDisplayPrecision)\r\n\r\n\r\ndef getR3CurveOfGeom(geom):\r\n    if isinstance(geom, rg.BrepTrim):\r\n        return geom.Edge.DuplicateCurve()\r\n    else:\r\n        return geom\r\n\r\n\r\ndef getIsoCurveOfSide(isoStatus, srf):\r\n\r\n    if isoStatus == W:\r\n        return srf.IsoCurve(direction=1, constantParameter=srf.Domain(0).T0)\r\n    elif isoStatus == S:\r\n        return srf.IsoCurve(direction=0, constantParameter=srf.Domain(1).T0)\r\n    elif isoStatus == E:\r\n        return srf.IsoCurve(direction=1, constantParameter=srf.Domain(0).T1)\r\n    elif isoStatus == N:\r\n        return srf.IsoCurve(direction=0, constantParameter=srf.Domain(1).T1)\r\n    raise ValueError(\r\n        \"Isostatus {} not allowed.  Needs to be West, South, East, or North\".format(\r\n            isoStatus))\r\n\r\n\r\ndef getCurveOfNurbs(geom):\r\n    if geom[1] is None:\r\n        c = geom[0]\r\n        if not isinstance(c, rg.NurbsCurve):\r\n            raise ValueError(\"Not a NurbsCurve.\")\r\n        return c\r\n\r\n    if isinstance(geom[1], rg.Plane):\r\n        if not isinstance(geom[0], rg.NurbsCurve):\r\n            raise ValueError(\"Not a NurbsCurve.\")\r\n        return geom[0]\r\n    else:\r\n        c = getIsoCurveOfSide(*geom)\r\n        if not isinstance(c, rg.NurbsCurve):\r\n            raise ValueError(\"Not a NurbsCurve.\")\r\n        return c\r\n\r\n\r\ndef isPointAtEitherCrvEnd(pt, cA):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    tol = 2.0 * sc.doc.ModelAbsoluteTolerance\r\n    if cA.PointAtStart.DistanceTo(pt) <= tol:\r\n        return True\r\n    if cA.PointAtEnd.DistanceTo(pt) <= tol:\r\n        return True\r\n\r\n    return False\r\n\r\n\r\ndef doCrvsFormAClosedLoop(cs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    found = [[False, False] for i in range(len(cs))]\r\n    tol = 2.0 * sc.doc.ModelAbsoluteTolerance\r\n\r\n    for iA in range(len(cs)-1):\r\n        cA = cs[iA]\r\n        if not found[iA][0]:\r\n            ptA = cA.PointAtStart\r\n            for iB in range(1+iA,len(cs)):\r\n                cB = cs[iB]\r\n                if ptA.DistanceTo(cB.PointAtStart) <= tol:\r\n                    #print(\"Start of [{}] matches start of [{}].\".format(iA, iB))\r\n                    found[iA][0] = True\r\n                    found[iB][0] = True\r\n                    if cA.PointAtEnd.DistanceTo(cB.PointAtEnd) <= tol:\r\n                        raise Exception(\"2 curves completely overlap.\")\r\n                    break\r\n                if ptA.DistanceTo(cB.PointAtEnd) <= tol:\r\n                    #print(\"Start of [{}] matches end of [{}].\".format(iA, iB))\r\n                    found[iA][0] = True\r\n                    found[iB][1] = True\r\n                    if cA.PointAtEnd.DistanceTo(cB.PointAtStart) <= tol:\r\n                        raise Exception(\"2 curves completely overlap.\")\r\n                    break\r\n            else:\r\n                #for c in cs: sc.doc.Objects.AddCurve(c)\r\n                return False\r\n\r\n        if not found[iA][1]:\r\n            ptA = cA.PointAtEnd\r\n            for iB in range(1+iA,len(cs)):\r\n                cB = cs[iB]\r\n                if ptA.DistanceTo(cB.PointAtStart) <= tol:\r\n                    #print(\"End of [{}] matches start of [{}].\".format(iA, iB))\r\n                    found[iA][1] = True\r\n                    found[iB][0] = True\r\n                    if cA.PointAtEnd.DistanceTo(cB.PointAtEnd) <= tol:\r\n                        raise Exception(\"2 curves completely overlap.\")\r\n                    break\r\n                if ptA.DistanceTo(cB.PointAtEnd) <= tol:\r\n                    #print(\"End of [{}] matches end of [{}].\".format(iA, iB))\r\n                    found[iA][1] = True\r\n                    found[iB][1] = True\r\n                    if cA.PointAtEnd.DistanceTo(cB.PointAtStart) <= tol:\r\n                        raise Exception(\"2 curves completely overlap.\")\r\n                    break\r\n            else:\r\n                #for c in cs: sc.doc.Objects.AddCurve(c)\r\n                return False\r\n\r\n    return True\r\n\r\n\r\ndef endsMatchWithOtherEnds(cs, tol=None):\r\n\r\n    if tol is None: tol = 2.0 * sc.doc.ModelAbsoluteTolerance\r\n\r\n    bEndEndMatches = [[False, False] for i in range(len(cs))]\r\n\r\n    for iA in range(len(cs)-1):\r\n        cA = cs[iA]\r\n        if bEndEndMatches[iA][0] and bEndEndMatches[iA][1]: continue\r\n\r\n        if not bEndEndMatches[iA][0]:\r\n            ptA = cA.PointAtStart\r\n            for iB in range(iA+1,len(cs)):\r\n                cB = cs[iB]\r\n                if ptA.DistanceTo(cB.PointAtStart) <= tol:\r\n                    #print(\"Start of [{}] matches start of [{}].\".format(iA, iB))\r\n                    bEndEndMatches[iA][0] = True\r\n                    bEndEndMatches[iB][0] = True\r\n                    if cA.PointAtEnd.DistanceTo(cB.PointAtEnd) <= tol:\r\n                        raise Exception(\"2 curves completely overlap.\")\r\n                    break # out of iB loop.\r\n                if ptA.DistanceTo(cB.PointAtEnd) <= tol:\r\n                    #print(\"Start of [{}] matches end of [{}].\".format(iA, iB))\r\n                    bEndEndMatches[iA][0] = True\r\n                    bEndEndMatches[iB][1] = True\r\n                    if cA.PointAtEnd.DistanceTo(cB.PointAtStart) <= tol:\r\n                        raise Exception(\"2 curves completely overlap.\")\r\n                    break # out of iB loop.\r\n\r\n        if not bEndEndMatches[iA][1]:\r\n            ptA = cA.PointAtEnd\r\n            for iB in range(iA+1,len(cs)):\r\n                cB = cs[iB]\r\n                if ptA.DistanceTo(cB.PointAtStart) <= tol:\r\n                    #print(\"End of [{}] matches start of [{}].\".format(iA, iB))\r\n                    bEndEndMatches[iA][1] = True\r\n                    bEndEndMatches[iB][0] = True\r\n                    if cA.PointAtEnd.DistanceTo(cB.PointAtEnd) <= tol:\r\n                        raise Exception(\"2 curves completely overlap.\")\r\n                    break # out of iB loop.\r\n                if ptA.DistanceTo(cB.PointAtEnd) <= tol:\r\n                    #print(\"End of [{}] matches end of [{}].\".format(iA, iB))\r\n                    bEndEndMatches[iA][1] = True\r\n                    bEndEndMatches[iB][1] = True\r\n                    if cA.PointAtEnd.DistanceTo(cB.PointAtStart) <= tol:\r\n                        raise Exception(\"2 curves completely overlap.\")\r\n                    break # out of iB loop.\r\n\r\n    return bEndEndMatches\r\n\r\n\r\ndef getPtsAtNonEndIntersects(cs, tol=None):\r\n\r\n    if tol is None: tol = 2.0 * sc.doc.ModelAbsoluteTolerance\r\n\r\n    bEndEndMatches = endsMatchWithOtherEnds(cs)\r\n\r\n    pts_Xs = [[] for i in range(len(cs))]\r\n\r\n    for iA in range(len(cs)-1):\r\n        if bEndEndMatches[iA][0] and bEndEndMatches[iA][1]:\r\n            continue\r\n        cA = cs[iA]\r\n        for iB in range(1+iA, len(cs)):\r\n            if bEndEndMatches[iB][0] and bEndEndMatches[iB][1]:\r\n                continue\r\n            cB = cs[iB]\r\n            crvinters = rg.Intersect.Intersection.CurveCurve(\r\n                cA, cB, tolerance=tol, overlapTolerance=0.0)\r\n            if crvinters.Count == 0: continue # to next curve.\r\n            for crvinter in crvinters:\r\n                pt = crvinter.PointA\r\n                if not isPointAtEitherCrvEnd(pt, cA):\r\n                    pts_Xs[iA].append(pt)\r\n                if not isPointAtEitherCrvEnd(pt, cB):\r\n                    pts_Xs[iB].append(pt)\r\n\r\n    return pts_Xs\r\n\r\n\r\ndef getTrimInterval_NurbsSrf(iso, ns, pt_End_ToRemain, pts_Xs):\r\n    \"\"\"\r\n    \"\"\"\r\n    if pt_End_ToRemain is None:\r\n        uvs_DomainEndsToKeep = None\r\n    else:\r\n        b, u, v = ns.ClosestPoint(pt_End_ToRemain)\r\n        if not b:\r\n            raise Exception(\"ClosestPoint failed.\")\r\n\r\n        if (abs(u - ns.Domain(0).T0) <= 1e-6) and (abs(v - ns.Domain(1).T0) <= 1e-6):\r\n            uvs_DomainEndsToKeep = (u,v)\r\n        elif (abs(u - ns.Domain(0).T1) <= 1e-6) and (abs(v - ns.Domain(1).T0) <= 1e-6):\r\n            uvs_DomainEndsToKeep = (u,v)\r\n        elif (abs(u - ns.Domain(0).T1) <= 1e-6) and (abs(v - ns.Domain(1).T1) <= 1e-6):\r\n            uvs_DomainEndsToKeep = (u,v)\r\n        elif (abs(u - ns.Domain(0).T0) <= 1e-6) and (abs(v - ns.Domain(1).T1) <= 1e-6):\r\n            uvs_DomainEndsToKeep = (u,v)\r\n        else:\r\n            uvs_DomainEndsToKeep = None\r\n\r\n    #sEval = \"t_DomainEndToKeep\"; print(sEval+':',eval(sEval))\r\n\r\n    uvs_InsideDomain = []\r\n    for pt in pts_Xs:\r\n        b, u, v = ns.ClosestPoint(pt)\r\n        if not b:\r\n            raise Exception(\"ClosestPoint failed.\")\r\n        uvs_InsideDomain.append((u,v))\r\n\r\n\r\n    if iso in (N, S):\r\n        us = [uv[0] for uv in uvs_InsideDomain]\r\n        if uvs_DomainEndsToKeep is not None:\r\n            us += [uvs_DomainEndsToKeep[0]]\r\n        us.sort()\r\n        return rg.Interval(us[0], us[1]), ns.Domain(1)\r\n    else:\r\n        vs = [uv[1] for uv in uvs_InsideDomain]\r\n        if uvs_DomainEndsToKeep is not None:\r\n            vs += [uvs_DomainEndsToKeep[1]]\r\n        vs.sort()\r\n        return ns.Domain(0), rg.Interval(vs[0], vs[1])\r\n\r\n\r\ndef getTrimInterval_NurbsCrv(nc, pt_End_ToRemain, pts_Xs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    if pt_End_ToRemain:\r\n        b, t = nc.ClosestPoint(pt_End_ToRemain)\r\n        if not b:\r\n            raise Exception(\"ClosestPoint failed.\")\r\n\r\n        if (abs(t - nc.Domain.T0) <= 1e-6):\r\n            t_DomainEndToKeep = t\r\n        elif (abs(t - nc.Domain.T1) <= 1e-6):\r\n            t_DomainEndToKeep = t\r\n\r\n    ts_InsideDomain = []\r\n    for pt in pts_Xs:\r\n        b, t = nc.ClosestPoint(pt)\r\n        if not b:\r\n            raise Exception(\"ClosestPoint failed.\")\r\n        ts_InsideDomain.append(t)\r\n\r\n\r\n    ts = ts_InsideDomain\r\n    if pt_End_ToRemain:\r\n        ts += [t_DomainEndToKeep]\r\n\r\n    ts.sort()\r\n\r\n    return rg.Interval(ts[0], ts[1])\r\n\r\n\r\ndef trimNurbsAtCrvIntersections(ngs_In, tol=None):\r\n    \"\"\"\r\n    At this time, only len(ngs_In) == 4.\r\n    \"\"\"\r\n\r\n    cs = [getCurveOfNurbs(geom) for geom in ngs_In]\r\n    if tol is None: tol = 2.0 * sc.doc.ModelAbsoluteTolerance\r\n\r\n    bEndEndMatches = endsMatchWithOtherEnds(cs, tol)\r\n\r\n    bTrims_NeedIntersect = [not (bEndEndMatches[i][0] and bEndEndMatches[i][1]) for i in range(len(ngs_In))]\r\n\r\n    if not any(bTrims_NeedIntersect):\r\n        raise Exception(\"No trims can be split to create good input for surface.\")\r\n\r\n    if sum(bTrims_NeedIntersect) == 1:\r\n        #print(bTrims_NeedIntersect)\r\n        raise Exception(\"Only 1 trim to split.\")\r\n\r\n    pts_Xs = getPtsAtNonEndIntersects(cs, tol)\r\n\r\n    #print(found)\r\n    #print(pts_Xs)\r\n\r\n    ngs_Out = []\r\n\r\n    for i in range(len(ngs_In)):\r\n        ng_In = ngs_In[i]\r\n        if len(pts_Xs[i]) == 0:\r\n            ngs_Out.append(ng_In)\r\n            continue\r\n\r\n        pt_End_ToRemain = None\r\n        if bEndEndMatches[i][0]:\r\n            pt_End_ToRemain = cs[i].PointAtStart\r\n        if bEndEndMatches[i][1]:\r\n            if pt_End_ToRemain is not None:\r\n                sEval = \"len(pts_Ends)\"\r\n                raise ValueError(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n            pt_End_ToRemain = cs[i].PointAtEnd\r\n\r\n\r\n        if isinstance(ng_In[1], rg.NurbsSurface):\r\n            iso, ns = ng_In\r\n            intvls_Trim = getTrimInterval_NurbsSrf(iso, ns, pt_End_ToRemain, pts_Xs[i])\r\n            ns_Trimmed = ns.Trim(intvls_Trim[0], intvls_Trim[1])\r\n            ngs_Out.append((iso, ns_Trimmed))\r\n        else:\r\n            nc = ng_In[0]\r\n            intvl_Trim = getTrimInterval_NurbsCrv(nc, pt_End_ToRemain, pts_Xs[i])\r\n            nc_Trimmed = nc.Trim(intvl_Trim[0], intvl_Trim[1])\r\n            ngs_Out.append((nc_Trimmed, ng_In[1]))\r\n\r\n\r\n    return ngs_Out\r\n\r\n\r\ndef createAlignedRefGeom_PerStart(geom_R_In, ns_M, side_M):\r\n    \"\"\"\r\n    Variation to a function in spb_Match1 in that\r\n    the start locations of the edges are used to determine whether\r\n    NS or NC needs to be reversed.\r\n\r\n    Returns either\r\n        NurbsSurface with parameterizations aligned with ns_M along side_M or\r\n        NurbsCurve with parameterization aligned with ns_M\r\n    \"\"\"\r\n\r\n\r\n    def areSrfParamsAlignedAlongMatchingSides(ns_A, side_A, ns_B, side_B):\r\n        \"\"\"\r\n        \"\"\"\r\n\r\n        def getSideEndPtsInAscendingSrfParam(ns, side):\r\n            cps = ns.Points\r\n            pt_SW = cps.GetControlPoint(           0,            0).Location\r\n            pt_SE = cps.GetControlPoint(cps.CountU-1,            0).Location\r\n            pt_NE = cps.GetControlPoint(cps.CountU-1, cps.CountV-1).Location\r\n            pt_NW = cps.GetControlPoint(           0, cps.CountV-1).Location\r\n            if side == E:\r\n                return pt_SE, pt_NE\r\n            elif side == W:\r\n                return pt_SW, pt_NW\r\n            elif side == S:\r\n                return pt_SW, pt_SE\r\n            elif side == N:\r\n                return pt_NW, pt_NE\r\n            else:\r\n                raise ValueError(\"{} is not a valid side.\".format(side))\r\n\r\n\r\n        pts_A = getSideEndPtsInAscendingSrfParam(ns_A, side_A)\r\n        pts_B = getSideEndPtsInAscendingSrfParam(ns_B, side_B)\r\n\r\n        #for pt in pts_A: sc.doc.Objects.AddPoint(pt)\r\n        #for pt in pts_B: sc.doc.Objects.AddPoint(pt)\r\n\r\n        tol = 2.0 * sc.doc.ModelAbsoluteTolerance\r\n\r\n        if (\r\n            (pts_A[0].DistanceTo(pts_B[0]) < tol) and \r\n            (pts_A[1].DistanceTo(pts_B[1]) < tol)\r\n        ):\r\n            return True\r\n\r\n        if (\r\n            (pts_A[0].DistanceTo(pts_B[1]) < tol) and \r\n            (pts_A[1].DistanceTo(pts_B[0]) < tol)\r\n        ):\r\n            return False\r\n\r\n        if bDebug:\r\n            for pt in pts_A: sc.doc.Objects.AddPoint(pt)\r\n            for pt in pts_B: sc.doc.Objects.AddPoint(pt)\r\n            sc.doc.Objects.AddSurface(ns_A)\r\n            sc.doc.Objects.AddSurface(ns_B)\r\n            sc.doc.Views.Redraw()\r\n\r\n        raise Exception(\"The 2 sides' positions do not match.\")\r\n\r\n\r\n    def createAlignedRefSrfs(side_M, ns_R, side_R):\r\n        \"\"\"\r\n        Notes:\r\n        ns_R.Reverse(int direction, bool inPlace)\r\n        Transpose(bool inPlace)\r\n        \"\"\"\r\n\r\n        if side_M == side_R:\r\n            pass\r\n        elif side_M in (S, N) and side_R in (S, N):\r\n            ns_R.Reverse(1, True)\r\n        elif side_M in (W, E) and side_R in (W, E):\r\n            ns_R.Reverse(0, True)\r\n        else:\r\n            ns_R.Transpose(True)\r\n\r\n            if side_M == S and side_R == E:\r\n                ns_R.Reverse(1, True)\r\n            elif side_M == S and side_R == W:\r\n                pass\r\n            elif side_M == E and side_R == N:\r\n                pass\r\n            elif side_M == E and side_R == S:\r\n                ns_R.Reverse(0, True)\r\n            elif side_M == N and side_R == W:\r\n                ns_R.Reverse(1, True)\r\n            elif side_M == N and side_R == E:\r\n                pass\r\n            elif side_M == W and side_R == S:\r\n                pass\r\n            elif side_M == W and side_R == N:\r\n                ns_R.Reverse(0, True)\r\n            else:\r\n                raise Exception(\"What happened?\")\r\n\r\n        if (not areSrfParamsAlignedAlongMatchingSides(\r\n            ns_M, side_M, ns_R, side_M)\r\n        ):\r\n            ns_R.Reverse(0 if side_M in (S, N) else 1, True)\r\n\r\n\r\n    if isinstance(geom_R_In[1], rg.NurbsSurface):\r\n        side_R, ns_R = geom_R_In\r\n        rc = createAlignedRefSrfs(side_M, ns_R, side_R)\r\n        return ns_R # Don't bother returning IsoStatus since R now matches that of M.\r\n\r\n    # Reference alignment is per Edge.\r\n    c_M = getIsoCurveOfSide(side_M, ns_M)\r\n    c_R = geom_R_In[0]\r\n    if not rg.Curve.DoDirectionsMatch(c_M, c_R):\r\n        c_R.Reverse()\r\n\r\n    return c_R # Don't bother returning tuple since none is needed for NS.\r\n\r\n\r\ndef transferUniqueKnotVector(nurbsA, nurbsB, sideA=None, sideB=None, paramTol=None):\r\n    \"\"\"\r\n    Union the knot vectors of nurbsA and nurbsB and apply to nurbsB (modify reference).\r\n\r\n    nurbsA and nurbsB: Any combination of NurbsSurface or NurbsCurve.\r\n    Return True if nsB was modified.\r\n    \"\"\"\r\n\r\n    if paramTol is None: paramTol = Rhino.RhinoMath.ZeroTolerance\r\n\r\n\r\n    def knotCount(geom, side):\r\n        if isinstance(geom, rg.NurbsSurface):\r\n            if side in (S, N): return geom.KnotsU.Count\r\n            else: return geom.KnotsV.Count\r\n        else:\r\n            return geom.Knots.Count\r\n\r\n    def degree(geom, side):\r\n        if isinstance(geom, rg.NurbsSurface):\r\n            iDir = 0 if side in (S, N) else 1\r\n            return geom.Degree(iDir)\r\n        else:\r\n            return geom.Degree\r\n\r\n    def knotMultiplicity(geom, side, iK):\r\n        if isinstance(geom, rg.NurbsSurface):\r\n            if side in (S, N): return geom.KnotsU.KnotMultiplicity(iK)\r\n            else: return geom.KnotsV.KnotMultiplicity(iK)\r\n        else:\r\n            return geom.Knots.KnotMultiplicity(iK)\r\n\r\n    def getKnot(geom, side, iK):\r\n        if isinstance(geom, rg.NurbsSurface):\r\n            if side in (S, N):\r\n                if iK >= geom.KnotsU.Count:\r\n                    pass\r\n                return geom.KnotsU[iK]\r\n            else:\r\n                if iK >= geom.KnotsV.Count:\r\n                    pass\r\n                return geom.KnotsV[iK]\r\n        else:\r\n            return geom.Knots[iK]\r\n\r\n    def insertKnot(geom, side, t, m):\r\n        if isinstance(geom, rg.NurbsSurface):\r\n            if side in (S, N): return geom.KnotsU.InsertKnot(t, m)\r\n            else: return geom.KnotsV.InsertKnot(t, m)\r\n        else:\r\n            return geom.Knots.InsertKnot(t, m)\r\n\r\n\r\n    knotCt_A = knotCount(nurbsA, sideA)\r\n    knotCt_B_In = knotCount(nurbsB, sideB)\r\n\r\n    deg_A = degree(nurbsA, sideA)\r\n\r\n    iK = deg_A\r\n    while iK < (knotCt_A - deg_A):\r\n        sc.escape_test()\r\n        t_A = getKnot(nurbsA, sideA, iK)\r\n        mA = knotMultiplicity(nurbsA, sideA, iK)\r\n        if knotCount(nurbsB, sideB) <= iK:\r\n            rc = insertKnot(nurbsB, sideB, t_A, mA)\r\n        elif abs(t_A - getKnot(nurbsB, sideB, iK)) > paramTol:\r\n            rc = insertKnot(nurbsB, sideB, t_A, mA)\r\n        elif abs(t_A - getKnot(nurbsB, sideB, iK)) < paramTol:\r\n            mB = knotMultiplicity(nurbsB, sideB, iK)\r\n            if mB < mA:\r\n                # To add missing multiple knots at an existing knot, insert the\r\n                # total target multiplicity, but using t_B instead of t_A due to\r\n                # apparent 2e-52 sensitivity of parameter value for InsertKnot.\r\n                t_B = getKnot(nurbsB, sideB, iK)\r\n                rc = insertKnot(nurbsB, sideB, t_B, mA)\r\n                #print(abs(t_A-t_B))\r\n        else:\r\n            raise Exception(\"What happened?\")\r\n        iK += mA\r\n\r\n    knotCt_B_Out = knotCount(nurbsB, sideB)\r\n\r\n    return knotCount(nurbsB, sideB) > knotCt_B_In\r\n\r\n\r\ndef _doAnyCrvsCompletelyOverlap(cs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    found = [[False, False] for i in range(len(cs))]\r\n    tol = 2.0 * sc.doc.ModelAbsoluteTolerance\r\n\r\n    for iA in range(len(cs)-1):\r\n        cA = cs[iA]\r\n        if not found[iA][0]:\r\n            ptA = cA.PointAtStart\r\n            for iB in range(1+iA, len(cs)):\r\n                cB = cs[iB]\r\n                if ptA.DistanceTo(cB.PointAtStart) <= tol:\r\n                    found[iA][0] = True\r\n                    found[iB][0] = True\r\n                    if cA.PointAtEnd.DistanceTo(cB.PointAtEnd) <= tol:\r\n                        return True\r\n                    break\r\n                if ptA.DistanceTo(cB.PointAtEnd) <= tol:\r\n                    found[iA][0] = True\r\n                    found[iB][1] = True\r\n                    if cA.PointAtEnd.DistanceTo(cB.PointAtStart) <= tol:\r\n                        return True\r\n                    break\r\n\r\n        if not found[iA][1]:\r\n            ptA = cA.PointAtEnd\r\n            for iB in range(1+iA, len(cs)):\r\n                cB = cs[iB]\r\n                if ptA.DistanceTo(cB.PointAtStart) <= tol:\r\n                    found[iA][1] = True\r\n                    found[iB][0] = True\r\n                    if cA.PointAtEnd.DistanceTo(cB.PointAtEnd) <= tol:\r\n                        return True\r\n                    break\r\n                if ptA.DistanceTo(cB.PointAtEnd) <= tol:\r\n                    found[iA][1] = True\r\n                    found[iB][1] = True\r\n                    if cA.PointAtEnd.DistanceTo(cB.PointAtStart) <= tol:\r\n                        return True\r\n                    break\r\n\r\n    return False\r\n\r\n\r\ndef _getOppSide(side):\r\n    sides = W, S, E, N\r\n    iSide_In = sides.index(side)\r\n    iSide_Out = (iSide_In + 2) % 4\r\n    return sides[iSide_Out]\r\n\r\n\r\ndef _areThereEnoughPtsToModifyTransverseFromSide(ns, side, iConts_Per_Side):\r\n\r\n    iG_side = iConts_Per_Side[side]\r\n    if iG_side < 0:\r\n        return True\r\n\r\n    opp = _getOppSide(side)\r\n    iG_opp = iConts_Per_Side[opp]\r\n\r\n    pts_Needed_side = iG_side + 1\r\n\r\n    pts_Needed_opp = 0 if (iG_opp < 0) else iG_opp + 1\r\n\r\n\r\n    if side in (W,E):\r\n        ct = ns.Points.CountU\r\n        #if ct < 2*(iG+1):\r\n        if ct < pts_Needed_side + pts_Needed_opp:\r\n            if side == W:\r\n                print(\"Not enough CPs to modify to G{} along U.\".format(iG_side))\r\n            return False\r\n    else:\r\n        ct = ns.Points.CountV\r\n        #if ct < 2*(iG_side+1):\r\n        if ct < pts_Needed_side + pts_Needed_opp:\r\n            if side == S:\r\n                print(\"Not enough CPs to modify to G{} along V.\".format(iG_side))\r\n            return False\r\n    return True\r\n\r\n\r\ndef createSurface(rhCrvs_In, **kwargs):\r\n    \"\"\"\r\n    Parmeteters:\r\n        rhCrvs_In: Can be ObjRefs or Geometry of any Curve, including BrepEdge.\r\n        iContinuity_PerCrv\r\n        bEcho,\r\n        bDebug\r\n    Returns NurbsSurface on success.\r\n    \"\"\"\r\n\r\n\r\n    if 'iContinuity_PerCrv' in kwargs:\r\n        iContinuity_PerCrv_In = kwargs['iContinuity_PerCrv']\r\n    else:\r\n        iContinuity_PerCrv_In = [Opts.values['iContinuity']]*len(rhCrvs_In)\r\n\r\n    iContinuity_PerCrv_WIP = iContinuity_PerCrv_In[:]\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    if len(rhCrvs_In) not in (2,3,4):\r\n        return None, \"{} curves provided.  Need 2, 3, or 4.\".format(len(rhCrvs_In))\r\n\r\n\r\n    tol0 = Rhino.RhinoMath.ZeroTolerance\r\n\r\n\r\n    def getGeomFromIn(In):\r\n        \"\"\" Returns BrepTrim, (wire) Curve, or None \"\"\"\r\n\r\n        def getMostUsefulGeomFromEdge(edge):\r\n            if len(edge.TrimIndices()) == 1:\r\n                trim = edge.Brep.Trims[edge.TrimIndices()[0]]\r\n                if trim.IsoStatus == rg.IsoStatus.None:\r\n                    trim.Brep.Faces.ShrinkFaces()\r\n                return trim\r\n            print(\"Edge with more than one face selected.\",\r\n                  \" Only G0 continuity will result for it.\")\r\n            return edge.DuplicateCurve()\r\n\r\n        def getMostUsefulGeomFromCrv(geom):\r\n            if isinstance(geom, rg.BrepEdge):\r\n                return getMostUsefulGeomFromEdge(geom)\r\n            if isinstance(geom, rg.Curve):\r\n                return geom\r\n            raise ValueError(\r\n                \"{} provided instead of something from which a curve can derive.\".format(\r\n                    geom.GetType().Name))\r\n\r\n        def getMostUsefulGeomFromObjRef(objref):\r\n            \"\"\" Returns BrepTrim, (wire) Curve, or None \"\"\"\r\n\r\n            if not isinstance(objref, rd.ObjRef): return\r\n\r\n            trim = objref.Trim()\r\n\r\n            if trim is not None:\r\n                if trim.IsoStatus == rg.IsoStatus.None:\r\n                    trim.Brep.Faces.ShrinkFaces()\r\n                return trim\r\n\r\n            edge = objref.Edge()\r\n\r\n            if edge is not None:\r\n                return getMostUsefulGeomFromEdge(edge)\r\n\r\n            crv = objref.Curve()\r\n            if crv is not None:\r\n                return crv\r\n\r\n            raise ValueError(\"{} provided instead of something from which a curve can derive.\".format(\r\n                    objref.Geometry().GetType().Name))\r\n\r\n        if isinstance(In, rd.ObjRef):\r\n            return getMostUsefulGeomFromObjRef(In)\r\n\r\n        if isinstance(In, rg.Curve):\r\n            return getMostUsefulGeomFromCrv(In)\r\n\r\n        raise ValueError(\"{} passed as input.\".format(In.GetType().Name))\r\n\r\n    geoms_In = [getGeomFromIn(In) for In in rhCrvs_In]\r\n\r\n\r\n    def areAllBrepTrimsUnique(geoms):\r\n        isos = []\r\n        srfs = []\r\n\r\n        for geom in geoms:\r\n            if not isinstance(geom, rg.BrepTrim): continue\r\n\r\n            trim = geom\r\n\r\n            iso = trim.IsoStatus\r\n            if iso not in (W,S,E,N): continue\r\n\r\n            srf = trim.Face.UnderlyingSurface()\r\n\r\n            for iso_InList, srf_InList in zip(isos, srfs):\r\n                if rg.GeometryBase.GeometryReferenceEquals(srf_InList, srf):\r\n                    if iso_InList == iso:\r\n                        return False\r\n\r\n            isos.append(iso)\r\n            srfs.append(srf)\r\n\r\n        return True\r\n\r\n    if not areAllBrepTrimsUnique(geoms_In):\r\n        return None, \"2 edges of the same isostatus of the same surface were selected.\"\r\n\r\n\r\n    cs_In = [getR3CurveOfGeom(g) for g in geoms_In]\r\n\r\n\r\n    if _doAnyCrvsCompletelyOverlap(cs_In):\r\n        return None, \"Some edges/trims completely overlap.\"\r\n\r\n    geoms_Nurbs = []\r\n    for geom, iContinuity in zip(geoms_In, iContinuity_PerCrv_In):\r\n        geom_Nurbs = spb.getShrunkNurbsSrfFromGeom(geom, bUseUnderlyingIsoCrvs=False)\r\n        if geom_Nurbs is None:\r\n            geom_Nurbs = spb.getNurbsGeomFromGeom(geom, iContinuity, bEcho, bDebug=False)\r\n            if geom_Nurbs is None:\r\n                if bEcho:\r\n                    print(\"NURBS geometry could not be obtained from input.\")\r\n                return\r\n        geoms_Nurbs.append(geom_Nurbs)\r\n\r\n\r\n    cs_R = [getCurveOfNurbs(geom) for geom in geoms_Nurbs]\r\n\r\n\r\n    ns_M_Start = None\r\n\r\n    # TODO: Clean this if block.\r\n    if len(rhCrvs_In) == 4:\r\n        if not doCrvsFormAClosedLoop(cs_R):\r\n            s = \"No matching endpoint of some curves found, \"\r\n            geoms_Nurbs = trimNurbsAtCrvIntersections(geoms_Nurbs)\r\n            cs_R = [getCurveOfNurbs(geom) for geom in geoms_Nurbs]\r\n            if not doCrvsFormAClosedLoop(cs_R):\r\n                print(s + \"and attempt ot split some trims at intersections failed.\")\r\n                return\r\n            print(s + \"but attempt ot split some trims at intersections succeeded.\")\r\n    elif len(rhCrvs_In) == 3:\r\n        if any(getPtsAtNonEndIntersects(cs_R)):\r\n            print(\"Input contains non-end-to-end intersections.  Split curves and rerun script.\")\r\n            return\r\n\r\n        pCrvs = rg.Curve.JoinCurves(cs_R, sc.doc.ModelAbsoluteTolerance) # Polycurves.\r\n\r\n        if len(pCrvs) == 1 and pCrvs[0].IsClosed:\r\n            print(\"3-curve input can join into a closed loop.  This is not (yet) supported.\")\r\n            return\r\n\r\n        if len(pCrvs) > 1:\r\n            if len(pCrvs) == 1 and pCrvs[0].IsClosed:\r\n                print(\"Input forms a Single, closed loop.\")\r\n                return\r\n\r\n            s = \"Curve do not form a single open loop, \"\r\n            geoms_Nurbs = trimNurbsAtCrvIntersections(geoms_Nurbs)\r\n            cs_R = [getCurveOfNurbs(geom) for geom in geoms_Nurbs]\r\n\r\n            pCrvs = rg.Curve.JoinCurves(cs_R, sc.doc.ModelAbsoluteTolerance)\r\n\r\n            if len(pCrvs) != 1:\r\n                print(s + \"and attempt ot split some trims at intersections failed.\")\r\n                return\r\n            print(s + \"but attempt ot split some trims at intersections succeeded.\")\r\n\r\n        polyCrv = pCrvs[0]\r\n        nc_ToAdd = rg.LineCurve(polyCrv.PointAtStart, polyCrv.PointAtEnd).ToNurbsCurve()\r\n        polyCrv.Dispose()\r\n        cs_R.append(nc_ToAdd)\r\n        geoms_Nurbs.append((nc_ToAdd, None))\r\n        iContinuity_PerCrv_WIP.append(-1)\r\n    elif len(rhCrvs_In) == 2:\r\n        if any(getPtsAtNonEndIntersects(cs_R)):\r\n            print(\"Input contains non-end-to-end intersections.  Split curves and rerun sctipt.\")\r\n            return\r\n\r\n        pCrvs = rg.Curve.JoinCurves(cs_R, sc.doc.ModelAbsoluteTolerance)\r\n\r\n        if pCrvs[0].IsClosed:\r\n            print(\"2-curve input can join into a closed loop.  This is not (yet) supported.\")\r\n            return\r\n\r\n        if len(pCrvs) == 1:\r\n            pCrv = pCrvs[0]\r\n            pt = pCrv.PointAt(pCrv.SegmentDomain(0).T1)\r\n            if cs_R[0].PointAtEnd.DistanceTo(pt) <= sc.doc.ModelAbsoluteTolerance:\r\n                cs_R[0].Reverse()\r\n            if cs_R[1].PointAtEnd.DistanceTo(pt) <= sc.doc.ModelAbsoluteTolerance:\r\n                cs_R[1].Reverse()\r\n\r\n            sumsrf = rg.SumSurface.Create(cs_R[0], cs_R[1])\r\n            if bDebug: spb.addGeoms(sumsrf)\r\n\r\n            ns_M_Start = sumsrf.ToNurbsSurface()\r\n            #spb.addGeoms(sumsrf)\r\n\r\n            cs_C = [getIsoCurveOfSide(s, ns_M_Start) for s in (W,S,E,N)]\r\n\r\n            idx_R_per_Ms_WSEN = spb.findMatchingCurveByEndPoints(\r\n                cs_C, cs_R, bDebug=bDebug)\r\n            if idx_R_per_Ms_WSEN is None: return\r\n\r\n            for side, idx in zip((W,S,E,N), idx_R_per_Ms_WSEN):\r\n                if idx is None:\r\n                    nc_ToAdd = getIsoCurveOfSide(side, ns_M_Start)\r\n                    cs_R.append(nc_ToAdd)\r\n                    geoms_Nurbs.append((nc_ToAdd, None))\r\n                    iContinuity_PerCrv_WIP.append(-1)\r\n\r\n        elif len(pCrvs) == 2:\r\n            # Create blend surface.  Can optionally do this using Brep.CreateFromLoft.\r\n            if rg.Curve.DoDirectionsMatch(cs_R[0], cs_R[1]):\r\n                pts = (\r\n                    (cs_R[0].PointAtStart, cs_R[1].PointAtStart),\r\n                    (cs_R[0].PointAtEnd, cs_R[1].PointAtEnd))\r\n            else:\r\n                pts = (\r\n                    (cs_R[0].PointAtStart, cs_R[1].PointAtEnd),\r\n                    (cs_R[0].PointAtEnd, cs_R[1].PointAtStart))\r\n            for i in 0,1:\r\n                nc_ToAdd = rg.LineCurve(pts[i][0], pts[i][1]).ToNurbsCurve()\r\n                nc_ToAdd.IncreaseDegree((iContinuity_PerCrv_WIP[i]+1)*2-1)\r\n                cs_R.append(nc_ToAdd)\r\n                geoms_Nurbs.append((nc_ToAdd, None))\r\n                iContinuity_PerCrv_WIP.append(-1)\r\n\r\n\r\n    if ns_M_Start is None:\r\n        rgB_Res = rg.Brep.CreateEdgeSurface(cs_R)\r\n        if rgB_Res is None:\r\n            return None, \"CreateEdgeSurface returned None.\"\r\n\r\n        #for c in cs_R: sc.doc.Objects.AddCurve(c)\r\n        #sc.doc.Objects.AddBrep(rgB_Res)\r\n        #sc.doc.Views.Redraw(); return None, None\r\n\r\n\r\n        if rgB_Res.Surfaces.Count != 1:\r\n            sc.doc.Objects.AddBrep(rgB_Res)\r\n            return None, \"Polyface brep with no continuity matching attempted added to document.\"\r\n\r\n        ns_M_Start = rgB_Res.Surfaces[0]\r\n\r\n\r\n    if ns_M_Start.IsRational:\r\n        spb.makeNonRational(ns_M_Start)\r\n\r\n\r\n    # Brep.CreateEdgeSurface (always?) produces a surface with the\r\n    # largest degree in chain of surfaces in each direction but\r\n    # may have missing knots and point distributions.\r\n    # Both it and the surfaces from which the reference trims are taken\r\n    # need to match along the relevant direction.\r\n    # Create 4 modified surfaces to use for remainder of script.\r\n\r\n\r\n    # Match references to the Coons.\r\n    cs_C = [getIsoCurveOfSide(s, ns_M_Start) for s in (W,S,E,N)]\r\n\r\n    idx_R_per_Ms_WSEN = spb.findMatchingCurveByEndPoints(\r\n        cs_C, cs_R, bDebug=bDebug)\r\n    if idx_R_per_Ms_WSEN is None: return\r\n\r\n    iConts_WSEN = [iContinuity_PerCrv_WIP[i] for i in idx_R_per_Ms_WSEN]\r\n\r\n\r\n    # Align each reference to the Coons by side and parameterization.\r\n    # This results in opposite u x v directions between each Refernce and the Coons.\r\n    geoms_Nurbs_AR = {}\r\n    iConts_Per_Side = {}\r\n    geoms_In_Per_Side = {}\r\n\r\n    for i, side in enumerate((W,S,E,N)):\r\n        idx_R_per_M_side = idx_R_per_Ms_WSEN[i]\r\n        rc = createAlignedRefGeom_PerStart(\r\n            geoms_Nurbs[idx_R_per_M_side], ns_M_Start, side)\r\n        if rc is None: return\r\n        geoms_Nurbs_AR[side] = rc\r\n        iConts_Per_Side[side] = iConts_WSEN[i]\r\n        if idx_R_per_M_side < len(geoms_In):\r\n            geoms_In_Per_Side[side] = geoms_In[idx_R_per_Ms_WSEN[i]]\r\n        else:\r\n            geoms_In_Per_Side[side] = None\r\n\r\n\r\n    # Reduce continuities that are above maximum that reference objects can offer.\r\n    for side in W,S,E,N:\r\n        if isinstance(geoms_Nurbs_AR[side], rg.NurbsCurve):\r\n            if iConts_Per_Side[side] > 0:\r\n                if bEcho:\r\n                    print(\"Reduced target continuity on {} from {} to {} since input geometry is a curve, not surface.\".format(\r\n                        side, iConts_Per_Side[side], 0))\r\n                iConts_Per_Side[side] = 0\r\n            continue\r\n\r\n        # Reference is a NurbsSurface.\r\n        if iConts_Per_Side[side] < 2:\r\n            continue\r\n\r\n        rgTrim_In = geoms_In_Per_Side[side]\r\n        if rgTrim_In.IsoStatus != rg.IsoStatus.None:\r\n            continue\r\n\r\n        if bDebug: print(\"Tangent surface is used on {}.\".format(side))\r\n\r\n        if rgTrim_In.Face.UnderlyingSurface().IsPlanar(tolerance=1e-8):\r\n            # G2 is acceptable.\r\n            continue\r\n\r\n        if side in (W,E):\r\n            if bEcho:\r\n                print(\"Reduced target continuity on {} from {} to {}.\".format(\r\n                    side, iConts_Per_Side[side], 1))\r\n            iConts_Per_Side[side] = 1\r\n        else:\r\n            if bEcho:\r\n                print(\"Reduced target continuity on {} from {} to {}.\".format(\r\n                    side, iConts_Per_Side[side], 1))\r\n            iConts_Per_Side[side] = 1\r\n\r\n\r\n    # If not enough points in Coons, increase degree of Coons and references.\r\n\r\n    if ns_M_Start.Points.CountU < (iConts_Per_Side[W] + iConts_Per_Side[E] + 2):\r\n        #print(\"Increase in U.\")\r\n        ns_M_Start.IncreaseDegreeU(\r\n            ns_M_Start.Degree(0) +\r\n            (iConts_Per_Side[W] + iConts_Per_Side[E] + 2) -\r\n            ns_M_Start.Points.CountU)\r\n    \r\n    if ns_M_Start.Points.CountV < (iConts_Per_Side[S] + iConts_Per_Side[N] + 2):\r\n        #print( \"Increase in V.\"\r\n        ns_M_Start.IncreaseDegreeV(\r\n            ns_M_Start.Degree(1) +\r\n            (iConts_Per_Side[S] + iConts_Per_Side[N] + 2) -\r\n            ns_M_Start.Points.CountV)\r\n\r\n    #print(ns_M_Start.Degree(0), ns_M_Start.Degree(1))\r\n    #print(ns_M_Start.Points.CountU, ns_M_Start.Points.CountV)\r\n\r\n    #return\r\n\r\n\r\n    # Match curve/surface degrees per direction to highest.\r\n\r\n    bResults = []\r\n    for side in W,S,E,N:\r\n        bResult = spb.transferHigherDegree(\r\n            ns_M_Start, geoms_Nurbs_AR[side], side, side)\r\n        bResults.append(bResult)\r\n    if bDebug: print(\"transferHigherDegree: {}\".format(bResults))\r\n\r\n    #for ns in geoms_ARs:\r\n    #    sc.doc.Objects.AddSurface(ns)\r\n    #sc.doc.Views.Redraw()\r\n\r\n\r\n    # Match reference srf relevant domains to Coons patch srf.\r\n    bResults = []\r\n    for side in W,S,E,N:\r\n        bResult = spb.transferDomain(\r\n            ns_M_Start, geoms_Nurbs_AR[side], side, side)\r\n        bResults.append(bResult)\r\n    if bDebug: print(\"transferDomain: {}\".format(bResults))\r\n\r\n    #for ns in geoms_ARs:\r\n    #    sc.doc.Objects.AddSurface(ns)\r\n    #sc.doc.Views.Redraw()\r\n\r\n\r\n\r\n    # Match reference srf knot vectors to Coons patch srf.\r\n\r\n    # First, transfer unique knots to Coons so that the latter can contain all unique knots\r\n    # to transfer to reference surfaces.\r\n    [transferUniqueKnotVector(geoms_Nurbs_AR[side], ns_M_Start, side, side) for side in (S,N,W,E)]\r\n\r\n    #sc.doc.Objects.AddSurface(ns_M_Start)#; sc.doc.Views.Redraw(); return\r\n\r\n\r\n    # Then, transfer unique knots back to reference surfaces.\r\n    [transferUniqueKnotVector(ns_M_Start, geoms_Nurbs_AR[side], side, side) for side in (S,N,W,E)]\r\n\r\n    if bDebug:\r\n        print(geoms_Nurbs_AR.values())\r\n        #spb.addGeoms(geoms_Nurbs_AR.values())\r\n\r\n    if all(iContinuity not in (1,2) for iContinuity in iConts_WSEN):\r\n        return ns_M_Start\r\n\r\n\r\n    if ns_M_Start.Points.CountU < 4 and ns_M_Start.Points.CountV < 4:\r\n        if bEcho: print(\"Not enough points to modify continuity.\")\r\n        return ns_M_Start\r\n\r\n    if bEcho:\r\n        print(\"Modifying continuity for {} reference edges.\".format(\r\n            sum(isinstance(geoms_Nurbs_AR[key], rg.NurbsSurface) for key in geoms_Nurbs_AR)))\r\n\r\n\r\n    ptsM_PreG1 = [cp.Location for cp in ns_M_Start.Points]\r\n\r\n    pts_G1_corners = {} # Collecting points for averaging.\r\n    planes_G1_corners = {} # For determining special cases that should not use simple averaging.\r\n    vectors_01_M = {} # For determining special case where 2 reference surfaces tangents flow linearly into each other.\r\n    pts_G2_corners = {}\r\n\r\n    ns_WIP = ns_M_Start.Duplicate()\r\n\r\n\r\n    def getUvIdxFromNsPoint1dIdx(ns, idxFlat):\r\n        return idxFlat // ns.Points.CountV, idxFlat % ns.Points.CountV\r\n\r\n\r\n    for side in W,S,E,N:\r\n\r\n        iContinuity = iConts_Per_Side[side]\r\n\r\n        if iContinuity < 1:\r\n            continue\r\n\r\n        if not _areThereEnoughPtsToModifyTransverseFromSide(\r\n            ns_M_Start,\r\n            side,\r\n            {W: 1, S: 1, E: 1, N: 1}\r\n        ):\r\n            continue\r\n\r\n        geom_AR = geoms_Nurbs_AR[side]\r\n\r\n        if isinstance(geom_AR, rg.Curve):\r\n            continue # Since surface is already G0.\r\n\r\n        ns_R = geom_AR\r\n\r\n        #sc.doc.Objects.AddSurface(ns_R)\r\n\r\n        idxPts = {} # Key is tuple(str('M' or 'R'), int(G continuity))\r\n        for i in range(iContinuity+1):\r\n            idxPts['M',i] = spb.getPtRowIndicesPerG(ns_M_Start, side, i)\r\n            idxPts['R',i] = spb.getPtRowIndicesPerG(ns_R, side, i)\r\n\r\n        iRowLn = len(idxPts['M',0])\r\n\r\n\r\n        def setModifyRowEnd(side):\r\n            if side in (W,E):\r\n                bModifyRowEnd_T0 = iConts_Per_Side[S] == -1\r\n                bModifyRowEnd_T1 = iConts_Per_Side[N] == -1\r\n            else:\r\n                bModifyRowEnd_T0 = iConts_Per_Side[W] == -1\r\n                bModifyRowEnd_T1 = iConts_Per_Side[E] == -1\r\n            return bModifyRowEnd_T0, bModifyRowEnd_T1\r\n\r\n\r\n        rc = setModifyRowEnd(side)\r\n        bModifyRowEnd_T0, bModifyRowEnd_T1 = rc\r\n\r\n        # G0 row is already set.\r\n\r\n        ns_M_G1 = spb.setContinuity_G1(\r\n            ns_M_BeforeAnyMatching=ns_M_Start,\r\n            ns_M_In=ns_WIP,\r\n            side_M=side,\r\n            nurbs_R=ns_R,\r\n            side_R=side,\r\n            bModifyRowEnd_T0=bModifyRowEnd_T0,\r\n            bModifyRowEnd_T1=bModifyRowEnd_T1,\r\n            )\r\n\r\n        if ns_M_G1 is None:\r\n            continue\r\n\r\n        #if side == S:\r\n        #sc.doc.Objects.AddSurface(ns_M_G1)#; sc.doc.Views.Redraw(); return\r\n\r\n        # Update.\r\n        ns_WIP.Dispose()\r\n        ns_WIP = ns_M_G1\r\n        pts_WIP = [cp.Location for cp in ns_WIP.Points]\r\n\r\n        # Record the G1 point from each 2nd from end for later average.\r\n        if iRowLn >= 4:\r\n            for i in (1, iRowLn-2):\r\n                iM1 = idxPts['M',1][i]\r\n                bPlanarRefSrf, plane_R = ns_R.TryGetPlane(tolerance=1e-9)\r\n\r\n                vector_01_M = None\r\n\r\n                if not bPlanarRefSrf:\r\n                    plane_R = None\r\n                    vector_01_M = spb.get_all_parallel_G01_vector(ns_WIP, side)\r\n\r\n                if iM1 in pts_G1_corners.keys():\r\n                    pts_G1_corners[iM1].append(pts_WIP[iM1])\r\n                    planes_G1_corners[iM1].append(plane_R)\r\n                    vectors_01_M[iM1].append(vector_01_M)\r\n                else:\r\n                    pts_G1_corners[iM1] = [pts_WIP[iM1]]\r\n                    planes_G1_corners[iM1] = [plane_R]\r\n                    vectors_01_M[iM1] = [vector_01_M]\r\n        #sc.doc.Objects.AddPoint(pts_WIP[idxPts['M',1][1]])\r\n        #sc.doc.Objects.AddPoint(pts_WIP[idxPts['M',1][len(idxPts['M',1])-2]])\r\n\r\n        if iContinuity == 2 and _areThereEnoughPtsToModifyTransverseFromSide(ns_M_Start, side, iConts_Per_Side):\r\n            ns_M_G2 = spb.setContinuity_G2(\r\n                ns_M_BeforeAnyMatching=ns_M_Start,\r\n                ns_M_In=ns_WIP,\r\n                side_M=side,\r\n                nurbs_R=ns_R,\r\n                side_R=side,\r\n                bModifyRowEnd_T0=bModifyRowEnd_T0,\r\n                bModifyRowEnd_T1=bModifyRowEnd_T1,\r\n                bDebug=bDebug,\r\n                bAddRefs=True,\r\n                )\r\n\r\n            # Update.\r\n            ns_WIP.Dispose()\r\n            ns_WIP = ns_M_G2\r\n            pts_WIP = [cp.Location for cp in ns_M_G2.Points]\r\n\r\n            # Record the G2 point from each 2nd from end for later average.\r\n            if iRowLn >= 6:\r\n                for i in (2, iRowLn-3):\r\n                    iM2 = idxPts['M',2][i]\r\n                    if iM2 in pts_G2_corners.keys():\r\n                        pts_G2_corners[iM2].append(pts_WIP[iM2])\r\n                    else:\r\n                        pts_G2_corners[iM2] = [pts_WIP[iM2]]\r\n                #sc.doc.Objects.AddPoint(pts_WIP[idxPts['M',1][1]])\r\n                #sc.doc.Objects.AddPoint(pts_WIP[idxPts['M',1][len(idxPts['M',1])-2]])\r\n\r\n                # Return the 3rd G2 points on each end to their original positions.\r\n                for idx in (2, iRowLn-3):\r\n                    iM2 = idxPts['M',2][idx]\r\n                    iUT_A, iVT_A = getUvIdxFromNsPoint1dIdx(ns_M_Start, iM2)\r\n                    ns_WIP.Points.SetPoint(\r\n                        iUT_A, iVT_A, ptsM_PreG1[iM2],\r\n                        weight=ns_M_Start.Points.GetWeight(iUT_A, iVT_A))\r\n\r\n\r\n        # Return the 2nd G1 points on each end to their original positions.\r\n        if iRowLn >= 4:\r\n            for idx in (1, iRowLn-2):\r\n                iM1 = idxPts['M',1][idx]\r\n                iUT_A, iVT_A = getUvIdxFromNsPoint1dIdx(ns_M_Start, iM1)\r\n                ns_WIP.Points.SetPoint(\r\n                    iUT_A, iVT_A, ptsM_PreG1[iM1],\r\n                    weight=ns_M_Start.Points.GetWeight(iUT_A, iVT_A))\r\n\r\n\r\n    # Average the corner G1 locations.\r\n    for iM1 in pts_G1_corners:\r\n        iUT_A, iVT_A = getUvIdxFromNsPoint1dIdx(ns_M_Start, iM1)\r\n        if len(pts_G1_corners[iM1]) == 1:\r\n            ns_WIP.Points.SetPoint(\r\n                iUT_A, iVT_A, pts_G1_corners[iM1][0],\r\n                weight=ns_M_Start.Points.GetWeight(iUT_A, iVT_A))\r\n        elif len(pts_G1_corners[iM1]) == 2:\r\n            if planes_G1_corners[iM1][0] is None and planes_G1_corners[iM1][1] is not None:\r\n                # Project index 0 point to index 1 plane and average with that instead of index 1 point.\r\n                pt_NewForIdx1 = rg.Point3d(pts_G1_corners[iM1][0])\r\n                xform = rg.Transform.PlanarProjection(planes_G1_corners[iM1][1])\r\n                pt_NewForIdx1.Transform(xform)\r\n                pt_Avg = (pts_G1_corners[iM1][0] + pt_NewForIdx1) / 2.0\r\n            elif planes_G1_corners[iM1][0] is not None and planes_G1_corners[iM1][1] is None:\r\n                # Project index 1 point to index 0 plane and average with that instead of index 0 point.\r\n                pt_NewForIdx0 = rg.Point3d(pts_G1_corners[iM1][1])\r\n                xform = rg.Transform.PlanarProjection(planes_G1_corners[iM1][0])\r\n                pt_NewForIdx0.Transform(xform)\r\n                pt_Avg = (pt_NewForIdx0 + pts_G1_corners[iM1][1]) / 2.0\r\n            elif vectors_01_M[iM1][0] is not None and vectors_01_M[iM1][1] is not None:\r\n                # Find intersection or closest points.\r\n                line0 = rg.Line(start=pts_G1_corners[iM1][0], span=vectors_01_M[iM1][0])\r\n                line1 = rg.Line(start=pts_G1_corners[iM1][1], span=vectors_01_M[iM1][1])\r\n                #sc.doc.Objects.AddLine(line0)\r\n                #sc.doc.Objects.AddLine(line1)\r\n                bIntersect, tA, tB = rg.Intersect.Intersection.LineLine(lineA=line0, lineB=line1, tolerance=1e-6, finiteSegments=False)\r\n                if not bIntersect:\r\n                    print(\"Do not intersect.\")\r\n                    pt_Avg = (pts_G1_corners[iM1][0] + pts_G1_corners[iM1][1]) / 2.0\r\n                else:\r\n                    pt_Avg = line0.PointAt(tA)\r\n            else:\r\n                # Either both references are or are not planes.\r\n                pt_Avg = (pts_G1_corners[iM1][0] + pts_G1_corners[iM1][1]) / 2.0\r\n            ns_WIP.Points.SetPoint(\r\n                iUT_A, iVT_A, pt_Avg,\r\n                weight=ns_M_Start.Points.GetWeight(iUT_A, iVT_A))\r\n        else:\r\n            raise Exception(\r\n                \"{} corner points recorded at index {}.\".format(\r\n                    len(pts_G1_corners[iM1]), iM1))\r\n\r\n    # Average the corner G2 locations.\r\n    for iM2 in pts_G2_corners:\r\n        iUT_A, iVT_A = getUvIdxFromNsPoint1dIdx(ns_M_Start, iM2)\r\n        if len(pts_G2_corners[iM2]) == 1:\r\n            ns_WIP.Points.SetPoint(\r\n                iUT_A, iVT_A, pts_G2_corners[iM2][0],\r\n                weight=ns_M_Start.Points.GetWeight(iUT_A, iVT_A))\r\n        elif len(pts_G2_corners[iM2]) == 2:\r\n            pt_Avg = (pts_G2_corners[iM2][0] + pts_G2_corners[iM2][1]) / 2.0\r\n            ns_WIP.Points.SetPoint(\r\n                iUT_A, iVT_A, pt_Avg,\r\n                weight=ns_M_Start.Points.GetWeight(iUT_A, iVT_A))\r\n        else:\r\n            raise Exception(\r\n                \"{} corner points recorded at index {}.\".format(\r\n                    len(pts_G2_corners[iM2]), iM2))\r\n\r\n\r\n\r\n    #pts_WIP = [cp.Location for cp in ns_M_Start.Points]\r\n\r\n    return ns_WIP\r\n\r\n\r\ndef main():\r\n    \r\n    rc = getInput()\r\n    if rc is None: return\r\n\r\n    (\r\n        objrefs_Crvs,\r\n        iContinuity_PerCrv,\r\n        bEcho,\r\n        bDebug,\r\n        ) = rc\r\n\r\n    objrefs_Crvs = tuple(objrefs_Crvs)\r\n    if not isinstance(iContinuity_PerCrv, list): \r\n        iContinuity_PerCrv = [iContinuity_PerCrv]*len(objrefs_Crvs)\r\n\r\n    Rhino.RhinoApp.CommandPrompt = \"Working ...\"\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n\r\n    rc = createSurface(\r\n        rhCrvs_In=objrefs_Crvs,\r\n        iContinuity_PerCrv=iContinuity_PerCrv,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug,\r\n        )\r\n    if rc is None:\r\n        sc.doc.Views.RedrawEnabled = True\r\n        return\r\n    if isinstance(rc, rg.NurbsSurface):\r\n        ns_Res = rc\r\n    elif isinstance(rc, tuple):\r\n        ns_Res, sLog = rc\r\n        print(sLog)\r\n        if ns_Res is None:\r\n            sc.doc.Views.RedrawEnabled = True\r\n            return\r\n    else:\r\n        raise ValueError(\"Bad output: {}\".format(rc))\r\n\r\n    if ns_Res.IsRational:\r\n        print(\"New surface is rational.  Check continuity.\")\r\n\r\n    gB_Res = sc.doc.Objects.AddSurface(ns_Res)\r\n    if gB_Res == gB_Res.Empty:\r\n        print(\"Brep could not be added to the document.\")\r\n    #else:\r\n    #    print(gB_Res)\r\n    sc.doc.Views.Redraw()\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()\r\n    #try: main()\r\n    #except Exception as ex:\r\n    #    print(\"{0}: {1}\".format(type(ex).__name__, \"\\n\".join(ex.args)))\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}