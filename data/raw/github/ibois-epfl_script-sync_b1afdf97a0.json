{
  "source_url": "https://github.com/ibois-epfl/script-sync/blob/a5d5c9a95520efd05291738c9774905011a49d08/GH/PyGH/components/scriptsynccpy/code.py",
  "repo": "ibois-epfl/script-sync",
  "repo_stars": 71,
  "repo_description": "Rhino/Grasshopper/VSCode plug-in to run C# and Python (IronPython or CPython) scripts directly from VSCode.",
  "license": "MIT",
  "filepath": "GH/PyGH/components/scriptsynccpy/code.py",
  "instruction": null,
  "code": "import System\nimport System.Drawing\nimport sys\nimport os\nimport time\n\nimport contextlib\nimport io\n\nimport typing\n\nimport abc\nimport socket\nimport threading\nimport queue\nimport json\n\nimport importlib\nimport sys\n\nimport traceback\n\nimport Rhino\nimport rhinoscriptsyntax as rs\nimport Grasshopper\nimport Grasshopper as gh\nfrom Grasshopper.Kernel import GH_RuntimeMessageLevel as RML\nimport ghpythonlib.treehelpers as th\n\n\ndef add_button(self,\n    nickname: str,\n    indx: int,\n    X_param_coord: float,\n    Y_param_coord: float,\n    X_offset: int=100\n    ) -> None:\n    \"\"\"\n        Adds a button to the component input\n\n        :param nickname: the nickname of the button\n        :param indx: the index of the input parameter\n        :param X_param_coord: the x coordinate of the input parameter\n        :param Y_param_coord: the y coordinate of the input parameter\n        :param X_offset: the offset of the button from the input parameter\n    \"\"\"\n    param = ghenv.Component.Params.Input[indx]\n    if param.SourceCount == 0:\n        button = Grasshopper.Kernel.Special.GH_ButtonObject()\n        button.NickName = \"\"\n        button.Description = \"\"\n        button.CreateAttributes()\n        button.Attributes.Pivot = System.Drawing.PointF(\n            X_param_coord - (button.Attributes.Bounds.Width) - X_offset,\n            Y_param_coord - (button.Attributes.Bounds.Height / 2 - 0.1)\n            )\n        button.Attributes.ExpireLayout()\n        Grasshopper.Instances.ActiveCanvas.Document.AddObject(button, False)\n        ghenv.Component.Params.Input[indx].AddSource(button)\n\nclass GHThread(threading.Thread, metaclass=abc.ABCMeta):\n    \"\"\"\n        A base class for Grasshopper threads.\n    \"\"\"\n    def __init__(self, name : str):\n        super().__init__(name=name, daemon=False)\n        self._component_on_canvas = True\n        self._component_enabled = True\n\n    @abc.abstractmethod\n    def run(self):\n        \"\"\" Run the thread. \"\"\"\n        pass\n\n    def _check_if_component_on_canvas(self):\n        \"\"\" Check if the component is on canvas from thread. \"\"\"\n        def __check_if_component_on_canvas():\n            if ghenv.Component.OnPingDocument() is None:\n                self._component_on_canvas = False\n                return False\n            else:\n                self._component_on_canvas = True\n                return True\n        action = System.Action(__check_if_component_on_canvas)\n        Rhino.RhinoApp.InvokeOnUiThread(action)\n\n    def _check_if_component_enabled(self):\n        \"\"\" Check if the component is enabled from thread. \"\"\"\n        def __check_if_component_enabled():\n            if ghenv.Component.Locked:\n                self._component_enabled = False\n            else:\n                self._component_enabled = True\n        action = System.Action(__check_if_component_enabled)\n        Rhino.RhinoApp.InvokeOnUiThread(action)\n\n    def expire_component_solution(self):\n        \"\"\" Fire the recalculation of the component solution from thread. \"\"\"\n        def __expire_component_solution():\n            ghenv.Component.Params.Output[0].ClearData()  # clear the output\n            ghenv.Component.ExpireSolution(True)  # expire the component\n        action = System.Action(__expire_component_solution)\n        Rhino.RhinoApp.InvokeOnUiThread(action)\n\n    def clear_component(self):\n        \"\"\" Clear the component from thread. \"\"\"\n        def __clear_component():\n            ghenv.Component.ClearData()\n        action = System.Action(__clear_component)\n        Rhino.RhinoApp.InvokeOnUiThread(action)\n\n    def add_runtime_warning(self, exception : str):\n        \"\"\" Add a warning tab to the component from main thread. \"\"\"\n        action = System.Action(\n            lambda: ghenv.Component.AddRuntimeMessage(RML.Warning, exception)\n        )\n        Rhino.RhinoApp.InvokeOnUiThread(action)\n\n    def add_runtime_error(self, exception : str):\n        \"\"\" Add an error tab to the component from main thread. \"\"\"\n        action = System.Action(\n            lambda: ghenv.Component.AddRuntimeMessage(RML.Error, exception)\n        )\n        Rhino.RhinoApp.InvokeOnUiThread(action)\n\n    def add_runtime_remark(self, exception : str):\n        \"\"\" Add a blank tab to the component from main thread. \"\"\"\n        action = System.Action(\n            lambda: ghenv.Component.AddRuntimeMessage(RML.Remark, exception)\n        )\n        Rhino.RhinoApp.InvokeOnUiThread(action)\n\n    @property\n    def component_enabled(self):\n        self._check_if_component_enabled()\n        return self._component_enabled\n\n    @property\n    def component_on_canvas(self):\n        self._check_if_component_on_canvas()\n        return self._component_on_canvas\n\nclass ClientThread(GHThread):\n    \"\"\"\n    A thread to connect to the VSCode server.\n    \"\"\"\n    def __init__(self, vscode_server_ip: str, vscode_server_port: int, name: str,\n                 queue_msg: queue.Queue = None, lock_queue_msg: threading.Lock = None,\n                 event_fire_msg: threading.Event = None):\n        super().__init__(name=name)\n        self.vscode_server_ip = vscode_server_ip\n        self.vscode_server_port = vscode_server_port\n        self.is_connected = False\n        self.connect_refresh_rate = 1  # seconds\n        self.queue_msg = queue_msg\n        self.lock_queue_msg = lock_queue_msg\n        self.event_fire_msg = event_fire_msg\n        self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    def run(self):\n        \"\"\" Run the thread. Send the message to the vscode server.\"\"\"\n        while self.component_on_canvas and self.component_enabled:\n            try:\n                if not self.is_connected:\n                    self.connect_to_vscode_server()\n                    self.clear_component()\n                    self.expire_component_solution()\n                    continue\n\n                self.event_fire_msg.wait()\n                self.send_message_from_queue()\n\n            except Exception as e:\n                self.add_runtime_warning(f\"script-sync::Unkown error from run: {str(e)}\")\n                self.is_connected = False\n                self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n        self.client_socket.close()\n\n    def send_message_from_queue(self):\n        with self.lock_queue_msg:\n            if self.queue_msg and not self.queue_msg.empty():\n                msg = self.queue_msg.get()\n                self.queue_msg.task_done()\n                self.event_fire_msg.set()\n                self.event_fire_msg.clear()\n                self.client_socket.send(msg)\n\n    def connect_to_vscode_server(self):\n        \"\"\" Connect to the VSCode server. \"\"\"\n        while self.component_on_canvas and not self.is_connected:\n            try:\n                self.client_socket.send(b\"\")\n                self.is_connected = True\n            except socket.error:\n                try:\n                    self.client_socket.connect((self.vscode_server_ip, self.vscode_server_port))\n                    self.is_connected = True\n                except (ConnectionRefusedError, ConnectionResetError, socket.error) as e:\n                    self.handle_connection_error(e)\n            finally:\n                time.sleep(self.connect_refresh_rate)\n\n    def handle_connection_error(self, e):\n        error_messages = {\n            ConnectionRefusedError: \"script-sync::Not connected to vscode\",\n            ConnectionResetError: \"script-sync::Connection was forcibly closed by the vscode\",\n            socket.error: f\"script-sync::Error connecting to the vscode: {str(e)}, have you tried to press Shift+F4 on VSCode?\"\n        }\n        self.add_runtime_warning(error_messages[type(e)])\n        self.is_connected = False if type(e) != socket.error or e.winerror != 10056 else True\n\nclass FileChangedThread(GHThread):\n    \"\"\"\n        A thread to check if the file has changed on disk.\n    \"\"\"\n    def __init__(self,\n                path : str,\n                name : str\n                ):\n        super().__init__(name=name)\n        self.path = path\n        self.refresh_rate = 1000  # milliseconds\n        self._on_file_changed = threading.Event()\n\n    def run(self):\n        \"\"\"\n            Check if the file has changed on disk.\n        \"\"\"\n        last_modified = os.path.getmtime(self.path)\n        while self.component_on_canvas and not self._on_file_changed.is_set():\n            System.Threading.Thread.Sleep(self.refresh_rate)\n            last_modified = self.is_file_modified(last_modified)\n        self._on_file_changed.clear()\n        return\n\n    def stop(self):\n        \"\"\" Stop the thread. \"\"\"\n        self._on_file_changed.set()\n\n    def is_file_modified(self, last_modified):\n        current_modified = os.path.getmtime(self.path)\n        if current_modified != last_modified:\n            self.expire_component_solution()\n            return current_modified\n        return last_modified\n\nclass ScriptSyncCPy(Grasshopper.Kernel.GH_ScriptInstance):\n    def __init__(self):\n        self._var_output = []\n\n        self.is_success = False\n\n        self.client_thread_name : str = f\"script-sync-client-thread::{ghenv.Component.InstanceGuid}\"\n        self.vscode_server_ip = \"127.0.0.1\"\n        self.vscode_server_port = 58260\n        self.stdout = None\n        self.queue_msg = queue.Queue()\n        self.queue_msg_lock = threading.Lock()\n        self.event_fire_msg = threading.Event()\n\n        self.filechanged_thread_name : str = f\"script-sync-fileChanged-thread::{ghenv.Component.InstanceGuid}\"\n        self.__path_name_table_value = \"script-sync::\" + \"path::\" + str(ghenv.Component.InstanceGuid)\n        if self.path is None:\n            ghenv.Component.Message = \"select-script\"\n        else:\n            ghenv.Component.Message = os.path.basename(self.path)\n\n        ghenv.Component.ExpireSolution(True)\n        ghenv.Component.Attributes.PerformLayout()\n        params = getattr(ghenv.Component.Params, \"Input\")\n        for j in range(len(params)):\n            X_cord = params[j].Attributes.Pivot.X\n            Y_cord = params[j].Attributes.InputGrip.Y\n            if params[j].Name == \"select_file\":\n                add_button(self, \"Select file\", j, X_cord, Y_cord)\n\n    def RemovedFromDocument(self, doc):\n        \"\"\" Remove the component from the document. \"\"\"\n        if self.client_thread_name in [t.name for t in threading.enumerate()]:\n            client_thread = [t for t in threading.enumerate() if t.name == self.client_thread_name][0]\n            client_thread.join()\n        if self.filechanged_thread_name in [t.name for t in threading.enumerate()]:\n            filechanged_thread = [t for t in threading.enumerate() if t.name == self.filechanged_thread_name][0]\n            filechanged_thread.join()\n        if self.queue_msg is not None:\n            self.queue_msg.join()\n        if self.queue_msg_lock is not None:\n            self.queue_msg_lock.release()\n        if self.event_fire_msg is not None:\n            self.event_fire_msg.clear()\n\n        # clear the path from the table view\n        del self.path\n\n    def init_script_path(self, select_file : bool = False) -> None:\n        \"\"\"\n            Check if the button is pressed and load/change path script.\n            \n            :param select_file: A boolean of the button\n        \"\"\"\n        # check if button is pressed\n        if select_file is True:\n            filename = rs.OpenFileName(\"Open\", \"Python Files (*.py)|*.py||\")\n            if filename is None:\n                raise Exception(\"script-sync::No file selected\")\n            self.path = filename\n\n        if self.path is None:\n            ghenv.Component.AddRuntimeMessage(RML.Remark, \"script-sync::No file selected\")\n            return\n        else:\n            # if file is in table view before\n            if not os.path.exists(self.path):\n                raise Exception(\"script-sync::File does not exist\")\n\n    def reload_all_modules(self, directory):\n        for filename in os.listdir(directory):\n            if filename.endswith('.py') and filename != '__init__.py':\n                module_name = filename[:-3]  # remove '.py' from filename\n                if module_name in sys.modules:\n                    importlib.reload(sys.modules[module_name])\n\n    def safe_exec(self, path, globals, locals, package_2_reload):\n        \"\"\"\n            Execute Python3 code safely. It redirects the output of the code\n            to a string buffer 'stdout' to output to the GH component param.\n            It is send to the vscode server.\n            \n            :param path: The path of the file to execute.\n            :param globals: The globals dictionary.\n            :param locals: The locals dictionary.\n            :param package_2_reload: The list of packages to reload, this is used for custom packages developement.\n            installed on the system via an editable pip installation for example.\n        \"\"\"\n        output_buffer = io.StringIO()\n        try:\n            sys.stdout = output_buffer\n            with open(path, 'r') as f:\n                # reload the specifyed packages\n                if package_2_reload is not None:\n                    if package_2_reload.__len__() != 0:\n                        for key in list(sys.modules.keys()):\n                            if package_2_reload in key:\n                                # check that the package must have the attribute __file__ (to avoid reloading pyd)\n                                if hasattr(sys.modules[key], '__file__'):\n                                    importlib.reload(sys.modules[key])\n\n                # add the path and sub directories to  the sys path\n                path_dir = os.path.dirname(path)\n                sub_dirs = []\n                for root, dirs, files in os.walk(path_dir):\n                    for d in dirs:\n                        sub_dirs.append(os.path.join(root, d))\n                sys.path.extend([path_dir] + sub_dirs)\n\n                # reload all the modules also of the sub directories\n                for root, dirs, files in os.walk(path_dir):\n                    for d in dirs:\n                        self.reload_all_modules(os.path.join(root, d))\n                self.reload_all_modules(path_dir)\n\n                # refresh the python interpreter\n                importlib.invalidate_caches()\n\n                # parse the code\n                code = compile(f.read(), path, 'exec')\n                # output = io.StringIO()\n\n                # empty the queue and event\n                with self.queue_msg_lock:\n                    while not self.queue_msg.empty():\n                        self.queue_msg.get()\n                        self.queue_msg.task_done()\n                self.event_fire_msg.clear()\n\n                # clear all the locals dictionary to avoid that the output variables stick between the component\n                # executions when it is recomputed\n                outparam = ghenv.Component.Params.Output\n                outparam_names = [p.NickName for p in outparam]\n                for outp in outparam_names:\n                    if outp in locals.keys():\n                        del locals[outp]\n\n                # execute the code\n                with contextlib.redirect_stdout(output_buffer):\n                    exec(code, globals, locals)\n                locals[\"stdout\"] = output_buffer.getvalue()\n\n                # send the msg to the vscode server\n                msg_json = json.dumps({\"script_path\": path,\n                                       \"guid\": str(ghenv.Component.InstanceGuid),\n                                       \"msg\": output_buffer.getvalue()})\n                msg_json = msg_json.encode('utf-8')\n                self.queue_msg.put(msg_json)\n                self.event_fire_msg.set()\n\n                # pass the script variables to the GH component outputs\n                for outp in outparam_names:\n                    if outp in locals.keys():\n                        self._var_output.append(locals[outp])\n                    else:\n                        self._var_output.append(None)\n            return locals\n\n        except Exception as e:\n            # Get the traceback\n            tb = traceback.format_exc()\n\n            # Send the error message to the vscode server\n            err_json = json.dumps({\n                \"script_path\": path,\n                \"guid\": str(ghenv.Component.InstanceGuid),\n                \"msg\": \"err:\" + str(e),\n                \"traceback\": tb  # Include the traceback in the JSON\n            })\n            err_json = err_json.encode('utf-8')\n            self.queue_msg.put(err_json)\n            self.event_fire_msg.set()\n\n            # FIXME: this is not working the retrival of the previous messages\n            # for debugging purposes we include the prints before and the error message\n            err_msg_header = f\"script-sync::Error in the code file {path}\"\n            err_msg_sep = \">\" * 30\n            err_msg = f\"script-sync::Error in the code: {str(e)}\\n{tb}\"\n            prints_before_err_msg = output_buffer.getvalue()\n            prints_before_msg = prints_before_err_msg.split(\"\\n\")\n\n            err_msg = err_msg_header + \\\n                f\"\\n{err_msg_sep}\\n\" + \"Error msg:\" + f\"\\n{err_msg_sep}\\n\" + \\\n                err_msg\n                # f\"\\n{err_msg_sep}\\n\" + \"Preavious prints before error:\" + f\"\\n{err_msg_sep}\\n\" + \\\n                # \"\\n\".join(prints_before_msg[:-1])\n\n            raise Exception(err_msg)\n        \n        finally:\n            sys.stdout = sys.__stdout__\n            output_buffer.close()\n\n    def RunScript(self, select_file: bool, package_2_reload: str, x : int):\n        \"\"\" This method is called whenever the component has to be recalculated it's the solve main instance. \"\"\"\n        self.is_success = False\n\n        # set up the tcp client to connect to the vscode server\n        _ = [print(t.name) for t in threading.enumerate()]\n        if self.client_thread_name not in [t.name for t in threading.enumerate()]:\n            ClientThread(self.vscode_server_ip,\n                        self.vscode_server_port,\n                        self.client_thread_name,\n                        self.queue_msg,\n                        self.queue_msg_lock,\n                        self.event_fire_msg\n                        ).start()\n        \n        # set the path if button is pressed\n        self.init_script_path(select_file)\n\n        # file change listener thread\n        if self.filechanged_thread_name not in [t.name for t in threading.enumerate()]:\n            FileChangedThread(self.path,\n                            self.filechanged_thread_name\n                            ).start()\n\n    \n\n        # add to the globals all the input parameters of the component (the locals)\n        globals().update(locals())\n\n        # execute the external script\n        if self.path is not None:\n            res = self.safe_exec(self.path, None, globals(), package_2_reload)\n            self.is_success = True\n        \n        return\n\n    def AfterRunScript(self):\n        \"\"\"\n            This method is called as soon as the component has finished\n            its calculation. It is used to load the GHComponent outputs\n            with the values created in the script.\n        \"\"\"\n        def _is_first_lvl_nested_iterable(lst : typing.List) -> bool:\n            \"\"\"\n            Detect if the first level of a list is nested. \n            e.g. \n                [1, 2, 3, 4, [5,6]] --> return value: False\n                [[1, 2], [3, 4]] --> return value: True\n\n            :param lst: The list to check\n            :return: True if the first level is nested, False otherwise\n            \"\"\"\n            return all(isinstance(item, list) for item in lst)\n        \n        def _nesting_level(container: typing.Union[typing.List, typing.Tuple]) -> int:\n            \"\"\" Get the level of nesting of a list or tuple. \"\"\"\n            if isinstance(container, (list, tuple)):\n                return 1 + max(_nesting_level(item) for item in container)\n            else:\n                return 0\n\n        def _force_nesting_list(lst : typing.List) -> list:\n            \"\"\"\n                Transform a list with nested lists into a list of lists.\n                \n                Example:\n                >>> list_C = [\n                                1, 2, 3, 4,  # {0;0}\n                                [5, 6],      # {1;0}\n                                [7, 8]       # {2;0}\n                            ]\n                >>> _force_nesting_list(list_C)\n                [[1, 2, 3, 4], [5, 6], [7, 8]]\n\n                :param lst: The list to transform\n                :return: The transformed list\n            \"\"\"\n            transformed_list = []\n            sublist = []\n            \n            for item in lst:\n                if isinstance(item, list):\n                    if sublist:\n                        transformed_list.append(sublist)\n                        sublist = []\n                    transformed_list.append(item)\n                else:\n                    sublist.append(item)\n            if sublist:\n                transformed_list.append(sublist)\n            \n            return transformed_list\n\n        def _get_list_shape(lst : typing.List) -> tuple:\n            \"\"\"\n                Get the shape of a list of lists.\n                \n                Example:\n                >>> list_A = [\n                                [\n                                    [1, 2],  # {0;0}\n                                    [3, 4]   # {0;1}\n                                ],\n                                [\n                                    [5, 6],  # {1;0}\n                                    [7, 8]   # {1;1}\n                                ]\n                            ]\n                >>> _get_list_shape(list_A)\n                (2, 2, 2)\n\n                :param lst: The list to get the shape of\n                :return: The shape of the list\n            \"\"\"\n            if isinstance(lst, list):\n                if len(lst) == 0:\n                    return (0,)\n                return (len(lst),) + _get_list_shape(lst[0])\n            else:\n                return ()\n\n        if not self.is_success:\n            return\n\n        outparam = [p for p in ghenv.Component.Params.Output]\n        outparam_names = [p.NickName for p in outparam]\n\n        for idx, outp in enumerate(outparam):\n            # case 1: nested lists\n            if type(self._var_output[idx]) == tuple or type(self._var_output[idx]) == list:\n                self._var_output[idx] = th.list_to_tree(self._var_output[idx])\n\n\n                # ghenv.Component.Params.Output[idx].VolatileData.Clear()\n\n                # list_nest_lvl = _nesting_level(self._var_output[idx])\n\n                # # case *: force the nesting of the list if it is nested but also with single elements on the first level (e.g. [1, 2, [3, 4]] --> [[1, 2], [3, 4]])\n                # if list_nest_lvl >= 2 and _is_first_lvl_nested_iterable(self._var_output[idx]) is False:\n                #     self._var_output[idx] = _force_nesting_list(self._var_output[idx])\n\n                # # case 1.A: <<< DESCRIPTION >>>\n                # if list_nest_lvl == 1:\n                #     ghenv.Component.Params.Output[idx].AddVolatileDataList(gh.Kernel.Data.GH_Path(0), self._var_output[idx])\n                # # case 1.B: <<< DESCRIPTION >>>\n                # elif list_nest_lvl == 2:\n                #     nbr_tuples_aka_branches = len(self._var_output[idx])\n                #     for i in range(nbr_tuples_aka_branches):\n                #         ghenv.Component.Params.Output[idx].AddVolatileDataList(gh.Kernel.Data.GH_Path(i), self._var_output[idx][i])\n                # # case 1.C: <<< DESCRIPTION >>>\n                # elif list_nest_lvl > 2:\n\n\n                #     # TODO: to be solved\n                #     # >>>>>>>>>>>>>>>>>>>>>>>>>\n                #     list_shape = _get_list_shape(self._var_output[idx])\n                #     # Create a recursive function to add the volatile data\n\n\n                #     def add_volatile_data_recursive(output_param, data, path):\n                #         if isinstance(data, list):\n                #             for i, item in enumerate(data):\n                #                 new_path = gh.Kernel.Data.GH_Path(path)\n                #                 new_path = new_path.AppendElement(i)\n                #                 add_volatile_data_recursive(output_param, item, new_path)\n                #         else:\n                #             output_param.AddVolatileData(path, 0, data)  # Use index 0 for leaf nodes\n\n                #     # Example usage within your existing code\n                #     nbr_tuples_aka_branches = len(self._var_output[idx])\n                #     for i in range(nbr_tuples_aka_branches):\n                #         path = gh.Kernel.Data.GH_Path(i)\n                #         add_volatile_data_recursive(ghenv.Component.Params.Output[idx], self._var_output[idx][i], path)\n                #     # <<<<<<<<<<<<<<<<<<<<<<<<<\n            # else:\n            # case 2: single values\n            ghenv.Component.Params.Output[idx].VolatileData.Clear()\n            # case 2.A: the user is returning a Grasshopper.DataTree[System.Object] via the utility ghpythonlib.treehelpers\n            # e.g.: list_tree = th.list_to_tree(list_A)\n            # this will be conserve the structure\n            if type(self._var_output[idx]) == Grasshopper.DataTree[System.Object]:\n                # self._var_output[idx].SimplifyPaths()\n                branch_count = self._var_output[idx].BranchCount\n                for i in range(branch_count):\n                    path = self._var_output[idx].Paths[i]\n                    data = self._var_output[idx].Branch(path)\n                    ghenv.Component.Params.Output[idx].AddVolatileDataList(path, data)\n            # case 2.B: simple single value\n            else:\n                ghenv.Component.Params.Output[idx].AddVolatileData(gh.Kernel.Data.GH_Path(0), 0, self._var_output[idx])\n        \n        self._var_output.clear()\n\n    @property\n    def path(self):\n        \"\"\" Get the path of the file from the table view to be sticking between the sessions. \"\"\"\n        table_value = ghenv.Component.OnPingDocument().ValueTable.GetValue(\n            self.__path_name_table_value, \"not_found\"\n        )\n        if table_value != \"not_found\":\n            return table_value\n        else:\n            return None\n\n    @path.setter\n    def path(self, path : str):\n        \"\"\" Set the path of the file to the table view to be sticking between the sessions. \"\"\"\n        ghenv.Component.OnPingDocument().ValueTable.SetValue(self.__path_name_table_value, path)\n\n        script_name = os.path.basename(path)\n        ghenv.Component.Message = f\"{script_name}\"\n\n        if self.filechanged_thread_name in [t.name for t in threading.enumerate()]:\n            _ = [t for t in threading.enumerate() if t.name == self.filechanged_thread_name][0].stop()\n\n    @path.deleter\n    def path(self):\n        \"\"\" Delete the path of the file from the table view if the object is erased. \"\"\"\n        ghenv.Component.OnPingDocument().ValueTable.DeleteValue(self.__path_name_table_value)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}