{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Brep_nakedEdgeLoop.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Brep_nakedEdgeLoop.py",
  "instruction": "Spb brep naked edge loop",
  "code": "\"\"\"\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n160924: Created.\r\n...\r\n250221,22: Added command options. Bug fix in printed output.\r\n\r\nTODO:\r\n    Move createClosedCrvs_2EdgesPerVertexOnly and getNakedEdgeIndices_2EdgesPerVertexOnly\r\n    into their own script with a UI?\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'fJoinTol'; keys.append(key)\r\n    #values[key] = sc.doc.ModelAbsoluteTolerance\r\n    value = 1e-6 * Rhino.RhinoMath.UnitScale(\r\n        Rhino.UnitSystem.Millimeters,\r\n        sc.doc.ModelUnitSystem)\r\n    values[key] = float(format(value, '.0e'))\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'fMinSegLengthToKeep'; keys.append(key)\r\n    values[key] = 1.0 * sc.doc.ModelAbsoluteTolerance\r\n    #value = 1e-3 * Rhino.RhinoMath.UnitScale(\r\n    #    Rhino.UnitSystem.Millimeters,\r\n    #    sc.doc.ModelUnitSystem)\r\n    #values[key] = float(format(value, '.0e'))\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        _debug = sc.sticky\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key in ('fJoinTol', 'fMinSegLengthToKeep'):\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < Rhino.RhinoMath.ZeroTolerance:\r\n                cls.riOpts[key].CurrentValue = Rhino.RhinoMath.ZeroTolerance\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = cls.riOpts[key].CurrentValue\r\n            return\r\n\r\n        if key in cls.listValues:\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key] = idxList\r\n\r\n        print(\"Invalid key?\")\r\n\r\n\r\n#\r\n# Functions only used externally.\r\n\r\n\r\ndef getNakedEdgeIndices_2EdgesPerVertexOnly(brep):\r\n\r\n\r\n    def getBorderEdgeInfo_OnlyVertexCountsOf2(brep):\r\n\r\n        idxs_NE_All = []\r\n        idxs_NEVs_All = []\r\n\r\n        for edge in brep.Edges:\r\n            if edge.Valence == rg.EdgeAdjacency.Naked:\r\n                idxs_NE_All.append(edge.EdgeIndex)\r\n                idxs_NEVs_All.append(\r\n                    (edge.StartVertex.VertexIndex,\r\n                        edge.EndVertex.VertexIndex))\r\n\r\n        # Edges of naked borders normally have a total of 2 count for each vertex.\r\n        # Edges with vertex counts != 2 will be ignored.\r\n        flatList = [item for pair in idxs_NEVs_All for item in pair]\r\n        idxVs_not2Count = [item for item in set(flatList) if flatList.count(item) != 2]\r\n\r\n        if not idxVs_not2Count:\r\n            return idxs_NE_All, idxs_NEVs_All\r\n        else:\r\n            idxs_NE_2CtVs, idxs_NEVs_2CtVs = [], []\r\n            for idxE, idxVs in zip(idxs_NE_All, idxs_NEVs_All):\r\n                edge = brep.Edges[idxE]\r\n                if (\r\n                    (edge.PointAtStart not in idxVs_not2Count) and\r\n                    (edge.PointAtEnd not in idxVs_not2Count)\r\n                ):\r\n                    idxs_NE_2CtVs.append(idxE)\r\n                    idxs_NEVs_2CtVs.append(idxVs)\r\n            return idxs_NE_2CtVs, idxs_NEVs_2CtVs\r\n\r\n\r\n    idx_NEs, idxs_Vs  = getBorderEdgeInfo_OnlyVertexCountsOf2(brep)\r\n\r\n    idxs_nakedEdges_perBorder = [[idx_NEs[0]]]\r\n\r\n    while True:\r\n        sc.escape_test()\r\n            \r\n        if not idxs_nakedEdges_perBorder[-1]:\r\n            # Add first items in nested lists.\r\n            for i in range(1, len(idx_NEs)):\r\n                idxE_A = idx_NEs[i]\r\n                if not any(idxE_A in idxs_Border for idxs_Border in idxs_nakedEdges_perBorder):\r\n                    idxs_nakedEdges_perBorder[-1].append(idxE_A)\r\n                    break\r\n        else:\r\n            idxE_A = idxs_nakedEdges_perBorder[-1][-1]\r\n            \r\n        for i in range(1, len(idx_NEs)):\r\n            idxE_B = idx_NEs[i]\r\n            if any(idxE_B in idxs_Border for idxs_Border in idxs_nakedEdges_perBorder):\r\n                continue\r\n            if not idxs_nakedEdges_perBorder[-1]:\r\n                # This only occurs after the 'else' in 'else' below.\r\n                idxs_nakedEdges_perBorder[-1].append(idxE_B)\r\n                continue\r\n            if (\r\n                    idxs_Vs[idx_NEs.index(idxE_A)][0] in idxs_Vs[i] or\r\n                    idxs_Vs[idx_NEs.index(idxE_A)][1] in idxs_Vs[i]\r\n            ):\r\n                idxs_nakedEdges_perBorder[-1].append(idxE_B)\r\n                break # to restart 'for i' but with the last added Edge index as Edge A.\r\n        else:\r\n            if sum([len(border) for border in idxs_nakedEdges_perBorder]) == len(idx_NEs):\r\n                # All naked edge indices are in idxs_nakedEdges_perBorder.\r\n                break # out of 'while'.\r\n            else:\r\n                # Start a new set of border edges.\r\n                idxs_nakedEdges_perBorder.append([])\r\n\r\n    #print(idxs_nakedEdges_perBorder\r\n\r\n    return idxs_nakedEdges_perBorder\r\n\r\n\r\ndef createClosedCrvs_2EdgesPerVertexOnly(brep, bDebug=False):\r\n    \"\"\"\r\n    Returns closed curves.\r\n    \"\"\"\r\n\r\n\r\n\r\n    def joinEdgeCrvsToEdgeTols(brep, idxs_Border, bDebug=False):\r\n\r\n        # Do not get EdgeCurves since they sometimes extend beyond the Edge Vertices.\r\n        crvs_toJoin = []\r\n        tols_Border = []\r\n        for iE in idxs_Border:\r\n            edge = brep.Edges[iE]\r\n            crvs_toJoin.append(edge)\r\n            tols_Border.append(edge.Tolerance)\r\n\r\n        rgCrvs_Joined = rg.Curve.JoinCurves(\r\n                crvs_toJoin,\r\n                joinTolerance=2.01*max(tols_Border))\r\n        if not rgCrvs_Joined:\r\n            1/0\r\n        elif len(rgCrvs_Joined) > 1:\r\n            if bDebug:\r\n                s  = \"More than 1 closed curve joined for a single border.\"\r\n                s += \"  This brep will not be used for trimming.\"\r\n                print(s)\r\n            return\r\n\r\n        rgCrv_Joined = rgCrvs_Joined[0]\r\n\r\n        #if not rgCrv_Joined.IsClosed:\r\n        #    sc.doc.Objects.AddCurve(rgCrv_Joined)\r\n        #    raise ValueError(\"Warning... curves for JoinCurves did not close.\")\r\n\r\n        return rgCrv_Joined\r\n\r\n\r\n\r\n    idxs_NEs_perBorder = getNakedEdgeIndices_2EdgesPerVertexOnly(brep)\r\n    crvs_Border = []\r\n    for idxs_Border in idxs_NEs_perBorder:\r\n        crv_Border = joinEdgeCrvsToEdgeTols(brep, idxs_Border, bDebug=bDebug)\r\n        if crv_Border and crv_Border.IsClosed: crvs_Border.append(crv_Border)\r\n    return crvs_Border\r\n\r\n\r\n#\r\n#\r\n\r\n\r\ndef convertObjrefsToSortedBrepsAndEdges(objrefs):\r\n    \"\"\"\r\n    Parameters:\r\n        objrefs of Edges\r\n    Returns on success:\r\n        list(GUIDs of breps)\r\n        list(list(Edge indices) per brep)\r\n    \"\"\"\r\n    \r\n    gBreps = []\r\n    idxs_Edges = []\r\n    \r\n   # Organize input into synchronized lists of brep ids and edge indices.\r\n    for objref in objrefs:\r\n        \r\n        gBrep = objref.ObjectId\r\n        idx_Edge = objref.Edge().EdgeIndex\r\n        \r\n        if gBrep not in gBreps:\r\n            # Brep not in list, so add it as well as objref's edge.\r\n            gBreps.append(gBrep)\r\n            idxs_Edges.append([idx_Edge])\r\n        else:\r\n            # Brep already in list, so add the objref's edge to the relative index.\r\n            iB = gBreps.index(gBrep)\r\n            if idx_Edge not in idxs_Edges[iB]:\r\n                idxs_Edges[iB].append(idx_Edge)\r\n    \r\n    return gBreps, idxs_Edges\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get naked edges of breps.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.EdgeFilter\r\n    go.GeometryAttributeFilter = (ri.Custom.GeometryAttributeFilter.BoundaryEdge)\r\n\r\n    go.SetCommandPrompt(\"Select one edge of each naked edge loop\")\r\n\r\n    go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n\r\n    idxs_Opts = {}\r\n\r\n    def addOption(key): idxs_Opts[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opts.clear()\r\n\r\n        addOption('fJoinTol')\r\n        addOption('fMinSegLengthToKeep')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opts:\r\n            if go.Option().Index == idxs_Opts[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef getEdgeIndicesOfBorders(rhBrep, idxs_Edges, bDebug=False):\r\n    \"\"\"\r\n    Parameter:\r\n        rhBrep\r\n        idxs_Edges: List of BrepEdge indices or None if all borders (naked edges) are to be returned.\r\n        bDebug: bool\r\n    Loop through each target edge of the brep:\r\n        Find adjacent naked edges using vertices.\r\n        Accumulate edges in a list of a naked edge loop.\r\n    Join edges of naked edge loop into a closed curve.\r\n    \r\n    Returns: 1-level deep list: Indices of BrepEdge in list per border.\r\n        The edges are in order in border loop.\r\n    \"\"\"\r\n\r\n    rgBrep = rhBrep if isinstance(rhBrep, rg.Brep) else rs.coercebrep(rhBrep)\r\n    if not rgBrep.IsValid:\r\n        print(\"Warning!  Brep is not valid.  Check results.\")\r\n\r\n    idxs_Es_perBorder = [] # 1-level deep list.\r\n\r\n    if not idxs_Edges:\r\n        idxs_Edges = [edge.EdgeIndex for edge in rgBrep.Edges if edge.Valence == rg.EdgeAdjacency.Naked]\r\n\r\n    for idx_Edge in idxs_Edges:\r\n        if bDebug:\r\n            print('-'*80)\r\n            sEval = 'idx_Edge'; print(sEval+':', eval(sEval))\r\n\r\n        # Skip edges that are already in join list.\r\n        if idx_Edge in [i for b in idxs_Es_perBorder for i in b]:\r\n            continue # To next edge.\r\n\r\n        rgEdge = rgBrep.Edges[idx_Edge]\r\n        idx_rgVertex_Start0 = rgEdge.StartVertex.VertexIndex\r\n        if bDebug: sEval = 'idx_rgVertex_Start0'; print(sEval+':', eval(sEval))\r\n        idx_rgVertex_Last = None\r\n        if bDebug: sEval = 'idx_rgVertex_Last'; print(sEval+':', eval(sEval))\r\n        idxs_Edges_in_border = []\r\n\r\n        # Accumulate indices of a border of edges.\r\n        while True:\r\n            if bDebug: print('-'*40)\r\n            sc.escape_test()\r\n            idxs_Edges_in_border.append(idx_Edge)\r\n            rgVertex_Now = rgEdge.EndVertex\r\n            idx_Vertex_Now = rgVertex_Now.VertexIndex\r\n            if bDebug: sEval = 'idx_Vertex_Now'; print(sEval+':', eval(sEval))\r\n\r\n            # When does this happen?\r\n            if bDebug: sEval = 'idx_Vertex_Now == idx_rgVertex_Last'; print(sEval+':', eval(sEval))\r\n            if idx_Vertex_Now == idx_rgVertex_Last:\r\n                if bDebug:\r\n                    print(\"End vertex matches the last end vertex, so using the start vertex instead.\")\r\n                rgVertex_Now = rgEdge.StartVertex\r\n                if bDebug: sEval = 'rgVertex_Now'; print(sEval+':', eval(sEval))\r\n                idx_Vertex_Now = rgVertex_Now.VertexIndex\r\n                if bDebug: sEval = 'idx_Vertex_Now'; print(sEval+':', eval(sEval))\r\n            \r\n            # Break out of while loop if this is the last edge of naked edge border.\r\n            if bDebug: sEval = 'idx_Vertex_Now == idx_rgVertex_Start0'; print(sEval+':', eval(sEval))\r\n            if idx_Vertex_Now == idx_rgVertex_Start0:\r\n                break\r\n            \r\n            if bDebug: sEval = 'rgVertex_Now.EdgeIndices()'; print(sEval+':', eval(sEval))\r\n            # Find next adjacent naked edge.\r\n            \r\n            idx_Es_V_Now = rgVertex_Now.EdgeIndices()\r\n            \r\n            for idx_Edge_at_Vertext in idx_Es_V_Now:\r\n                if bDebug: sEval = 'idx_Edge_at_Vertext'; print(sEval+':', eval(sEval))\r\n                rgEdge = rgBrep.Edges[idx_Edge_at_Vertext]\r\n                \r\n                if bDebug:\r\n                    sEval = 'idx_Edge_at_Vertext != idx_Edge'; print(sEval+':', eval(sEval))\r\n                    sEval = 'idx_Edge_at_Vertext not in idxs_Edges_in_border'; print(sEval+':', eval(sEval))\r\n                    sEval = 'rgEdge.Valence == rg.EdgeAdjacency.Naked'; print(sEval+':', eval(sEval))\r\n                \r\n                if (\r\n                        idx_Edge_at_Vertext != idx_Edge and\r\n                        idx_Edge_at_Vertext not in idxs_Edges_in_border and\r\n                        rgEdge.Valence == rg.EdgeAdjacency.Naked\r\n                ):\r\n                    idx_Edge = idx_Edge_at_Vertext\r\n                    if bDebug: sEval = 'idx_Edge'; print(sEval+':', eval(sEval))\r\n                    idx_rgVertex_Last = idx_Vertex_Now\r\n                    if bDebug: sEval = 'idx_rgVertex_Last'; print(sEval+':', eval(sEval))\r\n                    break\r\n            else: print(\"Next adjacent naked edge not found!\")\r\n\r\n        idxs_Es_perBorder.append(idxs_Edges_in_border)\r\n\r\n    return idxs_Es_perBorder\r\n\r\n\r\ndef removeIndicesOfShortEdges(rhBrep, idxs_Edges_in_border, fMinSegLengthToKeep=None):\r\n    rgBrep = rhBrep if isinstance(rhBrep, rg.Brep) else rs.coercebrep(rhBrep)\r\n    for idx in reversed(idxs_Edges_in_border):\r\n        fLength = rgBrep.Edges[idx].GetLength()\r\n        if fLength < fMinSegLengthToKeep:\r\n            idxs_Edges_in_border.remove(idx)\r\n\r\n\r\ndef get_joined_curves(rhBrep, idxs_Edges_per_border, fJoinTol=None, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        rhBrep: rg.Brep, rd.BrepObject, or (GUID of brep)\r\n        idxs_Edges_per_border: These are ordered to border loop.\r\n        fJoinTol\r\n        bEcho\r\n        bDebug\r\n        \r\n    Returns on success:\r\n        list(rg.Curve (0-level deep))\r\n    \"\"\"\r\n\r\n    rgBrep = rs.coercebrep(rhBrep)\r\n\r\n    rgCrvs_Borders = []\r\n\r\n    for idxEs_of_border in idxs_Edges_per_border:\r\n        rgEdges_in_border = [rgBrep.Edges[idx] for idx in idxEs_of_border]\r\n        rgCrvs = rg.Curve.JoinCurves(rgEdges_in_border, joinTolerance=fJoinTol)\r\n        rgCrvs_Borders.extend(rgCrvs)\r\n\r\n    return rgCrvs_Borders\r\n\r\n\r\ndef add_CurvesOfBorders(rgCrvs, bEcho=True, bDebug=False):\r\n    \r\n    gCurves_borders = []\r\n    \r\n    for rgCrv in rgCrvs:\r\n        if not rgCrv.IsClosed: bAllCurvesClosed = False\r\n        gCrv = sc.doc.Objects.AddCurve(rgCrv)\r\n        if gCrv == Guid.Empty: continue\r\n        sc.doc.Objects.Select(gCrv)\r\n        gCurves_borders.append(gCrv)\r\n    \r\n    return gCurves_borders\r\n\r\n\r\ndef processBrep(rgBrep, idxs_Trims, fMinSegLengthToKeep=None, fJoinTol=None, bEcho=True, bDebug=False):\r\n\r\n    idxs_Edges_per_border = getEdgeIndicesOfBorders(\r\n        rgBrep,\r\n        idxs_Trims,\r\n        bDebug=bDebug)\r\n    if idxs_Edges_per_border is None: return\r\n\r\n    if fMinSegLengthToKeep:\r\n        for idxEs_of_border in idxs_Edges_per_border:\r\n            removeIndicesOfShortEdges(\r\n                rgBrep,\r\n                idxEs_of_border,\r\n                fMinSegLengthToKeep=fMinSegLengthToKeep)\r\n\r\n    rgCrvs_Borders = get_joined_curves(\r\n        rgBrep,\r\n        idxs_Edges_per_border,\r\n        fJoinTol=fJoinTol,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug)\r\n    return rgCrvs_Borders\r\n\r\n\r\ndef processBrepObjects(rhBreps, idx_Trims_PerBrep, fMinSegLengthToKeep=None, fJoinTol=None, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        rdBreps, # list(rd.BrepObject's or GUID's of them)\r\n        idx_Trims_PerBrep,\r\n        bEcho,\r\n        bDebug\r\n    Returns on success:\r\n        list(list(GUIDs of curves) per brep))\r\n    \"\"\"\r\n\r\n    gCurves_Borders_PerBrep = [] # 1-level deep list nesting.\r\n\r\n    for rhBrep, idxs_Trims in zip(rhBreps, idx_Trims_PerBrep):\r\n        rgBrep_In = rs.coercebrep(rhBrep)\r\n\r\n        rgCrvs_Borders = processBrep(\r\n            rgBrep_In,\r\n            idxs_Trims,\r\n            fMinSegLengthToKeep=fMinSegLengthToKeep,\r\n            fJoinTol=fJoinTol,\r\n            bEcho=bEcho,\r\n            bDebug=bDebug)\r\n        if rgCrvs_Borders is None:\r\n            continue\r\n\r\n        gCurves_Borders = add_CurvesOfBorders(\r\n            rgCrvs_Borders,\r\n            bEcho,\r\n            bDebug)\r\n\r\n        if gCurves_Borders is None:\r\n            continue\r\n\r\n        gCurves_Borders_PerBrep.append(gCurves_Borders)\r\n    \r\n    return gCurves_Borders_PerBrep\r\n\r\n\r\ndef main():\r\n\r\n    objrefs = getInput()\r\n    if not objrefs: return\r\n\r\n    fJoinTol = Opts.values['fJoinTol']\r\n    fMinSegLengthToKeep = Opts.values['fMinSegLengthToKeep']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    #if not bDebug: sc.doc.Views.RedrawEnabled=False\r\n\r\n    rc = convertObjrefsToSortedBrepsAndEdges(objrefs)\r\n    if rc is None: return\r\n\r\n    gBreps, idxs_Edges_per_Brep = rc\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n    \r\n    gCurves_Borders_PerBrep = processBrepObjects(\r\n        gBreps,\r\n        idxs_Edges_per_Brep,\r\n        fMinSegLengthToKeep=fMinSegLengthToKeep,\r\n        fJoinTol=fJoinTol,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug)\r\n    if gCurves_Borders_PerBrep is None: return\r\n    \r\n    sc.doc.Views.Redraw()\r\n    \r\n    iCt_Crvs_added = 0\r\n    iCt_Open = 0\r\n    for gCurves_borders in gCurves_Borders_PerBrep:\r\n        for gCurve in gCurves_borders:\r\n            if not rs.IsCurveClosed(gCurve):\r\n                iCt_Open += 1\r\n            iCt_Crvs_added += 1\r\n    \r\n    if iCt_Crvs_added == 1:\r\n        if not iCt_Open:\r\n            print(\"1 closed curve added to document.\")\r\n        else:\r\n            print(\"1 open curve added to document.\")\r\n    else:\r\n        if iCt_Open == 0:\r\n            print(\"{} closed curves added to document.\".format(iCt_Crvs_added))\r\n        elif iCt_Open == iCt_Crvs_added:\r\n            print(\"{} open curves added to document.\".format(iCt_Open))\r\n        else:\r\n            print(\"{} open and {} closed curves added to document.\".format(\r\n                iCt_Open, iCt_Crvs_added-iCt_Open))\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}