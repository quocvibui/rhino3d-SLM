{
  "source_url": "https://github.com/Hand-and-Machine/extruder-turtle-Rhino/blob/68b9f4a35b6e2ff867de22a4eb8817569858def9/extruder_turtle/turtle_slice.py",
  "repo": "Hand-and-Machine/extruder-turtle-Rhino",
  "repo_stars": 3,
  "repo_description": null,
  "license": "MIT",
  "filepath": "extruder_turtle/turtle_slice.py",
  "instruction": "Turtle slice",
  "code": "import copy\nimport Rhino.Geometry as geom\nimport rhinoscriptsyntax as rs\nimport ExtruderTurtle as e\nimport operator as op\nimport math\nimport random\n\n# slices a shape using layer_height\ndef slice_with_turtle (t, shape, walls = 1, layer_height=False, spiral_up=False, bottom = False):\n\tif (layer_height==False or layer_height == 0):\n\t\tlayer_height = t.get_layer_height()\n\tbb = rs.BoundingBox(shape)\n\theight = rs.Distance(bb[0], bb[4])\n\tprint(\"height: \" +str(height))\n\tlayers = int(round(height/layer_height)) # number of slices\n\tprint(\"layers: \" +str(layers))\n\tsize = rs.Distance(bb[0], bb[6])*2 # size of slicing plane\n\tpoint_bottom = (rs.CreatePoint(0,0,bb[0].Z))\n\tpoint_top = (rs.CreatePoint(0,0,bb[4].Z))\n\n\tslices = rs.AddSrfContourCrvs(shape,(point_bottom,point_top),layer_height)\n\n\t#follow slice curves with turtle\n\tfollow_slice_curves_with_turtle(t,slices,walls=walls,spiral_up=spiral_up, bottom=bottom)\n\n\treturn slices\n\n# given a list of curves that slice a shape (slices)\n# follow the curves with the turtle\ndef follow_slice_curves_with_turtle(t,slices,walls=1, bottom = False, spiral_up=False, matrix = False):\n\tresolution = t.get_resolution()\n\n\tif (bottom!=False):\n\t\tbottom_layers = bottom\n\telse:\n\t\tbottom_layers = 0\n\n\t#z0 = t.getZ()\n\tpoints = rs.DivideCurve (slices[0], 100)\n\tt.set_position(points[0].X, points[0].Y, points[0].Z)\n\tz0 = points[0].Z\n\n\tlayers = len(slices)\n\t# generate paths for all layers\n\tfor i in range (0,layers):\n\t\tif (matrix):\n\t\t\tnum_points = len(matrix)\n\t\telse:\n\t\t\tpoints = rs.DivideCurve (slices[i], 100)\n\t\t\tll = line_length(points)\n\t\t\tnum_points = int(ll/resolution)\n\t\tpoints = rs.DivideCurve (slices[i], num_points)\n\n\t\t# account for current z position\n\t\t# move slices up if necessary\n\t\tif (z0 != 0):\n\t\t\tfor j in range (num_points):\n\t\t\t\tpoints[j].Z = points[j].Z+z0\n\t\t\n\t\t# spiral up if possible and relevant\n\t\t# don't spiral up on the last layer\n\t\t# don't spiral up on the bottom layers\n\t\tif (walls == 1 and spiral_up and i<layers-1 and i>bottom_layers):\n\t\t\tpoints_next = rs.DivideCurve (slices[i+1], num_points)\n\t\t\tz_inc = (points_next[0].Z+z0-points[0].Z)/num_points\n\t\t\tfollow_closed_line (t,points,z_inc=z_inc, matrix = matrix)\n\t\telse:\n\t\t\tfollow_closed_line(t,points,walls=walls, matrix = matrix)\n\n\t\tif (i < bottom_layers):\n\t\t\tspiral_bottom(t,slices[i],walls)   \n\n# given a list of curves that slice a shape (slices)\n# follow the curves with the turtle\ndef follow_slice_curves_woven(t,slices, bottom = False, spiral_up=False, matrix = False, num_oscillations=False, amplitude = False):\n\tresolution = t.get_resolution()\n\tinitial_n_points = 25\n\tif (num_oscillations==False):\n\t\tnum_oscillations = 21\n\tif (amplitude==False):\n\t\tamplitude=1\n\tif (bottom!=False):\n\t\tbottom_layers = bottom\n\telse:\n\t\tbottom_layers = 0\n\t\n\t# find starting point\n\tpoints = rs.DivideCurve (slices[0], initial_n_points)\n\tt.penup()\n\tt.set_position(points[0].X, points[0].Y, points[0].Z)\n\tt.pendown()\n\tz0 = points[0].Z\n\tlayers = len(slices)\n\n\t# create shape\n\t# generate paths for all layers\n\tvolume = 0\n\textruder_distance = 0\n\tmass = 0\n\t#t.set_tube_color(159, 102, 119)\n\t#t.set_tube_color(180, 43, 97)\n\tfor i in range (0,layers):\n\t\tif (matrix):\n\t\t\tnum_points = len(matrix)\n\t\telse:\n\t\t\tpoints = rs.DivideCurve (slices[i], initial_n_points)\n\t\t\tll = line_length(points)\n\t\t\tnum_points = int(ll/resolution)\n\n\t\tpoints = rs.DivideCurve (slices[i], num_points)\n\n\t\t# change number of oscillations to fit layer\n\t\t# comment out for constant number of oscillations\n\t\t#num_oscillations = len(points)/8\n\t\tif (num_oscillations%2==0):\n\t\t\tnum_oscillations = num_oscillations+1\n\n\t\t#print(\"num_oscillations: \" +str(num_oscillations))\n\n\t\tif (i%2==0):\n\t\t\ttheta_offset = 0\n\t\telse:\n\t\t\ttheta_offset = 180\n\n\t\t#main wall layers\n\t\tif (spiral_up and i<layers-1 and i>bottom_layers):\n\t\t\tpoints_next = rs.DivideCurve (slices[i+1], num_points)\n\t\t\tz_inc = (points_next[0].Z+z0-points[0].Z)/num_points\n\t\t\tfollow_closed_line_weave(t,points=points, num_oscillations=num_oscillations, amplitude = amplitude, z_inc = z_inc, theta_offset=theta_offset)\n\t\t# bottom layers\n\t\telse:\n\t\t\tfollow_closed_line_weave(t,points=points, num_oscillations=num_oscillations, amplitude = amplitude, theta_offset=theta_offset)\n\n\t\tif (i < bottom_layers):\n\t\t\tspiral_bottom(t,slices[i],walls=1) \n\t\tif (spiral_up==False or i<bottom_layers):\n\t\t\tt.lift(t.get_layer_height())\n\t\tif (i==bottom_layers or i==layers-2):\n\t\t\tt.lift(t.get_layer_height()/2)\n\n\n#generates a turtle path from a curve or a list of rhinoscript points\ndef follow_closed_line(t,points=False,curve=False,z_inc=0,walls = 1,matrix=False):\n\tif (not(curve) and not(points)):\n\t\tprint(\"You need to provide this function with either a curve or a list of points\")\n\t\treturn\n\tif (curve):\n\t\t#print(\"got a curve\")\n\t\tresolution = t.get_resolution()\n\t\tpoints = rs.DivideCurve (curve, 100)\n\t\tll = line_length(points)\n\t\tnum_points = int(ll/resolution)+1\n\t\tpoints = rs.DivideCurve (curve, num_points)\n\n\t# on multi-walled prints\n\t# stop extruding near the seam to avoid a bump\n\tsmooth_seam = 0 \n\t#start with pen up\n\tt.penup()\n\n\t# t2 keeps track of points for next wall\n\tt2 = e.ExtruderTurtle()\n\tt2.penup()\n\n\t# follow the curve\n\t# generate points for next wall if applicable (poinst2)\n\tpoints2 = []\n\tfor i in range (0, len(points)):\n\t\t# matrix marks pen up spots in path\n\t\tif (matrix and matrix[i]==1):\n\t\t\tt.penup()\n\t\telse:\n\t\t\tt.pendown()\n\n\t\t# move to next point\n\t\tif (z_inc==0 or walls > 1):\n\t\t\tt.set_position(points[i].X,points[i].Y,points[i].Z)\n\t\telse:\n\t\t\tt.set_position(points[i].X,points[i].Y)\n\t\t\tt.lift(z_inc)\n\n\t\t# pen up between walls\n\t\tif (i>=smooth_seam):\n\t\t\tt.pendown()\n\t\tif ((i>=len(points)-smooth_seam) and walls>1):\n\t\t\tt.penup()\n\n\t\t# get points for next wall\n\t\tif (walls>1):\n\t\t\tt2.set_position(points[i].X,points[i].Y,points[i].Z)\n\t\t\tt2.left(90)\n\t\t\tt2.forward(t.get_extrude_width()*.75)\n\t\t\tx1 = t2.getX()\n\t\t\ty1 = t2.getY()\n\t\t\tz1 = t2.getZ()\n\t\t\tt2.backward(t.get_extrude_width()*.75)\n\t\t\tt2.right(90)\n\t\t\tpoints2.append(rs.CreatePoint(x1,y1,z1))\n\n\t#close the layer curve\n\tif (z_inc==0 or walls > 1):\n\t\tt.set_position(points[0].X,points[0].Y,points[0].Z)\n\telse:\n\t\tt.set_position(points[0].X,points[0].Y)\n\n\t# draw second wall\n\twhile (walls>1):\n\t\tt.penup()\n\t\tfor i in range (1, len(points2)):\n\t\t\tif (matrix and matrix[i]==1):\n\t\t\t\tt.penup()\n\t\t\telse:\n\t\t\t\tt.pendown()\n\t\t\tt.set_position(points2[i].X,points2[i].Y,points[i].Z)\n\t\t\tif (i>=smooth_seam):\n\t\t\t\tt.pendown()\n\t\t\tif (i>=len(points2)-smooth_seam):\n\t\t\t\tt.penup()\n\t\twalls = walls-1\n\t\t# you've drawn 2 walls, subtract these and draw the next wall\n\t\t'''\n\t\twalls = walls-2\n\t\tif (walls > 1):\n\t\t\tfollow_closed_line(t, points2, walls = walls)\n\t\t'''\n\ndef spiral_bottom(t,curve,walls=1):\n\textrude_rate = t.get_extrude_rate()\\\n\tarea = 0\n\tprevious_area = 10\n\ti = 0\n\tcount = 100\n\tprevious_area = rs.CurveArea(curve)\n\tarea = previous_area\n\tcurve_center_previous =0\n\n\twhile (area <=previous_area and i<count):\n\t\tcurve_center = rs.CurveAreaCentroid(curve)\n\t\tif (curve_center):\n\t\t\tcurve_center = curve_center[0]\n\t\t\tcurve_center_previous = curve_center\n\t\telse:\n\t\t\tprint(\"Couldn't get a center point, using previous.\")\n\t\t\tcurve_center = curve_center_previous\n\n\t\to = rs.OffsetCurve(curve,curve_center,t.get_extrude_width())\n\t\tif (area):\t\n\t\t\tprevious_area = area\n\t\telse:\n\t\t\tprint(\"Couldn't get an area, using previous.\")\n\t\t\n\t\t# if there is a viable offset curve, compute the new area\n\t\t# otherwise, get out ot the loop\n\t\tif (o):\n\t\t\ttry:\n\t\t\t\tarea = rs.CurveArea(o)\n\t\t\texcept:\n\t\t\t\tprint(\"Challenging bottom 1. Re-computing.\")\n\t\t\t\ttry:\n\t\t\t\t\to = rs.OffsetCurve(curve,curve_center,t.get_extrude_width()-.5)\n\t\t\t\texcept:\n\t\t\t\t\tprint(\"Challenging bottom 2. Re-computing.\")\n\t\t\t\t\to = rs.OffsetCurve(curve,curve_center,t.get_extrude_width()+.5)\n\t\t\t\ttry:\n\t\t\t\t\tarea = rs.CurveArea(o)\n\t\t\t\texcept:\n\t\t\t\t\tprint(\"Couldn't get an area.\")\n\t\t\t\t\tbreak\n\t\telse:\n\t\t\t#print(\"Challenging bottom 3. Exiting.\")\n\t\t\tbreak\n\n\t\t# if you have reached the inner-most ring of bottom, get out of loop\n\t\tif (area>previous_area):\n\t\t\tprint(\"Next area larger. \")\n\t\t\tprint(\"previous_area = \" +str(previous_area) + \", area: \" +str(area))\n\t\t\t#follow_closed_line(t,curve=o)\n\t\t\tprint(i)\n\t\t\tbreak\n\t\telse:\n\t\t\tfollow_closed_line(t,curve=o)\n\t\t\tcurve = o\n\t\ti = i+1\n\n\tif (curve_center):\n\t\treturn curve_center\n\telse:\n\t\treturn curve_center_previous\n\n\n#generates a turtle path from a curve or a list of rhinoscript points\ndef follow_closed_line_chase (t,points=False,curve=False,z_inc=0,angle=50,movement=1):\n\tif (not(curve) and not(points)):\n\t\tprint(\"You need to provide this function with either a curve or a list of points\")\n\t\treturn\n\tif (curve):\n\t\t#print(\"got a curve\")\n\t\tresolution = t.get_resolution()*4.5\n\t\tpoints = rs.DivideCurve (curve, 100)\n\t\tll = line_length(points)\n\t\tnum_points = int(ll/resolution)\n\t\tpoints = rs.DivideCurve (curve, num_points)\n\n\tif (points):\n\t\tnum_points = len(points)\n\t\tt_extra_steps = 10\n\n\tif (num_points<15):\n\t\tmovment = movement/3.5\n\t\tt_extra_steps = 12\n\n\t# t2 follows the basic curve, t will chase t2\n\tt2 = e.ExtruderTurtle()\n\t\n\tif (z_inc==0 or walls > 1):\n\t\tt2.set_position(points[0].X,points[0].Y,points[0].Z)\n\telse:\n\t\tt2.set_position(points[0].X,points[0].Y)\n\n\tprevious_distance_sq = 10000000\n\n\tfor i in range (0, len(points)):\n\t\t# move to next point\n\t\tif (z_inc==0 or walls > 1):\n\t\t\tt2.set_position(points[i].X,points[i].Y,points[i].Z)\n\t\t\t#t.set_position(z=points[i].Z)\n\t\telse:\n\t\t\tt2.set_position(points[i].X,points[i].Y)\n\t\t\tt2.lift(z_inc)\n\n\t\tfor s in range (0,t_extra_steps):\n\t\t\tdistance_sq = distance_squaredXY(t2.get_position(), t.get_position())\n\t\t\tif (distance_sq > previous_distance_sq):\n\t\t\t\tt.right(angle)\n\t\t\t\tt.forward (movement)\n\t\t\telse:\n\t\t\t\tt.right(random.randint(-(angle-15),angle-15))\n\t\t\t\tt.forward(movement)\n\t\t\tif (z_inc>0):\n\t\t\t\tt.lift(z_inc)\n\t\t\tprevious_distance_sq = distance_sq\n\n\ndef follow_closed_line_weave(t,points=False, curve=False, num_oscillations=25.0, amplitude = 2, theta_offset=0, z_inc=0, extra_support=False):\n\tif (not(curve) and not(points)):\n\t\tprint(\"You need to provide this function with either a curve or a list of points\")\n\t\treturn\n\tif (curve):\n\t\tresolution = t.get_resolution()/2\n\t\tpoints = rs.DivideCurve (curve, 100)\n\t\tll = line_length(points)\n\t\tnum_points = int(ll/resolution)+1\n\t\tpoints = rs.DivideCurve (curve, num_points)\n\n\tnum_points = len(points)\n\tt2 = e.ExtruderTurtle()\n\tif (z_inc==0):\n\t\tt2.set_position(points[0].X,points[0].Y,points[0].Z)\n\telse:\n\t\tt2.set_position(points[0].X,points[0].Y)\n\n\tdtheta = 360.0/num_points\n\ttheta = 0.0\n\tx0 = 0.0\n\ty0 = 0.0\n\n\tif (theta_offset):\n\t\ttheta0 = 180\n\telse:\n\t\ttheta_offset = 0\n\t\ttheta0 = 0\n\n\tif (extra_support):\n\t\t#non-oscillating line for support\n\t\tdelta = t.get_extrude_width()*1.25\n\t\tfor i in range (0, num_points):\n\t\t\tif (z_inc==0):\n\t\t\t\tt2.set_position(points[i].X,points[i].Y,points[i].Z)\n\t\t\telse:\n\t\t\t\tt2.set_position(points[i].X,points[i].Y)\n\t\t\t#get the new point with spare turtle\n\t\t\tt2.right(90)\n\t\t\tt2.forward(-delta)\n\t\t\tx = t2.getX()\n\t\t\ty = t2.getY()\n\t\t\tif (i==0):\n\t\t\t\tx0 = x\n\t\t\t\ty0 = y\n\t\t\tt2.forward(delta)\n\t\t\tt2.left(90)\n\t\t\t#set main turtle's position\n\t\t\tif (i!=0):\n\t\t\t\tt.set_position(x,y)\n\t\t\tif (z_inc!=0):\n\t\t\t\tt.lift(z_inc)\n\t\t\ttheta = theta + dtheta\n\n\t#weave\n\tfor i in range (0, num_points):\n\t\tif (z_inc==0):\n\t\t\tt2.set_position(points[i].X,points[i].Y,points[i].Z)\n\t\telse:\n\t\t\tt2.set_position(points[i].X,points[i].Y)\n\t\tdelta = amplitude*math.cos(num_oscillations*math.radians(theta+theta0))\n\t\t#get the oscillating point with spare turtle\n\t\tt2.right(90)\n\t\tt2.forward(delta)\n\t\tx = t2.getX()\n\t\ty = t2.getY()\n\t\tif (i==0):\n\t\t\tx0 = x\n\t\t\ty0 = y\n\t\tt2.backward(delta)\n\t\tt2.left(90)\n\t\t#set main turtle's position\n\t\tif (i!=0):\n\t\t\tt.set_position(x,y)\n\t\t\tif (t.get_pen()==False):\n\t\t\t\tt.pen_down()\n\t\tif (z_inc!=0):\n\t\t\tt.lift(z_inc)\n\t\ttheta = theta + dtheta\n\n\treturn t2\n\ndef distance_squaredXY (p0, p1):\n\tds = (p1.X-p0.X)*(p1.X-p0.X)+(p1.Y-p0.Y)*(p1.Y-p0.Y)\n\treturn ds",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}