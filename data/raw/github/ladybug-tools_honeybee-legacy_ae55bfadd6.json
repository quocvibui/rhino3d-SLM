{
  "source_url": "https://github.com/ladybug-tools/honeybee-legacy/blob/bd62af4862fe022801fb87dbc8794fdf1dff73a9/src/Honeybee_Set%20EP%20Zone%20Interior%20Construction.py",
  "repo": "ladybug-tools/honeybee-legacy",
  "repo_stars": 129,
  "repo_description": ":bee: Honeybee is a free and open source plugin to connect Grasshopper3D to EnergyPlus, Radiance, Daysim and OpenStudio for building energy and daylighting simulation",
  "license": "NOASSERTION",
  "filepath": "src/Honeybee_Set EP Zone Interior Construction.py",
  "instruction": "Set EP Zones Interior Construction",
  "code": "# Set EP Zones Interior Construction\n#\n# Honeybee: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Honeybee.\n# \n# Copyright (c) 2013-2020, Mostapha Sadeghipour Roudsari <mostapha@ladybug.tools> \n# Honeybee is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Honeybee is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Honeybee; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nSet EP Zones Interior Construction\n\n-\nProvided by Honeybee 0.0.66\n    \n    Args:\n        _HBZones: Honeybee zones\n        intWallEPConstruction_: Optional new construction for interior walls\n        intWindowEPConstruction_: Optional new construction for interior windows \n        intFloorEPConstruction_: Optional new construction for interior floors\n        intCeilingEPConstruction_: Optional new construction for interior ceilings.  If no value is connected here but a value is connected for interior floors, the intCeiling construction will be assumed to be the same as the intFloor construction above.\n    Returns:\n        modifiedHBZones:  Honeybee zone with updated constructions\n\n\"\"\"\n\nghenv.Component.Name = \"Honeybee_Set EP Zone Interior Construction\"\nghenv.Component.NickName = 'setEPZoneIntCnstr'\nghenv.Component.Message = 'VER 0.0.66\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"HB-Legacy\"\nghenv.Component.SubCategory = \"08 | Energy | Set Zone Properties\"\n#compatibleHBVersion = VER 0.0.56\\nDEC_15_2016\n#compatibleLBVersion = VER 0.0.59\\nFEB_01_2015\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"0\"\nexcept: pass\n\nimport scriptcontext as sc\nimport Rhino as rc\nimport Grasshopper.Kernel as gh\n\n\ndef updateZoneMixing(surface1, zone1, zone2):\n    #Change the air mixing between the zone and other zones to \"True\"\n    zone1.mixAir = True\n    zone2.mixAir = True\n    \n    #Append the zone to be mixed with to the mixAirZoneList.\n    zone1.mixAirZoneList.append(zone2.name)\n    zone2.mixAirZoneList.append(zone1.name)\n    \n    #Calculate a rough flow rate of air based on the cross-sectional area of the surface between them.\n    flowFactor = zone1.mixAirFlowRate\n    flowRate = (rc.Geometry.AreaMassProperties.Compute(surface1.geometry).Area)*sc.sticky[\"honeybee_ConversionFactor\"]*sc.sticky[\"honeybee_ConversionFactor\"]*flowFactor\n    \n    #Append the flow rate of mixing to the mixAirFlowList\n    zone1.mixAirFlowList.append(flowRate)\n    zone2.mixAirFlowList.append(flowRate)\n    \n    #Append the flow shcedule to the mixing list.\n    zone1.mixAirFlowSched.append('ALWAYS ON')\n    zone2.mixAirFlowSched.append('ALWAYS ON')\n    \n    return flowRate\n\ndef checkAirWalls(construction, srf):\n    if construction.ToUpper() == \"AIR WALL\":\n        srf.setType(4, isUserInput= True)\n        updateZoneMixing(srf, srf.parent, srf.BCObject.parent)\n\ndef matchLists(input, length):\n    il = len(input)\n    if il == 0:\n        return tuple(None for i in range(length))\n    else:\n        return tuple(input[i] if i < il else input[-1] for i in range(length))\n        \ndef main(HBZones, wallEPCnst, windowEPCnst, flrEPCnst, cielConstr):\n    \n    # Make sure Honeybee is flying\n    if not sc.sticky.has_key('honeybee_release'):\n        print \"You should first let Honeybee to fly...\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, \"You should first let Honeybee to fly...\")\n        return -1\n\n    try:\n        if not sc.sticky['honeybee_release'].isCompatible(ghenv.Component): return -1\n        if sc.sticky['honeybee_release'].isInputMissing(ghenv.Component): return -1\n    except:\n        warning = \"You need a newer version of Honeybee to use this compoent.\" + \\\n        \" Use updateHoneybee component to update userObjects.\\n\" + \\\n        \"If you have already updated userObjects drag Honeybee_Honeybee component \" + \\\n        \"into canvas and try again.\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n        return -1\n    \n    # call the objects from the lib\n    hb_hive = sc.sticky[\"honeybee_Hive\"]()\n    HBZoneObjects = hb_hive.callFromHoneybeeHive(HBZones)\n    \n    hb_EPObjectsAux = sc.sticky[\"honeybee_EPObjectsAUX\"]()\n    modifiedObjects = []\n    l = len(HBZoneObjects)\n    wallEPCnst = matchLists(wallEPCnst, l)\n    windowEPCnst = matchLists(windowEPCnst, l)\n    flrEPCnst = matchLists(flrEPCnst, l)\n    cielConstr = matchLists(cielConstr, l)\n    \n    for count, HBZoneObject in enumerate(HBZoneObjects):\n        for srf in HBZoneObject.surfaces:\n            if srf.BC.lower() == \"surface\" or srf.BC.lower() == \"adiabatic\": # only internal surfaces\n                if windowEPCnst[count]!=None and srf.hasChild:\n                    for childSrf in srf.childSrfs:\n                        hb_EPObjectsAux.assignEPConstruction(childSrf, windowEPCnst[count], ghenv.Component)\n                        if srf.BC.lower() == \"surface\":\n                            hb_EPObjectsAux.assignEPConstruction(childSrf.BCObject, windowEPCnst[count], ghenv.Component)\n                            if windowEPCnst[count].ToUpper() == \"AIR WALL\":\n                                updateZoneMixing(childSrf, srf.parent, srf.BCObject.parent)\n                if srf.type == 0 and wallEPCnst[count]!=None:\n                    hb_EPObjectsAux.assignEPConstruction(srf, wallEPCnst[count], ghenv.Component)\n                    if srf.BC.lower() == \"surface\" or srf.BC.lower() == \"adiabatic\":\n                        if srf.BC.lower() == \"surface\":\n                            hb_EPObjectsAux.assignEPConstruction(srf.BCObject, wallEPCnst[count], ghenv.Component)\n                        else:\n                            hb_EPObjectsAux.assignEPConstruction(srf, wallEPCnst[count], ghenv.Component)\n                        checkAirWalls(wallEPCnst[count], srf)\n                elif (srf.type == 3 and cielConstr[count]!=None) or (srf.type == 1 and srf.BC.lower() == \"adiabatic\" and cielConstr[count]!=None):\n                    hb_EPObjectsAux.assignEPConstruction(srf, cielConstr[count], ghenv.Component)\n                    if srf.BC.lower() == \"surface\" or srf.BC.lower() == \"adiabatic\":\n                        if srf.BC.lower() == \"surface\":\n                            hb_EPObjectsAux.assignEPConstruction(srf.BCObject, cielConstr[count], ghenv.Component)\n                        else:\n                            hb_EPObjectsAux.assignEPConstruction(srf, cielConstr[count], ghenv.Component)\n                        checkAirWalls(cielConstr[count], srf)\n                elif (srf.type == 2 or srf.type == 3) and flrEPCnst[count]!=None:\n                    hb_EPObjectsAux.assignEPConstruction(srf, flrEPCnst[count], ghenv.Component)\n                    if srf.BC.lower() == \"surface\" or srf.BC.lower() == \"adiabatic\":\n                        if srf.BC.lower() == \"surface\":\n                            hb_EPObjectsAux.assignEPConstruction(srf.BCObject, flrEPCnst[count], ghenv.Component)\n                        else:\n                            hb_EPObjectsAux.assignEPConstruction(srf, flrEPCnst[count], ghenv.Component)\n                        checkAirWalls(flrEPCnst[count], srf)\n            \n        modifiedObjects.append(HBZoneObject)\n    # add zones to dictionary\n    HBZones  = hb_hive.addToHoneybeeHive(modifiedObjects, ghenv.Component)\n    \n    #print HBZones\n    return HBZones\n\nif _HBZones:\n    result = main(_HBZones, intWallEPConstruction_, intWindowEPConstruction_, \\\n            intFloorEPConstruction_, intCeilingEPConstruction_)\n    if result!=-1: modifiedHBZones = result",
  "language": "python",
  "imports": [
    "Rhino",
    "scriptcontext"
  ],
  "has_docstring": true
}