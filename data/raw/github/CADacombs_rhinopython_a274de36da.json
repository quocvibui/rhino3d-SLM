{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/xBrepObject.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "xBrepObject.py",
  "instruction": "181025: Created.\r\n...\r\n190810: replaceFaces now accepts surfaces as input for the new geometry.\r\n        Added fTolerance_Join parameter for replaceFaces.  If one is not provided, the current brep's...",
  "code": "\"\"\"\r\n181025: Created.\r\n...\r\n190810: replaceFaces now accepts surfaces as input for the new geometry.\r\n        Added fTolerance_Join parameter for replaceFaces.  If one is not provided, the current brep's maximum edge tolerance is used.\r\n...\r\n191010: Fixed bug where duplicate values in idxFaces caused some faces to be missing from brep with faces removed.\r\n        Changed some parameter names.  Changed a printed output to bDebug.\r\n191015: Corrected a variable name in 1 function.\r\n191028: replaceFaces can now accept more types of input for breps and face indices.\r\n191029: Refactored replaceGeometry.\r\n191029-30: Created replaceFaces_WIP, a replacement for replaceFaces that allows the new geometry to be plural.\r\n191030: Bug fix in extractFaces.\r\n191031: Refactored replaceFaces.\r\n191101: removeFaces now returns [] instead of True when all faces are removed.\r\n        extractFaces now returns a tuple of (list of extracted), (list of remaining) instead of just a list of extracted Breps.\r\n191117: CreateBooleanUnion for separating \"shells\" now accepts non-manifold breps.\r\n191118: Modified determination of joining tolerances in 2 functions.\r\n191208: Replaced an xrange with range so that the reversed result can be passed to length\r\n191213: Bug fixed by changing JoinBrep tolerance value in addFromSubsetOfFaces.\r\n200107: replaceGeometry now returns None when some of the new geometry is invalid.\r\n200108: Modified how addFromSubsetOfFaces handles invalid breps created by BrepFace.DuplicateFace.\r\n200129: Corrected a docstring.\r\n200527: Modified conditionals for some printed output.\r\n200619: Added more functions.  Purged some of this history.\r\n200701: Now no face indices passed to extractFaces creates an _Explode.  Various minor changes.\r\n210503: Fixed bug in addFromSubsetOfFaces that distorted some edges when\r\n        CreateBooleanUnion was used to separate \"shells\".  CreateBooleanUnion\r\n        now is performed on individual breps, not Array of Breps.  This bug also\r\n        indicated a possible change in CreateBooleanUnion between RC6 and RC7,\r\n        since the former's method returned None while the latter returned\r\n        distorted edges.\r\n210507: Corrected printed output.\r\n220317: Moved a function to another script so that an import could be eliminated.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\nfrom System.Diagnostics import Stopwatch\r\n\r\n\r\ndef coerceRhinoObject(rhObj):\r\n    \"\"\"\r\n    'Deleted objects cannot be found by id.'\r\n    (https://developer.rhino3d.com/api/RhinoCommon/html/M_Rhino_DocObjects_Tables_ObjectTable_FindId.htm)\r\n    \"\"\"\r\n    rdObj = None\r\n    if isinstance(rhObj, rd.RhinoObject):\r\n        rdObj = rhObj\r\n    elif isinstance(rhObj, rd.ObjRef):\r\n        rdObj = rhObj.Object()\r\n    elif isinstance(rhObj, Guid):\r\n        rdObj = sc.doc.Objects.FindId(rhObj) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(rhObj)\r\n    return rdObj\r\n\r\n\r\ndef coerceBrepObject(rhObj):\r\n    rdObj = coerceRhinoObject(rhObj)\r\n    if rdObj and (rdObj.ObjectType == rd.ObjectType.Brep):\r\n        return rdObj\r\n\r\n\r\ndef coerceBrepGuid(rhObj):\r\n    if isinstance(rhObj, Guid): return rhObj\r\n    rdBrep = coerceBrepObject(rhObj)\r\n    if rdBrep:\r\n        return rdBrep.Id\r\n\r\n\r\ndef coerceBrep(rhObj):\r\n    if isinstance(rhObj, rg.Brep):\r\n        return rhObj\r\n    elif isinstance(rhObj, rg.Surface):\r\n        return rhObj.ToBrep()\r\n    elif isinstance(rhObj, rg.GeometryBase):\r\n        geom = rhObj\r\n    elif isinstance(rhObj, rd.ObjRef):\r\n        #print rhObj.GeometryComponentIndex.ComponentIndexType\r\n        geom = rhObj.Geometry()\r\n    elif isinstance(rhObj, Guid):\r\n        rdObj = sc.doc.Objects.FindId(rhObj) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(rhObj)\r\n        geom = rdObj.Geometry\r\n    else:\r\n        return\r\n\r\n    if isinstance(geom, rg.Brep):\r\n        return geom\r\n\r\n\r\ndef addFromSubsetOfFaces(rhBrep, idxFaces, bAddOnlyMonofaces=True, bRetainLayer=True, bRetainColor=True, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n    \r\n    rdBrep_In = coerceBrepObject(rhBrep)\r\n    if rdBrep_In is None: return\r\n    rgBrep_In = rdBrep_In.BrepGeometry\r\n    if not rgBrep_In.IsValid: return\r\n    \r\n    \r\n    def addBrepOfSubsetOfFaces_JoinBreps():\r\n        \r\n        # Duplicate faces to their own breps to be joined.\r\n        rgBreps1 = [] # Faces (breps) to be duplicated.\r\n        \r\n        for i in idxFaces:\r\n            rgFace = rgBrep_In.Faces[i]\r\n            rgBrep_1Face = rgFace.DuplicateFace(True)\r\n            if rgBrep_1Face is None:\r\n                if bDebug: print \"Face {} could not be duplicated as a brep!\".format(i)\r\n                return None\r\n            rgBreps1.append(rgBrep_1Face)\r\n        \r\n        # Join monoface breps.\r\n\r\n        # Using a tight tolerance to rejoin only existing shared edges.\r\n        fTol_Join = 1e-9\r\n\r\n        rgBreps_Joined = rg.Brep.JoinBreps(rgBreps1, tolerance=fTol_Join)\r\n        if rgBreps_Joined is None:\r\n                if bDebug: print \"Joining breps failed!\"\r\n                return\r\n        for rgB in rgBreps_Joined:\r\n            if not rgB.IsValid:\r\n                if bDebug: print \"Joined brep not valid.  Exiting...\"\r\n                return\r\n        \r\n        if any(b.Faces.Count > 1 for b in rgBreps_Joined):\r\n            # Separate any brep shells of modified brep and act based on shell quantity.\r\n            rgBreps_per_shell = []\r\n            for b in rgBreps_Joined:\r\n                rc = rg.Brep.CreateBooleanUnion(\r\n                    [b],\r\n                    tolerance=0.0,\r\n                    manifoldOnly=False)\r\n                if rc is None:\r\n                    if bDebug: print \"Error in attempting to separate brep shells.  No objects have been modified.\"\r\n                    return\r\n                rgBreps_per_shell.extend(rc)\r\n        else:\r\n            # Skipped attempting to Boolean union monoface breps in case any contact are in contact with one another.\r\n            rgBreps_per_shell = rgBreps_Joined[:]\r\n        \r\n        \r\n        attr = rdBrep_In.Attributes.Duplicate()\r\n        if not bRetainLayer: attr.LayerIndex = sc.doc.Layers.CurrentLayerIndex\r\n        if not bRetainColor: attr.ColorSource = rd.ObjectColorSource.ColorFromLayer\r\n        \r\n        \r\n        gBreps_1Shell = map(lambda x: sc.doc.Objects.AddBrep(x, attr), rgBreps_per_shell)\r\n        map(lambda x: x.Dispose(), rgBreps_per_shell)\r\n        \r\n        return gBreps_1Shell\r\n    \r\n    \r\n    def addBrepOfSubsetOfFaces_RemoveAt():\r\n        \r\n        rgBrep1 = rgBrep_In.Duplicate()\r\n        \r\n        # Create list of non-extracted faces.\r\n        # This is faster than looping through all faces while testing each.\r\n        idx_rgFaces_ToRemove = list(\r\n                set(range(rgBrep1.Faces.Count)) - set(idxFaces))\r\n        idx_rgFaces_ToRemove.sort(reverse=True)\r\n        \r\n        stopwatch = Stopwatch()\r\n        stopwatch.Start()\r\n        [rgBrep1.Faces.RemoveAt(idx) for idx in idx_rgFaces_ToRemove]\r\n        stopwatch.Stop()\r\n        if bDebug: print \"{} seconds for Faces.RemoveAt\".format(stopwatch.Elapsed.TotalSeconds)\r\n        \r\n        # Separate any brep shells of modified brep and act based on shell quantity.\r\n        stopwatch.Restart()\r\n        rgBreps_per_shell = rg.Brep.CreateBooleanUnion(\r\n            [rgBrep1], tolerance=0.0, manifoldOnly=False)\r\n        stopwatch.Stop()\r\n        if bDebug:\r\n            print \"{} seconds for CreateBooleanUnion\".format(\r\n                stopwatch.Elapsed.TotalSeconds)\r\n        if rgBreps_per_shell is None:\r\n            if bDebug: print \"Error in attempting to separate brep shells.  No objects have been modified.\"\r\n            return\r\n        \r\n        rgBrep1.Dispose()\r\n        \r\n        attr = rdBrep_In.Attributes.Duplicate()\r\n        if not bRetainLayer: attr.LayerIndex = sc.doc.Layers.CurrentLayerIndex\r\n        if not bRetainColor: attr.ColorSource = rd.ObjectColorSource.ColorFromLayer\r\n        \r\n        stopwatch.Restart()\r\n        gBreps_1Shell = map(lambda x: sc.doc.Objects.AddBrep(x, attr), rgBreps_per_shell)\r\n        stopwatch.Stop()\r\n        if bDebug: print \"{:.1f} seconds for AddBrep\".format(stopwatch.Elapsed.TotalSeconds)\r\n        map(lambda x: x.Dispose(), rgBreps_per_shell)\r\n        \r\n        return gBreps_1Shell\r\n    \r\n    \r\n    nFaces = rgBrep_In.Faces.Count\r\n    \r\n    # If brep has only 1 face, return the brep's GUID.\r\n    if nFaces == 1:\r\n        return [rdBrep_In.Id]\r\n    \r\n    idxFaces = list(set(idxFaces))\r\n    \r\n    if not bAddOnlyMonofaces:\r\n        \r\n        stopwatch = Stopwatch()\r\n        \r\n        # Create brep(s) of extracted faces using method chosen by whether number of\r\n        # extracted faces is less or more than the remaining number of faces.\r\n        if len(idxFaces) < nFaces // 2 :\r\n            stopwatch.Restart()\r\n            gBreps1_Extracted = addBrepOfSubsetOfFaces_JoinBreps()\r\n            stopwatch.Stop()\r\n            if bDebug:\r\n                print \"{} seconds for addBrepOfSubsetOfFaces_JoinBreps\".format(\r\n                        stopwatch.Elapsed.TotalSeconds)\r\n            if gBreps1_Extracted is not None:\r\n                return gBreps1_Extracted\r\n            if bDebug: print \"addBrepOfSubsetOfFaces_JoinBreps returned None.\"\r\n        # Since addBrepOfSubsetOfFaces_JoinBreps failed, will try RemoveAt instead.\r\n        \r\n        # Either the number of faces to add > half the total number of faces in the brep or addBrepOfSubsetOfFaces_JoinBreps had returned None.\r\n        stopwatch.Restart()\r\n        gBreps1_Extracted = addBrepOfSubsetOfFaces_RemoveAt()\r\n        stopwatch.Stop()\r\n        if bDebug:\r\n            print \"{} seconds for addBrepOfSubsetOfFaces_RemoveAt\".format(\r\n                    stopwatch.Elapsed.TotalSeconds)\r\n        if gBreps1_Extracted is not None:\r\n            return gBreps1_Extracted\r\n        if bDebug: print \"addBrepOfSubsetOfFaces_RemoveAt returned None.\"\r\n    \r\n    # Add only monoface breps.\r\n    \r\n    attr = rdBrep_In.Attributes.Duplicate()\r\n    if not bRetainLayer: attr.LayerIndex = sc.doc.Layers.CurrentLayerIndex\r\n    if not bRetainColor: attr.ColorSource = rd.ObjectColorSource.ColorFromLayer\r\n    \r\n    gBreps1_Extracted = []\r\n    \r\n    for idx in idxFaces:\r\n        rgFace = rgBrep_In.Faces[idx]\r\n        \r\n        # Duplicate face to its own brep.\r\n        rgBrep1 = rgFace.DuplicateFace(duplicateMeshes=True)\r\n        if not rgBrep1.IsValid:\r\n            gBrep1 = None\r\n        else:\r\n            gBrep1 = sc.doc.Objects.AddBrep(rgBrep1, attr)\r\n\r\n        if gBrep1 is None:\r\n            s = \"Brep face {} from {} could not be added to document.\".format(\r\n                    idx, rdBrep_In.Id)\r\n            print s\r\n            rc = rs.MessageBox(\r\n                s + \"\\nContinue extracting faces, skipping this one?\",\r\n                buttons=4,\r\n                title=\"xBrepObject.addFromSubsetOfFaces\")\r\n            if rc is not None and rc == 6:\r\n                continue\r\n            #if not bDebug: rs.DeleteObjects(gBreps1_Extracted)\r\n            return\r\n        \r\n        gBreps1_Extracted.append(gBrep1)\r\n        rgBrep1.Dispose()\r\n    \r\n    return gBreps1_Extracted\r\n\r\n\r\ndef replaceGeometry(rhBrep_toReplace, rgBreps_NewGeom):\r\n    \"\"\"\r\n    Replaces BrepObject with new geometry after separating any 'shells'.\r\n    Parameters:\r\n        brep_toReplace: BrepObject, ObjRef, or GUID.\r\n        rgBreps_NewGeom: Single or list of BrepObjects or Breps in any form.\r\n    Returns:\r\n        list of Brep GUIDs of remaining GUIDs.\r\n        None if input doesn't qualify.\r\n    \"\"\"\r\n    \r\n    #if rgBrep1.Faces.Count == 0: return\r\n    \r\n    rdBrep_In = coerceBrepObject(rhBrep_toReplace)\r\n\r\n    try: rgBreps_NewGeom = list(set(rgBreps_NewGeom))\r\n    except: rgBreps_NewGeom = [rgBreps_NewGeom]\r\n\r\n    rgBreps_NewGeom = [coerceBrep(o) for o in rgBreps_NewGeom]\r\n    \r\n    for rgB in rgBreps_NewGeom:\r\n        if not rgB.IsValid:\r\n            print \"Brep geometry was not replaced because\" \\\r\n                  \" some of the new geometry is invalid.\"\r\n            return\r\n\r\n    # Separate any shells of modified brep and act based on shell quantity.\r\n    rgBreps_per_shell = []\r\n    for brepN in rgBreps_NewGeom:\r\n        rgBs_Unioned = rg.Brep.CreateBooleanUnion(\r\n            [brepN], tolerance=0.0, manifoldOnly=False)\r\n        if rgBs_Unioned is None:\r\n            rgBreps_per_shell.append(None)\r\n            break # rgBreps_per_shell will be disregarded later.\r\n        for rgB_Unioned in rgBs_Unioned:\r\n            rgBreps_per_shell.append(rgB_Unioned)\r\n            if rgB_Unioned is None:\r\n                break # rgBreps_per_shell will be disregarded later.\r\n\r\n    if None in rgBreps_per_shell:\r\n        print \"Error in attempting to separate 'shells'.\" \\\r\n            \"  Attempting to replace brep as is.\"\r\n        rgBreps_ReadyToReplace = [brep.Duplicate() for brep in rgBreps_NewGeom]\r\n    else:\r\n        rgBreps_ReadyToReplace = [brep.Duplicate() for brep in rgBreps_per_shell]\r\n\r\n    for brep in rgBreps_per_shell: brep.Dispose()\r\n\r\n    if len(rgBreps_ReadyToReplace) == 1:\r\n        # Replace original brep with its modified geometry.\r\n        # Starting GUID will be maintained.\r\n        if sc.doc.Objects.Replace(rdBrep_In.Id, rgBreps_ReadyToReplace[0]):\r\n            return [rdBrep_In.Id]\r\n        else:\r\n            print \"Replace brep {} failed.  Check this.\".format(rdBrep_In.Id)\r\n    else:\r\n        # Multiple breps will be added.\r\n        # Original will be deleted, not replaced,\r\n        # so that none will inherit the original GUID.\r\n        attr = rdBrep_In.Attributes\r\n        gBreps_Out = [\r\n            sc.doc.Objects.AddBrep(brep, attr) for brep in rgBreps_ReadyToReplace]\r\n        if not any(g == Guid.Empty for g in gBreps_Out):\r\n            if not sc.doc.Objects.Delete(rdBrep_In, True):\r\n                print \"Original brep cannot be deleted.  Check this\"\r\n        return gBreps_Out\r\n\r\n\r\ndef removeFaces(rhBrep, idxs_rgFaces):\r\n    \"\"\"\r\n    rhBrep: GUID or BrepObject.\r\n    idxs_rgFaces: Iterable of face indices.\r\n    \r\n    Returns:\r\n        Iterable of GUIDs of breps with faces removed.\r\n        None on fail.\r\n    \"\"\"\r\n\r\n    try: idxs_rgFaces = sorted(list(set(idxs_rgFaces)), reverse=True)\r\n    except: idxs_rgFaces = [idxs_rgFaces]\r\n\r\n    rdBrep_In = coerceBrepObject(rhBrep)\r\n    if rdBrep_In is None: return\r\n    rgBrep_In = rdBrep_In.Geometry\r\n    if not rgBrep_In.IsValid and rgBrep_In.Faces.Count > 1: return\r\n    \r\n    if rgBrep_In.Faces.Count == len(idxs_rgFaces):\r\n        # Since all faces of original brep are to be removed,\r\n        # delete brep instead of removing faces.\r\n        bSuccess = sc.doc.Objects.Delete(rdBrep_In, True)\r\n        rgBrep_In.Dispose()\r\n        return [] if bSuccess else None\r\n    \r\n    rgBrep_WIP = rgBrep_In.Duplicate()\r\n    \r\n    # Remove faces from brep geometry.\r\n    map(rgBrep_WIP.Faces.RemoveAt, idxs_rgFaces)\r\n    if (rgBrep_In.Faces.Count - rgBrep_WIP.Faces.Count) != len(idxs_rgFaces):\r\n        return None\r\n    return replaceGeometry(rdBrep_In, rgBrep_WIP) # GUIDs of modified (remaining) Breps.\r\n\r\n\r\ndef replaceFaces(rhBrep, idxs_rgFaces, rgBreps_NewGeom, bExtract=False, fTolerance_Join=None, bEcho=False, bDebug=False):\r\n    \"\"\"Replaces faces using Brep.JoinBreps .\r\n    \r\n    Parameters:\r\n        rhBrep: Guid or BrepObject\r\n        idxs_rgFaces: Indices of faces that are to be replaced.\r\n            ints, iterable of ints, or None (to indicate that all faces are to be replaced.)\r\n        rgBreps_NewGeom: Brep or surface geometry.\r\n        bEcho: Boolean\r\n        bDebug: Boolean\r\n    Returns on success (bExtract==True):\r\n        list(GUIDs of Breps),\r\n        list(GUIDs of remaining Breps)\r\n    Returns on success (bExtract==False):\r\n        list(GUIDs of BrepObjects)\r\n    Returns on fail:\r\n        None\r\n    \r\n    TODO: Allow BrepFace as alternative input for rgBreps_NewGeom.\r\n    \"\"\"\r\n\r\n    rdBrep0 = coerceBrepObject(rhBrep)\r\n    if rdBrep0 is None: return\r\n    rgBrep0 = rdBrep0.BrepGeometry\r\n    \r\n    def coerceList(obj):\r\n        try: obj = list(set(obj))\r\n        except: obj = [obj]\r\n        return obj\r\n    if idxs_rgFaces is None:\r\n        idxs_rgFaces = range(rgBrep0.Faces.Count)\r\n        idxs_rgFaces.reverse()\r\n    else:\r\n        idxs_rgFaces = sorted(coerceList(idxs_rgFaces), reverse=True)\r\n    rgBreps_NewGeom = coerceList(rgBreps_NewGeom)\r\n\r\n    bSolidAtStart = rgBrep0.IsSolid\r\n\r\n    # Convert any surfaces in list to breps.\r\n    #rgBreps_New1F_WIP = [coerceBrep(o) for o in rgBreps_NewGeom] # Not using due to Dispose() problem.\r\n    breps_NewGeom_WIP = []\r\n    for i in xrange(len(rgBreps_NewGeom)):\r\n        if isinstance(rgBreps_NewGeom[i], rg.Surface):\r\n            srf = rgBreps_NewGeom[i]\r\n            breps_NewGeom_WIP.append(srf.ToBrep())\r\n        else:\r\n            breps_NewGeom_WIP.append(rgBreps_NewGeom[i].Duplicate())\r\n    \r\n    if rgBrep0.Faces.Count == 1:\r\n        # Monoface brep.\r\n        def replaceGeomOfMonofaceBrep():\r\n            gBreps_Out = replaceGeometry(rdBrep0, breps_NewGeom_WIP) # Nore or list of GUIDs.\r\n            rgBrep0.Dispose()\r\n            for b in breps_NewGeom_WIP: b.Dispose()\r\n            return gBreps_Out\r\n        if bExtract:\r\n            return replaceGeomOfMonofaceBrep(), []\r\n        else:\r\n            return replaceGeomOfMonofaceBrep()\r\n\r\n    if not bExtract:\r\n        fTol_Join_toUse = max(\r\n            fTolerance_Join,\r\n            1.05 * max([edge.Tolerance for edge in rgBrep0.Edges]),\r\n            2.1 * sc.doc.ModelAbsoluteTolerance,\r\n        ) # None (fTolerance_Join) is acceptable input for max().\r\n\r\n\r\n    if len(idxs_rgFaces) < rgBrep0.Faces.Count:\r\n        # Not all faces of a polyface brep are to be replaced.\r\n        \r\n        # Remove faces from copy of original brep geometry.\r\n        rgBrep0_WithFacesRemoved = rgBrep0.DuplicateBrep()\r\n        rgBrep0.Dispose()\r\n        for idx_rgFace_ToRemove in idxs_rgFaces:\r\n            rgBrep0_WithFacesRemoved.Faces.RemoveAt(idx_rgFace_ToRemove)\r\n\r\n        b, sLog = rgBrep0_WithFacesRemoved.IsValidWithLog()\r\n        if not b:\r\n            if bEcho: print sLog\r\n            rgBrep0_WithFacesRemoved.Dispose()\r\n            for b in breps_NewGeom_WIP: b.Dispose()\r\n            return\r\n\r\n        if bExtract:\r\n            def replaceSome_Extract():\r\n                gBreps_Extracted = []\r\n                for brep in breps_NewGeom_WIP:\r\n                    gBrep1_1Face = sc.doc.Objects.AddBrep(brep, rdBrep0.Attributes)\r\n                    brep.Dispose()\r\n                    if gBrep1_1Face != Guid.Empty:\r\n                        gBreps_Extracted.append(gBrep1_1Face)\r\n                if len(gBreps_Extracted) == len(breps_NewGeom_WIP):\r\n                    gBreps_Modified = replaceGeometry(rdBrep0, rgBrep0_WithFacesRemoved)\r\n                    rgBrep0_WithFacesRemoved.Dispose()\r\n                else:\r\n                    if bEcho:\r\n                        s  = \"{} new faces could not be added.\".format(\r\n                            len(breps_NewGeom_WIP) - len(gBreps_Extracted))\r\n                        s += \"  No faces were removed from original brep.\"\r\n                        print s\r\n                return gBreps_Extracted, gBreps_Modified\r\n            return replaceSome_Extract()\r\n        else:\r\n            def replaceSome_Join():\r\n                gBreps_Out = []\r\n\r\n                rgBreps_Joined = rg.Brep.JoinBreps(\r\n                        [rgBrep0_WithFacesRemoved] + breps_NewGeom_WIP,\r\n                        tolerance=fTol_Join_toUse)\r\n\r\n                rgBrep0_WithFacesRemoved.Dispose()\r\n                for brep in breps_NewGeom_WIP: brep.Dispose()\r\n\r\n                len_Joined = len(rgBreps_Joined)\r\n                if len_Joined == 0:\r\n                    if bEcho:\r\n                        print \"rgBreps_Joined is empty.  No objects have been modified.\"\r\n                    return\r\n                else:\r\n                    if bEcho:\r\n                        print \"JoinBreps returned {} breps.\".format(len_Joined)\r\n                        if (\r\n                            len_Joined == 1 and\r\n                            bSolidAtStart and\r\n                            not rgBreps_Joined[0].IsSolid\r\n                        ):\r\n                            print \"Warning: Brep is no longer a solid!\"\r\n                    gBreps_Out = replaceGeometry(rdBrep0, rgBreps_Joined) # None or list of GUIDs.\r\n                    for brep in rgBreps_Joined: brep.Dispose()\r\n                    return gBreps_Out\r\n            return replaceSome_Join()\r\n    else:\r\n        # All faces of a polyface brep are to be replaced.\r\n        rgBrep0.Dispose()\r\n\r\n        if bExtract:\r\n            def replaceAll_Extract():\r\n                # All output GUIDs will be new.\r\n                gBreps_Extracted = []\r\n                for brep in breps_NewGeom_WIP:\r\n                    gBrep1_1Face = sc.doc.Objects.AddBrep(brep, rdBrep0.Attributes)\r\n                    brep.Dispose()\r\n                    if gBrep1_1Face != Guid.Empty:\r\n                        gBreps_Extracted.append(gBrep1_1Face)\r\n                if len(gBreps_Extracted) == len(breps_NewGeom_WIP):\r\n                    sc.doc.Objects.Delete(objectId=rdBrep0.Id, quiet=False)\r\n                else:\r\n                    if bEcho:\r\n                        s  = \"{} new faces could not be added.\".format(\r\n                            len(breps_NewGeom_WIP) - len(gBreps_Extracted))\r\n                        s += \"  Original brep was not deleted.\"\r\n                        print s\r\n                return gBreps_Extracted, []\r\n            return replaceAll_Extract()\r\n        else:\r\n            def replaceAll_Join():\r\n                gBreps_Out = []\r\n\r\n                rgBreps_Joined = rg.Brep.JoinBreps(\r\n                        breps_NewGeom_WIP,\r\n                        tolerance=fTol_Join_toUse)\r\n\r\n                for brep in breps_NewGeom_WIP: brep.Dispose()\r\n\r\n                len_Joined = len(rgBreps_Joined)\r\n                if len_Joined == 0:\r\n                    if bEcho:\r\n                        print \"rgBreps_Joined is empty.  No objects have been modified.\"\r\n                    return\r\n                else:\r\n                    if bEcho:\r\n                        print \"JoinBreps returned {} breps.\".format(len_Joined)\r\n                        if (\r\n                            len_Joined == 1 and\r\n                            bSolidAtStart and\r\n                            not rgBreps_Joined[0].IsSolid\r\n                        ):\r\n                            print \"Warning: Brep is no longer a solid!\"\r\n                    gBreps_Out = replaceGeometry(rdBrep0, rgBreps_Joined) # None or list of GUIDs.\r\n                    for brep in rgBreps_Joined: brep.Dispose()\r\n                    return gBreps_Out\r\n            return replaceAll_Join()\r\n\r\n\r\ndef extractFaces(rhBrep, idxFaces, bAddOnlyMonofaces=True, bRetainLayer=True, bRetainColor=True, bCurrentLayer=None, bByLayerColor=None, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        rhBrep: rd.BrepObject, GUID of rd.BrepObject, or ObjRef of rd.BrepObject\r\n        idxFaces: list(int(Index of face) or not for all.\r\n    Returns:\r\n        list(GUID of extracted brep), list(GUID of remaining brep) on success.\r\n        None on fail.\r\n    \r\n    TODO: Remove support for bCurrentLayer and bByLayerColor after dependent scripts are modified.\r\n    \"\"\"\r\n\r\n    rdBrep_In = coerceBrepObject(rhBrep)\r\n    if rdBrep_In is None: return\r\n    rgBrep_In = rdBrep_In.BrepGeometry\r\n    if not rgBrep_In.IsValid:\r\n        if bEcho: print \"Invalid Brep {} will not be processed.\".format(rdBrep_In.Id)\r\n        return\r\n\r\n    if not idxFaces:\r\n        if rgBrep_In.Faces.Count == 1:\r\n            return [rdBrep_In.Id], []\r\n        idxFaces = range(rgBrep_In.Faces.Count)\r\n    else:\r\n        try: idxFaces = list(set(idxFaces))\r\n        except: idxFaces = [idxFaces]\r\n\r\n    if bCurrentLayer is not None: bRetainLayer = not bCurrentLayer\r\n    if bByLayerColor is not None: bRetainColor = not bByLayerColor\r\n    \r\n    if rgBrep_In.Faces.Count == 1:\r\n        # Brep is monoface.\r\n        rgBrep_In.Dispose()\r\n        \r\n        if bRetainLayer and bRetainColor: return [rdBrep_In.Id], []\r\n        \r\n        # The layer and/or color is to be modified.\r\n        attr = rdBrep_In.Attributes\r\n        if not bRetainLayer: attr.LayerIndex = sc.doc.Layers.CurrentLayerIndex\r\n        if not bRetainColor: attr.ColorSource = rd.ObjectColorSource.ColorFromLayer\r\n        rdBrep_In.CommitChanges()\r\n        return [rdBrep_In.Id], []\r\n    \r\n    \r\n    # Brep is polyface.\r\n    \r\n    gBreps1_Extracted = addFromSubsetOfFaces(\r\n            rhBrep=rdBrep_In,\r\n            idxFaces=idxFaces,\r\n            bRetainLayer=bRetainLayer,\r\n            bRetainColor=bRetainColor,\r\n            bAddOnlyMonofaces=bAddOnlyMonofaces,\r\n            bDebug=bDebug\r\n    )\r\n    if gBreps1_Extracted is None: return\r\n    \r\n    rc = removeFaces(rdBrep_In, idxFaces)\r\n    if rc is None:\r\n        return\r\n    else:\r\n        gBs_Remaining = rc\r\n    \r\n    if bEcho:\r\n        print \"Extracted {} breps.\".format(len(gBreps1_Extracted))\r\n    \r\n    return gBreps1_Extracted, gBs_Remaining\r\n\r\n\r\ndef selectFaces(rhBreps, idxFaces_perBrep=None, surfaceTestFunc=None, bEcho=True):\r\n    if Rhino.RhinoApp.ExeVersion < 6: return\r\n\r\n    try: rhBreps = list(rhBreps)\r\n    except: rhBreps = [rhBreps]\r\n\r\n    if idxFaces_perBrep:\r\n        if isinstance(idxFaces_perBrep[0], int):\r\n            idxFaces_perBrep = [idxFaces_perBrep]\r\n\r\n\r\n    if idxFaces_perBrep is None and isinstance(rhBreps[0], rd.ObjRef):\r\n        rc = sortObjrefsIntoBrepGuidsAndFaceIndices(objrefs=rhBreps)\r\n        if rc is None: return\r\n\r\n        rhBreps, idxFaces_perBrep = rc\r\n\r\n    if idxFaces_perBrep is None and surfaceTestFunc is None:\r\n        print \"Parameters result in selection of all faces.  None will be be selected.\"\r\n        return\r\n\r\n\r\n    iCt_Fs_Found = 0 # Applies when using surfaceTestFunc.\r\n    iCt_Fs_Selected = 0\r\n\r\n    for iB, rhB_In in enumerate(rhBreps):\r\n\r\n        idxFaces = idxFaces_perBrep[iB]\r\n    \r\n        rdBrep0 = coerceBrepObject(rhB_In)\r\n        if rdBrep0 is None: return\r\n    \r\n        rgBrep0 = rdBrep0.Geometry\r\n        if not rgBrep0.IsValid:\r\n            rgBrep0.Dispose()\r\n            return\r\n\r\n        for idxFace in idxFaces:\r\n\r\n            if surfaceTestFunc:\r\n                if not surfaceTestFunc(rgBrep0.Faces[idxFace]):\r\n                    continue\r\n\r\n            iCt_Fs_Found += 1\r\n\r\n            compIdx = rg.ComponentIndex(\r\n                    rg.ComponentIndexType.BrepFace,\r\n                    index=idxFace)\r\n            iSelected = rdBrep0.SelectSubObject(\r\n                    componentIndex=compIdx,\r\n                    select=True, syncHighlight=True, persistentSelect=True)\r\n            \"\"\"\r\n            iSelected:\r\n                0: object is not selected\r\n                1: object is selected\r\n                2: object is selected persistently.\r\n            \"\"\"\r\n\r\n        for idxFace in xrange(rgBrep0.Faces.Count):\r\n            compIdx = rg.ComponentIndex(\r\n                    rg.ComponentIndexType.BrepFace, idxFace)\r\n            if rdBrep0.IsSubObjectSelected(compIdx): iCt_Fs_Selected += 1\r\n        rgBrep0.Dispose()\r\n\r\n\r\n    if bEcho:\r\n        if surfaceTestFunc:\r\n            if iCt_Fs_Found == iCt_Fs_Selected:\r\n                print \"{} faces found and are selected.\".format(\r\n                    iCt_Fs_Found)\r\n            else:\r\n                print \"{} faces found, but only {} are selected.\".format(\r\n                    iCt_Fs_Found, iCt_Fs_Selected)\r\n        else:\r\n            print \"{} faces are selected.\".format(iCt_Fs_Selected)\r\n\r\n    return iCt_Fs_Selected\r\n\r\n\r\ndef separateShells(rhBrep, bEcho=True):\r\n    \"\"\"\r\n    Separate any brep shells of modified brep and act based on shell quantity.\r\n    Returns list of GUIDs of new breps or list with GUID of only existing brep.\r\n    \"\"\"\r\n    rdBrep0 = coerceBrepObject(rhBrep)\r\n    if rdBrep0 is None: return\r\n    rgBrep0 = rdBrep0.Geometry\r\n    if rgBrep0.Faces.Count == 1:\r\n        return [rdBrep0.Id]\r\n    elif rgBrep0.Faces.Count > 1:\r\n        rgBreps_per_shell = rg.Brep.CreateBooleanUnion(\r\n            [rgBrep0], tolerance=0.0, manifoldOnly=False)\r\n        if rgBreps_per_shell is None:\r\n            if bDebug: print \"Error in attempting to separate brep shells.  No objects have been modified.\"\r\n            return\r\n    else:\r\n        return\r\n    \r\n    if rgBreps_per_shell is None: return []\r\n    elif len(rgBreps_per_shell) == 1: return [rdBrep0.Id]\r\n    else:\r\n        gBreps1 = []\r\n        attr = rdBrep0.Attributes\r\n        for rgBrep1 in rgBreps_per_shell:\r\n            gBrep1 = sc.doc.Objects.AddBrep(rgBrep1, attr)\r\n            if gBrep1 != Guid.Empty:\r\n                gBreps1.append(gBrep1)\r\n            else:\r\n                # Delete all new BrepObjects if any AddBrep fails.\r\n                if bEcho:\r\n                    s  = \"Brep could not be added to document.\"\r\n                    s += \"  Brep {} will not have its shells separated.\".format(\r\n                            rdBrep0.Id)\r\n                    print s\r\n                for gBrep1 in gBreps1:\r\n                    sc.doc.Objects.Delete(gBrep1, True)\r\n                return\r\n        sc.doc.Objects.Delete(rdBrep0, True)\r\n        return gBreps1\r\n\r\n\r\ndef formatDistance(fDistance):\r\n    if fDistance is None:\r\n        return \"(No deviation was provided.)\"\r\n    if fDistance == 0.0:\r\n        return \"Exactly zero\"\r\n    if fDistance < 10.0**(-(sc.doc.DistanceDisplayPrecision-3)):\r\n        return \"{:.1e}\".format(fDistance)\r\n    else:\r\n        return \"{:.{}f}\".format(fDistance, sc.doc.ModelDistanceDisplayPrecision)\r\n\r\n\r\ndef sortObjrefsIntoBrepGuidsAndFaceIndices(objrefs):\r\n    \"\"\"\r\n    Sorts objrefs of entire breps or faces into 2 lists.\r\n\r\n    Returns on success:\r\n        list(GUIDs of breps)\r\n        list(lists(int(Indices of faces)) per brep in other list)\r\n    \"\"\"\r\n\r\n    gBreps = []\r\n    idx_Faces_PerBrep = []\r\n    \r\n    for objref in objrefs:\r\n        rdBrep = objref.Object()\r\n        gBrep = objref.ObjectId\r\n        compIndex = objref.GeometryComponentIndex.Index\r\n\r\n        if compIndex == -1:\r\n            rgBrep = objref.Brep()\r\n            if not rgBrep: continue\r\n            if gBrep in gBreps:\r\n                if rgBrep.Faces.Count == len(idx_Faces_PerBrep[gBreps.index(gBrep)]):\r\n                    continue\r\n                else:\r\n                    idx_Faces_PerBrep[gBreps.index(gBrep)] = range(rgBrep.Faces.Count)\r\n            else:\r\n                gBreps.append(gBrep)\r\n                idx_Faces_PerBrep.append(range(rgBrep.Faces.Count))\r\n        else:\r\n            # Face of polyface brep was selected.\r\n            rdObj = objref.Object()\r\n            if rdObj.ObjectType == rd.ObjectType.InstanceReference:\r\n                print \"Objects in block instances are not supported.\"\r\n                continue\r\n            else:\r\n                if gBrep in gBreps:\r\n                    idx_gBrep = gBreps.index(gBrep)\r\n                    idx_Faces_PerBrep[idx_gBrep].append(compIndex)\r\n                else:\r\n                    gBreps.append(gBrep)\r\n                    idx_Faces_PerBrep.append([compIndex])\r\n\r\n    return gBreps, idx_Faces_PerBrep\r\n\r\n\r\ndef createBrepObjectsOfNewSurfaces(rhSrfs_In, surfaceFunc, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    gBs_Out = []\r\n    srf_devs_All = []\r\n    sLogs = []\r\n    \r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    sCmdPrompt0 = Rhino.RhinoApp.CommandPrompt\r\n\r\n    for iS, rhSrf_In in enumerate(rhSrfs_In):\r\n\r\n        Rhino.RhinoApp.SetCommandPrompt(\r\n            \"Processing surface {} of {} ...\".format(\r\n                iS+1,\r\n                len(rhSrfs_In)))\r\n\r\n        if isinstance(rhSrf_In, Guid):\r\n            gBrep_In = rhSrf_In\r\n            rdBrep_In = sc.doc.Objects.FindId(gBrep_In) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(gBrep_In)\r\n            rgBrep_In = rdBrep_In.BrepGeometry\r\n            if rgBrep_In.Faces.Count > 1:\r\n                sLogs.append(\"BrepObject input has more than 1 face and was skipped.\")\r\n                continue # to next surface.\r\n            rgFace_In = rgBrep_In.Faces[0]\r\n        elif isinstance(rhSrf_In, rd.BrepObject):\r\n            rdBrep_In = rhSrf_In\r\n            gBrep_In = rdBrep_In.Id\r\n            rgBrep_In = rdBrep_In.BrepGeometry\r\n            if rgBrep_In.Faces.Count > 1:\r\n                sLogs.append(\"BrepObject input has more than 1 face and was skipped.\")\r\n                continue # to next surface.\r\n            rgFace_In = rgBrep_In.Faces[0]\r\n        elif isinstance(rhSrf_In, rd.ObjRef):\r\n            gBrep_In = rhSrf_In.ObjectId\r\n            rdBrep_In = rhSrf_In.Object()\r\n            rgBrep_In = rhSrf_In.Brep()\r\n            rgFace_In = rhSrf_In.Face()\r\n        else:\r\n            sLogs.append(\"{} passed to createBrepObjects.\".format(\r\n                rhSrf_In.GetType().Name))\r\n            continue # to next surface.\r\n\r\n        rgSrf_In = rgFace_In.UnderlyingSurface()\r\n\r\n        res, sLog = surfaceFunc(rgSrf_In)\r\n\r\n        if sLog is not None:\r\n            sLogs.append(sLog)\r\n\r\n        if res is None:\r\n            continue # to next surface.\r\n\r\n        ns_Res, srf_dev = res\r\n\r\n        if not ns_Res:\r\n            continue # to next brep.\r\n\r\n        srf_devs_All.append(srf_dev)\r\n\r\n        gB_Added = sc.doc.Objects.AddSurface(ns_Res)\r\n        ns_Res.Dispose()\r\n        if gB_Added == Guid.Empty:\r\n            sLogs.append(\"New surface could not be added to document.\")\r\n            continue\r\n\r\n        gBs_Out.append(gB_Added)\r\n\r\n    for sLog in set(sLogs):\r\n        print \"{} count of: {}\".format(sLogs.count(sLog), sLog)\r\n\r\n    if gBs_Out:\r\n        print \"{} surfaces added to document.\".format(len(gBs_Out))\r\n        print \"Maximum deviation from original surface: {}\".format(formatDistance(max(srf_devs_All)))\r\n    else:\r\n        print \"No surfaces added to document.\"\r\n\r\n    return gBs_Out\r\n\r\n\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}