{
  "source_url": "https://github.com/le-ar-n/le-ar-n/blob/64600ee3bbe7e42f87f28442923b216cc565cf24/code/02_geometry/libraries/algorithms/dendrite_system/dendrite_sys_from_image.py",
  "repo": "le-ar-n/le-ar-n",
  "repo_stars": 9,
  "repo_description": null,
  "license": "unknown",
  "filepath": "code/02_geometry/libraries/algorithms/dendrite_system/dendrite_sys_from_image.py",
  "instruction": ". . . . . . . . . . . . . . . . . . . . . \n.                                       .\n.    <<      ><      ><       >< <<     .\n.    < ><   ><<     ><<<    ><    ><<   .\n.    << >< > ><    ><  ><    ...",
  "code": "'''\n. . . . . . . . . . . . . . . . . . . . . \n.                                       .\n.    <<      ><      ><       >< <<     .\n.    < ><   ><<     ><<<    ><    ><<   .\n.    << >< > ><    ><  ><     ><        .  \n.    <<  ><  ><   ><<<<<><      ><      .\n.    <<      >< ><<     ><< ><    ><<   .\n.    <<      ><><<       ><<  >< <<     .\n.                                       .\n.             DFAB 2016/17              .\n. . . . . . . . . . . . . . . . . . . . . \n\nCreated on 27.09.2016\n\n@author: kathrind\n'''\n\nimport Rhino.Geometry as rg\nimport random as rnd\nimport math\n\nimport ghpythonlib.components as ghcomp\nfrom libraries.useful import clamp, map_range\nfrom libraries.geometry.vector import get_vector_sum\nfrom libraries.useful.color import convert_rgb_to_grey\n\n#===============================================================================\nNODE_SIZE = 0.8\nNODE_SIZE_MIN = 0.8\nNODE_SIZE_MAX = 3.2\n \nKILL_DISTANCE_MIN = 3\nKILL_DISTANCE_MAX = 20\nKILL_DISTANCE = KILL_DISTANCE_MIN\nRADIUS_MIN = KILL_DISTANCE_MIN * 2\nRADIUS_MAX = KILL_DISTANCE_MAX * 2\nRADIUS = RADIUS_MIN\nSTEP_SIZE = 2\nSTEP_SIZE_MIN = 3\nSTEP_SIZE_MAX = 10\n \nSMALL_VALUE = 0.00001\n\n\n#===============================================================================\nclass Node:\n    def __init__(self, position):\n        self.position = position\n        self.sources = []\n        self.direction = rg.Vector3d(0,0,0)\n        self.kill_distance = KILL_DISTANCE # distance of within sources are \"killed\"\n        self.node_size = NODE_SIZE # the size of the node\n        self.step_size = STEP_SIZE\n        self.radius = RADIUS # radius of affecting sources\n        self.children = 0 # amount of children\n        self.parent = None # the parent Node\n        self.active = True # if sources cannot be assigned to the node, it is not active anymore\n         \n#===============================================================================\nclass DendriteSystemImg:\n    \n    #===========================================================================\n    def __init__(self, image_file, step, black_value, num_init_nodes, thresh_nodes):\n        self.nodes = []\n        self.load_image(image_file) \n        self.sources = self.generate_random_sources_from_image(step, black_value)\n        self.generate_init_nodes_from_image(num_init_nodes, thresh_nodes)\n\n    #===========================================================================\n    def load_image(self, image_file):\n        self.cmesh = ghcomp.ImportImage(image_file)\n        bb = self.cmesh.GetBoundingBox(rg.Plane.WorldXY)\n        self.width = bb.Max.X\n        self.height = bb.Max.Y\n        self.point_cloud = rg.PointCloud(self.cmesh.Vertices.ToPoint3dArray())\n    \n    #===========================================================================   \n    def get_color_grey(self, x, y):     \n        point = rg.Point3d(x, y, 0)\n        color_rgb = self.cmesh.VertexColors[self.point_cloud.ClosestPoint(point)]\n        grey = convert_rgb_to_grey(color_rgb.R, color_rgb.G, color_rgb.B)   \n        grey = clamp(grey, 0, 255)\n        return grey\n        \n    #===========================================================================\n    def generate_random_sources_from_image(self, step, black_value):\n        '''Read pixel values from an image and according to the grey value in every pixel, create random \n        points. The size is adjustable with 'step' and the amount of points in black with 'black_value'.'''\n\n        random_points = []\n\n        for x in range(int(self.width / float(step))):\n            for y in range(int(self.height / float(step))): \n                #amount = int(map_range(pix[x, y], 0, 255, black_value, 0))\n                grey = self.get_color_grey(x*step, y*step)\n                amount = int(map_range(grey, 0, 255, black_value, 0))\n                for i in range(amount):\n                    rndx = x*step + rnd.uniform(-1, 1)*step\n                    rndy = y*step + rnd.uniform(-1, 1)*step\n                    random_points.append(rg.Point3d(rndx, rndy, 0))\n        \n        return random_points\n    \n    #===========================================================================\n    def generate_init_nodes_from_image(self, num_init_nodes, thresh_nodes):  \n        \n        # dart-throwing algorithm\n        for i in range(num_init_nodes * 10):  \n            tx = math.floor(rnd.random() * self.width)\n            ty = math.floor(rnd.random() * self.height)\n            \n            grey = self.get_color_grey(tx, ty)\n            if grey < thresh_nodes:\n                position = rg.Point3d(tx, ty, 0)\n                self.create_node(position)\n                \n            if len(self.nodes) == num_init_nodes:\n                break\n    \n    #===========================================================================\n    def create_node(self, position):\n        node = Node(position)\n        self.nodes.append(node)\n    \n    #===========================================================================\n    def map_value_from_position(self,position):\n        value = self.get_color_grey(position.X, position.Y)\n        kill_distance = map_range(value, 0, 255, KILL_DISTANCE_MIN, KILL_DISTANCE_MAX)\n        node_size = map_range(value, 0, 255, NODE_SIZE_MIN, NODE_SIZE_MAX)\n        radius = map_range(value, 0, 255, RADIUS_MIN, RADIUS_MAX)\n        step_size = map_range(value, 0, 255, STEP_SIZE_MIN, STEP_SIZE_MAX)\n        return kill_distance, node_size, radius, step_size\n    \n\n    #===========================================================================\n    def min_distance(self, s, others):\n        distances = [s.DistanceTo(o) for o in others]\n        min_distance = min(distances)\n        other = others[distances.index(min_distance)]\n        return min_distance, other\n    \n    #===========================================================================\n    def kill_sources_and_get_sources_within_radius(self, node):\n    \n        # compute squared distances\n        distances = [source.DistanceTo(node.position)**2 for source in self.sources]\n        dist_idx_sorted = [i[0] for i in sorted(enumerate(distances), key=lambda x:x[1])]\n        \n        sources_within_radius = []\n        sources_to_kill = []\n        squared_radius = node.radius * node.radius\n        squared_killdist = node.kill_distance * node.kill_distance\n        \n        for i, d in enumerate(dist_idx_sorted):\n            if distances[d] <= squared_killdist:\n                sources_to_kill.append(d)\n            elif squared_killdist < distances[d] < squared_radius:\n                sources_within_radius.append(self.sources[d])\n            else:\n                break\n\n\n        new_sources = [i for j, i in enumerate(self.sources) if j not in sources_to_kill]\n        self.sources = new_sources\n        \n        return sources_within_radius\n     \n    #===========================================================================\n    def get_closest_node_to_source(self, active_nodes, source):\n        # array of active node positions\n        # source = rg.Point3d\n\n        #distances = ((nodes_npa-[x,y])**2).sum(axis=1)  # compute squared distances\n        distances = [node.position.DistanceTo(source)**2 for node in active_nodes] # compute squared distances\n        dist_idx_sorted = [i[0] for i in sorted(enumerate(distances), key=lambda x:x[1])] # indirect sort\n        return active_nodes[dist_idx_sorted[0]] # return node closest to source\n    \n    #===========================================================================  \n    def step(self):\n         \n        active_nodes = [n for n in self.nodes if n.active == True]\n        max_children = max([n.children for n in self.nodes])\n        \n        \n        # assign sources to each node \n        for n in active_nodes:\n            n.sources = [] # delete everything to reassign\n            if max_children > 0:\n                # adjust the node size according to the amount of their children\n                n.node_size = map_range(n.children, 0, max_children, NODE_SIZE_MIN, NODE_SIZE_MAX)    \n             \n            # 1. kill the sources which are too close and assign sources to the node\n            sources = self.kill_sources_and_get_sources_within_radius(n)\n             \n            # now we have to check whether one of this sources belongs to another node\n            for source in sources:\n                closest_node = self.get_closest_node_to_source(active_nodes, source)\n                if n.position.DistanceTo(closest_node.position) < SMALL_VALUE: # n is the closest node to s\n                    n.sources.append(source)\n             \n            # set n.active False if no sources can be assigned\n            if not len(n.sources):\n                n.active = False\n             \n        # calculate for each active node the average direction where to put the next node\n        active_nodes = [n for n in self.nodes if n.active == True]\n        \n        for n in active_nodes:\n            \n            vec_list = [rg.Vector3d(source - n.position) for source in n.sources]\n            sum_vec = rg.Vector3d(get_vector_sum(vec_list))\n            n.direction = (sum_vec/len(n.sources))\n            n.direction.Unitize()\n            \n            new_position = n.position + n.direction * n.step_size\n             \n            if not (0 <= new_position.X < self.width and 0 <= new_position.Y < self.height):\n                continue\n            \n            # add new node at the right place\n            new_node = Node(new_position)\n            kill_distance, node_size, radius, step_size = self.map_value_from_position(new_position)\n            new_node.kill_distance = kill_distance\n            #new_node.node_size = node_size\n            new_node.radius = radius\n            new_node.step_size = step_size\n            new_node.parent = n\n            \n            self.add_child_to_all_parents(n)\n            self.nodes.append(new_node)\n         \n        print \"len(self.nodes)\", len(self.nodes)\n         \n    #===========================================================================\n    def add_child_to_all_parents(self, node):\n         \n        def add_child_to_parent(node):\n            if node.parent:\n                node.parent.children += 1\n                return True\n            else:\n                return False\n             \n        while add_child_to_parent(node):\n            node = node.parent",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": true
}