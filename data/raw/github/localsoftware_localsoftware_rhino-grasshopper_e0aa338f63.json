{
  "source_url": "https://github.com/localsoftware/localsoftware_rhino-grasshopper/blob/4aafec57e33b9f09cce6fd73dcda12b17cf794a5/python/WriteSHP.py",
  "repo": "localsoftware/localsoftware_rhino-grasshopper",
  "repo_stars": 0,
  "repo_description": null,
  "license": "BSD-2-Clause",
  "filepath": "python/WriteSHP.py",
  "instruction": "Write shapefile.py",
  "code": "\"\"\"Write shapefile.py\n\nWrites GH Geometries into ESRI Shapefiles.\nbased on the work of jlawhead<at>geospatialpython.com\n\n\tTypical usage:\n\t\tInput geoemtry, projection and a boolean.\n\n\tInputs:\n\t\tgeometry: List of geometry objects to save in shapefile.\n\t\tfields: List of attribute names for all geometry objects.\n\t\tvalues: Tree with attribute values for all geometry objects.\n\t\tpath: Path to destination file.\n\t\tfilename: destination file name.\n\t\tActivate: Boolean to write shapefile.\n\t\tprojection: map projection to create PRJ file (required for readShapefile)\n\n\tOutputs:\n\t\tNone\"\"\"\n\n__author__ = \"palomagr\"\n__version__ = \"2020.07.09\"\n\n#ghenv.Component.Name = \"Write ShapeFile\"\n#ghenv.Component.NickName = \"Write ShapeFile\"\n\n\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport Grasshopper, GhPython, System, Rhino\nimport rhinoscriptsyntax as rs\nfrom struct import pack, unpack, calcsize, error\nimport os, time, array\n\n\nclass MyComponent(component):\n\n    def RunScript(self, geometry, fields, values, path, filename, Activate, projection):\n        import sys\n        # Constants for shape types\n        NULL = 0\n        POINT = 1\n        POLYLINE = 3\n        POLYGON = 5\n        MULTIPOINT = 8\n        POINTZ = 11\n        POLYLINEZ = 13\n        POLYGONZ = 15\n        MULTIPOINTZ = 18\n        POINTM = 21\n        POLYLINEM = 23\n        POLYGONM = 25\n        MULTIPOINTM = 28\n        MULTIPATCH = 31\n\n        PYTHON3 = sys.version_info[0] == 3\n\n        def b(v):\n            if PYTHON3:\n                if isinstance(v, str):\n                    # For python 3 encode str to bytes.\n                    return v.encode('utf-8')\n                elif isinstance(v, bytes):\n                    # Already bytes.\n                    return v\n                else:\n                    # Error.\n                    raise Exception('Unknown input type')\n            else:\n                # For python 2 assume str passed in and return str.\n                return v\n\n        def u(v):\n            if PYTHON3:\n                if isinstance(v, bytes):\n                    # For python 3 decode bytes to str.\n                    return v.decode('utf-8')\n                elif isinstance(v, str):\n                    # Already str.\n                    return v\n                else:\n                    # Error.\n                    raise Exception('Unknown input type')\n            else:\n                # For python 2 assume str passed in and return str.\n                return v\n\n        def is_string(v):\n            if PYTHON3:\n                return isinstance(v, str)\n            else:\n                return isinstance(v, basestring)\n\n        class _Array(array.array):\n            \"\"\"Converts python tuples to lits of the appropritate type.\n            Used to unpack different shapefile header parts.\"\"\"\n            def __repr__(self):\n                return str(self.tolist())\n\n        class _Shape:\n            def __init__(self, shapeType=None):\n                \"\"\"Stores the geometry of the different shape types\n                specified in the Shapefile spec. Shape types are\n                usually point, polyline, or polygons. Every shape type\n                except the \"Null\" type contains points at some level for\n                example verticies in a polygon. If a shape type has\n                multiple shapes containing points within a single\n                geometry record then those shapes are called parts. Parts\n                are designated by their starting index in geometry record's\n                list of shapes.\"\"\"\n                self.shapeType = shapeType\n                self.points = []\n\n        class _ShapeRecord:\n            \"\"\"A shape object of any type.\"\"\"\n            def __init__(self, shape=None, record=None):\n                self.shape = shape\n                self.record = record\n\n        class ShapefileException(Exception):\n            \"\"\"An exception to handle shapefile specific problems.\"\"\"\n            pass\n\n        class Writer:\n            \"\"\"Provides write support for ESRI Shapefiles.\"\"\"\n            def __init__(self, shapeType=None):\n                self._shapes = []\n                self.fields = []\n                self.records = []\n                self.shapeType = shapeType\n                self.shp = None\n                self.shx = None\n                self.dbf = None\n                # Geometry record offsets and lengths for writing shx file.\n                self._offsets = []\n                self._lengths = []\n                # Use deletion flags in dbf? Default is false (0).\n                self.deletionFlag = 0\n\n            def __getFileObj(self, f):\n                \"\"\"Safety handler to verify file-like objects\"\"\"\n                if not f:\n                    raise ShapefileException(\"No file-like object available.\")\n                elif hasattr(f, \"write\"):\n                    return f\n                else:\n                    pth = os.path.split(f)[0]\n                    if pth and not os.path.exists(pth):\n                        os.makedirs(pth)\n                    return open(f, \"wb\")\n\n            def __shpFileLength(self):\n                \"\"\"Calculates the file length of the shp file.\"\"\"\n                # Start with header length\n                size = 100\n                # Calculate size of all shapes\n                for s in self._shapes:\n                    # Add in record header and shape type fields\n                    size += 12\n                    # nParts and nPoints do not apply to all shapes\n                    #if self.shapeType not in (0,1):\n                    #       nParts = len(s.parts)\n                    #       nPoints = len(s.points)\n                    if hasattr(s,'parts'):\n                        nParts = len(s.parts)\n                    if hasattr(s,'points'):\n                        nPoints = len(s.points)\n                    # All shape types capable of having a bounding box\n                    if self.shapeType in (3,5,8,13,15,18,23,25,28,31):\n                        size += 32\n                    # Shape types with parts\n                    if self.shapeType in (3,5,13,15,23,25,31):\n                        # Parts count\n                        size += 4\n                        # Parts index array\n                        size += nParts * 4\n                    # Shape types with points\n                    if self.shapeType in (3,5,8,13,15,23,25,31):\n                        # Points count\n                        size += 4\n                        # Points array\n                        size += 16 * nPoints\n                    # Calc size of part types for Multipatch (31)\n                    if self.shapeType == 31:\n                        size += nParts * 4\n                    # Calc z extremes and values\n                    if self.shapeType in (13,15,18,31):\n                        # z extremes\n                        size += 16\n                        # z array\n                        size += 8 * nPoints\n                    # Calc m extremes and values\n                    if self.shapeType in (23,25,31):\n                        # m extremes\n                        size += 16\n                        # m array\n                        size += 8 * nPoints\n                    # Calc a single point\n                    if self.shapeType in (1,11,21):\n                        size += 16\n                    # Calc a single Z value\n                    if self.shapeType == 11:\n                        size += 8\n                    # Calc a single M value\n                    if self.shapeType in (11,21):\n                        size += 8\n                # Calculate size as 16-bit words\n                size //= 2\n                return size\n\n            def __bbox(self, shapes, shapeTypes=[]):\n                x = []\n                y = []\n                for s in shapes:\n                    shapeType = self.shapeType\n                    if shapeTypes:\n                        shapeType = shapeTypes[shapes.index(s)]\n                    px, py = list(zip(*s.points))[:2]\n                    x.extend(px)\n                    y.extend(py)\n                return [min(x), min(y), max(x), max(y)]\n\n            def __zbox(self, shapes, shapeTypes=[]):\n                z = []\n                for s in shapes:\n                    try:\n                        for p in s.points:\n                            z.append(p[2])\n                    except IndexError:\n                        pass\n                if not z: z.append(0)\n                return [min(z), max(z)]\n\n            def __mbox(self, shapes, shapeTypes=[]):\n                m = [0]\n                for s in shapes:\n                    try:\n                        for p in s.points:\n                            m.append(p[3])\n                    except IndexError:\n                        pass\n                return [min(m), max(m)]\n\n            def bbox(self):\n                \"\"\"Returns the current bounding box for the shapefile which is\n                the lower-left and upper-right corners. It does not contain the\n                elevation or measure extremes.\"\"\"\n                return self.__bbox(self._shapes)\n\n            def zbox(self):\n                \"\"\"Returns the current z extremes for the shapefile.\"\"\"\n                return self.__zbox(self._shapes)\n\n            def mbox(self):\n                \"\"\"Returns the current m extremes for the shapefile.\"\"\"\n                return self.__mbox(self._shapes)\n\n            def __shapefileHeader(self, fileObj, headerType='shp'):\n                \"\"\"Writes the specified header type to the specified file-like object.\n                Several of the shapefile formats are so similar that a single generic\n                method to read or write them is warranted.\"\"\"\n                f = self.__getFileObj(fileObj)\n                f.seek(0)\n                # File code, Unused bytes\n                f.write(pack(\">6i\", 9994,0,0,0,0,0))\n                # File length (Bytes / 2 = 16-bit words)\n                if headerType == 'shp':\n                    f.write(pack(\">i\", self.__shpFileLength()))\n                elif headerType == 'shx':\n                    f.write(pack('>i', ((100 + (len(self._shapes) * 8)) // 2)))\n                # Version, Shape type\n                f.write(pack(\"<2i\", 1000, self.shapeType))\n                # The shapefile's bounding box (lower left, upper right)\n                if self.shapeType != 0:\n                    try:\n                        f.write(pack(\"<4d\", *self.bbox()))\n                    except error:\n                        raise ShapefileException(\"Failed to write shapefile bounding box. Floats required.\")\n                else:\n                    f.write(pack(\"<4d\", 0,0,0,0))\n                # Elevation\n                z = self.zbox()\n                # Measure\n                m = self.mbox()\n                try:\n                    f.write(pack(\"<4d\", z[0], z[1], m[0], m[1]))\n                except error:\n                    raise ShapefileException(\"Failed to write shapefile elevation and measure values. Floats required.\")\n\n            def __dbfHeader(self):\n                \"\"\"Writes the dbf header and field descriptors.\"\"\"\n                f = self.__getFileObj(self.dbf)\n                f.seek(0)\n                version = 3\n                year, month, day = time.localtime()[:3]\n                year -= 1900\n                # Remove deletion flag placeholder from fields\n                for field in self.fields:\n                    if field[0].startswith(\"Deletion\"):\n                        self.fields.remove(field)\n                numRecs = len(self.records)\n                numFields = len(self.fields)\n                headerLength = numFields * 32 + 33\n                recordLength = sum([int(field[2]) for field in self.fields]) + 1\n                header = pack('<BBBBLHH20x', version, year, month, day, numRecs,\n                        headerLength, recordLength)\n                f.write(header)\n                # Field descriptors\n                for field in self.fields:\n                    name, fieldType, size, decimal = field\n                    name = b(name)\n                    name = name.replace(b(' '), b('_'))\n                    name = name.ljust(11).replace(b(' '), b('\\x00'))\n                    fieldType = b(fieldType)\n                    size = int(size)\n                    fld = pack('<11sc4xBB14x', name, fieldType, size, decimal)\n                    f.write(fld)\n                # Terminator\n                f.write(b('\\r'))\n\n            def __shpRecords(self):\n                \"\"\"Write the shp records\"\"\"\n                f = self.__getFileObj(self.shp)\n                f.seek(100)\n                recNum = 1\n                for s in self._shapes:\n                    self._offsets.append(f.tell())\n                    # Record number, Content length place holder\n                    f.write(pack(\">2i\", recNum, 0))\n                    recNum += 1\n                    start = f.tell()\n                    # Shape Type\n                    f.write(pack(\"<i\", s.shapeType))\n                    # All shape types capable of having a bounding box\n                    if s.shapeType in (3,5,8,13,15,18,23,25,28,31):\n                        try:\n                            f.write(pack(\"<4d\", *self.__bbox([s])))\n                        except error:\n                            raise ShapefileException(\"Falied to write bounding box for record %s. Expected floats.\" % recNum)\n                    # Shape types with parts\n                    if s.shapeType in (3,5,13,15,23,25,31):\n                        # Number of parts\n                        f.write(pack(\"<i\", len(s.parts)))\n                    # Shape types with multiple points per record\n                    if s.shapeType in (3,5,8,13,15,23,25,31):\n                        # Number of points\n                        f.write(pack(\"<i\", len(s.points)))\n                    # Write part indexes\n                    if s.shapeType in (3,5,13,15,23,25,31):\n                        for p in s.parts:\n                            f.write(pack(\"<i\", p))\n                    # Part types for Multipatch (31)\n                    if s.shapeType == 31:\n                        for pt in s.partTypes:\n                            f.write(pack(\"<i\", pt))\n                    # Write points for multiple-point records\n                    if s.shapeType in (3,5,8,13,15,23,25,31):\n                        try:\n                            [f.write(pack(\"<2d\", *p[:2])) for p in s.points]\n                        except error:\n                            raise ShapefileException(\"Failed to write points for record %s. Expected floats.\" % recNum)\n                    # Write z extremes and values\n                    if s.shapeType in (13,15,18,31):\n                        try:\n                            f.write(pack(\"<2d\", *self.__zbox([s])))\n                        except error:\n                            raise ShapefileException(\"Failed to write elevation extremes for record %s. Expected floats.\" % recNum)\n                        try:\n                            [f.write(pack(\"<d\", p[2])) for p in s.points]\n                        except error:\n                            raise ShapefileException(\"Failed to write elevation values for record %s. Expected floats.\" % recNum)\n                    # Write m extremes and values\n                    if s.shapeType in (23,25,31):\n                        try:\n                            f.write(pack(\"<2d\", *self.__mbox([s])))\n                        except error:\n                            raise ShapefileException(\"Failed to write measure extremes for record %s. Expected floats\" % recNum)\n                        try:\n                            [f.write(pack(\"<d\", p[3])) for p in s.points]\n                        except error:\n                            raise ShapefileException(\"Failed to write measure values for record %s. Expected floats\" % recNum)\n                    # Write a single point\n                    if s.shapeType in (1,11,21):\n                        try:\n                            f.write(pack(\"<2d\", s.points[0][0], s.points[0][1]))\n                        except error:\n                            raise ShapefileException(\"Failed to write point for record %s. Expected floats.\" % recNum)\n                    # Write a single Z value\n                    if s.shapeType == 11:\n                        try:\n                            f.write(pack(\"<1d\", s.points[0][2]))\n                        except error:\n                            raise ShapefileException(\"Failed to write elevation value for record %s. Expected floats.\" % recNum)\n                    # Write a single M value\n                    if s.shapeType in (11,21):\n                        try:\n                            f.write(pack(\"<1d\", s.points[0][3]))\n                        except error:\n                            raise ShapefileException(\"Failed to write measure value for record %s. Expected floats.\" % recNum)\n                    # Finalize record length as 16-bit words\n                    finish = f.tell()\n                    length = (finish - start) // 2\n                    self._lengths.append(length)\n                    # start - 4 bytes is the content length field\n                    f.seek(start-4)\n                    f.write(pack(\">i\", length))\n                    f.seek(finish)\n\n            def __shxRecords(self):\n                \"\"\"Writes the shx records.\"\"\"\n                f = self.__getFileObj(self.shx)\n                f.seek(100)\n                for i in range(len(self._shapes)):\n                    f.write(pack(\">i\", self._offsets[i] // 2))\n                    f.write(pack(\">i\", self._lengths[i]))\n\n            def __dbfRecords(self):\n                \"\"\"Writes the dbf records.\"\"\"\n                f = self.__getFileObj(self.dbf)\n                for record in self.records:\n                    if not self.fields[0][0].startswith(\"Deletion\"):\n                        f.write(b(' ')) # deletion flag\n                    for (fieldName, fieldType, size, dec), value in zip(self.fields, record):\n                        fieldType = fieldType.upper()\n                        size = int(size)\n                        if fieldType.upper() == \"N\":\n                            value = str(value).rjust(size)\n                        elif fieldType == 'L':\n                            value = str(value)[0].upper()\n                        else:\n                            value = str(value)[:size].ljust(size)\n                        assert len(value) == size\n                        value = b(value)\n                        f.write(value)\n\n            def null(self):\n                \"\"\"Creates a null shape.\"\"\"\n                self._shapes.append(_Shape(NULL))\n\n            def point(self, x, y, z=0, m=0):\n                \"\"\"Creates a point shape.\"\"\"\n                pointShape = _Shape(self.shapeType)\n                pointShape.points.append([x, y, z, m])\n                self._shapes.append(pointShape)\n\n            def line(self, parts=[], shapeType=POLYLINE):\n                \"\"\"Creates a line shape. This method is just a convienience method\n                which wraps 'poly()'.\n                \"\"\"\n                self.poly(parts, shapeType, [])\n\n            def poly(self, parts=[], shapeType=POLYGON, partTypes=[]):\n                \"\"\"Creates a shape that has multiple collections of points (parts)\n                including lines, polygons, and even multipoint shapes. If no shape type\n                is specified it defaults to 'polygon'. If no part types are specified\n                (which they normally won't be) then all parts default to the shape type.\n                \"\"\"\n                polyShape = _Shape(shapeType)\n                polyShape.parts = []\n                polyShape.points = []\n                for part in parts:\n                    polyShape.parts.append(len(polyShape.points))\n                    for point in part:\n                        # Ensure point is list\n                        if not isinstance(point, list):\n                            point = list(point)\n                        # Make sure point has z and m values\n                        while len(point) < 4:\n                            point.append(0)\n                        polyShape.points.append(point)\n                if polyShape.shapeType == 31:\n                    if not partTypes:\n                        for part in parts:\n                            partTypes.append(polyShape.shapeType)\n                    polyShape.partTypes = partTypes\n                self._shapes.append(polyShape)\n\n            def field(self, name, fieldType=\"C\", size=\"50\", decimal=0):\n                \"\"\"Adds a dbf field descriptor to the shapefile.\"\"\"\n                self.fields.append((name, fieldType, size, decimal))\n\n            def record(self, *recordList, **recordDict):\n                \"\"\"Creates a dbf attribute record. You can submit either a sequence of\n                field values or keyword arguments of field names and values. Before\n                adding records you must add fields for the record values using the\n                fields() method. If the record values exceed the number of fields the\n                extra ones won't be added. In the case of using keyword arguments to specify\n                field/value pairs only fields matching the already registered fields\n                will be added.\"\"\"\n                record = []\n                fieldCount = len(self.fields)\n                # Compensate for deletion flag\n                if self.fields[0][0].startswith(\"Deletion\"): fieldCount -= 1\n                if recordList:\n                    [record.append(recordList[i]) for i in range(fieldCount)]\n                elif recordDict:\n                    for field in self.fields:\n                        if field[0] in recordDict:\n                            val = recordDict[field[0]]\n                            if val:\n                                record.append(val)\n                            else:\n                                record.append(\"\")\n                if record:\n                    self.records.append(record)\n\n            def shape(self, i):\n                return self._shapes[i]\n\n            def shapes(self):\n                \"\"\"Return the current list of shapes.\"\"\"\n                return self._shapes\n\n            def saveShp(self, target):\n                \"\"\"Save an shp file.\"\"\"\n                if not hasattr(target, \"write\"):\n                    target = os.path.splitext(target)[0] + '.shp'\n                if not self.shapeType:\n                    self.shapeType = self._shapes[0].shapeType\n                self.shp = self.__getFileObj(target)\n                self.__shapefileHeader(self.shp, headerType='shp')\n                self.__shpRecords()\n\n            def saveShx(self, target):\n                \"\"\"Save an shx file.\"\"\"\n                if not hasattr(target, \"write\"):\n                    target = os.path.splitext(target)[0] + '.shx'\n                if not self.shapeType:\n                    self.shapeType = self._shapes[0].shapeType\n                self.shx = self.__getFileObj(target)\n                self.__shapefileHeader(self.shx, headerType='shx')\n                self.__shxRecords()\n\n            def saveDbf(self, target):\n                \"\"\"Save a dbf file.\"\"\"\n                if not hasattr(target, \"write\"):\n                    target = os.path.splitext(target)[0] + '.dbf'\n                self.dbf = self.__getFileObj(target)\n                self.__dbfHeader()\n                self.__dbfRecords()\n\n            def save(self, target=None, shp=None, shx=None, dbf=None):\n                \"\"\"Save the shapefile data to three files or\n                three file-like objects. SHP and DBF files can also\n                be written exclusively using saveShp, saveShx, and saveDbf respectively.\"\"\"\n                # TODO: Create a unique filename for target if None.\n                if shp:\n                    self.saveShp(shp)\n                if shx:\n                    self.saveShx(shx)\n                if dbf:\n                    self.saveDbf(dbf)\n                elif target:\n                    self.saveShp(target)\n                    self.shp.close()\n                    self.saveShx(target)\n                    self.shx.close()\n                    self.saveDbf(target)\n                    self.dbf.close()\n\n        def Main():\n            if path!=None and filename!=None:\n                file = os.path.join(path, filename)\n                if Activate == True:\n                    if type(geometry[0]) == Rhino.Geometry.Point: # If it is a point collection\n                        w = Writer(POINT)\n                        for field in fields: # Write the fields in the dbf\n                            w.field(field)\n                        for i, pt in enumerate(geometry):\n                            vals = get_fields(i, fields, values, geometry)\n                            point = rs.PointCoordinates(pt) # Turn the points into Rhino pt objects\n                            w.point(point.X, point.Y, point.Z) # Write the pts as shp geometry objects\n                            w.record(*vals) # Write the values for each pt\n                        w.save(file)\n\n                    else:\n                        if geometry[0].IsClosed == False: # If the geometry is a curve, write a line shp\n                            w = Writer(POLYLINE)\n                            for field in fields: # Write the fields in the dbf\n                                w.field(field)\n                            for i, crv in enumerate(geometry):\n                                cp = rs.CurvePoints(crv) # get the cps of the curves\n                                if len(cp) >1: # Make sure it's a line\n                                    vals = get_fields(i, fields, values, geometry)\n                                    points = [[[pt.X,pt.Y,pt.Z] for pt in cp]] # create a formated nested list from the cps to write the shp\n                                    w.poly(parts=points) # Write the polylines as shp geometry objects\n                                    w.record(*vals) # Write the values for each pt\n                            w.save(file)\n\n                        else: # It is a polygon\n                            w = Writer(POLYGON)\n                            for field in fields: # Write the fields in the dbf\n                                w.field(field)\n                            for i, crv in enumerate(geometry):\n                                cp = rs.CurvePoints(crv) # get the cps of the curves\n                                if len(cp) >1: # Make sure it's a line\n                                    vals = get_fields(i, fields, values, geometry)\n                                    points = [[[pt.X,pt.Y,pt.Z] for pt in cp]] # create a formated nested list from the cps to write the shp\n                                    w.poly(parts=points) # Write the polylines as shp geometry objects\n                                    w.record(*vals) # Write the values for each pt\n                            w.save(file)\n                if projection:\n                    prj(file, projection)\n\n        def get_fields(i, fields, values, geometry):\n            vals = [] # Create a list to store values for each geom\n            for h in range(len(fields)):\n                vals.append(values[values.Path(i),h]) # I iterate through the data tree and build individual lists\n            return vals\n\n        def prj(file, epsg):\n            # create the PRJ file\n            prj = open(\"%s.prj\" % file, \"w\")\n            prj.write(epsg)\n            prj.close()\n\n#        if __name__ == \"__main__\":\n#            Main()\n\n        Main()\n\n        # return outputs if you have them; here I try it for you:\n        return\n",
  "language": "python",
  "imports": [
    "Rhino.Geometry",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}