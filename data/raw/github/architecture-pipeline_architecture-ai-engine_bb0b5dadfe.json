{
  "source_url": "https://github.com/architecture-pipeline/architecture-ai-engine/blob/d88a1e08796fbe0bbc24c0c2a96c282317235c94/generate.py",
  "repo": "architecture-pipeline/architecture-ai-engine",
  "repo_stars": 0,
  "repo_description": "Research Project for Scalable Dataset",
  "license": "unknown",
  "filepath": "generate.py",
  "instruction": "Generate",
  "code": "import rhinoscriptsyntax as rs\nimport random\nimport os\nimport time\nimport json\nimport math\n\n# --- CONFIG ---\nNUM_VARIATIONS = 5\nCELL_SIZE = 2.0\nLAYER_HEIGHT = 1.0\nMAX_BASE = 12\nMAX_LAYERS = 40\nMAX_VOXELS = 400\n\nBIRTH_OPTIONS = [2, 3]\nSURV_MIN_OPTIONS = [2, 3]\nSURV_MAX_OPTIONS = [4, 5, 6]\n\n# --- Camera Configuration ---\nCAMERA_DISTANCE_MULTIPLIER = 2.0\nCAMERA_HORIZONTAL_ANGLE_DEG = 35.0\nCAMERA_TARGET_Z_FACTOR = 0.5\nCAMERA_Z_FACTOR = 0.5\n\n\n# --- OUTPUT DIRECTORY ---\n# Set this to your desired output folder (works on any OS)\nROOT_DIR = os.path.join(os.path.expanduser(\"~\"), \"Desktop\", \"architecture-ai-engine\", \"GeometryImagesRhino\")\nif not os.path.exists(ROOT_DIR):\n    os.makedirs(ROOT_DIR)\n\ndef compute_next(g, prev_g, b, smin, smax, z):\n    w, h = len(g), len(g[0])\n    nxt = [[0] * h for _ in range(w)]\n    for x in range(w):\n        for y in range(h):\n            cnt = sum(g[x + dx][y + dy] for dx in (-1, 0, 1) for dy in (-1, 0, 1)\n                      if not (dx == dy == 0) and 0 <= x + dx < w and 0 <= y + dy < h)\n\n            # Direct vertical support from the cell directly below\n            has_direct_vertical_support = prev_g[x][y] == 1 if 0 <= x < w and 0 <= y < h else False\n\n            # Check for horizontal connectivity to an existing cell in the current grid (g)\n            # This helps prevent new isolated islands\n            has_horizontal_connectivity = False\n            for dx in (-1, 0, 1):\n                for dy in (-1, 0, 1):\n                    if dx == 0 and dy == 0: continue # Skip self\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < w and 0 <= ny < h and g[nx][ny] == 1:\n                        has_horizontal_connectivity = True\n                        break\n                if has_horizontal_connectivity:\n                    break\n\n            if not g[x][y]: # If the cell is currently dead (0)\n                # A new cell is born if it has enough neighbors, direct vertical support,\n                # AND some horizontal connectivity (or is at the very base for initial growth)\n                if cnt >= b and (has_direct_vertical_support or (x == 0 and y == 0)) and (has_horizontal_connectivity or (z == 0)): # Added z==0 check for initial layer growth without strict horizontal pre-existing cells\n                    nxt[x][y] = 1\n\n            elif g[x][y]: # If the cell is currently alive (1)\n                # An existing cell survives if it has enough neighbors, direct vertical support,\n                # AND it maintains some horizontal connectivity\n                if smin <= cnt <= smax and (has_direct_vertical_support or (x == 0 and y == 0)) and (has_horizontal_connectivity or (z == 0)): # Added z==0 check\n                    nxt[x][y] = 1\n            else:\n                nxt[x][y] = 0\n    return nxt\n\ndef get_bounding_box_center_coords(bbox_points):\n    if not bbox_points or len(bbox_points) < 8: return None\n    min_pt, max_pt = bbox_points[0], bbox_points[6]\n    return ((min_pt[0] + max_pt[0]) / 2.0,\n            (min_pt[1] + max_pt[1]) / 2.0,\n            (min_pt[2] + max_pt[2]) / 2.0)\n\ndef setup_angled_perspective_view(target_point, camera_distance, building_height, lens_length,\n                                  target_z_factor, camera_z_factor, horizontal_angle_deg):\n    angle_rad = math.radians(horizontal_angle_deg)\n    direction_xy = (-math.cos(angle_rad), -math.sin(angle_rad))\n\n    cam_x = target_point[0] + direction_xy[0] * camera_distance\n    cam_y = target_point[1] + direction_xy[1] * camera_distance\n\n    target_z = building_height * target_z_factor\n    camera_z = building_height * camera_z_factor\n\n    camera_location = (cam_x, cam_y, camera_z)\n    target_location = list(target_point)\n    target_location[2] = target_z\n\n    rs.Command(\"_-SetActiveViewport Perspective\", False)\n    rs.ViewCameraTarget(camera=camera_location, target=target_location)\n    rs.Command(\"_-Lens \" + str(lens_length), False)\n\ndef capture_view(filepath):\n    rs.UnselectAllObjects()\n    rs.Command(\"_-SetDisplayMode _Shaded _Enter\", True)\n    command = (\n        '-_ViewCaptureToFile \"{}\" '\n        \"Width=800 Height=1200 \"\n        \"LockAspectRatio=Yes \"\n        \"TransparentBackground=No \"\n        \"_Enter\"\n    ).format(filepath)\n    rs.Command(command, False)\n    time.sleep(0.1)\n\n# --- MAIN ---\nrs.EnableRedraw(False)\nrs.DeleteObjects(rs.AllObjects())\n\n# Find the next available tower index\nexisting_towers = [d for d in os.listdir(ROOT_DIR) if d.startswith(\"tower_\") and os.path.isdir(os.path.join(ROOT_DIR, d))]\nif existing_towers:\n    max_idx = max(int(t.split(\"_\")[1]) for t in existing_towers)\n    START_IDX = max_idx + 1\nelse:\n    START_IDX = 0\n\nprint(f\"Starting from tower {START_IDX:03d}\")\n\nfor idx in range(START_IDX, START_IDX + NUM_VARIATIONS):\n    layer_name = f\"T{idx}\"\n    if rs.IsLayer(layer_name): rs.PurgeLayer(layer_name)\n    rs.AddLayer(layer_name)\n\n    cell_centers = []\n    current_seed = 42 + idx\n\n    random.seed(current_seed)\n    b = random.choice(BIRTH_OPTIONS)\n    smin = random.choice(SURV_MIN_OPTIONS)\n    smax = random.choice(SURV_MAX_OPTIONS)\n\n\n    xc = random.randint(3, 4)\n    yc = random.randint(3, 4)\n\n\n    min_height_ratio = 4\n    min_layers = int(min_height_ratio * max(xc, yc))\n    layers = random.randint(min_layers, MAX_LAYERS)\n\n\n    grid = [[random.choice([0, 1]) for _ in range(yc)] for _ in range(xc)]\n    while sum(map(sum, grid)) < 0.5 * xc * yc:\n        grid = [[random.choice([0, 1]) for _ in range(yc)] for _ in range(xc)]\n\n    vox, building_objs = 0, []\n    actual_layers_created = 0\n    taper_interval = 7\n    rule_interval = 8\n\n    prev_grid = [row[:] for row in grid]\n    for z in range(layers):\n        MIN_LAYERS = 20\n        if actual_layers_created < MIN_LAYERS:\n            remaining_layers = MIN_LAYERS - actual_layers_created\n            for extra_z in range(remaining_layers):\n                for i in range(len(grid)):\n                    for j in range(len(grid[0])):\n                        if grid[i][j]:\n                            x0 = i * CELL_SIZE\n                            y0 = j * CELL_SIZE\n                            z0 = (actual_layers_created + extra_z) * LAYER_HEIGHT\n                            corners = [(x0,y0,z0),(x0+CELL_SIZE,y0,z0),(x0+CELL_SIZE,y0+CELL_SIZE,z0),(x0,y0+CELL_SIZE,z0),\n                                       (x0,y0,z0+LAYER_HEIGHT),(x0+CELL_SIZE,y0,z0+LAYER_HEIGHT),\n                                       (x0+CELL_SIZE,y0+CELL_SIZE,z0+LAYER_HEIGHT),(x0,y0+CELL_SIZE,z0+LAYER_HEIGHT)]\n                            building_objs.append(rs.AddBox(corners))\n                            cell_centers.append([x0+CELL_SIZE/2.0, y0+CELL_SIZE/2.0, z0+LAYER_HEIGHT/2.0])\n                            vox += 1\n                            if vox >= MAX_VOXELS: break\n                    if vox >= MAX_VOXELS: break\n                actual_layers_created += 1\n                if vox >= MAX_VOXELS: break\n\n        if vox >= MAX_VOXELS or not any(map(sum, grid)):\n            actual_layers_created = z + 1\n            break\n\n        prev_grid = [row[:] for row in grid]\n        grid = compute_next(grid, prev_grid, b, smin, smax, z)\n\n        taper_interval = 6\n        if (z + 1) % taper_interval == 0 and len(grid) > 3 and len(grid[0]) > 3:\n            grid = [row[1:-1] for row in grid[1:-1]]\n\n        if not any(map(sum, grid)):\n            if len(grid) > 3 and len(grid[0]) > 3:\n                grid = [[1 if 1 < i < len(grid)-2 and 1 < j < len(grid[0])-2 else 0\n                        for j in range(len(grid[0]))]\n                        for i in range(len(grid))]\n            else:\n                break\n        actual_layers_created = z + 1\n\n        # Taper every few layers\n        if (z + 1) % taper_interval == 0 and len(grid) > 3 and len(grid[0]) > 3:\n            grid = [row[1:-1] for row in grid[1:-1]]  # remove outer ring\n\n        # Change CA rule periodically\n        if (z + 1) % rule_interval == 0:\n            b = random.choice(BIRTH_OPTIONS)\n            smin = random.choice(SURV_MIN_OPTIONS)\n            smax = random.choice(SURV_MAX_OPTIONS)\n\n    if not building_objs:\n        print(f\"Tower {idx:03d} resulted in no geometry. Skipping.\"); continue\n\n    rs.ObjectLayer(building_objs, layer_name)\n\n    bbox = rs.BoundingBox(building_objs)\n    if bbox:\n        move_vector = rs.VectorSubtract((0,0,0),((bbox[0][0]+bbox[6][0])/2,(bbox[0][1]+bbox[6][1])/2,bbox[0][2]))\n        rs.MoveObjects(building_objs, move_vector)\n\n    ground_plane_size = (MAX_BASE*CELL_SIZE)*5.0\n    ground_plane = rs.AddPlaneSurface(rs.WorldXYPlane(), ground_plane_size, ground_plane_size)\n    if ground_plane:\n        rs.MoveObject(ground_plane, (-ground_plane_size/2.0, -ground_plane_size/2.0, 0))\n\n    tower_dir = os.path.join(ROOT_DIR, \"tower_%03d\" % idx)\n    if not os.path.exists(tower_dir):\n        os.makedirs(tower_dir)\n\n    tower_bbox_at_origin = rs.BoundingBox(building_objs)\n    if tower_bbox_at_origin:\n        target_coords = get_bounding_box_center_coords(tower_bbox_at_origin)\n        if target_coords:\n            building_height = tower_bbox_at_origin[6][2] - tower_bbox_at_origin[0][2]\n            building_width = tower_bbox_at_origin[6][0] - tower_bbox_at_origin[0][0]\n            building_depth = tower_bbox_at_origin[6][1] - tower_bbox_at_origin[0][1]\n            largest_dim = max(building_width, building_depth, building_height)\n            \n            # --- MODIFIED CAMERA DISTANCE ---\n            cam_dist = largest_dim * CAMERA_DISTANCE_MULTIPLIER\n\n            setup_angled_perspective_view(\n                target_coords,\n                cam_dist,\n                building_height,\n                50,\n                CAMERA_TARGET_Z_FACTOR,\n                CAMERA_Z_FACTOR,\n                CAMERA_HORIZONTAL_ANGLE_DEG\n            )\n\n            \n            filepath = os.path.join(tower_dir, \"perspective.png\")\n            capture_view(filepath)\n\n            # Capture perspective_opposite (180 degrees rotated)\n            setup_angled_perspective_view(\n                target_coords,\n                cam_dist,\n                building_height,\n                50,\n                CAMERA_TARGET_Z_FACTOR,\n                CAMERA_Z_FACTOR,\n                CAMERA_HORIZONTAL_ANGLE_DEG + 180\n            )\n            filepath = os.path.join(tower_dir, \"perspective_opposite.png\")\n            capture_view(filepath)\n\n            # Capture elevation (side view - camera at mid height, looking straight)\n            setup_angled_perspective_view(\n                target_coords,\n                cam_dist,\n                building_height,\n                50,\n                0.5,\n                0.5,\n                90\n            )\n            filepath = os.path.join(tower_dir, \"elevation.png\")\n            capture_view(filepath)\n\n            # Capture street_level (low angle looking up)\n            setup_angled_perspective_view(\n                target_coords,\n                cam_dist * 1.2,\n                building_height,\n                50,\n                0.4,\n                0.25,\n                135\n            )\n            filepath = os.path.join(tower_dir, \"street_level.png\")\n            capture_view(filepath)\n\n    if ground_plane: rs.DeleteObject(ground_plane)\n\n    output_data = {\n        \"tower_info\": {\n            \"ID\": idx,\n            \"unit_cell_size\": CELL_SIZE,\n            \"layer_height\": LAYER_HEIGHT,\n            \"actual_layers_created\": actual_layers_created,\n            \"total_cells\": vox,\n            \"seed\": current_seed,\n            \"prompt\": \"\"\n        },\n        \"cell_centers\": cell_centers\n    }\n    with open(os.path.join(tower_dir, \"params.json\"), \"w\") as fp:\n        json.dump(output_data, fp, indent=2)\n\n    # Clean up memory - delete tower geometry after capturing\n    rs.DeleteObjects(building_objs)\n    if rs.IsLayer(layer_name):\n        rs.PurgeLayer(layer_name)\n\n    print(f\"Generated and captured tower {idx:03d}\")\n\nrs.EnableRedraw(True)\n\nprint(f\"\\nProcess complete. Generated {NUM_VARIATIONS} towers in {ROOT_DIR}\")\nprint(\"Images and params saved. Geometry cleaned from memory.\")",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}