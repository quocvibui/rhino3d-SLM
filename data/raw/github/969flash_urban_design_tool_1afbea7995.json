{
  "source_url": "https://github.com/969flash/urban_design_tool/blob/0a891333039b4d06213c16f2d4b6bb12b02f2ad1/src/landuse_trimmer.py",
  "repo": "969flash/urban_design_tool",
  "repo_stars": 0,
  "repo_description": "urban_design_tool",
  "license": "unknown",
  "filepath": "src/landuse_trimmer.py",
  "instruction": "Landuse trimmer",
  "code": "import Rhino\nimport Rhino.Geometry as rg\nimport ghpythonlib.components as ghcomp\nimport System\n\n\nclass Block:\n    def __init__(self, region, landuse_name, block_id):\n        self.region = region\n        self.landuse_name = landuse_name\n        self.block_id = block_id\n        self.buildings = []  # trimmed building footprints per block\n\n\nDEBUG = False\nLANDUSE_PARENT = \"Landuse\"\nTARGET_PARENT_LAYER = \"Landuse-Road\"\nZ_EXTRUDE = 1.0\nZ_LIMIT = 0.1\n\n\ndef dprint(*args):\n    if DEBUG:\n        try:\n            print(*args)\n        except Exception:\n            pass\n\n\ndef extrude_srf(srf, height):\n    \"\"\"Surface/Brep를 z축으로 height만큼 Extrude한 Brep 반환.\"\"\"\n    extrusion = ghcomp.Extrude(srf, rg.Vector3d(0, 0, height))\n    return ghcomp.CapHoles(extrusion)\n\n\ndef get_layer_surfaces(doc, parent_name):\n    \"\"\"parent_name 하위 레이어에서 Surface/Brep를 모두 Brep로 수집.\"\"\"\n    layer_dict = {}\n    for layer in doc.Layers:\n        if not layer.IsVisible:\n            continue\n        full_path = getattr(layer, \"FullPath\", layer.Name)\n        parts = full_path.split(\"::\") if full_path else []\n        if len(parts) >= 2 and parts[0] == parent_name:\n            child_name = parts[1]\n            objs = [\n                obj\n                for obj in doc.Objects.FindByLayer(layer)\n                if isinstance(obj.Geometry, (rg.Surface, rg.Brep))\n            ]\n            srfs = []\n            for obj in objs:\n                geo = obj.Geometry\n                if isinstance(geo, rg.Surface):\n                    srfs.append(rg.Brep.CreateFromSurface(geo))\n                elif isinstance(geo, rg.Brep):\n                    srfs.append(geo)\n            if child_name in layer_dict:\n                layer_dict[child_name].extend(srfs)\n            else:\n                layer_dict[child_name] = srfs\n    return layer_dict\n\n\ndef is_point_on_srf(pt, srf):\n    if pt is None:\n        return False\n    pt_on_srf = ghcomp.SurfaceClosestPoint(pt, srf).point\n    return pt_on_srf.DistanceTo(pt) < 0.01\n\n\ndef get_point_inside_face(surface):\n    meshes = rg.Mesh.CreateFromBrep(surface, rg.MeshingParameters.Default)\n    if not meshes:\n        return None\n    mesh = meshes[0]\n    if mesh.Faces.Count == 0:\n        return None\n    indices = mesh.Faces[0]\n    p0 = mesh.Vertices[indices.A]\n    p1 = mesh.Vertices[indices.B]\n    p2 = mesh.Vertices[indices.C]\n    return rg.Point3d(\n        (p0.X + p1.X + p2.X) / 3.0,\n        (p0.Y + p1.Y + p2.Y) / 3.0,\n        (p0.Z + p1.Z + p2.Z) / 3.0,\n    )\n\n\ndef collect_landuse_road_faces(\n    doc,\n    road_regions,\n    landuse_parent=LANDUSE_PARENT,\n    z_height=Z_EXTRUDE,\n    z_limit=Z_LIMIT,\n):\n    \"\"\"Landuse 면에서 도로를 차감한 후 유효 BrepFace 목록을 용도별로 반환.\"\"\"\n    landuse_dict = get_layer_surfaces(doc, landuse_parent)\n    faces_by_landuse = {}\n\n    road_breps = []\n    for region in road_regions:\n        road_brep = extrude_srf(region, z_height)\n        if road_brep:\n            road_breps.append(road_brep)\n\n    for lu_name, lu_srfs in landuse_dict.items():\n        collected_faces = []\n        for lu_srf in lu_srfs:\n            base_brep = extrude_srf(lu_srf, z_height)\n            if not base_brep:\n                continue\n            diff_brep = base_brep\n            for road_brep in road_breps:\n                diff_brep = ghcomp.SolidDifference(diff_brep, road_brep)\n                if not diff_brep:\n                    break\n            if not diff_brep:\n                continue\n            decon = ghcomp.DeconstructBrep(diff_brep)\n            faces = decon[0]\n            for face in faces:\n                mp = rg.AreaMassProperties.Compute(face)\n                if mp and mp.Centroid.Z > z_limit:\n                    continue\n                test_pt = get_point_inside_face(face)\n                if not is_point_on_srf(test_pt, lu_srf):\n                    continue\n                collected_faces.append(face)\n        if collected_faces:\n            faces_by_landuse[lu_name] = collected_faces\n    return faces_by_landuse\n\n\ndef _find_layer_by_fullpath(doc, fullpath):\n    for ly in doc.Layers:\n        fp = getattr(ly, \"FullPath\", None) or ly.Name or \"\"\n        if fp == fullpath:\n            return ly\n    return None\n\n\ndef _ensure_layer(doc, name, parent_id=None):\n    if parent_id:\n        parent = doc.Layers.FindId(parent_id)\n        parent_path = getattr(parent, \"FullPath\", parent.Name) if parent else None\n        target_path = (parent_path + \"::\" + name) if parent_path else name\n        found = _find_layer_by_fullpath(doc, target_path)\n        if found:\n            return found\n    else:\n        for ly in doc.Layers:\n            if ly.ParentLayerId == System.Guid.Empty and ly.Name == name:\n                return ly\n    layer = Rhino.DocObjects.Layer()\n    layer.Name = name\n    if parent_id:\n        layer.ParentLayerId = parent_id\n        try:\n            parent_layer = doc.Layers.FindId(parent_id)\n            if parent_layer:\n                layer.Color = parent_layer.Color\n        except Exception:\n            pass\n    idx = doc.Layers.Add(layer)\n    return doc.Layers[idx] if idx >= 0 else None\n\n\ndef _clear_layer_tree(doc, parent_name):\n    parent = None\n    for ly in doc.Layers:\n        if ly.Name == parent_name and ly.ParentLayerId == System.Guid.Empty:\n            parent = ly\n            break\n    if not parent:\n        return 0\n    parent_path = getattr(parent, \"FullPath\", None) or parent.Name or \"\"\n    deleted = 0\n    for ly in doc.Layers:\n        fp = getattr(ly, \"FullPath\", None) or ly.Name or \"\"\n        if parent_path and (fp == parent_path or fp.startswith(parent_path + \"::\")):\n            objs = doc.Objects.FindByLayer(ly) or []\n            for obj in objs:\n                if doc.Objects.Delete(obj, True):\n                    deleted += 1\n    return deleted\n\n\ndef _planar_breps_from_face(doc, face):\n    breps = []\n    try:\n        fb = face.DuplicateFace(True)\n        if fb and fb.IsValid:\n            breps.append(fb)\n    except Exception:\n        fb = None\n    if not breps:\n        try:\n            tol = doc.ModelAbsoluteTolerance if doc else 0.01\n            crvs = []\n            for loop in face.Loops:\n                crv = loop.To3dCurve()\n                if crv and crv.IsClosed:\n                    crvs.append(crv)\n            if crvs:\n                made = rg.Brep.CreatePlanarBreps(crvs, tol)\n                if made:\n                    breps.extend([b for b in made if b and b.IsValid])\n        except Exception:\n            pass\n    return breps\n\n\ndef planar_breps_by_landuse(doc, faces_by_landuse, z_limit=Z_LIMIT):\n    planar = {}\n    if not faces_by_landuse:\n        return planar\n    for lu_name, faces in faces_by_landuse.items():\n        breps = []\n        for face in faces:\n            mp = rg.AreaMassProperties.Compute(face)\n            if mp and mp.Centroid.Z > z_limit:\n                continue\n            breps.extend(_planar_breps_from_face(doc, face))\n        if breps:\n            planar[lu_name] = breps\n    return planar\n\n\ndef bake_road_subregion_results(\n    doc,\n    planar_breps_by_lu,\n    landuse_parent=LANDUSE_PARENT,\n    target_parent=TARGET_PARENT_LAYER,\n    clear_existing=True,\n):\n    if not planar_breps_by_lu:\n        return 0\n    parent_layer = _ensure_layer(doc, target_parent, parent_id=None)\n    if not parent_layer:\n        raise Exception(\"레이어 생성 실패: {}\".format(target_parent))\n    if clear_existing:\n        _clear_layer_tree(doc, target_parent)\n    baked = 0\n    for lu_name, breps in planar_breps_by_lu.items():\n        child_layer = _ensure_layer(doc, lu_name, parent_id=parent_layer.Id)\n        if not child_layer:\n            continue\n        try:\n            original = _find_layer_by_fullpath(doc, f\"{landuse_parent}::{lu_name}\")\n            if original:\n                lyr = doc.Layers[child_layer.Index]\n                lyr.Color = original.Color\n                doc.Layers.Modify(lyr, child_layer.Index, True)\n        except Exception:\n            pass\n        attrs = Rhino.DocObjects.ObjectAttributes()\n        attrs.LayerIndex = child_layer.Index\n        for brep in breps:\n            try:\n                if isinstance(brep, rg.Brep):\n                    obj_id = doc.Objects.AddBrep(brep, attrs)\n                elif isinstance(brep, rg.Surface):\n                    obj_id = doc.Objects.AddSurface(brep, attrs)\n                else:\n                    brep_try = rg.Brep.TryConvertBrep(brep)\n                    obj_id = (\n                        doc.Objects.AddBrep(brep_try, attrs)\n                        if brep_try\n                        else System.Guid.Empty\n                    )\n                if obj_id and obj_id != System.Guid.Empty:\n                    baked += 1\n            except Exception:\n                pass\n    try:\n        doc.Views.Redraw()\n    except Exception:\n        pass\n    return baked\n\n\ndef build_blocks(planar_breps_by_lu):\n    blocks = []\n    for lu_name, breps in planar_breps_by_lu.items():\n        for idx, brep in enumerate(breps, start=1):\n            try:\n                block_id = f\"{lu_name}_{idx}\"\n                blocks.append(\n                    Block(region=brep, landuse_name=lu_name, block_id=block_id)\n                )\n            except Exception:\n                pass\n    return blocks\n\n\ndoc = Rhino.RhinoDoc.ActiveDoc\nroad_regions = globals().get(\"road_regions\", [])\nif not isinstance(road_regions, list):\n    road_regions = [road_regions]\nrun = bool(globals().get(\"run\", False))\n\nif not run:\n    raise Exception(\"run 입력이 False입니다. 실행을 원하면 True로 설정하세요.\")\n\nfaces_cache = collect_landuse_road_faces(\n    doc,\n    road_regions,\n    landuse_parent=LANDUSE_PARENT,\n    z_height=Z_EXTRUDE,\n    z_limit=Z_LIMIT,\n)\n\nplanar_cache = planar_breps_by_landuse(doc, faces_cache, z_limit=Z_LIMIT)\n\ntry:\n    baked_cnt = bake_road_subregion_results(\n        doc,\n        planar_cache,\n        landuse_parent=LANDUSE_PARENT,\n        target_parent=TARGET_PARENT_LAYER,\n        clear_existing=True,\n    )\n    dprint(\n        \"BakeRoadSubRegion: baked {} objects under '{}'.\".format(\n            baked_cnt, TARGET_PARENT_LAYER\n        )\n    )\nexcept Exception as bake_err:\n    dprint(\"BakeRoadSubRegion 오류:\", bake_err)\n\nblocks = build_blocks(planar_cache)\n\nout_lines = [\n    \"Landuse trimming complete.\",\n    \"Landuse categories: {}\".format(len(planar_cache)),\n    \"Blocks generated: {}\".format(len(blocks)),\n]\nout = \"\\n\".join(out_lines)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}