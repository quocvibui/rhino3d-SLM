{
  "source_url": "https://github.com/bsamiee/Parametric_Arsenal/blob/54ec3f5a7fc2c671cb7bc4601772820e625a1904/rhino/plugins/ArchBuilder/libs/geometry/profiles.py",
  "repo": "bsamiee/Parametric_Arsenal",
  "repo_stars": 0,
  "repo_description": "Rhino 8 Plugins and Scripts - A comprehensive monorepo for architectural automation, parametric design, and creative workflows",
  "license": "MIT",
  "filepath": "rhino/plugins/ArchBuilder/libs/geometry/profiles.py",
  "instruction": "Title         : profiles.py\nAuthor        : Bardia Samiee\nProject       : Parametric Forge\nLicense       : MIT\nPath          : rhino/plugins/ArchBuilder/libs/geometry/profiles.py",
  "code": "# r: numpy\n\"\"\"\nTitle         : profiles.py\nAuthor        : Bardia Samiee\nProject       : Parametric Forge\nLicense       : MIT\nPath          : rhino/plugins/ArchBuilder/libs/geometry/profiles.py\n\nDescription\n----------------------------------------------------------------------------\nProfile construction helpers for arch geometry.\nProvides functions that assemble ordered curve segments for specific arch\ntypes, combining analytic builders with solver-driven parameter logic.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom dataclasses import dataclass\n\nimport numpy as np\nimport Rhino.Geometry as rg\nfrom geometry.curves import arc_curve, arc_from_center_endpoints, profile_curve\n\nfrom libs.solvers import (\n    solve_catenary_parameter,\n    solve_four_center_parameters,\n    solve_horseshoe_parameters,\n    solve_multifoil_parameters,\n    solve_ogee_parameters,\n    solve_three_center_parameters,\n)\nfrom libs.specs import (\n    FourCenterArchOptions,\n    HorseshoeArchOptions,\n    MultifoilArchOptions,\n    OgeeArchOptions,\n    ThreeCenterArchOptions,\n)\n\n\n# --- Vector Angle Helper --------------------------------------------------\ndef calculate_vector_angle(v1: rg.Vector3d, v2: rg.Vector3d) -> float:\n    \"\"\"Calculate angle between two vectors using correct Rhino 8 API.\"\"\"\n    v1_unit = rg.Vector3d(v1)\n    v2_unit = rg.Vector3d(v2)\n    v1_unit.Unitize()\n    v2_unit.Unitize()\n\n    # Calculate dot product and clamp to prevent domain errors\n    dot = v1_unit * v2_unit\n    dot = max(-1.0, min(1.0, dot))\n\n    return math.acos(dot)\n\n\n# --- Profile Result Container ---------------------------------------------\n@dataclass(frozen=True)\nclass ProfileSegments:\n    \"\"\"Container for arch profile curve segments and endpoints.\"\"\"\n\n    segments: list[rg.Curve]\n    start: rg.Point3d\n    end: rg.Point3d\n\n\n# --- Analytic Profiles ----------------------------------------------------\ndef catenary_profile(\n    half_span: float,\n    rise: float,\n    tolerance: float,\n    samples: int = 128,\n) -> ProfileSegments:\n    \"\"\"Build a catenary profile curve.\"\"\"\n    parameter = solve_catenary_parameter(half_span, rise, tolerance)\n\n    xs = np.linspace(-half_span, half_span, samples)\n    points = []\n    for x in xs:\n        y_local = parameter * (math.cosh(x / parameter) - 1.0)\n        # Invert profile so the apex is at +rise and the feet sit on y = 0.\n        points.append(rg.Point3d(float(x), float(rise - y_local), 0.0))\n    curve = arc_curve(points)\n    return ProfileSegments([curve], curve.PointAtStart, curve.PointAtEnd)\n\n\ndef parabola_profile(half_span: float, rise: float, samples: int = 64) -> ProfileSegments:\n    \"\"\"Build a parabolic profile curve.\"\"\"\n\n    def parabola(x: float) -> float:\n        t = x / half_span\n        return rise * (1.0 - t * t)\n\n    curve = profile_curve(half_span * 2.0, parabola, samples)\n    return ProfileSegments([curve], curve.PointAtStart, curve.PointAtEnd)\n\n\ndef ellipse_profile(half_span: float, rise: float) -> ProfileSegments:\n    \"\"\"Build the upper half ellipse profile curve.\"\"\"\n    ellipse = rg.Ellipse(rg.Plane.WorldXY, half_span, rise)\n    ellipse_curve = ellipse.ToNurbsCurve()\n    domain = ellipse_curve.Domain\n    mid_param = domain.Mid\n\n    curves = ellipse_curve.Split([domain.T0, mid_param])\n    upper_half = curves[0] if curves else ellipse_curve\n    return ProfileSegments([upper_half], rg.Point3d(-half_span, 0.0, 0.0), rg.Point3d(half_span, 0.0, 0.0))\n\n\ndef semicircle_profile(span: float) -> ProfileSegments:\n    \"\"\"Build a semicircular profile curve.\"\"\"\n    radius = span * 0.5\n    start = rg.Point3d(-radius, 0.0, 0.0)\n    mid = rg.Point3d(0.0, radius, 0.0)\n    end = rg.Point3d(radius, 0.0, 0.0)\n    arc = rg.Arc(start, mid, end)\n    arc_curve = rg.ArcCurve(arc)\n    return ProfileSegments([arc_curve], arc_curve.PointAtStart, arc_curve.PointAtEnd)\n\n\ndef circular_segment_profile(half_span: float, rise: float) -> ProfileSegments:\n    \"\"\"Build a circular segment profile curve.\"\"\"\n    start = rg.Point3d(-half_span, 0.0, 0.0)\n    apex = rg.Point3d(0.0, rise, 0.0)\n    end = rg.Point3d(half_span, 0.0, 0.0)\n\n    arc = rg.Arc(start, apex, end)\n    if not arc.IsValid:\n        raise ValueError(\"Circular segment could not be constructed from the provided span and rise.\")\n    arc_curve = rg.ArcCurve(arc)\n    return ProfileSegments([arc_curve], start, end)\n\n\ndef two_center_profile(half_span: float, rise: float) -> ProfileSegments:\n    \"\"\"Build a two-center arch profile with correct center calculation.\"\"\"\n    left_base = rg.Point3d(-half_span, 0.0, 0.0)\n    right_base = rg.Point3d(half_span, 0.0, 0.0)\n    apex = rg.Point3d(0.0, rise, 0.0)\n\n    # Calculate center position for given span and rise\n    # Centers at (±x_c, 0) where arcs pass through apex with equal radii\n    x_c = (rise * rise - half_span * half_span) / (2.0 * half_span)\n\n    # Centers move based on geometry:\n    # - Equilateral arch (rise ≈ 0.866*span): centers near endpoints\n    # - Lancet arch (rise > 0.866*span): centers outside endpoints\n    # - Drop arch (rise < 0.866*span): centers inside endpoints\n    left_center = rg.Point3d(x_c, 0.0, 0.0)\n    right_center = rg.Point3d(-x_c, 0.0, 0.0)\n\n    left_arc = rg.ArcCurve(arc_from_center_endpoints(left_center, left_base, apex))\n    right_arc = rg.ArcCurve(arc_from_center_endpoints(right_center, apex, right_base))\n    return ProfileSegments([left_arc, right_arc], left_base, right_base)\n\n\n# --- Solver-driven Profiles -----------------------------------------------\ndef three_center_profile(\n    span: float,\n    rise: float,\n    options: ThreeCenterArchOptions,\n    tolerance: float,\n) -> ProfileSegments:\n    \"\"\"Build a three-center arch profile with proper center-based construction.\"\"\"\n    parameters = solve_three_center_parameters(\n        span,\n        rise,\n        shoulder_ratio=options.shoulder_ratio,\n        tolerance=tolerance,\n    )\n    half_span = span * 0.5\n\n    left_base = rg.Point3d(-half_span, 0.0, 0.0)\n    right_base = rg.Point3d(half_span, 0.0, 0.0)\n    left_tangent = rg.Point3d(-parameters.tangent_x, parameters.tangent_y, 0.0)\n    right_tangent = rg.Point3d(parameters.tangent_x, parameters.tangent_y, 0.0)\n\n    left_center = rg.Point3d(-parameters.side_center_offset, 0.0, 0.0)\n    right_center = rg.Point3d(parameters.side_center_offset, 0.0, 0.0)\n\n    # Use the computed central center from solver\n    central_center = rg.Point3d(0.0, parameters.central_center_y, 0.0)\n\n    # Create side arcs\n    left_lower_arc = arc_from_center_endpoints(left_center, left_base, left_tangent)\n    right_lower_arc = arc_from_center_endpoints(right_center, right_tangent, right_base)\n\n    # Create central arc using computed center\n    # Calculate angles for the central arc that spans from left tangent to right tangent\n    angle_left = math.atan2(left_tangent.Y - parameters.central_center_y, left_tangent.X - 0.0)\n    angle_right = math.atan2(right_tangent.Y - parameters.central_center_y, right_tangent.X - 0.0)\n\n    # Create the central arc using Circle and Interval\n    plane = rg.Plane(central_center, rg.Vector3d.ZAxis)\n    circle = rg.Circle(plane, parameters.central_radius)\n    central_arc_geom = rg.Arc(circle, rg.Interval(angle_left, angle_right))\n\n    # Convert to ArcCurves\n    left_lower = rg.ArcCurve(left_lower_arc)\n    central_arc = rg.ArcCurve(central_arc_geom)\n    right_lower = rg.ArcCurve(right_lower_arc)\n\n    # Verify tangency at left junction point\n    left_tangent_vec = left_lower.TangentAt(left_lower.Domain.Max)\n    central_left_tangent_vec = central_arc.TangentAt(central_arc.Domain.Min)\n    if left_tangent_vec.IsParallelTo(central_left_tangent_vec, tolerance) != 1:\n        # Log warning but continue\n        print(\n            f\"Warning: Left junction tangency not achieved \"\n            f\"(angle: {calculate_vector_angle(left_tangent_vec, central_left_tangent_vec):.6f} rad)\"\n        )\n\n    # Verify tangency at right junction point\n    central_right_tangent_vec = central_arc.TangentAt(central_arc.Domain.Max)\n    right_tangent_vec = right_lower.TangentAt(right_lower.Domain.Min)\n    if central_right_tangent_vec.IsParallelTo(right_tangent_vec, tolerance) != 1:\n        # Log warning but continue\n        print(\n            f\"Warning: Right junction tangency not achieved \"\n            f\"(angle: {calculate_vector_angle(central_right_tangent_vec, right_tangent_vec):.6f} rad)\"\n        )\n\n    return ProfileSegments([left_lower, central_arc, right_lower], left_base, right_base)\n\n\ndef four_center_profile(\n    span: float,\n    rise: float,\n    options: FourCenterArchOptions,\n    tolerance: float,\n) -> ProfileSegments:\n    \"\"\"Build a four-center arch profile with tangency verification.\"\"\"\n    params = solve_four_center_parameters(\n        span,\n        rise,\n        shoulder_ratio=options.shoulder_ratio,\n        shoulder_height_ratio=options.shoulder_height_ratio,\n        tolerance=tolerance,\n    )\n    half_span = span * 0.5\n\n    left_base = rg.Point3d(-half_span, 0.0, 0.0)\n    right_base = rg.Point3d(half_span, 0.0, 0.0)\n    left_tangent = rg.Point3d(-params.tangent_x, params.tangent_y, 0.0)\n    right_tangent = rg.Point3d(params.tangent_x, params.tangent_y, 0.0)\n    apex = rg.Point3d(0.0, rise, 0.0)\n\n    left_lower_center = rg.Point3d(-params.lower_center_offset, 0.0, 0.0)\n    right_lower_center = rg.Point3d(params.lower_center_offset, 0.0, 0.0)\n    left_upper_center = rg.Point3d(-params.upper_center_offset, params.upper_center_height, 0.0)\n    right_upper_center = rg.Point3d(params.upper_center_offset, params.upper_center_height, 0.0)\n\n    # Create arc curves\n    left_lower_arc = arc_from_center_endpoints(left_lower_center, left_base, left_tangent)\n    left_upper_arc = arc_from_center_endpoints(left_upper_center, left_tangent, apex)\n    right_upper_arc = arc_from_center_endpoints(right_upper_center, apex, right_tangent)\n    right_lower_arc = arc_from_center_endpoints(right_lower_center, right_tangent, right_base)\n\n    # Convert to ArcCurves for tangent verification\n    left_lower = rg.ArcCurve(left_lower_arc)\n    left_upper = rg.ArcCurve(left_upper_arc)\n    right_upper = rg.ArcCurve(right_upper_arc)\n    right_lower = rg.ArcCurve(right_lower_arc)\n\n    # Verify tangency at left shoulder point\n    left_lower_tangent = left_lower.TangentAt(left_lower.Domain.Max)\n    left_upper_tangent = left_upper.TangentAt(left_upper.Domain.Min)\n    if left_lower_tangent.IsParallelTo(left_upper_tangent, tolerance) != 1:\n        # Log warning but continue - the mathematical solver should have ensured tangency\n        print(\n            f\"Warning: Left shoulder tangency not achieved \"\n            f\"(angle: {calculate_vector_angle(left_lower_tangent, left_upper_tangent):.6f} rad)\"\n        )\n\n    # Verify tangency at right shoulder point\n    right_upper_tangent = right_upper.TangentAt(right_upper.Domain.Max)\n    right_lower_tangent = right_lower.TangentAt(right_lower.Domain.Min)\n    if right_upper_tangent.IsParallelTo(right_lower_tangent, tolerance) != 1:\n        # Log warning but continue\n        print(\n            f\"Warning: Right shoulder tangency not achieved \"\n            f\"(angle: {calculate_vector_angle(right_upper_tangent, right_lower_tangent):.6f} rad)\"\n        )\n\n    # Verify tangency at apex, tangents should be opposite at apex (anti-parallel is correct)\n    left_upper_apex_tangent = left_upper.TangentAt(left_upper.Domain.Max)\n    right_upper_apex_tangent = right_upper.TangentAt(right_upper.Domain.Min)\n    if left_upper_apex_tangent.IsParallelTo(right_upper_apex_tangent, tolerance) == -1:\n        pass  # This is expected behavior\n    elif left_upper_apex_tangent.IsParallelTo(right_upper_apex_tangent, tolerance) != 1:\n        print(\n            f\"Warning: Apex tangency not achieved \"\n            f\"(angle: {calculate_vector_angle(left_upper_apex_tangent, right_upper_apex_tangent):.6f} rad)\"\n        )\n\n    return ProfileSegments(\n        [left_lower, left_upper, right_upper, right_lower],\n        left_base,\n        right_base,\n    )\n\n\ndef ogee_profile(\n    half_span: float,\n    rise: float,\n    options: OgeeArchOptions,\n    tolerance: float,\n) -> ProfileSegments:\n    \"\"\"Build an ogee arch profile with tangency verification.\"\"\"\n    params = solve_ogee_parameters(\n        half_span=half_span,\n        rise=rise,\n        inflection_height=options.inflection_height,\n        curve_strength=options.curve_strength,\n        tolerance=tolerance,\n    )\n\n    left_base = rg.Point3d(-half_span, 0.0, 0.0)\n    right_base = rg.Point3d(half_span, 0.0, 0.0)\n    left_inflection = rg.Point3d(-params.tangent_x, params.tangent_y, 0.0)\n    right_inflection = rg.Point3d(params.tangent_x, params.tangent_y, 0.0)\n    apex = rg.Point3d(0.0, rise, 0.0)\n\n    left_lower_center = rg.Point3d(params.lower_center_x, params.lower_center_y, 0.0)\n    right_lower_center = rg.Point3d(-params.lower_center_x, params.lower_center_y, 0.0)\n    left_upper_center = rg.Point3d(params.upper_center_x, params.upper_center_y, 0.0)\n    right_upper_center = rg.Point3d(-params.upper_center_x, params.upper_center_y, 0.0)\n\n    left_lower_arc = arc_from_center_endpoints(left_lower_center, left_base, left_inflection)\n    left_upper_arc = arc_from_center_endpoints(left_upper_center, left_inflection, apex)\n    right_upper_arc = arc_from_center_endpoints(right_upper_center, apex, right_inflection)\n    right_lower_arc = arc_from_center_endpoints(right_lower_center, right_inflection, right_base)\n\n    # Convert to ArcCurves\n    left_lower = rg.ArcCurve(left_lower_arc)\n    left_upper = rg.ArcCurve(left_upper_arc)\n    right_upper = rg.ArcCurve(right_upper_arc)\n    right_lower = rg.ArcCurve(right_lower_arc)\n\n    # Verify tangency at left inflection point (S-curve transition)\n    left_lower_tangent = left_lower.TangentAt(left_lower.Domain.Max)\n    left_upper_tangent = left_upper.TangentAt(left_upper.Domain.Min)\n    if left_lower_tangent.IsParallelTo(left_upper_tangent, tolerance) != 1:\n        # Log warning but continue - the solver should have ensured tangency\n        print(\n            f\"Warning: Left inflection tangency not achieved \"\n            f\"(angle: {calculate_vector_angle(left_lower_tangent, left_upper_tangent):.6f} rad)\"\n        )\n\n    # Verify tangency at right inflection point\n    right_upper_tangent = right_upper.TangentAt(right_upper.Domain.Max)\n    right_lower_tangent = right_lower.TangentAt(right_lower.Domain.Min)\n    if right_upper_tangent.IsParallelTo(right_lower_tangent, tolerance) != 1:\n        # Log warning but continue\n        print(\n            f\"Warning: Right inflection tangency not achieved \"\n            f\"(angle: {calculate_vector_angle(right_upper_tangent, right_lower_tangent):.6f} rad)\"\n        )\n\n    # Verify tangency at apex (should be anti-parallel as curves meet from opposite sides)\n    left_apex_tangent = left_upper.TangentAt(left_upper.Domain.Max)\n    right_apex_tangent = right_upper.TangentAt(right_upper.Domain.Min)\n    if left_apex_tangent.IsParallelTo(right_apex_tangent, tolerance) == -1:\n        pass  # Expected behavior - tangents are opposite at apex\n    elif left_apex_tangent.IsParallelTo(right_apex_tangent, tolerance) != 1:\n        print(\n            f\"Warning: Apex tangency not achieved \"\n            f\"(angle: {calculate_vector_angle(left_apex_tangent, right_apex_tangent):.6f} rad)\"\n        )\n\n    curves = [left_lower, left_upper, right_upper, right_lower]\n    return ProfileSegments(curves, left_base, right_base)\n\n\ndef horseshoe_profile(\n    half_span: float,\n    rise: float,\n    options: HorseshoeArchOptions,\n    tolerance: float,\n) -> ProfileSegments:\n    \"\"\"Build a horseshoe arch profile.\"\"\"\n    params = solve_horseshoe_parameters(\n        half_span=half_span,\n        rise=rise,\n        extension_degrees=options.extension_degrees,\n        tolerance=tolerance,\n    )\n    center = rg.Point3d(params.center_x, params.center_y, 0.0)\n    plane = rg.Plane(center, rg.Vector3d.XAxis, rg.Vector3d.YAxis)\n    circle = rg.Circle(plane, params.radius)\n    arc = rg.Arc(circle, rg.Interval(params.angle_left, params.angle_right))\n    arc_curve = rg.ArcCurve(arc)\n\n    left_base = rg.Point3d(-half_span, 0.0, 0.0)\n    right_base = rg.Point3d(half_span, 0.0, 0.0)\n    return ProfileSegments([arc_curve], left_base, right_base)\n\n\ndef multifoil_profile(\n    half_span: float,\n    rise: float,\n    options: MultifoilArchOptions,\n    tolerance: float,\n) -> ProfileSegments:\n    \"\"\"Build a multifoil arch profile with proper cusped geometry.\"\"\"\n    params = solve_multifoil_parameters(\n        half_span=half_span,\n        rise=rise,\n        lobes=options.lobes,\n        lobe_size=options.lobe_size,\n        tolerance=tolerance,\n    )\n\n    # Create individual foil arcs that form the cusped profile\n    curves: list[rg.Curve] = []\n\n    for foil_arc in params.foil_arcs:\n        foil_center = rg.Point3d(foil_arc.center_x, foil_arc.center_y, 0.0)\n        foil_plane = rg.Plane(foil_center, rg.Vector3d.XAxis, rg.Vector3d.YAxis)\n        foil_circle = rg.Circle(foil_plane, foil_arc.radius)\n\n        # Create the cusped foil arc\n        foil_arc_geom = rg.Arc(foil_circle, rg.Interval(foil_arc.angle_start, foil_arc.angle_end))\n        curves.append(rg.ArcCurve(foil_arc_geom))\n\n    # Join all foil arcs into a continuous curve if possible\n    if len(curves) > 1:\n        tolerance_join = tolerance * 10  # More relaxed tolerance for joining\n        joined_curves = rg.Curve.JoinCurves(curves, tolerance_join)\n        if joined_curves and len(joined_curves) > 0:\n            curves = [joined_curves[0]]  # Use the first joined result\n\n    left_base = rg.Point3d(-half_span, 0.0, 0.0)\n    right_base = rg.Point3d(half_span, 0.0, 0.0)\n    return ProfileSegments(curves, left_base, right_base)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}