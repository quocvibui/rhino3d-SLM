{
  "source_url": "https://github.com/jrhe121314/rhino-compute-demo/blob/0ec00779fbd01a92428cd35b4eb7c0c515bcbd13/compute.rhino3d/src/ghhops-server-py/ghhops_server/base.py",
  "repo": "jrhe121314/rhino-compute-demo",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "compute.rhino3d/src/ghhops-server-py/ghhops_server/base.py",
  "instruction": "Base types for Hops middleware",
  "code": "\"\"\"Base types for Hops middleware\"\"\"\r\nimport sys\r\nimport traceback\r\nimport os.path as op\r\nimport inspect\r\nimport json\r\nimport base64\r\nfrom typing import Tuple\r\n\r\nfrom ghhops_server.logger import hlogger\r\nfrom ghhops_server.component import HopsComponent\r\n\r\n\r\nDEFAULT_CATEGORY = \"Hops\"\r\nDEFAULT_SUBCATEGORY = \"Hops Python\"\r\n\r\n\r\nclass HopsBase:\r\n    \"\"\"Base class for all Hops middleware implementations\"\"\"\r\n\r\n    def __init__(self, app):\r\n        self.app = app\r\n        # components dict store each components two times under\r\n        # two keys get uri and solve uri, for faster lookups in query and solve\r\n        # it is assumed that uri and solve uri and both unique to the component\r\n        self._components: dict[str, HopsComponent] = {}\r\n\r\n    def query(self, uri) -> Tuple[bool, str]:\r\n        \"\"\"Get information on given uri\"\"\"\r\n        if uri == \"/\":\r\n            hlogger.debug(\"Getting a list of all registered components\")\r\n            return True, self._get_comps_data()\r\n        else:\r\n            comp = self._components.get(uri, None)\r\n            if comp:\r\n                hlogger.debug(\"Getting component metadata: %s\", comp)\r\n                return True, self._get_comp_data(comp)\r\n        return False, self._return_with_err(\"Unknown Hops url\")\r\n\r\n    def solve(self, uri, payload) -> Tuple[bool, str]:\r\n        \"\"\"Perform Solve on given uri\"\"\"\r\n        if uri == \"/\":\r\n            hlogger.debug(\"Nothing to solve on root\")\r\n            return False, self._return_with_err(\"Nothing to solve on root\")\r\n\r\n        # FIXME: remove support for legacy solve behaviour\r\n        elif uri == \"/solve\":\r\n            data = json.loads(payload)\r\n            comp_name = data[\"pointer\"]\r\n            for comp in self._components.values():\r\n                if comp_name == comp.uri.replace(\"/\", \"\"):\r\n                    hlogger.info(\"Solving using legacy API: %s\", comp)\r\n                    return self._process_solve_request(comp, payload)\r\n\r\n        # FIXME: test this new api\r\n        else:\r\n            comp = self._components.get(uri, None)\r\n            if comp:\r\n                hlogger.info(\"Solving: %s\", comp)\r\n                return self._process_solve_request(comp, payload)\r\n        return False, self._return_with_err(\"Unknown Hops component url\")\r\n\r\n    def _return_with_err(self, err_msg, res_dict=None):\r\n        err_res = res_dict\r\n        if err_res:\r\n            err = err_res.get(\"errors\", None)\r\n            if isinstance(err, list):\r\n                err.append(err_msg)\r\n            else:\r\n                err_res[\"errors\"] = [err_msg]\r\n        else:\r\n            err_res = {\"values\": [], \"errors\": [err_msg]}\r\n\r\n        return json.dumps(err_res, cls=_HopsEncoder)\r\n\r\n    def _get_comps_data(self):\r\n        # return json formatted string of all components metadata\r\n        return json.dumps(list(self._components.values()), cls=_HopsEncoder)\r\n\r\n    def _get_comp_data(self, comp):\r\n        # return json formatted string of component metadata\r\n        return json.dumps(comp, cls=_HopsEncoder)\r\n\r\n    def _prepare_icon(self, icon_file_path):\r\n        # return icon data in base64 for embedding in http results\r\n        if not op.exists(icon_file_path):\r\n            hlogger.error(\"Can not find icon file at %s\", icon_file_path)\r\n        else:\r\n            with open(icon_file_path, \"rb\") as image_file:\r\n                base64_bytes = base64.b64encode(image_file.read())\r\n                return base64_bytes.decode(\"ascii\")\r\n\r\n    def _process_solve_request(self, comp, payload) -> Tuple[bool, str]:\r\n        # parse payload for inputs\r\n        res, inputs = self._prepare_inputs(comp, payload)\r\n        if not res:\r\n            hlogger.debug(\"Bad inputs: %s\", inputs)\r\n            return res, self._return_with_err(\"Bad inputs\")\r\n\r\n        # run\r\n        try:\r\n            solve_returned = self._solve(comp, inputs)\r\n            hlogger.debug(\"Return data: %s\", solve_returned)\r\n            res, outputs = self._prepare_outputs(comp, solve_returned)\r\n            return (\r\n                res,\r\n                outputs if res else self._return_with_err(\"Bad outputs\"),\r\n            )\r\n        except Exception as solve_ex:\r\n            # try to grab traceback data and create err msg\r\n            _, _, exc_traceback = sys.exc_info()\r\n            try:\r\n                fmt_tb = traceback.format_tb(exc_traceback)\r\n                # FIXME: can we safely assume we are only 2 levels in stack?\r\n                ex_msg = \"\\n\".join(fmt_tb[2:])\r\n                ex_msg = str(solve_ex) + f\"\\n{ex_msg}\"\r\n            except Exception:\r\n                # otherwise use exception str as msg\r\n                ex_msg = str(solve_ex)\r\n\r\n            hlogger.debug(\"Exception occured in handler: %s\", ex_msg)\r\n            return False, self._return_with_err(\r\n                \"Exception occured in handler:\\n%s\" % ex_msg\r\n            )\r\n\r\n    def _prepare_inputs(self, comp, payload) -> Tuple[bool, list]:\r\n        # parse input payload\r\n        data = json.loads(payload)\r\n\r\n        # grab input param data and value items\r\n        # FIXME: this works on a single branch only? [\"0\"][0]\r\n        param_values = {}\r\n        for item in data[\"values\"]:\r\n            param_values[item[\"ParamName\"]] = item\r\n\r\n        inputs = []\r\n        for in_param in comp.inputs:\r\n            if in_param.name not in param_values and not in_param.optional:\r\n                return (\r\n                    False,\r\n                    f\"Missing value for required input {in_param.name}\",\r\n                )\r\n            in_param_data = param_values[in_param.name]\r\n            value = in_param.from_input(in_param_data)\r\n            inputs.append(value)\r\n\r\n        if len(comp.inputs) != len(param_values):\r\n            return (\r\n                False,\r\n                \"Input count does not match number of inputs for component\"\r\n            )\r\n\r\n        return True, inputs\r\n\r\n    def _solve(self, comp, inputs):\r\n        return comp.handler(*inputs)\r\n\r\n    def _prepare_outputs(self, comp, returns) -> Tuple[bool, str]:\r\n        outputs = []\r\n        if not isinstance(returns, tuple):\r\n            returns = (returns,)\r\n        for out_param, out_result in zip(comp.outputs, returns):\r\n            output_data = out_param.from_result(out_result)\r\n            outputs.append(output_data)\r\n        payload = {\"values\": outputs}\r\n        hlogger.debug(\"Return payload: %s\", payload)\r\n        return True, json.dumps(payload, cls=_HopsEncoder)\r\n\r\n    def component(\r\n        self,\r\n        rule=None,\r\n        name=None,\r\n        nickname=None,\r\n        description=None,\r\n        category=None,\r\n        subcategory=None,\r\n        icon=None,\r\n        inputs=None,\r\n        outputs=None,\r\n    ):\r\n        \"\"\"Decorator for Hops middleware\"\"\"\r\n\r\n        def __func_wrapper__(comp_func):\r\n            # register python func as Hops component\r\n            if inputs:\r\n                # inspect default parameters in function signature\r\n                f_sig = inspect.signature(comp_func)\r\n                f_params = f_sig.parameters.values()\r\n                if len(inputs) != len(f_params):\r\n                    raise Exception(\r\n                        \"Number of function parameters is \"\r\n                        \"different from defined Hops inputs\"\r\n                    )\r\n                # apply function param default values in order\r\n                # to defined Hops inputs. this will override any\r\n                # previously defined default values\r\n                for hinput, fparam in zip(inputs, f_params):\r\n                    if fparam.default != inspect.Parameter.empty:\r\n                        hinput.default = fparam.default\r\n\r\n            # determine name, and uri\r\n            comp_name = name or comp_func.__qualname__\r\n            uri = rule or f\"/{comp_name}\"\r\n            # create component instance\r\n            comp = HopsComponent(\r\n                uri=uri,\r\n                name=comp_name,\r\n                nickname=nickname,\r\n                desc=description or comp_func.__doc__,\r\n                cat=category or DEFAULT_CATEGORY,\r\n                subcat=subcategory or DEFAULT_SUBCATEGORY,\r\n                icon=self._prepare_icon(icon) if icon is not None else None,\r\n                inputs=inputs or [],\r\n                outputs=outputs or [],\r\n                handler=comp_func,\r\n            )\r\n            hlogger.debug(\"Component registered: %s\", comp)\r\n            # register by uri and solve uri, for fast lookup on query and solve\r\n            self._components[uri] = comp\r\n            self._components[comp.solve_uri] = comp\r\n            return comp_func\r\n\r\n        return __func_wrapper__\r\n\r\n\r\nclass _HopsEncoder(json.JSONEncoder):\r\n    \"\"\"Custom json encoder to properly encode RhinoCommon and Hops types\"\"\"\r\n\r\n    def default(self, o):\r\n        if hasattr(o, \"Encode\"):\r\n            return o.Encode()\r\n        elif hasattr(o, \"encode\"):\r\n            return o.encode()\r\n        return json.JSONEncoder.default(self, o)\r\n",
  "language": "python",
  "imports": [
    "RhinoCommon"
  ],
  "has_docstring": true
}