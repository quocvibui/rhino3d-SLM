{
  "source_url": "https://github.com/AntonelloDN/lb_envimet/blob/f49c125fcf2cc2dd9deaab3ae220523a805a0247/Newlb_envimet/scr/lb_envimet%20Spaces.py",
  "repo": "AntonelloDN/lb_envimet",
  "repo_stars": 4,
  "repo_description": "﻿lb_envimet: a series of components to connect Ladybug and Gismo to Envimet for urban microclimatic analysis",
  "license": "GPL-3.0",
  "filepath": "Newlb_envimet/scr/lb_envimet Spaces.py",
  "instruction": "Use this component to generate ENVI-Met v4 3D geometry models.\n-\nSome components depend on Ladybug Legacy, please install Ladybug Legacy.\n-\nProvided by lb_envimet\n    \n    Args:\n       ...",
  "code": "# lb_envimet: A series of component for ENVI_MET\n# \n# It depends on Ladybug Legacy.\n# \n# Copyright (c) 2013-2019, Antonello Di Nunzio <antonellodinunzio@gmail.com> \n# lb_envimet is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# lb_envimet is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with lb_envimet; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to generate ENVI-Met v4 3D geometry models.\n-\nSome components depend on Ladybug Legacy, please install Ladybug Legacy.\n-\nProvided by lb_envimet\n    \n    Args:\n        _envimetFolder: Workspace folder which comes from lb_envimet ManageWorkspace\"\n        _envimetLocation: Location data which comes from \"lb_envimet Location\" component.\n        --------------------: (...)\n        _envimetGrid: Grid settings which comes from \"lb_envimet Grid\" component.\n        nestingGrid_: Connect the output of \"lb_envimet Nesting Grid\".\n        _envimetObjects_: Connect objects of lb_envimet you need in your model. The objects comes from:\n        .\n        1) \"lb_envimet Building\"\n        .\n        2) \"lb_envimet Soil\"\n        .\n        3) \"lb_envimet 2D Plant\"\n        .\n        4) \"lb_envimet 3D Plant\"\n        .\n        5) \"lb_envimet Source\"\n        .\n        6) \"lb_envimet Terrain\"\n        --------------------: (...)\n        fileName_: The file name that you would like the envimet model to be saved as. Default name is \"LBenvimet\".\n        _runIt: Set to \"True\" to run the component and generate the envimet model.\n        viewGridXY_: Set to \"True\" to view grid XY.\n        viewGridXZ_: Set to \"True\" to view grid XZ.\n        viewGridYZ_: Set to \"True\" to view grid YZ.\n    Returns:\n        readMe!: ...\n        XYGrid: Preview of grid XY.\n        XZGrid: Preview of 3D grid XZ.\n        YZGrid: Preview of 3D grid YZ.\n        INXfileAddress: The file path of the inx result file that has been generated on your machine.\n\"\"\"\n\nghenv.Component.Name = \"lb_envimet Spaces\"\nghenv.Component.NickName = 'lb_envimetSpaces'\nghenv.Component.Message = 'VER 0.0.02\\nMAR_30_2019'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"lb_envimet\"\nghenv.Component.SubCategory = \"2 | Simulation\"\n\n\nimport os\nimport re\nimport sys\nimport scriptcontext as sc\nimport Grasshopper.Kernel as gh\nimport Rhino as rc\nfrom copy import deepcopy\n##################LB ENVI_MET###################\nuserPath = os.getenv(\"APPDATA\")\npath = os.path.join(userPath, \"lb_envimet\")\nsys.path.append(path)\nfrom Geometry import Grid, Building, Dem, Object2d, NestingGrid, SingleWall\nfrom IO.writeINX import *\n################################################\n\n\ndef separateObjects(objects):\n    \n    buildings, terrain, plant3d, plant2d, soils, sources, singleWall  = [], None, [], [], [], [], []\n    \n    for obj in objects:\n        if obj.__class__ is Building:\n            buildings.append(obj)\n        elif obj.__class__ is Dem:\n            terrain = obj\n        elif obj.__class__ is Plant3d:\n            plant3d.append(obj)\n        elif obj.__class__ is SingleWall:\n            singleWall.append(obj)\n        elif obj.name == 'Plant2d':\n            plant2d.append(obj)\n        elif obj.name == 'Soil':\n            soils.append(obj)\n        elif obj.name == 'Source':\n            sources.append(obj)\n\n    \n    return buildings, terrain, plant3d, plant2d, soils, sources, singleWall\n\n\ndef createGrid(buildings, grid):\n    \n    baseObject = []\n    \n    if not grid.baseSurface:\n        baseObject = [building.geometry for building in buildings]\n    else:\n        baseObject = [grid.baseSurface]\n    \n    if baseObject:\n        grid.gZmethod(baseObject)\n        gridXY = grid.gridPreviewXY()\n        \n        return gridXY\n    else:\n        w = gh.GH_RuntimeMessageLevel.Warning\n        message = \"Please provide envimetBuildings if your grid is based on buildings \"\\\n        \"or baseSurface if your grid is based on surface\"\n        ghenv.Component.AddRuntimeMessage(w, message)\n        return -1\n\n\ndef checkDistanceFromBorder(points, buildings, grid):\n    \n    planeWorldXY = rc.Geometry.Plane.WorldXY\n    \n    ptMin = rc.Geometry.Point3d(min(points).X, min(points).Y, 0)\n    ptMax = rc.Geometry.Point3d(max(points).X, max(points).Y, 0)\n    border = rc.Geometry.Rectangle3d(planeWorldXY, ptMin, ptMax).ToNurbsCurve()\n    \n    # let's check!\n    cornerStyle = rc.Geometry.CurveOffsetCornerStyle.Sharp\n    firstCorner = rc.Geometry.Point3d(ptMin.X + grid.dimX, ptMin.Y + grid.dimY, 0)\n    secondCorner = rc.Geometry.Point3d(ptMax.X - grid.dimX, ptMax.Y - grid.dimY, 0)\n    firstCheck = rc.Geometry.Rectangle3d(planeWorldXY, firstCorner, secondCorner).ToNurbsCurve()\n    \n    geometry = [building.geometry for building in buildings]\n    \n    for index, building in enumerate(geometry):\n        bbox = building.GetBoundingBox(True).ToBrep()\n        xprj = rc.Geometry.Transform.PlanarProjection(planeWorldXY)\n        bbox.Transform(xprj)\n        \n        for v in bbox.Vertices:\n            if firstCheck.Contains(v.Location, planeWorldXY) == rc.Geometry.PointContainment.Outside:\n                w = gh.GH_RuntimeMessageLevel.Warning\n                message = \"There is not enough space between the border and Building n°{0}.\"\n                ghenv.Component.AddRuntimeMessage(w, message.format(index))\n                return -1\n\n\ndef main():\n    \n    XYGrid, XZGrid, YZGrid, INXfileAddress = None, None, None, None\n    \n    # default materials\n    if defaultSoilMaterial_ == None:\n        defaultSoilMaterial = '000000'\n    else:\n        defaultSoilMaterial = defaultSoilMaterial_\n    \n    if defaultBuildingMaterial_ == None:\n        buildingCommonMaterial = ['000000'] * 2\n    else:\n        buildingCommonMaterial = [defaultBuildingMaterial_] * 2\n    \n    # name of file\n    if fileName_ == None:\n        fileName = 'LBenvimet.INX'\n    else:\n        fileName = fileName_ + '.INX'\n    \n    if not os.path.exists(_envimetFolder):\n        os.makedirs(_envimetFolder)\n    fileAddress = _envimetFolder + '\\\\' + fileName\n    \n    if nestingGrid_:\n        nesting = nestingGrid_\n    else:\n        nesting = NestingGrid()\n    \n    location = _envimetLocation.locationAttributes\n    \n    # separate objects\n    try:\n        buildings, terrain, plant3ds, plant2ds, soils, sources, singleWall = separateObjects(_envimetObjects_)\n    except AttributeError:\n        w = gh.GH_RuntimeMessageLevel.Warning\n        message = \"An input is missing. Please check it.\"\n        ghenv.Component.AddRuntimeMessage(w, message)\n        return -1\n    \n    if buildings or _envimetGrid:\n        gridXY = createGrid(buildings, _envimetGrid)\n        \n        if viewGridXY_:\n            XYGrid = _envimetGrid.gridPreviewXY()\n        if viewGridXZ_:\n            XZGrid = _envimetGrid.gridPreviewXZ()\n        if viewGridYZ_:\n            YZGrid = _envimetGrid.gridPreviewYZ()\n    if _runIt:\n            # preparation\n            plant2d, source = _envimetGrid.emptyMatrix, _envimetGrid.emptyMatrix\n            soil = re.sub('', defaultSoilMaterial, _envimetGrid.emptyMatrix)\n            plant3d, shadings = '', ''\n            \n            # terrain\n            demVoxel, demDBMatrix, dem2d = getDemMatrix(_envimetGrid, terrain)\n            \n            # buildings\n            zeroMatrix = re.sub('', '0', _envimetGrid.emptyMatrix)\n            IdMatrix, bottomMatrix, topMatrix = zeroMatrix, zeroMatrix, zeroMatrix\n            wallDBMatrix, buildingNumberMatrix, greenIds, greenDBMatrix = '', '', '', ''\n            \n            buildingMatrix = [_envimetGrid.emptyMatrix , IdMatrix, bottomMatrix, topMatrix, buildingNumberMatrix, wallDBMatrix, greenIds, greenDBMatrix]\n            \n            if buildings:\n                checkDistanceFromBorder(gridXY, buildings, _envimetGrid)\n                IdMatrix, bottomMatrix, topMatrix, buildingNumberMatrix, wallDBMatrix, greenIds, greenDBMatrix = getBuildingPreparationMatrix(_envimetGrid, buildings, terrain, demVoxel)\n                \n                buildingMatrix = [_envimetGrid.emptyMatrix , IdMatrix, bottomMatrix, topMatrix, buildingNumberMatrix, wallDBMatrix, greenIds, greenDBMatrix]\n            \n            # other\n            if plant3ds:\n                plant3d = treeObjectMatrix(_envimetGrid, plant3ds)\n            if plant2ds:\n                plant2d = get2dObjectMatrix(_envimetGrid, plant2ds, '')\n            if soils:\n                soil = get2dObjectMatrix(_envimetGrid, soils, defaultSoilMaterial)\n            if sources:\n                source = get2dObjectMatrix(_envimetGrid, sources, '')\n            if singleWall:\n                shadings = getSimpleWall(_envimetGrid, singleWall)\n            \n            writeINX(fileAddress, _envimetGrid, _envimetLocation.locationAttributes, nesting, buildingMatrix, buildingCommonMaterial, dem2d, demDBMatrix, plant2d, plant3d, soil, source, shadings)\n            INXfileAddress = fileAddress\n        \n    return XYGrid, XZGrid, YZGrid, INXfileAddress\n\n\nif _envimetGrid and _envimetLocation and _envimetFolder:\n    result = main()\n    if result != -1:\n        XYGrid, XZGrid, YZGrid, INXfileAddress = result\nelse:\n    w = gh.GH_RuntimeMessageLevel.Warning\n    message = \"Please provide _envimetGrid, _envimetLocation and _envimetFolder.\"\n    ghenv.Component.AddRuntimeMessage(w, message)",
  "language": "python",
  "imports": [
    "Rhino",
    "scriptcontext"
  ],
  "has_docstring": true
}