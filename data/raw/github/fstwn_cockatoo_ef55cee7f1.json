{
  "source_url": "https://github.com/fstwn/cockatoo/blob/d952ac5d2148ec29fba52e8eb75f0f43770c74ca/usrobj_src/Cockatoo_QuadReMeshExtendedParallel.py",
  "repo": "fstwn/cockatoo",
  "repo_stars": 38,
  "repo_description": "Cockatoo is a prototypical open-source software toolkit for generating (3d-)knitting patterns from NURBS surface and mesh geometry directly inside Grasshopper.",
  "license": "MIT",
  "filepath": "usrobj_src/Cockatoo_QuadReMeshExtendedParallel.py",
  "instruction": "Remeshes the input mesh using the new QuadRemesh functionality until all the\nnaked points are identical to the supplied points.\nTODO: Update docstring, update inputs to item + runcount strategy...",
  "code": "\"\"\"\nRemeshes the input mesh using the new QuadRemesh functionality until all the\nnaked points are identical to the supplied points.\nTODO: Update docstring, update inputs to item + runcount strategy instead of\nusing tree branches\n    Inputs:\n        Geometry: The original input mesh or brep to quad-remesh.\n                  {tree, mesh/brep}\n        FixedPts: The points where the quadmesh should connect (i.e. naked\n                  vertices).\n                  {list, point}\n        InitialTargetQuadCount: The number of quads to try to achieve in the\n                                final remeshed object.\n                                {tree, integer}\n        AdaptiveQuadCount: Respect the original Target Quad Count value as much\n                           as possible. True returns more quads than\n                           TargetQuadCount depending on amount of high-curvature\n                           areas.\n                           {item, bool}\n        AdaptiveSize: Larger values results in for quad sizes that adjust to\n                      match input curvature. Smaller values results in more\n                      uniform quad sizes at the risk of less feature\n                      preservation. Range [0 - 100]\n                      {item, float}\n        DetectHardEdges: When enabled the hard edges in models will be retained.\n                         {item, boolean}\n        GuideCurves: GuideCurves for the remeshing process.\n                     {list, curve}\n        GuideCurveInfluence: This value is ignored if Guide Curves are not\n                             supplied.\n                             [0] = Approximate\n                             [1] = Interpolate Edge Ring \n                             [2] = Interpolate Edge Loop\n                             {item, int}\n        SymmetryAxis: Symmetry axis to use for symmetric remeshing.\n                      [0] = No Symmetry\n                      [1] = X\n                      [2] = Y\n                      [4] = Z \n                      {item, int}\n        PreserveMeshArrayEdgesMode: Mesh array's created from Breps will have\n                                    their brep face edge boundaries retained.\n                                    Smart - Small or insignificant input faces\n                                    are ignored.\n                                    Strict - All input faces are factored in\n                                    remeshed result.\n                                    [0] = Off\n                                    [1] = On(Smart)\n                                    [2] = On(Strict)\n                                    {item, int}\n        MaxMeshingIterations: The maximum number of attempts to find a quadmesh\n                              connecting to the supplied FixedPts. 0 turns off\n                              the feature and only returns the first result.\n                              {item, int}\n        AdjustQuadMesh: If True, the component will try to move the naked\n                        vertices of the quadmesh to the locations of the\n                        supplied FixedPts. This will only be executed for meshes\n                        where NakedPts = FixedPts!\n                        {item, bool}\n        RelaxQuadMesh: If True, an internal Kangaroo 2 solver will relax the\n                       quadmesh and keep naked vertices fixed.\n                       {item, bool}\n        RelaxationEdgeLengthFactor: The target edgelength factor for the\n                                    relaxation process.\n                                    {item, float}\n        RelaxationIterations: Number of iterations for the relaxation of the\n                              mesh.\n                              {item, int}\n        RelaxationTolerance: Tolerance for the relaxation process.\n                             Defaults to [0.01] units.\n                             {item, float}\n        Parallel: Toggle parallel execution on and off.\n                  {item, bool}\n    Output:\n        QuadMesh: The remeshed result.\n                  {item/list, mesh}\n    Remarks:\n        Author: Max Eschenbach\n        License: MIT License\n        Version: 200705\n\"\"\"\n\n# PYTHON STANDARD LIBRARY IMPORTS\nfrom __future__ import division\nimport clr\nimport math\nimport os\n\n# GHPYTHON SDK IMPORTS\nfrom ghpythonlib.componentbase import executingcomponent as component\nimport ghpythonlib.treehelpers as th\nimport ghpythonlib.components as ghcomp\nimport Grasshopper, GhPython\nimport System\nimport Rhino\n\n# KANGAROO 2 IMPORT\nif \"KangarooSolver\" in str(clr.References):\n    import KangarooSolver as ks\nelse:\n    try:\n        rhino_version = Rhino.RhinoApp.ExeVersion\n        if os.name == \"nt\":\n            if rhino_version == 6:\n                k2ap = (\"C:/Program Files/Rhino 6/Plug-ins/Grasshopper/\"\n                        \"Components/KangarooSolver.dll\")\n                clr.AddReferenceToFileAndPath(os.path.normpath(k2ap))\n            elif rhino_version == 7:\n                k2ap = (\"C:/Program Files/Rhino 7/Plug-ins/Grasshopper/\"\n                        \"Components/KangarooSolver.dll\")\n                if not os.path.exists(k2ap):\n                    k2ap = (\"C:/Program Files/Rhino 7 WIP/Plug-ins/Grasshopper/\"\n                            \"Components/KangarooSolver.dll\")\n                clr.AddReferenceToFileAndPath(os.path.normpath(k2ap))\n        elif os.name == \"posix\":\n            k2ap = (r\"/Applications/Rhinoceros.app/Contents/Frameworks/\"\n                      \"RhCore.framework/Versions/A/Resources/ManagedPlugIns/\"\n                      \"GrasshopperPlugin.rhp/Components/KangarooSolver.dll\")\n            clr.AddReferenceToFileAndPath(os.path.normpath(k2ap))\n        import KangarooSolver as ks\n    except (IOError, ImportError):\n        try:\n            clr.AddReferenceToFile(\"KangarooSolver.dll\")\n            import KangarooSolver as ks\n        except (IOError, ImportError):\n            raise RuntimeError(\"KangarooSolver.dll was not found! \"\n                               \"please add the folder to your module \"\n                               \"search paths manually!\")\n\n# ADDITIONAL RHINO IMPORTS\nfrom System.Collections.Generic import List\nimport scriptcontext as sc\n\n# GHENV COMPONENT SETTINGS\nghenv.Component.Name = \"QuadReMeshExtendedParallel\"\nghenv.Component.NickName = \"QRMExP\"\nghenv.Component.Category = \"Cockatoo\"\nghenv.Component.SubCategory = \"02 Meshing & Remeshing\"\n\nclass QuadReMeshExtendedParallel(component):\n    \n    MINOR_ADJUSTMENT = 4\n    MICRO_ADJUSTMENT = 2\n    \n    def checkInputData(self, geo, fpts, tqc, aqc, aqs, dhe, gci, sa, pmaem):\n        # check Geometry input\n        if not geo or geo == None or geo == []:\n            return None\n        \n        if not fpts or fpts == None or fpts == []:\n            fpts = []\n        \n        # check TargetQuadCount input\n        if ((not tqc) or \n            (tqc == None) or \n            (tqc == [])):\n            return None\n        \n        # check AdaptiveQuadCount input\n        if aqc == None or aqc == []:\n            aqc = False\n        \n        # check AdaptiveSize input\n        if not aqs or aqs == None or aqs == []:\n            aqs = 0\n        elif aqs > 100:\n            aqs = 100\n        \n        # check DetectHardEdges input\n        if dhe == None or dhe == []:\n            dhe = False\n        \n        # check GuideCurveInfluence input\n        if ((not gci) or\n            (gci == None) or \n            (gci == [])):\n            gci = 0\n        elif gci > 2:\n            gci = 2\n       \n       # check SymmetryAxis input\n        if ((not sa) or \n            (sa == None) or \n            (sa == []) or \n            (sa == 0) or \n            (sa > 4)):\n                sa = Rhino.Geometry.QuadRemeshSymmetryAxis.None\n        elif sa == 1:\n            sa = Rhino.Geometry.QuadRemeshSymmetryAxis.X\n        elif sa == 2 or sa == 3:\n            sa = Rhino.Geometry.QuadRemeshSymmetryAxis.Y\n        elif sa == 4:\n            sa = Rhino.Geometry.QuadRemeshSymmetryAxis.Z\n        \n        # check PreserveMeshArrayEdgesMode input\n        if ((not pmaem) or \n            (pmaem == None) or\n            (pmaem == []) or\n            (pmaem < 0)):\n                pmaem = 0\n        elif pmaem > 2:\n            pmaem = 2\n        \n        return (geo, fpts, tqc, aqc, aqs, dhe, gci, sa, pmaem)\n    \n    def createRemeshParameters(self, tqc, aqc, aqs, dhe, gci, sa, pmaem):\n        # create quad remesh parameters instance\n        qrp = Rhino.Geometry.QuadRemeshParameters()\n        \n        # fill instance with the parameters\n        qrp.TargetQuadCount = tqc\n        qrp.AdaptiveQuadCount = aqc\n        qrp.AdaptiveSize = aqs\n        qrp.DetectHardEdges = dhe\n        qrp.GuideCurveInfluence = gci\n        qrp.SymmetryAxis = sa\n        qrp.PreserveMeshArrayEdgesMode = pmaem\n        \n        # return the quad remesh parameters\n        return qrp\n    \n    def createRemeshedResult(self, Geometry, ReParams, GuideCurves):\n        \"\"\"Creates a remeshed QuadMesh from the inputs and returns it.\"\"\"\n        \n        # if guidecurves are supplied, supply them to the remesh routine\n        if GuideCurves and GuideCurves != None and GuideCurves != []:\n            # if a mesh is supplied as geometry, remesh this mesh\n            if type(Geometry) == Rhino.Geometry.Mesh:\n                QuadMesh = Geometry.QuadRemesh(ReParams,\n                                               GuideCurves)\n            \n            # if a brep is supplied, create a new quadmesh from this brep\n            elif type(Geometry) == Rhino.Geometry.Brep:\n                QuadMesh = Rhino.Geometry.Mesh.QuadRemeshBrep(Geometry,\n                                                              ReParams,\n                                                              GuideCurves)\n        \n        # if no guidecurves are supplied, don't add them to the routine\n        else:\n            # if a mesh is supplied as geometry, remesh this mesh\n            if type(Geometry) == Rhino.Geometry.Mesh:\n                QuadMesh = Geometry.QuadRemesh(ReParams)\n                \n            # if a brep is supplied, create a new quadmesh from this brep\n            elif type(Geometry) == Rhino.Geometry.Brep:\n                QuadMesh = Rhino.Geometry.Mesh.QuadRemeshBrep(Geometry,\n                                                              ReParams)\n        \n        return QuadMesh\n    \n    def getNakedVertices(self, mesh, p3d=False):\n        \"\"\"Returns the naked vertices of a mesh\"\"\"\n        \n        if mesh == None:\n            return None\n        \n        if len(list(mesh.Vertices)) < 1:\n            return ([], [], [], [])\n        \n        cIds = []\n        cPts = []\n        nIds = []\n        nPts = []\n        if p3d == True:\n            for i, (vertex, status) in enumerate(zip(list(mesh.Vertices), \n                                            mesh.GetNakedEdgePointStatus())):\n                if status == True:\n                    nIds.append(i)\n                    nPts.append(Rhino.Geometry.Point3d(vertex))\n                else:\n                    cIds.append(i)\n                    cPts.append(Rhino.Geometry.Point3d(vertex))\n        else:\n            for i, (vertex, status) in enumerate(zip(list(mesh.Vertices), \n                                            mesh.GetNakedEdgePointStatus())):\n                if status == True:\n                    nIds.append(i)\n                    nPts.append(vertex)\n                else:\n                    cIds.append(i)\n                    cPts.append(vertex)\n        return (nIds, nPts, cIds, cPts)\n    \n    def adjustRemeshParameters(self, ReParams, numNaked, numFixed, history, tqc_min, tqc_max, gc_off):\n        # make list for logging messages\n        Logging = []\n        \n        # compute and update TQC minima and maxima\n        mins = sorted([h[2] for h in history if h[2] != None])\n        maxs = sorted([h[3] for h in history if h[3] != None])\n        \n        # if last result is below numfixed\n        if numNaked < numFixed:\n            if tqc_min == None:\n                tqc_min = history[-1][0]\n            else:\n                if history[-1][0] > mins[-1]:\n                    tqc_min = history[-1][0]\n                else:\n                    tqc_min = mins[-1]\n        # if last result is above numfixed\n        elif numNaked > numFixed:\n            if tqc_max == None:\n                tqc_max = history[-1][0]\n            else:\n                if history[-1][0] < maxs[0]:\n                    tqc_max = history[-1][0]\n                else:\n                    tqc_max = maxs[0]\n        \n        # detect overshoots and undershoots as possible new min or max values\n        if len(history) >= 2:\n            # if last diff is positive and last-last diff is negative\n            if (history[-1][1] > numFixed and history[-2][1] < numFixed):\n                Logging.append(\"OVERSHOOT DETECTED\")\n                Logging.append(\" \")\n                if maxs != [] and history[-1][0] < maxs[0]:\n                    tqc_max = history[-1][0]\n            # if last diff is negative and las-last diff is positive\n            elif (history[-1][1] < numFixed and history[-2][1] > numFixed):\n                Logging.append(\"UNDERSHOOT DETECTED\")\n                Logging.append(\" \")\n                if mins != [] and history[-1][0] > mins[-1]:\n                    tqc_min = history[-1][0]\n        \n        # compute difference between num of naked vertices and num of fixed pts\n        diff = numNaked - numFixed\n        \n        # set current targetquadcpount to last targetquadcount\n        tqc = ReParams.TargetQuadCount\n        \n        # eyeball something like a QPN value (quads per naked vertex)\n        # silly approach but works quite well ;-)\n        qpn = int(math.ceil(ReParams.TargetQuadCount / numNaked))\n        \n        # compute adjustment of remesh parameters\n        adjustment = abs(diff) * qpn\n        \n        # if min and max has already been found\n        if tqc_min and tqc_max:\n            if abs(tqc_max - tqc_min) < 2:\n                if gc_off == False:\n                    gc_off = True\n                    Logging.append(\"TURNING OFF GUIDECURVES...\")\n                    tqc_min = None\n                    tqc_max = None\n                elif gc_off == True:\n                    gc_off = False\n                    tqc_min = None\n                    tqc_max = None\n                    Logging.append(\"TURNING ON GUIDECURVES...\")\n            else:\n                tqc = int(math.ceil(abs(tqc_min + tqc_max) / 2))\n                adjustment = tqc - ReParams.TargetQuadCount\n        else:\n            # do something to decrease the number of naked vertices\n            if diff > 0:\n                tqc -= adjustment\n            # do something to increase the number of naked vertices\n            elif diff < 0:\n                tqc += adjustment\n        \n        \"\"\"\n        # CODE FOR OLD ADJUSTMENTS\n        \n        if abs(diff) > 4 and abs(diff) <= 8:\n            adjustment = int(qpn - (qpn % 2)) * abs(diff)\n        elif abs(diff) > 1 and abs(diff) <= 4:\n            adjustment = self.MINOR_ADJUSTMENT\n        elif abs(diff) <= 1:\n            adjustment = self.MICRO_ADJUSTMENT\n        else:\n            adjustment = abs(diff) * self.TQC_NVX_EQUIVALENT\n        \"\"\"\n        \n        # write everything to the log\n        Logging.append(\"Quads/NakedPt:       \" + str(qpn))\n        Logging.append(\"Last TQC:            \" + str(history[-1][0]))\n        Logging.append(\"Last numNakedPts:    \" + str(numNaked))\n        Logging.append(\"Target numNakedPts:  \" + str(numFixed))\n        Logging.append(\" \")\n        Logging.append(\"numNaked Difference: \" + str(diff))\n        Logging.append(\"Adjustment Value:    \" + str(adjustment))\n        Logging.append(\"Next TQC:            \" + str(tqc))\n        Logging.append(\"TQC MIN:             \" + str(tqc_min))\n        Logging.append(\"TQC MAX:             \" + str(tqc_max))\n        \n        # write new tqc to reparams\n        ReParams.TargetQuadCount = tqc\n        \n        # return the whole salad\n        return ReParams, Logging, tqc_min, tqc_max, gc_off\n    \n    def adjustNakedPts(self, QuadMesh, FixedPts):\n        \"\"\"\n        Adjusts the naked vertices location of the remeshed result to match\n        locations of the FixedPts input.\n        Returns the adjusted Mesh.\n        \"\"\"\n        \n        if not QuadMesh:\n            return None\n        \n        if not FixedPts:\n            return None\n        \n        # pull naked points to fixed points and get distances\n        NakedIDs, NakedPts, cIds, cPts = self.getNakedVertices(QuadMesh, p3d=True)\n        pulledPts, distKeys = ghcomp.PullPoint(NakedPts, FixedPts)\n        \n        # sort everything after distance values\n        distKeys, SortedFixedPts, SortedNakedPts, SortedNakedIDs = zip(*sorted(zip(distKeys, pulledPts, NakedPts[:], NakedIDs[:])))\n        \n        # find out where the first point of SortedFixedPts appears\n        memberIndex = [i for i, pt in enumerate(FixedPts) if pt == SortedFixedPts[0]]\n        ShiftedFixedPts = list(FixedPts[:])\n        ShiftedFixedPts = ShiftedFixedPts[memberIndex[0]:] + ShiftedFixedPts[:memberIndex[0]]\n        \n        # create polyline from shifted fixedpts\n        pl = Rhino.Geometry.Polyline(ShiftedFixedPts)\n        \n        # sort sorted NakedPts along crv\n        crvPts, crvIds = ghcomp.SortAlongCurve(SortedNakedPts, pl)\n        \n        # get proper ids via the mapping\n        crvNakedIDs = [SortedNakedIDs[id] for id in crvIds]\n        \n        # create a copy of the input mesh\n        AdjustedMesh = Rhino.Geometry.Mesh()\n        AdjustedMesh.CopyFrom(QuadMesh)\n        \n        MeshVertices = AdjustedMesh.Vertices\n        for i, vertexId in enumerate(crvNakedIDs):\n            p3f = Rhino.Geometry.Point3f(ShiftedFixedPts[i].X, \n                                         ShiftedFixedPts[i].Y,\n                                         ShiftedFixedPts[i].Z)\n            MeshVertices[vertexId] = p3f\n        \n        return AdjustedMesh\n    \n    def createRelaxationGoals(self, QuadMesh, EdgeLengthFactor):\n        \"\"\"\n        creates a goals list for relaxation of the mesh\n        \"\"\"\n        \n        if QuadMesh == None:\n            QuadMesh = Rhino.Geometry.Mesh()\n        \n        # get edges and naked vertices from the mesh\n        edges = [QuadMesh.TopologyEdges.EdgeLine(i) for i in range(\n                                            QuadMesh.TopologyEdges.Count)]\n        nakedPts = self.getNakedVertices(QuadMesh, p3d=True)[1]\n        \n        # make goals list\n        goals = []\n        \n        # make show goal for mesh\n        wrappedMesh = Grasshopper.Kernel.Types.GH_ObjectWrapper()\n        wrappedMesh.CastFrom(QuadMesh)\n        g = ks.Goals.Locator(wrappedMesh)\n        goals.append(g)\n        \n        # make edge goals and append to goals list\n        for l in edges:\n            tel = l.Length * EdgeLengthFactor\n            g = ks.Goals.Spring(l.From, l.To, tel, 1.00)\n            goals.append(g)\n        \n        # make anchors and append to goals list\n        for pt in nakedPts:\n            g = ks.Goals.Anchor(pt, 1000000)\n            goals.append(g)\n        \n        return goals\n    \n    def remeshRoutine(self, dataPackage):\n        \n        Logging = []\n        \n        # unpack the dataPackage\n        Geometry, \\\n        Branch, \\\n        FixedPts, \\\n        TargetQuadCount, \\\n        AdaptiveQuadCount, \\\n        AdaptiveSize, \\\n        DetectHardEdges,\\\n        GuideCurves, \\\n        GuideCurveInfluence, \\\n        SymmetryAxis, \\\n        PreserveMeshArrayEdgesMode, \\\n        MaxMeshingIterations, \\\n        AdjustQuadMesh, \\\n        RelaxQuadMesh = dataPackage\n        \n        # check data\n        result = self.checkInputData(Geometry,\n                                     FixedPts,\n                                     TargetQuadCount,\n                                     AdaptiveQuadCount,\n                                     AdaptiveSize,\n                                     DetectHardEdges,\n                                     GuideCurveInfluence,\n                                     SymmetryAxis,\n                                     PreserveMeshArrayEdgesMode)\n        if not result:\n            # return nothing if the check fails\n            return None\n        else:\n            # unpack the result of the check\n            Geometry, \\\n            FixedPts, \\\n            TargetQuadCount, \\\n            AdaptiveQuadCount, \\\n            AdaptiveSize, \\\n            DetectHardEdges,\\\n            GuideCurveInfluence, \\\n            SymmetryAxis, \\\n            PreserveMeshArrayEdgesMode = result\n        \n        # create QuadRemeshing Parameters based on input values\n        ReParams = self.createRemeshParameters(TargetQuadCount,\n                                               AdaptiveQuadCount,\n                                               AdaptiveSize,\n                                               DetectHardEdges,\n                                               GuideCurveInfluence,\n                                               SymmetryAxis,\n                                               PreserveMeshArrayEdgesMode)\n        \n        # If MaxMeshingIterations is 0 return the first result\n        if MaxMeshingIterations <= 0:\n            Logging.append(\"-------------------------------------\")\n            QuadMesh = self.createRemeshedResult(Geometry,\n                                                 ReParams,\n                                                 GuideCurves)\n            \n            if not QuadMesh:\n                Logging.append(\"QUADREMESH RETURNED NO RESULT!\")\n                if GuideCurves:\n                    Logging.append(\"TRYING WITHOUT GUIDECURVES...\")\n                    Logging.append(\" \")\n                    QuadMesh = self.createRemeshedResult(Geometry,\n                                                         ReParams,\n                                                         None)\n                if not QuadMesh:\n                    Logging.append(\"TRYING WITH DOUBLE ITQC...\")\n                    ReParams.TargetQuadCount = ReParams.TargetQuadCount * 2\n                    QuadMesh = self.createRemeshedResult(Geometry,\n                                                              ReParams,\n                                                              None)\n                if not QuadMesh:\n                    Logging.append(\"QUADREMESH RETURNED NO RESULT!\")\n                    Logging.append(\"SKIPPING...\")\n                    return [None]\n            \n            # get naked ids, vertices etc.\n            NakedIDs, NakedPts, cIds, cPts = self.getNakedVertices(\n                                                                QuadMesh,\n                                                                p3d=True)\n            \n            # write status message to the log\n            Logging.append(\"RETURNING FIRST RESULT FOR THIS MESH.\")\n            Logging.append(\" \")\n        \n        # if MaxMeshingIterations is > 0 try to get a refined result\n        else:\n            numFixed = len(FixedPts)\n            numNaked = None\n            history = []\n            iteration = 1\n            solution = False\n            tqc_min = None\n            tqc_max = None\n            gc_off = False\n            \n            while solution == False and iteration <= MaxMeshingIterations:\n                # write status message to the log\n                Logging.append(\"-------------------------------------\")\n                Logging.append(\"ITERATION \" + str(iteration))\n                Logging.append(\" \")\n                \n                # listen for escape key and abort if pressed\n                sc.escape_test()\n                \n                # create a quadremeshed result\n                if gc_off == True:\n                    currentResult = self.createRemeshedResult(Geometry,\n                                                          ReParams,\n                                                          None)\n                elif gc_off == False:\n                    currentResult = self.createRemeshedResult(Geometry,\n                                                          ReParams,\n                                                          GuideCurves)\n                \n                if not currentResult:\n                    Logging.append(\"QUADREMESH RETURNED NO RESULT!\")\n                    if GuideCurves:\n                        Logging.append(\"TRYING WITHOUT GUIDECURVES...\")\n                        currentResult = self.createRemeshedResult(Geometry,\n                                                                  ReParams,\n                                                                  None)\n                    if not currentResult:\n                        Logging.append(\"TRYING WITH DOUBLE ITQC...\")\n                        ReParams.TargetQuadCount = ReParams.TargetQuadCount * 2\n                        currentResult = self.createRemeshedResult(Geometry,\n                                                                  ReParams,\n                                                                  None)\n                    if not currentResult:\n                        break\n                \n                # get naked ids, vertices, etc. of current result\n                NakedIDs, NakedPts, cIds, cPts = self.getNakedVertices(\n                                                                currentResult,\n                                                                p3d=True)\n                \n                # if the number of naked points is identical to fixed points,\n                # treat this as the solution\n                numNaked = len(NakedPts)\n                \n                history.append((ReParams.TargetQuadCount, numNaked, tqc_min, tqc_max))\n                \n                # if numnaked equals numfixed, we have a solution\n                if numNaked == numFixed:\n                    # write status message to the log\n                    Logging.append(\"TargetQuadCount: \" + str(ReParams.TargetQuadCount))\n                    Logging.append(\"NakedPts:        \" + str(numNaked))\n                    Logging.append(\"Difference:      \" + str(numNaked-numFixed))\n                    Logging.append(\" \")\n                    Logging.append(\"SOLUTION ACCEPTED - RETURNING RESULT.\")\n                    \n                    iteration += 1\n                    solution = True\n                    break\n                \n                # adjust the remeshing parameters for the next iteration\n                else:\n                    ReParams, logs, tqc_min, tqc_max, gc_off = self.adjustRemeshParameters(ReParams,\n                                                           numNaked,\n                                                           numFixed,\n                                                           history,\n                                                           tqc_min,\n                                                           tqc_max,\n                                                           gc_off)\n                    Logging.extend(logs)\n                    iteration += 1\n            \n            if not currentResult:\n                Logging.append(\"NO SOLUTION FOR THIS MESH.\")\n                Logging.append(\"SKIPPING...\")\n                rmlevel = Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning\n                self.AddRuntimeMessage(rmlevel,\n                    \"Mesh at Branch \" + str(Branch) + \" did not return any solution.\")\n                return (None, None, None, None, Logging)\n            \n            # set RuntimeMessages\n            if numNaked == numFixed:\n                rmlevel = Grasshopper.Kernel.GH_RuntimeMessageLevel.Remark\n                self.AddRuntimeMessage(rmlevel,\n                    \"Mesh at Branch \" + str(Branch) + \" was returned with \" +\n                    \"the target number of naked vertices after \" +\n                    str(iteration) + \" iterations.\" )\n            else:\n                rmlevel = Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning\n                diff = numNaked-numFixed\n                if diff > 0:\n                    msgdiff = \"+\" + str(diff)\n                else:\n                    msgdiff = str(diff)\n                self.AddRuntimeMessage(rmlevel,\n                    \"Mesh at Branch \" + str(Branch) + \" was returned with \" +\n                    msgdiff + \" naked vertices compared to FixedPts after \" + \n                    str(iteration-1) + \" iterations!\" )\n            \n            QuadMesh = currentResult\n        \n        # if AdjustQuadMesh is True call the respective function\n        if AdjustQuadMesh and solution == True:\n            AdjustedQuadMesh = self.adjustNakedPts(QuadMesh, FixedPts)\n        else:\n            AdjustedQuadMesh = None\n        \n        # return the outputs\n        return (QuadMesh, AdjustedQuadMesh, NakedPts, NakedIDs, Logging)\n    \n    def RunScript(self, Geometry, FixedPts, InitialTargetQuadCount, AdaptiveQuadCount, AdaptiveSize, DetectHardEdges, GuideCurves, GuideCurveInfluence, SymmetryAxis, PreserveMeshArrayEdgesMode, MaxMeshingIterations, AdjustQuadMesh, RelaxQuadMesh, RelaxationEdgeLengthFactor, RelaxationIterations, RelaxationTolerance, Parallel):\n        \n        # define outputs so that they are never empty\n        QuadMesh = []\n        AdjustedQuadMesh = []\n        RelaxedQuadMesh = []\n        NakedPts = []\n        NakedIDs = []\n        Logging = []\n        \n        # CHECK TREE INPUTS ----------------------------------------------------\n        \n        # if no geometry is supplied, do nothing\n        if not Geometry.DataCount:\n            return (QuadMesh,\n                    AdjustedQuadMesh,\n                    RelaxedQuadMesh,\n                    NakedPts,\n                    NakedIDs,\n                    Logging)\n        \n        # unpack input datatrees\n        arrData = []\n        for i, branch in enumerate(Geometry.Branches):\n            # step through branches of geometry input and collect other inputs\n            if len(branch) > 1:\n                rmw = Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning\n                self.AddRuntimeMessage(rmw,\n                    \"Please make sure that the 'Geometry' input has one Mesh\" +\n                    \"per branch in a DataTree!\")\n            SingleGeometry = branch[0]\n            \n            # collect fixedpts input\n            if FixedPts.DataCount:\n                try:\n                    if len(Geometry.Branches) > 1 and len(FixedPts.Branches) > 1:\n                        fpts_branch = FixedPts.Branch(Geometry.Path(i))\n                    else:\n                        fpts_branch = FixedPts.Branch(FixedPts.Paths[0])\n                except:\n                    rmw = Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning\n                    self.AddRuntimeMessage(rmw,\n                        \"Please make sure that the 'FixedPts' input has the \" +\n                        \"same DataTree-structure as the 'Geometry' input \" +\n                        \"(one or multiple fixedpts per branch in a DataTree)!\")\n            else:\n                fpts_branch = None\n            \n            # collect initial target quad count input\n            if InitialTargetQuadCount.DataCount:\n                tqc_branch = InitialTargetQuadCount.Branch(Geometry.Path(i))\n                if len(tqc_branch) > 1:\n                    rmw = Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning\n                    self.AddRuntimeMessage(rmw,\n                        \"Please make sure that the 'TargetQuadCount' input \" +\n                        \"has the same DataTree-structure as the 'Geometry' \" +\n                        \"input (one int value per branch in a DataTree)!\")\n                if InitialTargetQuadCount.DataCount == 1:\n                    tqc_branch = InitialTargetQuadCount.Branch(\n                                                InitialTargetQuadCount.Paths[0])\n            \n            # collect guidecurves input\n            if GuideCurves.DataCount:\n                try:\n                    if len(Geometry.Branches) > 1 and len(GuideCurves.Branches) > 1:\n                        gc_branch = list(GuideCurves.Branch(Geometry.Path(i)))\n                    else:\n                        gc_branch = list(GuideCurves.Branch(GuideCurves.Paths[0]))\n                except:\n                    rmw = Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning\n                    self.AddRuntimeMessage(rmw,\n                      \"Please make sure that the 'GuideCurves' input has \" +\n                      \"the same DataTree-structure as the 'Geometry' input \" +\n                      \"(one or multiple guidecurves per branch in a DataTree)!\")\n                if not gc_branch:\n                    rmw = Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning\n                    self.AddRuntimeMessage(rmw,\n                      \"Please make sure that the 'GuideCurves' input has \" +\n                      \"the same DataTree-structure as the 'Geometry' input \" +\n                      \"(one or multiple guidecurves per branch in a DataTree)!\")\n            else:\n                gc_branch = None\n            \n            # COMPILE DATAPACKAGE FOR PARALLEL EXECUTION -----------------------\n            \n            dataPackage = (SingleGeometry, \\\n                           Geometry.Path(i), \\\n                           fpts_branch, \\\n                           tqc_branch[0], \\\n                           AdaptiveQuadCount, \\\n                           AdaptiveSize, \\\n                           DetectHardEdges, \\\n                           gc_branch, \\\n                           GuideCurveInfluence, \\\n                           SymmetryAxis, \\\n                           PreserveMeshArrayEdgesMode, \\\n                           MaxMeshingIterations, \\\n                           AdjustQuadMesh, \\\n                           RelaxQuadMesh)\n            \n            arrData.append(dataPackage)\n        \n        if not arrData:\n            return None\n        \n        # TRIGGER REMESHING AND COLLECT RESULTS --------------------------------\n        \n        if Parallel:\n            results = list(GhPython.ScriptHelpers.Parallel.Run(\n                                                           self.remeshRoutine,\n                                                           arrData,\n                                                           False))\n        else:\n            results = [self.remeshRoutine(d) for d in arrData]\n        \n        for i, result in enumerate(results):\n            if result == None:\n                result = [None, None, None, None, None]\n            QuadMesh.append([result[0]])\n            if AdjustQuadMesh:\n                AdjustedQuadMesh.append([result[1]])\n            NakedPts.append(result[2])\n            NakedIDs.append(result[3])\n            Logging.append(result[4])\n        \n        # RELAXTAION -----------------------------------------------------------\n        \n        if RelaxQuadMesh and RelaxationIterations and RelaxationIterations != 0:\n            if not RelaxationTolerance:\n                RelaxationTolerance = 0.01\n            \n            if not RelaxationEdgeLengthFactor:\n                RelaxationEdgeLengthFactor = 0.00\n            \n            # create all relaxation goals\n            if AdjustQuadMesh:\n                allgoals = [g for goals in (self.createRelaxationGoals(qm[0], RelaxationEdgeLengthFactor) for qm in AdjustedQuadMesh) for g in goals]\n            else:\n                allgoals = [g for goals in (self.createRelaxationGoals(qm[0], RelaxationEdgeLengthFactor) for qm in QuadMesh) for g in goals]\n            \n            #create physical system and dotnet list of goals\n            ps = ks.PhysicalSystem()\n            goalsList = List[ks.IGoal]()\n            \n            # assign particle indices automatically\n            for g in allgoals:\n                ps.AssignPIndex(g, RelaxationTolerance)\n                goalsList.Add(g)\n            \n            # solve k2 system\n            for i in range(int(RelaxationIterations)):\n                ps.Step(goalsList, False, 1000)\n            \n            # Get meshes\n            RelaxedQuadMesh = []\n            for o in ps.GetOutput(goalsList):\n                if type(o) is not Rhino.Geometry.Point3d and o is not None and type(o) is not Rhino.Geometry.Line:\n                    if str(o) == \"Invalid Mesh\":\n                        RelaxedQuadMesh.append(None)\n                        continue\n                    RelaxedQuadMesh.append(o)\n        \n        # PREPARE RESULTS FOR OUTPUT -------------------------------------------\n        \n        QuadMesh = th.list_to_tree(QuadMesh, [0])\n        AdjustedQuadMesh = th.list_to_tree(AdjustedQuadMesh, [0])\n        RelaxedQuadMesh = th.list_to_tree(RelaxedQuadMesh, [0])\n        NakedPts = th.list_to_tree(NakedPts, [0])\n        NakedIDs = th.list_to_tree(NakedIDs, [0])\n        Logging = th.list_to_tree(Logging, [0])\n        \n        # RETURN RESULTS -------------------------------------------------------\n        return (QuadMesh,\n                AdjustedQuadMesh,\n                RelaxedQuadMesh,\n                NakedPts,\n                NakedIDs,\n                Logging)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "scriptcontext"
  ],
  "has_docstring": true
}