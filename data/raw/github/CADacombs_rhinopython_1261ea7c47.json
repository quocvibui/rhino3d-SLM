{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/xPrimitiveShape.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "xPrimitiveShape.py",
  "instruction": "X primitive shape",
  "code": "\"\"\"\r\n\"\"\"\r\n\r\n\"\"\"\r\n190522-24: Started from another module.\r\n...\r\n220831: Modified tolerance range in shape searching.\r\n241231: Bug fix in tolerances in tolerance loop after cylinder search.\r\n        Added check to quickly eliminate some iterative searches for shapes.\r\n\r\nNotes: Surface.IsTorus, etc., has trouble finding shapes for NurbSurfaces converted from RevSurfaces.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.Geometry as rg\r\nimport scriptcontext as sc\r\n\r\n\r\nMAX_ACCEPTED_SIZE = 1e4\r\n\r\n\r\nclass AnyShape():\r\n\r\n    @staticmethod\r\n    def areEqual(shapes, epsilon=1e-9, bDebug=False):\r\n        \"\"\"\r\n        \"\"\"\r\n    \r\n        if len(shapes) < 2: return\r\n    \r\n        shapeA = shapes[0]\r\n        sShapeA = shapeA.GetType().Name\r\n    \r\n        for i in range(1, len(shapes)):\r\n            shapeB = shapes[i]\r\n            sShapeB = shapeB.GetType().Name\r\n        \r\n            if sShapeA != sShapeB: \r\n                return False\r\n        \r\n            if sShapeA == 'Plane':\r\n                if Plane.areEqual([shapeA, shapeB], epsilon=epsilon, bDebug=bDebug): continue\r\n                else: return False\r\n            elif sShapeA == 'Cylinder':\r\n                if Cylinder.areEqual([shapeA, shapeB], epsilon=epsilon, bDebug=bDebug): continue\r\n                else: return False\r\n            elif sShapeA == \"Cone\":\r\n                if Cone.areEqual([shapeA, shapeB], epsilon=epsilon, bDebug=bDebug): continue\r\n                else: return False\r\n            elif sShapeA == 'Sphere':\r\n                if Sphere.areEqual([shapeA, shapeB], epsilon=epsilon, bDebug=bDebug): continue\r\n                else: return False\r\n            elif sShapeA == \"Torus\":\r\n                if Torus.areEqual([shapeA, shapeB], epsilon=epsilon, bDebug=bDebug): continue\r\n                else: return False\r\n    \r\n        return True\r\n\r\n\r\nclass Cylinder():\r\n\r\n    @staticmethod\r\n    def areEqual(cylinders, epsilon=1e-9, bDebug=False):\r\n        if len(cylinders) < 2: return\r\n    \r\n        for cyl in cylinders:\r\n            if not isinstance(cyl, rg.Cylinder): return False\r\n    \r\n        cylA = cylinders[0]\r\n    \r\n        for i in range(1, len(cylinders)):\r\n            cylB = cylinders[i]\r\n        \r\n            if cylA.EpsilonEquals(other=cylB, epsilon=epsilon):\r\n                if bDebug: print \"Cylinders are EpsilonEqual.\"\r\n                continue\r\n        \r\n            # Simple cylinder comparison did not find a match, but this doesn't mean\r\n            # they do not.\r\n        \r\n            # Compare Radii.\r\n            if abs(cylA.Radius - cylB.Radius) > epsilon:\r\n                return False\r\n            if bDebug: print \"Cylinders' Radii are EpsilonEqual.\"\r\n        \r\n            # Compare vectors of Axes.\r\n            if (\r\n                    not cylA.Axis.EpsilonEquals(other=cylB.Axis, epsilon=epsilon)\r\n                    and\r\n                    not cylA.Axis.EpsilonEquals(other=-cylB.Axis, epsilon=epsilon)\r\n            ):\r\n                return False\r\n            if bDebug: print \"Cylinders' Axes are EpsilonEqual.\"\r\n        \r\n            # Compare locations of Axes.\r\n            lineA = rg.Line(cylA.Center, cylA.Axis)\r\n            pt_ClosestOnA = lineA.ClosestPoint(testPoint=cylB.Center, limitToFiniteSegment=False)\r\n            if pt_ClosestOnA.DistanceTo(cylB.Center) > epsilon:\r\n                return False\r\n    \r\n        return True\r\n\r\n\r\n    @staticmethod\r\n    def extendToObjectSize(rgCyl, rgObjForSizeRef, bDebug=False):\r\n        if not rgCyl.IsFinite: # Fix cylinder that is infinite (has 0 height).\r\n            if bDebug: print \"Making cylinder finite...\"\r\n            rgBbox_ForSizeRef = rgObjForSizeRef.GetBoundingBox(True)\r\n            fAddLen = 1.1 * rgBbox_ForSizeRef.Min.DistanceTo(rgBbox_ForSizeRef.Max)\r\n            rgCyl.Height1 = -fAddLen\r\n            rgCyl.Height2 = fAddLen\r\n        else: # Increase length of cylinder so that it extends the reference object.\r\n            if bDebug: print \"Height of cylinder before: {}\".format(rgCyl.TotalHeight)\r\n            rgBbox_ForSizeRef = rgObjForSizeRef.GetBoundingBox(False)\r\n            fAddLen = 1.1 * rgBbox_ForSizeRef.Min.DistanceTo(rgBbox_ForSizeRef.Max)\r\n            if rgCyl.Height1 < rgCyl.Height2:\r\n                rgCyl.Height1 -= fAddLen\r\n                rgCyl.Height2 += fAddLen\r\n            else:\r\n                rgCyl.Height1 += fAddLen\r\n                rgCyl.Height2 -= fAddLen\r\n            if bDebug: print \"Height of cylinder after: {}\".format(rgCyl.TotalHeight)\r\n\r\n\r\n    @staticmethod\r\n    def isSizeAcceptable(cylinder, bDebug=False):\r\n    \r\n        mmPerModelUnit = 1.0 / Rhino.RhinoMath.UnitScale(\r\n                Rhino.UnitSystem.Millimeters,\r\n                sc.doc.ModelUnitSystem)\r\n    \r\n        if (cylinder.Radius * mmPerModelUnit) >= MAX_ACCEPTED_SIZE:\r\n            if bDebug:\r\n                print \"Cylinder with {} Radius skipped.\".format(\r\n                        cylinder.Radius)\r\n            return False\r\n        return True\r\n\r\n\r\nclass Cone():\r\n\r\n    @staticmethod\r\n    def areEqual(cones, epsilon=1e-9, bDebug=False):\r\n        \"\"\"\r\n        # Changing the Cone's Height changes\r\n        # its BasePoint location, but not its Radius.\r\n        # Conclusion: Do not compare Height, Radius, and BasePoint.\r\n        # Also not comparing Planes due to needed research on how to properly\r\n        # do this, but there are probably enough other properties being tested.\r\n        \"\"\"\r\n    \r\n        if len(cones) < 2: return\r\n    \r\n        for cone in cones:\r\n            if not isinstance(cone, rg.Cone): return False\r\n    \r\n        coneA = cones[0]\r\n    \r\n        for i in range(1, len(cones)):\r\n            coneB = cones[i]\r\n        \r\n            if coneA.EpsilonEquals(other=coneB, epsilon=epsilon):\r\n                if bDebug: print \"Cones are EpsilonEqual.\"\r\n                continue\r\n\r\n            # Simple cone comparison did not find a match, but this doesn't mean\r\n            # they do not, so will keep testing.\r\n        \r\n            if not coneA.Axis.EpsilonEquals(other=coneB.Axis, epsilon=epsilon):\r\n                return False\r\n            if bDebug: print \"Cones' Axes are EpsilonEqual.\"\r\n        \r\n            # Keep testing.\r\n            if not coneA.ApexPoint.EpsilonEquals(\r\n                        other=coneB.ApexPoint,\r\n                        epsilon=10.0*epsilon\r\n            ):\r\n                s  = \"Not EpsilonEquals because Cone.ApexPoint location difference is\"\r\n                s += \" {}, \".format(\r\n                        coneA.ApexPoint.DistanceTo(other=coneB.ApexPoint))\r\n                s += \"but the epsilon is {}.\".format(epsilon)\r\n                print s\r\n                return False\r\n            if bDebug: print \"Cones' ApexPoints are EpsilonEqual.\"\r\n        \r\n            # Keep testing.\r\n            fTol_Angle = sc.doc.ModelAngleToleranceDegrees\r\n            angle_A = coneA.AngleInDegrees()\r\n            angle_B = coneB.AngleInDegrees()\r\n            if not abs(angle_A - angle_B) <= fTol_Angle:\r\n                s  = \"Not EpsilonEquals because Cone.AngleInDegrees() difference is\"\r\n                s += \" {}, \".format(\r\n                        abs(coneA.AngleInDegrees()-coneB.AngleInDegrees()))\r\n                s += \"but the epsilon is {}.\".format(fTol_Angle)\r\n                print s\r\n                return False\r\n            if bDebug: print \"Cones' Radii are EpsilonEqual.\"\r\n        \r\n    \r\n        return True\r\n\r\n\r\n    @staticmethod\r\n    def isSizeAcceptableAtPoint(cone, point, bDebug=False):\r\n    \r\n        mmPerModelUnit = 1.0 / Rhino.RhinoMath.UnitScale(\r\n                Rhino.UnitSystem.Millimeters,\r\n                sc.doc.ModelUnitSystem)\r\n    \r\n        if abs(cone.ApexPoint.MaximumCoordinate * mmPerModelUnit) >= MAX_ACCEPTED_SIZE:\r\n            if bDebug:\r\n                print \"Cone with ApexPoint of {} skipped.\".format(\r\n                        cone.ApexPoint)\r\n            return False\r\n        else:\r\n            apexToPtOnCone = cone.ApexPoint.DistanceTo(point)\r\n            if apexToPtOnCone <= sc.doc.ModelAbsoluteTolerance:\r\n                # Point must be at apex.\r\n                return\r\n        \r\n            line_Axis = rg.Line(cone.ApexPoint, cone.BasePoint)\r\n            pt_onAxis = line_Axis.ClosestPoint(point, limitToFiniteSegment=False)\r\n            apexToPtOnAxis = cone.ApexPoint.DistanceTo(pt_onAxis)\r\n            if apexToPtOnAxis <= sc.doc.ModelAbsoluteTolerance:\r\n                # Point must be at apex.\r\n                return\r\n        \r\n            radiusAtPt = point.DistanceTo(pt_onAxis)\r\n        \r\n            if radiusAtPt >= MAX_ACCEPTED_SIZE:\r\n                if bDebug: print \"Cone with {} Radius skipped.\".format(\r\n                        cone_radius_at_srf)\r\n                return False\r\n        \r\n            if radiusAtPt < sc.doc.ModelAbsoluteTolerance:\r\n                if bDebug: print \"Cone with {} Radius skipped.\".format(\r\n                        cone_radius_at_srf)\r\n                return False\r\n        \r\n            # Older method.\r\n            #            cone_radius_at_srf = (apexToPtOnCone**2.0 - apexToPtOnAxis**2.0)**0.5\r\n            #            if (cone_radius_at_srf * mmPerModelUnit) >= MAX_ACCEPTED_SIZE:\r\n            #                if bDebug:\r\n            #                    print \"Cone with {} Radius skipped.\".format(\r\n            #                            cone_radius_at_srf)\r\n            #                return False\r\n    \r\n        return True\r\n\r\n\r\nclass Plane():\r\n\r\n    @staticmethod\r\n    def areEqual(planes, epsilon=1e-9, bDebug=False):\r\n        if len(planes) < 2: return\r\n    \r\n        for plane in planes:\r\n            if not isinstance(plane, rg.Plane): return False\r\n    \r\n        planeA = planes[0]\r\n    \r\n        ptA0 = planeA.PointAt(0.0, 0.0)\r\n        ptAU = planeA.PointAt(1.0, 0.0)\r\n        ptAV = planeA.PointAt(0.0, 1.0)\r\n    \r\n        #    for pt in (ptA0, ptAU, ptAV):\r\n        #        sc.doc.Objects.AddPoint(pt)\r\n    \r\n        for i in range(1, len(planes)):\r\n            planeB = planes[i]\r\n        \r\n            #        if bDebug:\r\n            #            ptB_ToA0 = planeB.ClosestPoint(ptA0)\r\n            #            ptB_ToAU = planeB.ClosestPoint(ptAU)\r\n            #            ptB_ToAV = planeB.ClosestPoint(ptAV)\r\n            #            for pt in (ptB_ToA0, ptB_ToAU, ptB_ToAV):\r\n            #                sc.doc.Objects.AddPoint(pt)\r\n        \r\n            ptB_ToA0 = planeB.ClosestPoint(ptA0)\r\n            fDelta_0 = ptA0.DistanceTo(ptB_ToA0)\r\n            if fDelta_0 > epsilon:\r\n                #            if bDebug:\r\n                #                s  = \"No match because planes' difference at A's \"\r\n                #                s += \"0,0 is {:.2e}.\".format(fDelta_0)\r\n                #                print s\r\n                return False\r\n        \r\n            ptB_ToAU = planeB.ClosestPoint(ptAU)\r\n            fDelta_U = ptAU.DistanceTo(ptB_ToAU)\r\n            if fDelta_U > epsilon:\r\n                #            if bDebug:\r\n                #                s  = \"No match because planes' difference at A's \"\r\n                #                s += \"1,0 is {:.2e}.\".format(fDelta_U)\r\n                #                print s\r\n                return False\r\n        \r\n            ptB_ToAV = planeB.ClosestPoint(ptAV)\r\n            fDelta_V = ptAV.DistanceTo(ptB_ToAV)\r\n            if fDelta_V > epsilon:\r\n                #            if bDebug:\r\n                #                s  = \"No match because planes' difference at A's \"\r\n                #                s += \"0,1 is {:.2e}.\".format(fDelta_V)\r\n                #                print s\r\n                return False\r\n            \r\n            # False positive may exist if planeA was derived from a small BrepFace.\r\n            # Therefore, test the planes again in the opposite way.\r\n            for uv in (0.0, 0.0), (1.0, 0.0), (0.0, 1.0):\r\n                ptB = planeB.PointAt(*uv)\r\n            \r\n                ptA_ToB = planeA.ClosestPoint(ptB)\r\n                fDelta = ptB.DistanceTo(ptA_ToB)\r\n                if fDelta > epsilon:\r\n                    return False\r\n    \r\n        return True\r\n\r\n\r\nclass Sphere():\r\n\r\n    @staticmethod\r\n    def areEqual(spheres, epsilon=1e-9, bDebug=False):\r\n        \"\"\"\r\n        \"\"\"\r\n    \r\n        if len(spheres) < 2: return\r\n    \r\n        for sphere in spheres:\r\n            if not isinstance(sphere, rg.Sphere): return False\r\n    \r\n        sphereA = spheres[0]\r\n    \r\n        for i in range(1, len(spheres)):\r\n            sphereB = spheres[i]\r\n        \r\n            if not sphereA.Center.EpsilonEquals(sphereB.Center, epsilon):\r\n                return False\r\n            if not Rhino.RhinoMath.EpsilonEquals(sphereA.Radius, sphereB.Radius, epsilon):\r\n                return False\r\n    \r\n        return True\r\n\r\n\r\n    @staticmethod\r\n    def isSizeAcceptable(sphere, bDebug=False):\r\n    \r\n        mmPerModelUnit = 1.0 / Rhino.RhinoMath.UnitScale(\r\n                Rhino.UnitSystem.Millimeters,\r\n                sc.doc.ModelUnitSystem)\r\n    \r\n        if (sphere.Radius * mmPerModelUnit) >= MAX_ACCEPTED_SIZE:\r\n            if bDebug:\r\n                print \"Sphere with {} Radius skipped.\".format(\r\n                        tol_Try, sphere.Radius)\r\n            return False\r\n        return True\r\n\r\n\r\nclass Torus():\r\n\r\n    @staticmethod\r\n    def areEqual(tori, epsilon=1e-9, bDebug=False):\r\n        \"\"\"\r\n        \"\"\"\r\n    \r\n        if len(tori) < 2: return\r\n    \r\n        for torus in tori:\r\n            if not isinstance(torus, rg.Torus): return False\r\n    \r\n        torusA = tori[0]\r\n    \r\n        for i in range(1, len(tori)):\r\n            torusB = tori[i]\r\n        \r\n            if torusA.EpsilonEquals(other=torusB, epsilon=epsilon):\r\n                if bDebug: print \"Tori are EpsilonEqual.\"\r\n                continue\r\n            else:\r\n                fDelta_MajRad = abs(torusA.MajorRadius - torusB.MajorRadius)\r\n                if fDelta_MajRad <= epsilon:\r\n                    pass\r\n                else:\r\n                    if bDebug:\r\n                        s  = \"No match because tori's\"\r\n                        s += \" MajorRadius difference is {:.2e}.\".format(fDelta_MajRad)\r\n                        print s\r\n                    return False\r\n            \r\n                fDelta_MinRad = abs(torusA.MinorRadius - torusB.MinorRadius)\r\n                if fDelta_MinRad <= epsilon:\r\n                    pass\r\n                else:\r\n                    if bDebug:\r\n                        s  = \"No match because tori's\"\r\n                        s += \" MinorRadius difference is {:.2e}.\".format(fDelta_MinRad)\r\n                        print s\r\n                    return False\r\n            \r\n                # Using custom function because Plane.EpsilonEquals is too strict for this application.\r\n                if Plane.areEqual(\r\n                        [torusA.Plane, torusB.Plane],\r\n                        epsilon=epsilon,\r\n                        bDebug=bDebug):\r\n                    if bDebug: print \"Tori's Planes are EpsilonEqual.\"\r\n                else:\r\n                    return False\r\n    \r\n        return True\r\n\r\n\r\n    @staticmethod\r\n    def isSizeAcceptable(torus, bDebug=False):\r\n    \r\n        mmPerModelUnit = 1.0 / Rhino.RhinoMath.UnitScale(\r\n                Rhino.UnitSystem.Millimeters,\r\n                sc.doc.ModelUnitSystem)\r\n    \r\n        if (torus.MajorRadius * mmPerModelUnit) >= MAX_ACCEPTED_SIZE:\r\n            if bDebug:\r\n                print \"Torus with {} MajorRadius skipped.\".format(torus.MajorRadius)\r\n            return False\r\n        elif (torus.MinorRadius * mmPerModelUnit) >= MAX_ACCEPTED_SIZE:\r\n            if bDebug:\r\n                print \"Torus with {} MinorRadius skipped.\".format(torus.MinorRadius)\r\n            return False\r\n        return True\r\n\r\n\r\nclass Surface():\r\n\r\n    @staticmethod\r\n    def tryGetPlane(rgSrf0, fTolerance=1e-9, bDebug=False):\r\n        \"\"\"\r\n        Updated in May of 2019.\r\n    \r\n        Returns a tuple:\r\n            On success: (rg.Plane instance), (float: tolerance actually used to obtain shape)\r\n            On fail: None, None\r\n        \"\"\"\r\n\r\n        exp = -52\r\n        m_eps = 2**exp # 2.22044604925e-16\r\n\r\n        if fTolerance <= 0.0:\r\n            return None, None\r\n        elif fTolerance < m_eps:\r\n            fTolerance = m_eps\r\n\r\n        if isinstance(rgSrf0, rg.BrepFace):\r\n            rgSrf0 = rgSrf0.UnderlyingSurface()\r\n    \r\n        if isinstance(rgSrf0, rg.NurbsSurface):\r\n            rgNurbsSrf1 = rgSrf0.Duplicate()\r\n        else:\r\n            rgNurbsSrf1 = rgSrf0.ToNurbsSurface()\r\n    \r\n        # Start tolerance to use at a low value and iterate up to input tolerance.\r\n        fTol_Attempting = m_eps\r\n\r\n        while fTol_Attempting <= fTolerance:\r\n            sc.escape_test()\r\n\r\n            b, plane = rgNurbsSrf1.TryGetPlane(fTol_Attempting)\r\n            if b:\r\n                rgNurbsSrf1.Dispose()\r\n                return plane, fTol_Attempting\r\n\r\n            if fTol_Attempting == fTolerance:\r\n                break\r\n\r\n            exp += 1\r\n            fTol_Attempting = 2**exp\r\n\r\n            if fTol_Attempting > fTolerance:\r\n                fTol_Attempting = fTolerance\r\n    \r\n        return None, None\r\n\r\n\r\n    @staticmethod\r\n    def tryGetRoundPrimitive(rgSrf0, bCylinder=True, bCone=True, bSphere=True, bTorus=True, fTolerance=1e-9, bDebug=False):\r\n        \"\"\"\r\n        Updated in May of 2019.\r\n    \r\n        Returns a tuple:\r\n            On success: (rg.Cone, Cylinder, Sphere, or Torus instance), (float: tolerance actually used to obtain shape)\r\n            On fail: None, None\r\n    \r\n        Tolerance up to fTolerance parameter is first tested for a Cylinder\r\n        Then the other 3 shapes are tested together each tolerance trial at a time.\r\n        \"\"\"\r\n\r\n        if not any((bCylinder, bCone, bSphere, bTorus)):\r\n            return None, None\r\n\r\n        if fTolerance <= 0.0:\r\n            return None, None\r\n\r\n        exp = -52\r\n        m_eps = 2**exp # 2.22044604925e-16\r\n\r\n\r\n        if isinstance(rgSrf0, rg.BrepFace):\r\n            rgSrf0 = rgSrf0.UnderlyingSurface()\r\n    \r\n        if isinstance(rgSrf0, rg.NurbsSurface):\r\n            rgNurbsSrf1 = rgSrf0.Duplicate()\r\n        else:\r\n            rgNurbsSrf1 = rgSrf0.ToNurbsSurface()\r\n\r\n        # If initially True, these may later be set to False when either\r\n        #   1. The shape cannot be found at fTolerance.\r\n        #   2. The relative shape is found but not at an acceptable size\r\n        bCone_WIP = bCone\r\n        bSphere_WIP = bSphere\r\n        bTorus_WIP = bTorus\r\n    \r\n        if fTolerance < m_eps:\r\n            fTolerance = m_eps\r\n\r\n        # Start tolerance to use at a low value and iterate up to input tolerance.\r\n        fTol_Attempting = m_eps\r\n\r\n        # Cylinder has preference, so all tolerances will be iterated, trying for that shape.\r\n        if bCylinder:\r\n            # Check max. tolerance first.\r\n            b, cylinder = rgNurbsSrf1.TryGetCylinder(fTolerance)\r\n            if b:\r\n                cylinder = None\r\n                while fTol_Attempting <= fTolerance:\r\n                    sc.escape_test()\r\n                    b, cylinder = rgNurbsSrf1.TryGetCylinder(fTol_Attempting)\r\n                    if b:\r\n                        if Cylinder.isSizeAcceptable(cylinder, bDebug=bDebug):\r\n                            rgNurbsSrf1.Dispose()\r\n                            return cylinder, fTol_Attempting\r\n                        else:\r\n                            break\r\n            \r\n                    if fTol_Attempting == fTolerance:\r\n                        break\r\n    \r\n                    exp += 1\r\n                    fTol_Attempting = 2**exp\r\n    \r\n                    #fTol_Attempting *= 10.0\r\n    \r\n                    if fTol_Attempting > fTolerance:\r\n                        fTol_Attempting = fTolerance\r\n\r\n        if bCone_WIP:\r\n            b, cone = rgNurbsSrf1.TryGetCone(fTolerance)\r\n            if b:\r\n                cone = None\r\n            else:\r\n                bCone_WIP = False\r\n        if bSphere_WIP:\r\n            b, sphere = rgNurbsSrf1.TryGetSphere(fTolerance)\r\n            if b:\r\n                sphere = None\r\n            else:\r\n                bSphere_WIP = False\r\n        if bTorus_WIP:\r\n            b, torus = rgNurbsSrf1.TryGetTorus(fTolerance)\r\n            if b:\r\n                torus = None\r\n            else:\r\n                bTorus_WIP = False\r\n\r\n        if not any((bCone_WIP, bSphere_WIP, bTorus_WIP)):\r\n            return None, None\r\n\r\n        # Reset starting tolerance for non-cylinder search.\r\n        exp = -52\r\n        fTol_Attempting = m_eps\r\n\r\n        while fTol_Attempting <= fTolerance:\r\n            sc.escape_test()\r\n        \r\n            if bCone_WIP:\r\n                b, cone = rgNurbsSrf1.TryGetCone(fTol_Attempting)\r\n                if b:\r\n                    for pt in (\r\n                            rgNurbsSrf1.PointAt(\r\n                                    rgNurbsSrf1.Domain(0).T0,\r\n                                    rgNurbsSrf1.Domain(1).T0),\r\n                            rgNurbsSrf1.PointAt(\r\n                                    rgNurbsSrf1.Domain(0).T1,\r\n                                    rgNurbsSrf1.Domain(1).T1)\r\n                    ):\r\n                        rc = Cone.isSizeAcceptableAtPoint(\r\n                                cone,\r\n                                point=pt,\r\n                                bDebug=bDebug)\r\n                        if rc is None:\r\n                            continue\r\n                        elif rc is False:\r\n                            bCone_WIP = False\r\n                            break\r\n                    else:\r\n                        # Size is acceptable.\r\n                        rgNurbsSrf1.Dispose()\r\n                        return cone, fTol_Attempting\r\n            if bSphere_WIP:\r\n                b, sphere = rgNurbsSrf1.TryGetSphere(fTol_Attempting)\r\n                if b:\r\n                    if Sphere.isSizeAcceptable(sphere, bDebug=bDebug):\r\n                        rgNurbsSrf1.Dispose()\r\n                        return sphere, fTol_Attempting\r\n                    else:\r\n                        bSphere_WIP = False\r\n            if bTorus_WIP:\r\n                b, torus = rgNurbsSrf1.TryGetTorus(fTol_Attempting)\r\n                if b:\r\n                    if Torus.isSizeAcceptable(torus, bDebug=bDebug):\r\n                        rgNurbsSrf1.Dispose()\r\n                        return torus, fTol_Attempting\r\n                    else:\r\n                        bTorus_WIP = False\r\n        \r\n            if fTol_Attempting == fTolerance:\r\n                rgNurbsSrf1.Dispose()\r\n                return None, None\r\n\r\n            exp += 1\r\n            fTol_Attempting = 2**exp\r\n\r\n            #fTol_Attempting *= 10.0\r\n\r\n            if fTol_Attempting > fTolerance:\r\n                fTol_Attempting = fTolerance\r\n\r\n\r\n    @staticmethod\r\n    def tryGetPrimitiveShape(rgSrf0, bPlane=True, bCylinder=True, bCone=True, bSphere=True, bTorus=True, fTolerance=1e-9, bDebug=False):\r\n        \"\"\"\r\n        190722: Routines were split into 2 other functions.\r\n    \r\n        Returns a tuple:\r\n            On success: (rg.Cone, Cylinder, Plane, Sphere, or Torus instance), (float: tolerance actually used to obtain shape)\r\n            On fail: None, None\r\n        \"\"\"\r\n    \r\n        if isinstance(rgSrf0, rg.BrepFace):\r\n            rgSrf0 = rgSrf0.UnderlyingSurface()\r\n    \r\n        if isinstance(rgSrf0, rg.NurbsSurface):\r\n            rgNurbsSrf1 = rgSrf0\r\n        else:\r\n            rgNurbsSrf1 = rgSrf0.ToNurbsSurface()\r\n    \r\n        rc = None, None\r\n    \r\n        if bPlane:\r\n            rc = Surface.tryGetPlane(\r\n                    rgSrf0=rgSrf0,\r\n                    fTolerance=fTolerance,\r\n                    bDebug=bDebug)\r\n            if rc[0] is not None:\r\n                return rc\r\n    \r\n        if bCylinder or bCone or bSphere or bTorus:\r\n            rc = Surface.tryGetRoundPrimitive(\r\n                    rgSrf0=rgSrf0,\r\n                    bCylinder=bCylinder,\r\n                    bCone=bCone,\r\n                    bSphere=bSphere,\r\n                    bTorus=bTorus,\r\n                    fTolerance=fTolerance,\r\n                    bDebug=bDebug)\r\n    \r\n        return rc\r\n\r\n\r\nclass BrepFace():\r\n\r\n\r\n    @staticmethod\r\n    def tryGetPlane(rgFace0, bMatchToShrunkFace=True, fTolerance=1e-9, bDebug=False):\r\n        \"\"\"\r\n        Return on success: tuple(\r\n            tuple(\r\n                rg.Plane\r\n                float(Tolerance used)\r\n                bool(Whether shrunk surface was used),\r\n            None)\r\n        Return on fail: tuple(\r\n            None\r\n            str(LogStatement))\r\n        \"\"\"\r\n        if bMatchToShrunkFace:\r\n            rgBrep_1Face_Shrunk = rgFace0.DuplicateFace(False)\r\n            rgBrep_1Face_Shrunk.Faces.ShrinkFaces()\r\n            rgFace_Shrunk = rgBrep_1Face_Shrunk.Faces[0]\r\n            rgSrfs_ToTry = rgFace0.UnderlyingSurface(), rgFace_Shrunk.UnderlyingSurface()\r\n        else:\r\n            rgSrfs_ToTry = rgFace0.UnderlyingSurface(),\r\n    \r\n        for i_NotShrunk_Shrunk, rgSrf_ToTry in enumerate(rgSrfs_ToTry):\r\n            rc = Surface.tryGetPlane(\r\n                    rgSrf_ToTry,\r\n                    fTolerance=fTolerance,\r\n                    bDebug=bDebug)\r\n            if rc[0]:\r\n                if bMatchToShrunkFace: rgBrep_1Face_Shrunk.Dispose()\r\n                rgPlane_Found, fTol_PlaneFound = rc\r\n                if not rgPlane_Found.IsValid:\r\n                    return None, \"Plane is not valid.\"\r\n                bShrunkUsed = bool(i_NotShrunk_Shrunk)\r\n                return (rgPlane_Found, fTol_PlaneFound, bShrunkUsed), None\r\n    \r\n        if bMatchToShrunkFace: rgBrep_1Face_Shrunk.Dispose()\r\n    \r\n        return None, \"Plane not found within tolerance of {:.2e}.\".format(fTolerance)\r\n\r\n\r\n    @staticmethod\r\n    def tryGetRoundPrimitive(rgFace0, bMatchToShrunkFace=True, bCylinder=True, bCone=True, bSphere=True, bTorus=True, fTolerance=1e-9, bDebug=False):\r\n        \"\"\"\r\n        Return on success: tuple(\r\n            tuple(\r\n                rg.Cone, Cylinder, Sphere, or Torus\r\n                float(Tolerance used)\r\n                bool(Whether shrunk surface was used),\r\n            None)\r\n        Return on fail: tuple(\r\n            None\r\n            str(LogStatement))\r\n        \"\"\"\r\n    \r\n        if bMatchToShrunkFace:\r\n            rgBrep_1Face_Shrunk = rgFace0.DuplicateFace(False)\r\n            rgBrep_1Face_Shrunk.Faces.ShrinkFaces()\r\n            rgFace_Shrunk = rgBrep_1Face_Shrunk.Faces[0]\r\n            rgFaces_ToTest = rgFace0, rgFace_Shrunk\r\n            rgSrfs_ToTry = rgFace0.UnderlyingSurface(), rgFace_Shrunk.UnderlyingSurface()\r\n        else:\r\n            rgSrfs_ToTry = rgFace0.UnderlyingSurface(),\r\n    \r\n        for i_NotShrunk_Shrunk, rgSrf_ToTry in enumerate(rgSrfs_ToTry):\r\n            rc = Surface.tryGetRoundPrimitive(\r\n                    rgSrf0=rgSrf_ToTry,\r\n                    bCylinder=bCylinder,\r\n                    bCone=bCone,\r\n                    bSphere=bSphere,\r\n                    bTorus=bTorus,\r\n                    fTolerance=fTolerance,\r\n                    bDebug=bDebug)\r\n            if rc[0]:\r\n                if bMatchToShrunkFace: rgBrep_1Face_Shrunk.Dispose()\r\n                rgShape_Found, fTol_ShapeFound = rc\r\n                if not rgShape_Found.IsValid:\r\n                    return None, \"{} is not valid.\".format(rgShape_Found.GetType().Name)\r\n                bShrunkUsed = bool(i_NotShrunk_Shrunk)\r\n                return (rgShape_Found, fTol_ShapeFound, bShrunkUsed), None\r\n    \r\n        if bMatchToShrunkFace: rgBrep_1Face_Shrunk.Dispose()\r\n    \r\n        return None, \"Round primitive not found within tolerance of {:.2e}.\".format(fTolerance)\r\n\r\n\r\n    @staticmethod\r\n    def tryGetPrimitiveShape(rgFace0, bMatchToShrunkFace=True, bPlane=True, bCylinder=True, bCone=True, bSphere=True, bTorus=True, fTolerance=1e-9, bDebug=False):\r\n        \"\"\"\r\n        Updated in May of 2019.  Based on hasPrimitiveShape.\r\n    \r\n        Returns:\r\n            On Success (regardless if primitive is found):\r\n                tuple:\r\n                    (\r\n                        tuple: (rg.Plane or rg.Cylinder or rg.Cone or rg.Sphere or rg.Torus,\r\n                        float of tolerance used to find shape,\r\n                        'shrunk' or 'not shrunk')\r\n                    ,\r\n                        str: (Fail log)\r\n                    )\r\n            On fail: None, None\r\n        \"\"\"\r\n        rgSrf_Face0 = rgFace0.UnderlyingSurface()\r\n    \r\n\r\n        if bPlane:\r\n            rc = BrepFace.tryGetPlane(\r\n                    rgFace0,\r\n                    bMatchToShrunkFace=bMatchToShrunkFace,\r\n                    fTolerance=fTolerance,\r\n                    bDebug=bDebug)\r\n            if rc[0] is not None:\r\n                return rc\r\n\r\n        if bCylinder or bCone or bSphere or bTorus:\r\n            rc = BrepFace.tryGetRoundPrimitive(\r\n                    rgFace0=rgFace0,\r\n                    bMatchToShrunkFace=bMatchToShrunkFace,\r\n                    bCylinder=bCylinder,\r\n                    bCone=bCone,\r\n                    bSphere=bSphere,\r\n                    bTorus=bTorus,\r\n                    fTolerance=fTolerance,\r\n                    bDebug=bDebug)\r\n            if rc[0] is not None:\r\n                return rc\r\n    \r\n        return None, None\r\n\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": false
}