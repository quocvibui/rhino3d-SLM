{
  "source_url": "https://github.com/TTM-KK/TimberFormOptimization/blob/a728057ff3bfbfb7995b309e835a6278a6e86fcc/Generate.py",
  "repo": "TTM-KK/TimberFormOptimization",
  "repo_stars": 0,
  "repo_description": "This is a Form Generate Project, using non preform timber.",
  "license": "unknown",
  "filepath": "Generate.py",
  "instruction": "Generate",
  "code": "# -*- coding:utf-8 -*-\n\nfrom Timber import Timber\nimport random as rnd\nimport math  # ttm add 181003\nfrom forGenerate import timberMethod as timber\nimport Rhino\nfrom forGenerate import RhinoCommonOriginalMethods as oriRhino\nimport copy\n\n\nclass Generate:\n\n    # 初期化\n    def __init__(self, center_line, surface, id, sum_timber, population_id, generate_range):\n        self.center_line_list = center_line  # center line list\n        self.surface_list = surface  # surface list\n        self.id_list = id  # timber name list\n        self.sum_timber = sum_timber  # timberの総本数\n        self.timber_list = []  # まだ使用していないtimberのリスト\n        self.used_list = []  # 使用したtimberのリスト\n        self.population_id = population_id\n\n        self.evaluation = 0\n        self.yet_regenerate_tim_id = []  # 再生成されずにいる部材のidを格納\n        self.already_regenerate_tim_id = []  # 再生成すでにされている部材のidを格納する。\n        self.generate_range = generate_range\n\n    def instantiate_timber(self):\n\n        # スキャンデータをtimberクラスのオブジェクトにする\n        for i in range(0, self.sum_timber):\n            timber = Timber(self.center_line_list[i], self.surface_list[i], self.id_list[i])  # インスタンス生成\n            self.timber_list.append(timber)  # timber_listに追加\n\n            # 中心線の長さを取得する\n            timber.measure_length()\n            timber.measure_section_length()\n            timber.init_tim_distance(self.sum_timber)\n\n    def generate_ground_init(self, generate_range, objects_curve=None, objects_point=None):\n        \"\"\"\n        :param generate_range: 生成可能範囲の入力ー＞int\n        :param objects_curve Rhinocerosの閉じたCurveで範囲を指定。Rhino.Objectに変換したものを引数へ\n        :param generate_point: RhinocerosのPointで指定するRhino.Objectに変換したものを引数へ\n        :return:\n        \"\"\"\n\n        # 部材の選択。\n        if len(self.used_list) == 0:\n            tim = self.timber_list[0]\n        else:\n            index = rnd.randint(0, len(self.timber_list) - 1)\n            tim = self.timber_list[index]\n\n        tim_srf = tim.surface\n        tim_axis = tim.center_line\n\n        axis_start_p = tim_axis.PointAtStart\n        axis_end_p = tim_axis.PointAtEnd\n\n        # if generate range is predetermined\n        # objects_curve = []\n        # if len(self.used_list) == 0 and generate_range_curve:\n        #     for i in range(len(generate_range_curve)):\n        #         curve = rs.coercecurve(generate_range_curve[i])\n        #         objects_curve.append(curve)\n\n        # if generate base point is predetermined\n        # objects_point = []\n        # if len(self.used_list) == 0 and generate_point:\n        #     for i in range(len(generate_point)):\n        #         point = rs.coerce3dpoint(generate_point[i])\n        #         objects_point.append(point)\n\n        # 生成される範囲が予めCurveで決められている場合\n        if objects_curve:\n            flag = True\n            loop = 0\n            while flag:\n                loop += 1\n                x = rnd.randint(0, generate_range)\n                y = rnd.randint(0, generate_range)\n\n                point_base = Rhino.Geometry.Point3d(x, y, 0)\n\n                for i in range(len(objects_curve)):\n                    rc = objects_curve[i].Contains(point_base)\n                    if rc == Rhino.Geometry.PointContainment.Inside:\n                        flag = False\n                        break\n\n                if loop > 100:\n                    raise Exception(\"while infinite loop\")\n\n        # 生成される範囲がPointで決められている場合。\n        elif objects_point:\n            select_index = rnd.randint(0, len(objects_point)-1)\n\n            point_base = objects_point[select_index]\n            del objects_point[select_index]  # TODO 他の場所と干渉する恐れがあるので要注意\n\n        # 生成される場所が特に決定されていない場合。\n        else:\n            x = rnd.randint(0, generate_range)\n            y = rnd.randint(0, generate_range)\n            point_base = Rhino.Geometry.Point3d(x, y, 0)\n\n        # selectされたpointとaxisの端点とのベクトルを計算\n        if axis_end_p[2] > axis_start_p[2]:\n            point_base_tim = axis_start_p\n        else:\n            point_base_tim = axis_end_p\n\n        vector_from_tim = point_base - point_base_tim\n\n        # timをbaseまでMoveさせる\n        xf = Rhino.Geometry.Transform.Translation(vector_from_tim)\n        tim_axis.Transform(xf)\n        tim_srf.Transform(xf)\n\n        # 指定した生成可能範囲内に収まるように試行する。\n        # 接点からのフリをランダムにする。 TODO 一旦部材がほとんど垂直に置かれていることを前提にアルゴリズムを構築\n        restriction_angle = 45\n\n        # rotateを行うための平面を定義。\n        p1 = Rhino.Geometry.Point3d(0, 0, 0)\n        p2 = Rhino.Geometry.Point3d(0, 0, 10)\n        p3 = Rhino.Geometry.Point3d(10, 0, 0)\n        plane1 = Rhino.Geometry.Plane(p1, p2, p3)\n\n        p1_ = Rhino.Geometry.Point3d(0, 0, 0)\n        p2_ = Rhino.Geometry.Point3d(0, 10, 0)\n        p3_ = Rhino.Geometry.Point3d(10, 0, 0)\n        plane2 = Rhino.Geometry.Plane(p1_, p2_, p3_)\n\n        # 指定した生成可能範囲に部材が収まるまで試行を繰り返す。\n        # Curveの端部が外に出ている場合のみなので、精度をまだ上げることが可能。\n        # 他部材との接触判定を含める必要あり。\n        init_generate = True\n        avoid_infinite_loop = 1\n        while init_generate:\n            avoid_infinite_loop += 1\n            if avoid_infinite_loop > 100:\n                raise Exception('infinite loop occur')\n\n            rotate_angle = math.radians(rnd.randint(-restriction_angle, restriction_angle))\n            xf = Rhino.Geometry.Transform.Rotation(rotate_angle, plane1[3], point_base)\n            tim_srf.Transform(xf)\n            tim_axis.Transform(xf)\n\n            rotate_angle = math.radians(rnd.randint(-restriction_angle, -restriction_angle))\n            xf = Rhino.Geometry.Transform.Rotation(rotate_angle, plane2[3], point_base)\n            tim_srf.Transform(xf)\n            tim_axis.Transform(xf)\n\n            start_p = tim_axis.PointAtStart\n            end_p = tim_axis.PointAtEnd\n            for i in start_p:\n                if i < self.generate_range:\n                    init_generate = False\n                    pass\n                else:\n                    init_generate = True\n                    break\n\n            for i in end_p:\n                if i < self.generate_range:\n                    init_generate = False\n                    pass\n                else:\n                    init_generate = True\n                    break\n\n        # 各パラメータの更新\n        # 木材同士の間隔の最小値を計測。\n        if len(self.used_list) == 0:\n            pass\n        else:\n            for i in range(len(self.used_list)):\n                timber.distanceBetweenTimber_RhinoCommon(self.used_list[i], tim)\n\n        # 木材未使用、使用リストの更新\n        if len(self.used_list) == 0:\n            self.used_list.append(tim)\n            self.timber_list.pop(0)\n        else:\n            self.used_list.append(tim)\n            self.timber_list.pop(index)\n\n        return True\n\n    def cantilever(self, limit_degree):\n        divide_domain_num = 10\n\n        for h in range(50):\n            if h == 49:\n                raise Exception('GL avoid is not work well')\n\n            # 各オブジェクトの取得　--->  Timber Instanceに置き換える\n            if len(self.used_list) == 0:\n                used_timber = self.timber_list[0]\n                unused_timber = self.timber_list[1]\n\n            else:\n                x = rnd.randint(0, len(self.used_list) - 1)\n                used_timber = self.used_list[x]\n\n                y = rnd.randint(0, len(self.timber_list) - 1)\n                unused_timber = self.timber_list[y]\n\n            tim1_srf = used_timber.surface\n            tim2_srf = unused_timber.surface\n\n            tim1_center_crv = used_timber.center_line\n            tim2_center_crv = unused_timber.center_line\n\n            domain_crv1 = tim1_center_crv.Domain\n            domain_crv2 = tim2_center_crv.Domain\n\n            each_domain_length1 = (domain_crv1[1] - domain_crv1[0]) / divide_domain_num\n            each_domain_length2 = (domain_crv2[1] - domain_crv2[0]) / divide_domain_num\n\n            # select_domainの値を変化させることで接合部を変化させる事ができる。\n            select_domain1 = used_timber.select_surface_domain()\n            select_domain2 = unused_timber.select_surface_domain()\n\n            tim1_point = tim1_center_crv.PointAt(domain_crv1[0] + select_domain1 * each_domain_length1)\n            tim2_point = tim2_center_crv.PointAt(domain_crv2[0] + select_domain2 * each_domain_length2)\n\n            vec_move = tim1_point - tim2_point\n\n            xf = Rhino.Geometry.Transform.Translation(vec_move)\n            tim2_center_crv.Transform(xf)\n            tim2_srf.Transform(xf)\n\n            # Rotateするために回転平面を規定。Plane1\n            p1 = Rhino.Geometry.Point3d(0, 0, 0)\n            p2 = Rhino.Geometry.Point3d(0, 0, 10)\n            p3 = Rhino.Geometry.Point3d(10, 0, 0)\n            plane1 = Rhino.Geometry.Plane(p1, p2, p3)\n\n            # Rotateするために回転平面を規定。Plane2\n            p1_ = Rhino.Geometry.Point3d(0, 0, 0)\n            p2_ = Rhino.Geometry.Point3d(0, 10, 0)\n            p3_ = Rhino.Geometry.Point3d(10, 0, 0)\n            plane2 = Rhino.Geometry.Plane(p1_, p2_, p3_)\n\n            # GLに部材を生成しないために部材端のz座標値を計算\n            # 生成可能範囲に部材が収まるように制限。\n            flag_gl = True\n            avoid_infinite_loop = 0\n            while flag_gl:\n\n                avoid_infinite_loop += 1\n                if avoid_infinite_loop > 50:\n                    # print('infinite loop is occur')\n                    break\n\n                # Rotate1回目\n                rotate_angle = math.radians(rnd.randint(0, 360))\n                xf = Rhino.Geometry.Transform.Rotation(rotate_angle, plane1[3], tim1_point)\n                tim2_center_crv.Transform(xf)\n                tim2_srf.Transform(xf)\n\n                # Rotate2回目\n                rotate_angle = math.radians(rnd.randint(0, 360))\n                xf = Rhino.Geometry.Transform.Rotation(rotate_angle, plane2[3], tim1_point)\n                tim2_center_crv.Transform(xf)\n                tim2_srf.Transform(xf)\n\n                tim2_crv_end = tim2_center_crv.PointAtEnd\n                tim2_crv_start = tim2_center_crv.PointAtStart\n\n                # GL との接触を判定\n                if 4000 > tim2_crv_end[2] > 100 and 4000 > tim2_crv_start[2] > 100:\n                    gl_check = True\n                else:\n                    gl_check = False\n\n                # 生成可能範囲に収まっているか判定。\n                counter = 0\n                if (self.generate_range * 2) * self.population_id < tim2_crv_start[0] < (self.generate_range * 2) * (self.population_id) + self.generate_range\\\n                        and (self.generate_range * 2) * self.population_id < tim2_crv_end[0] < (self.generate_range * 2) * (self.population_id) + self.generate_range:\n                    counter += 1\n                if -(self.generate_range) > tim2_crv_start[1] > -(self.generate_range * 2) and  \\\n                        -(self.generate_range) > tim2_crv_end[1] > -(self.generate_range * 2):\n                    counter += 1\n\n                if counter == 2:\n                    range_check = True\n                else:\n                    range_check = False\n\n                # 両条件を満たしていればOK\n                if range_check and gl_check:\n                    pass\n                else:\n                    continue\n\n                contact_judge_flag = False\n                # contact_judge_flag = self.contact_judgement_cantilever(unused_timber.id, used_timber.id)\n                if contact_judge_flag:\n                    flag_gl = True\n                else:\n                    flag_gl = False\n                    # print('cantilever contact judgement clear : while{} loop{}'.format(avoid_infinite_loop, h))\n\n            if flag_gl:\n                continue\n            else:\n                pass\n\n            # 接合部の接合範囲最適化。\n            # ここも現状は精度がイマイチなため、修正が必要。\n            length1, rc1 = oriRhino.GetTimberSectionLength_RhinoCommon(tim1_srf, tim1_point)\n            length2, rc2 = oriRhino.GetTimberSectionLength_RhinoCommon(tim2_srf, tim2_point)\n\n            vec_move = rc1 - tim2_point\n            if length1 > length2:\n                rc = Rhino.Geometry.Vector3d(vec_move.X, vec_move.Y, vec_move.Z)\n                rc.Unitize()\n                vec_move = rc * ((length1 / 2) + (length2 / 3))\n                xf = Rhino.Geometry.Transform.Translation(vec_move)\n                tim2_srf.Transform(xf)\n                tim2_center_crv.Transform(xf)\n            else:\n                rc = Rhino.Geometry.Vector3d(vec_move.X, vec_move.Y, vec_move.Z)\n                rc.Unitize()\n                vec_move = rc * ((length1 / 2) + (length2 / 3))\n                xf = Rhino.Geometry.Transform.Translation(vec_move)\n                tim2_srf.Transform(xf)\n                tim2_center_crv.Transform(xf)\n\n            tim2_crv_end = tim2_center_crv.PointAtEnd\n            tim2_crv_start = tim2_center_crv.PointAtStart\n\n            # GLとの接触判定。\n            if tim2_crv_end[2] > 100 and tim2_crv_start[2] > 100:\n                break\n            else:\n                continue\n\n        # domainの更新\n        used_timber.select_domain_list.append([select_domain1, unused_timber.id])\n        unused_timber.select_domain_list.append([select_domain2, used_timber.id])\n\n        # 接合した相手の木材のIDを格納。\n        used_timber.partner_tim.append(unused_timber.id)\n        unused_timber.partner_tim.append(used_timber.id)\n        if used_timber.id == unused_timber.id:\n            raise Exception('partner tim renewal fail')\n\n        # 木材同士の間隔の最小値を計測。\n        if len(self.used_list) == 0:\n            timber.distanceBetweenTimber_RhinoCommon(used_timber, unused_timber)\n        else:\n            for i in range(len(self.used_list)):\n                timber.distanceBetweenTimber_RhinoCommon(self.used_list[i], unused_timber)\n\n        # 木材未使用、使用リストの更新\n        if len(self.used_list) == 0:\n            self.used_list.append(used_timber)\n            self.used_list.append(unused_timber)\n            self.timber_list.pop(0)\n            self.timber_list.pop(0)\n        else:\n            self.used_list.append(unused_timber)\n            self.timber_list.pop(y)\n\n        return True\n\n    def cantilever_specify(self, tim_preexist_num, tim_add_num, already_regenerated_list, limit_degree,\n                           generation_num, loop_num, loop, between_draw_rhino):\n\n        gl_distance = 0\n        divide_domain_num = 10\n\n        # 各オブジェクトの取得　--->  Timber Instanceに置き換える\n        used_timber = self.used_list[tim_preexist_num]\n        unused_timber = self.used_list[tim_add_num]\n\n        tim1_srf = self.used_list[tim_preexist_num].surface\n        tim2_srf = self.used_list[tim_add_num].surface\n\n        tim1_center_crv = self.used_list[tim_preexist_num].center_line\n        tim2_center_crv = self.used_list[tim_add_num].center_line\n\n        domain_crv1 = tim1_center_crv.Domain\n        domain_crv2 = tim2_center_crv.Domain\n\n        each_domain_length1 = (domain_crv1[1] - domain_crv1[0]) / divide_domain_num\n        each_domain_length2 = (domain_crv2[1] - domain_crv2[0]) / divide_domain_num\n\n        select_domain1 = used_timber.select_surface_domain()\n        select_domain2 = unused_timber.select_surface_domain()\n\n        tim1_point = tim1_center_crv.PointAt(domain_crv1[0] + select_domain1 * each_domain_length1)\n        tim2_point = tim2_center_crv.PointAt(domain_crv2[0] + select_domain2 * each_domain_length2)\n\n        vec_move = tim1_point - tim2_point\n\n        xf = Rhino.Geometry.Transform.Translation(vec_move)\n        tim2_center_crv.Transform(xf)\n        tim2_srf.Transform(xf)\n\n        # Rotateを行うための平面を定義。Plane1\n        p1 = Rhino.Geometry.Point3d(0, 0, 0)\n        p2 = Rhino.Geometry.Point3d(0, 0, 10)\n        p3 = Rhino.Geometry.Point3d(10, 0, 0)\n        plane1 = Rhino.Geometry.Plane(p1, p2, p3)\n\n        # Rotateを行うための平面を定義。Plane2\n        p1_ = Rhino.Geometry.Point3d(0, 0, 0)\n        p2_ = Rhino.Geometry.Point3d(0, 10, 0)\n        p3_ = Rhino.Geometry.Point3d(10, 0, 0)\n        plane2 = Rhino.Geometry.Plane(p1_, p2_, p3_)\n\n        # GL Method\n        flag = True\n        avoid_infinite_loop = 0\n        while flag:\n            avoid_infinite_loop += 1\n            if avoid_infinite_loop > 100:\n                break\n\n            # Rotate1回目\n            rotate_angle = math.radians(rnd.randint(0, 360))\n            xf = Rhino.Geometry.Transform.Rotation(rotate_angle, plane1[3], tim1_point)\n            tim2_center_crv.Transform(xf)\n            tim2_srf.Transform(xf)\n\n            # Rotate2回目\n            rotate_angle = math.radians(rnd.randint(0, 360))\n            xf = Rhino.Geometry.Transform.Rotation(rotate_angle, plane2[3], tim1_point)\n            tim2_center_crv.Transform(xf)\n            tim2_srf.Transform(xf)\n\n            end_p = tim2_center_crv.PointAtEnd\n            start_p = tim2_center_crv.PointAtStart\n\n            # GL との接触を判定 + 高さ制限\n            if 4000 > end_p[2] > 100 and 4000> start_p[2] > 100:\n                gl_check = True\n            else:\n                gl_check = False\n\n            # 生成可能範囲に収まっているか判定。\n            counter = 0\n            if (self.generate_range * 2) * loop < start_p[0] < (self.generate_range * 2) * (\n                    loop) + self.generate_range \\\n                    and (self.generate_range * 2) * loop < end_p[0] < (self.generate_range * 2) * (\n                    loop) + self.generate_range:\n                counter += 1\n\n            if -(self.generate_range * 2) * (loop_num + 1) + self.generate_range > start_p[1] > -(self.generate_range * 2) * (loop_num + 1) - (self.generate_range * 2) \\\n                    and -(self.generate_range * 2) * (loop_num + 1) + self.generate_range > end_p[1] > -(self.generate_range * 2) * (loop_num + 1) - (self.generate_range * 2):\n                counter += 1\n\n            if counter == 2:\n                range_check = True\n            else:\n                range_check = False\n\n            # 両条件を満たしていればOK\n            if range_check and gl_check:\n                pass\n            else:\n                continue\n            # contact_judge_flag = False\n            contact_judge_flag = self.contact_judgement_cantilever_specify(unused_timber.id, used_timber.id, already_regenerated_list)\n            if contact_judge_flag:\n                flag = True\n            else:\n                # print('cantilever_specify contact judgement clear : while{}'.format(avoid_infinite_loop))\n                flag = False\n\n        if flag:\n            return False\n        else:\n            pass\n\n        # 接合部最適化開始。\n        length1, rc1 = oriRhino.GetTimberSectionLength_RhinoCommon(tim1_srf, tim1_point)\n        length2, rc2 = oriRhino.GetTimberSectionLength_RhinoCommon(tim2_srf, tim2_point)\n\n        vec_move = rc1 - tim2_point\n        if length1 > length2:\n            rc = Rhino.Geometry.Vector3d(vec_move.X, vec_move.Y, vec_move.Z)\n            rc.Unitize()\n            vec_move = rc * ((length1 / 2) + (length2 / 3))\n            xf = Rhino.Geometry.Transform.Translation(vec_move)\n            tim2_srf.Transform(xf)\n            tim2_center_crv.Transform(xf)\n        else:\n            rc = Rhino.Geometry.Vector3d(vec_move.X, vec_move.Y, vec_move.Z)\n            rc.Unitize()\n            vec_move = rc * ((length1 / 2) + (length2 / 3))\n            xf = Rhino.Geometry.Transform.Translation(vec_move)\n            tim2_srf.Transform(xf)\n            tim2_center_crv.Transform(xf)\n\n        # GL Method\n        end_p = tim2_center_crv.PointAtEnd\n        start_p = tim2_center_crv.PointAtStart\n\n        if end_p[2] > gl_distance and start_p[2] > gl_distance:\n            pass\n        else:\n            return False\n\n        # domainの更新\n        used_timber.select_domain_list.append([select_domain1, unused_timber.id])\n        unused_timber.select_domain_list.append([select_domain2, used_timber.id])\n\n        # partnerの更新\n        used_timber.partner_tim.append(unused_timber.id)\n        unused_timber.partner_tim.append(used_timber.id)\n        if used_timber.id == unused_timber.id:\n            raise Exception('partner_tim renewal fail')\n\n        # 木材同士の間隔の最小値を計測。\n        for i in range(len(self.used_list)):\n            already_exist_timber = self.used_list[i]\n            already_exist_timber_name = self.used_list[i].id\n            if already_exist_timber_name in already_regenerated_list:\n                timber.distanceBetweenTimber_RhinoCommon(already_exist_timber, unused_timber)\n\n        return True\n\n    def bridge(self, limit_degree):\n\n        split_ = 200\n        split_domain_range_num = 10\n\n        for h in range(100):\n\n            if h > 99:\n                raise Exception('bridge GL method is not work well')\n\n            # 部材の選択を行い、部材間の距離を測定することにより、Bridge可能かどうか判定する。\n            for i in range(20):\n                flag_select_timber_domain = True\n                flag_select_timber_domain_success = False\n\n                flag_select_timber = False\n                samples = [sample for sample in range(len(self.used_list))]\n\n                # 部材の選択を行う\n                for _ in range(1000):\n                    # used_timberの選択\n                    index = rnd.sample(samples, 2)\n                    x1 = index[0]\n                    x2 = index[1]\n                    used_timber1 = self.used_list[x1]\n                    used_timber2 = self.used_list[x2]\n\n                    # unused_timberの選択\n                    y = rnd.randint(0, len(self.timber_list) - 1)\n                    unused_timber = self.timber_list[y]\n\n                    length_of_between = used_timber1.tim_distance[used_timber2.id][0]\n                    length_of_timber = unused_timber.timber_length\n\n                    if length_of_timber < length_of_between:\n                        continue\n                    else:\n                        flag_select_timber = True\n                        break\n\n                if not flag_select_timber:\n                    raise Exception('select timber does not work')\n\n                tim3_srf = unused_timber.surface\n                tim1_center_crv = used_timber1.center_line\n                tim2_center_crv = used_timber2.center_line\n                tim3_center_crv = unused_timber.center_line\n\n                # Get each crv domain\n                domain_crv1 = tim1_center_crv.Domain\n                domain_crv2 = tim2_center_crv.Domain\n                domain_crv3 = tim3_center_crv.Domain\n                split_range = (domain_crv3[1] - domain_crv3[0]) / split_\n\n                # 指定したdomain内にある点を算出する。\n                domain_range1 = abs((domain_crv1[1] - domain_crv1[0]) / split_domain_range_num)\n                domain_range2 = abs((domain_crv2[1] - domain_crv2[0]) / split_domain_range_num)\n                domain_range3 = abs((domain_crv3[1] - domain_crv3[0]) / split_domain_range_num)\n\n                select_domain_3_start = 0  # TODO 今のところ固定値\n                for select_domain_loop in range(200):\n\n                    select_domain_1 = used_timber1.select_surface_domain()  # select_domain はドメインの値をintで返される。\n                    select_domain_2 = used_timber2.select_surface_domain()\n\n                    # TODO　ドメインの指定に関しては範囲内をランダムにする、中心線を単純にするなどによって精度を向上させること可能。\n                    tim1_point = tim1_center_crv.PointAt(domain_crv1[0] + domain_range1 * select_domain_1)\n                    tim2_point = tim2_center_crv.PointAt(domain_crv2[0] + domain_range2 * select_domain_2)\n\n                    # tim1, tim2間の点と点の長さを取得する\n                    distance_between = (tim1_point - tim2_point).Length\n\n                    # bridge可能か判断　\n                    length_tim3 = tim3_center_crv.GetLength() / split_domain_range_num * 2\n                    if distance_between > length_tim3 - (length_tim3 / 10) * 4:\n                        if select_domain_loop == 199:\n                            flag_select_timber_domain = False\n                            break\n\n                        else:\n                            continue\n                    else:\n                        flag_select_timber_domain_success = True\n                        break\n\n                # 部材の再選択へもどる。\n                if not flag_select_timber_domain:\n                    continue\n\n                # 部材がBridge可能と判断されたなら。部材の選択を終了。\n                if flag_select_timber_domain_success:\n                    break\n                else:\n                    raise Exception(\"select timber domain is fail in Generate line 1422\")\n\n            # distance_betweenの距離よりもlength_tim3のほうが長かったとしても、EvaluateCurveで選択される点次第で長さが足りなくなることも十分に考えられるだろう。\n            # このｔの値が変化することによってかけられるDomainの範囲が自由になる。\n            t = domain_crv3[0] + domain_range3 * select_domain_3_start\n            tim3_start_point_coordinate = tim3_center_crv.PointAt(t)\n\n            # distance_between と同じ長さとなるcrv3上のパラメータを取得。　点を加える。\n            t_ = domain_crv3[0]\n            flag_select = True\n            avoid_ = 0\n            while flag_select:\n                avoid_ = avoid_ + 1\n                t_ = t_ + split_range * 5  # ここを調整することでスピードを上げることができるはず。\n                tim3_end_point_coordinate = tim3_center_crv.PointAt(t_)  # RhinoCommon\n                distance = (tim3_end_point_coordinate - tim3_start_point_coordinate).Length  # RhinoCommon\n                if distance > distance_between:\n                    break\n                if avoid_ > 100:\n                    raise ValueError(\"infinite loop: select_domain_3_end\")\n\n            # ObjectのMove\n            vec_move = tim1_point - tim3_start_point_coordinate  # RhinoCommon\n            # print(\"vec_move\", vec_move)\n            xf = Rhino.Geometry.Transform.Translation(vec_move)\n            tim3_center_crv.Transform(xf)\n            tim3_srf.Transform(xf)\n\n            # 再計測\n            tim3_end_point = tim3_center_crv.PointAt(t_)\n\n            # 1回目のRotate\n            vec1 = tim1_point - tim3_end_point\n            vec2 = tim1_point - tim2_point\n            rotate_angle1 = oriRhino.VectorAngle_RhinoCommon(vec1, vec2)\n            plane1 = Rhino.Geometry.Plane(tim1_point, tim3_end_point, tim2_point)\n            xf = Rhino.Geometry.Transform.Rotation(rotate_angle1, plane1[3], tim1_point)\n            tim3_center_crv.Transform(xf)\n            tim3_srf.Transform(xf)\n\n            # 再計測\n            tim3_end_point = tim3_center_crv.PointAt(t_)\n            # tim3_start_point = tim3_center_crv.PointAt(t)\n\n            # 2回目のRotate\n            vec3 = tim3_end_point - tim1_point\n            vec4 = tim2_point - tim1_point\n            rotate_angle2 = oriRhino.VectorAngle_RhinoCommon(vec3, vec4)\n            plane2 = Rhino.Geometry.Plane(tim1_point, tim3_end_point, tim2_point)\n\n            if int(tim3_end_point[0]) - 10 <= int(tim2_point[0]) <= int(tim3_end_point[0]) + 10 or \\\n                    int(tim3_end_point[1]) - 10 <= int(tim2_point[1]) <= int(tim3_end_point[1] + 10 or \\\n                                                                             int(tim3_end_point[2]) - 10 <= int(\n                tim2_point[2]) <= int(tim3_end_point[2])) + 10:  # TODO 範囲の式に書き換える。\n                pass\n            else:\n\n                xf = Rhino.Geometry.Transform.Rotation(rotate_angle2, plane2[3], tim1_point)\n                tim3_center_crv.Transform(xf)\n                tim3_srf.Transform(xf)\n\n            # 再計測\n            tim3_end_point = tim3_center_crv.PointAt(t_)\n            tim3_start_point = tim3_center_crv.PointAt(t)\n\n            # 接合部の接触面積最適化\n            # tim1とtim2のtim3にたいする外積をそれぞれ求める。\n            vec_tim3 = tim3_end_point - tim3_start_point\n            tim1_end_point = tim1_center_crv.PointAtEnd\n            vec_tim1 = tim1_end_point - tim1_point\n            tim2_end_point = tim2_center_crv.PointAtEnd\n\n            vec_tim2 = tim2_end_point - tim2_point\n\n            cross_vec1 = Rhino.Geometry.Vector3d.CrossProduct(vec_tim3, vec_tim1)\n            cross_vec2 = Rhino.Geometry.Vector3d.CrossProduct(vec_tim3, vec_tim2)\n            add_vec = cross_vec1 + cross_vec2\n\n            # 接合部の直径を求めることにより、移動距離を決定する。\n            dis1, rp1 = oriRhino.GetTimberSectionLength_RhinoCommon(tim3_srf, tim3_start_point)\n            dis2, rp2 = oriRhino.GetTimberSectionLength_RhinoCommon(tim3_srf, tim3_end_point)\n\n            # 移動距離を決定。\n            if dis1 >= dis2:\n                rc = Rhino.Geometry.Vector3d(add_vec.X, add_vec.Y, add_vec.Z)\n                rc.Unitize()\n                vec_move = rc * dis2\n                xf = Rhino.Geometry.Transform.Translation(vec_move)\n                tim3_srf.Transform(xf)\n                tim3_center_crv.Transform(xf)\n\n            else:\n                rc = Rhino.Geometry.Vector3d(add_vec.X, add_vec.Y, add_vec.Z)\n                rc.Unitize()\n                vec_move = rc * dis1\n                xf = Rhino.Geometry.Transform.Translation(vec_move)\n                tim3_srf.Transform(xf)\n                tim3_center_crv.Transform(xf)\n\n            tim3_end_p = tim3_center_crv.PointAtEnd\n            tim3_start_p = tim3_center_crv.PointAtStart\n\n            # ----------------------------------------------------------------------------------------------------------\n            # GLに接ししているか判定。\n            if 4000 > tim3_end_p[2] > 100 and 4000 > tim3_start_p[2] > 100:\n                gl_check = True\n            else:\n                gl_check = False\n\n            # 生成可能範囲に収まっているか判定。\n            counter = 0\n            if (self.generate_range * 2) * self.population_id < tim3_start_p[0] < (self.generate_range * 2) * (\n                    self.population_id) + self.generate_range\\\n                    and (self.generate_range * 2) * self.population_id < tim3_end_p[0] < (self.generate_range * 2) * (\n                    self.population_id) + self.generate_range:\n                counter += 1\n\n            if -(self.generate_range) > tim3_start_p[1] > -(self.generate_range * 2) \\\n                    and -(self.generate_range) > tim3_end_p[1] > -(self.generate_range * 2):\n                counter += 1\n\n            if counter == 2:\n                range_check = True\n            else:\n                range_check = False\n\n            # 両条件を満たしていればOK\n            if range_check and gl_check:\n                pass\n            else:\n                continue\n\n            contact_judge_flag = False\n            # contact_judge_flag = self.contact_judgement_bridge(unused_timber.id, used_timber1.id, used_timber2.id)\n            if contact_judge_flag:\n                continue\n            else:\n                # print('bridge contact judgement is success: {}'.format(h))\n                break\n\n        # # layerを変更して正しいレイヤーへ\n        # a = 'tim'\n        # b = str(unused_timber.name)\n        # print(\"unused_timber.name\", unused_timber.name)\n        # rs.CurrentLayer(a + b)\n        #\n        # cr = scriptcontext.doc.Objects.AddCurve(tim3_center_crv)\n        # sf = scriptcontext.doc.Objects.AddBrep(tim3_srf)\n        #\n\n        # 使用domainの更新のための値\n        select_domain_3_end = abs(int(t_ // domain_range3))\n        # print(\"select_domain_3_end : %s\" % (select_domain_3_end))\n        used_timber1.select_domain_list.append([select_domain_1, unused_timber.id])\n        used_timber2.select_domain_list.append([select_domain_2, unused_timber.id])\n        unused_timber.select_domain_list.append([select_domain_3_start, used_timber1.id])\n        unused_timber.select_domain_list.append([select_domain_3_end, used_timber2.id])\n\n        # partner_tim 更新\n        used_timber1.partner_tim.append(unused_timber.id)\n        used_timber2.partner_tim.append(unused_timber.id)\n\n        unused_timber.partner_tim.append(used_timber1.id)\n        unused_timber.partner_tim.append(used_timber2.id)\n\n        if used_timber1.id == unused_timber.id:\n            raise Exception('partner_tim renewal fail')\n        if used_timber2.id == unused_timber.id:\n            raise Exception('partner_tim renewal fail')\n\n        for i in range(len(self.used_list)):\n            timber.distanceBetweenTimber_RhinoCommon(unused_timber, self.used_list[i])\n\n        self.used_list.append(unused_timber)\n        self.timber_list.pop(y)\n\n        return True\n\n    def bridge_specify(self, tim_preexist_num_1, tim_preexist_num_2, tim_add_num, already_regenerated_list,\n                       limit_degree, generation_num, loop_num, loop, between_draw_rhino):\n        # start_time = time.time()\n\n        gl_distance = 0\n\n        split_ = 200\n        split_domain_range_num = 10\n\n        # 各オブジェクトの取得　--->  Timber Instanceに置き換える\n        used_timber1 = self.used_list[tim_preexist_num_1]\n        used_timber2 = self.used_list[tim_preexist_num_2]\n        unused_timber = self.used_list[tim_add_num]\n\n        tim3_srf = self.used_list[tim_add_num].surface\n        tim1_center_crv = self.used_list[tim_preexist_num_1].center_line\n        tim2_center_crv = self.used_list[tim_preexist_num_2].center_line\n        tim3_center_crv = self.used_list[tim_add_num].center_line\n\n        # bridge可能か判断　その１\n        distance = used_timber1.tim_distance[used_timber2.id][0]\n        if distance + 100 > unused_timber.timber_length:\n            return False\n\n        # Get each crv domain\n        domain_crv1 = tim1_center_crv.Domain\n        domain_crv2 = tim2_center_crv.Domain\n        domain_crv3 = tim3_center_crv.Domain\n        split_range = (domain_crv3[1] - domain_crv3[0]) / split_\n\n        # 指定したdomain内にある点を算出する。\n        domain_range1 = abs((domain_crv1[1] - domain_crv1[0]) / split_domain_range_num)\n        domain_range2 = abs((domain_crv2[1] - domain_crv2[0]) / split_domain_range_num)\n        domain_range3 = abs((domain_crv3[1] - domain_crv3[0]) / split_domain_range_num)\n\n        for i in range(10):\n            select_domain_3_start = 0  # TODO 今のところ固定値\n            for select_domain_loop in range(200):\n                select_domain_1 = used_timber1.select_surface_domain()  # select_domain はドメインの値をintで返される。\n                select_domain_2 = used_timber2.select_surface_domain()\n\n                # TODO　ドメインの指定に関しては範囲内をランダムにする、中心線を単純にするなどによって精度を向上させること可能。\n                tim1_point = tim1_center_crv.PointAt(domain_crv1[0] + domain_range1 * select_domain_1)\n                tim2_point = tim2_center_crv.PointAt(domain_crv2[0] + domain_range2 * select_domain_2)\n\n                # tim1, tim2間の点と点の長さを取得する\n                distance_between = (tim1_point - tim2_point).Length\n\n                # bridge可能か判断　その２\n                length_tim3 = tim3_center_crv.GetLength() - tim3_center_crv.GetLength() / split_domain_range_num * 2\n                if distance_between > length_tim3 - (length_tim3/10)* 4:\n                    if select_domain_loop == 199:\n                        return False\n\n                    else:\n                        continue\n                else:\n                    break\n            # distance_betweenの距離よりもlength_tim3のほうが長かったとしても、EvaluateCurveで選択される点次第で長さが足りなくなることも十分に考えられるだろう。\n            # t = domain_crv3[0] + split_range*20\n            t = domain_crv3[0] + domain_range3 * select_domain_3_start\n            tim3_start_point_coordinate = tim3_center_crv.PointAt(t)\n\n            # distance_between と同じ長さとなるcrv3上のパラメータを取得。　点を加える。\n            t_ = domain_crv3[0]\n            flag_select = True\n            avoid_ = 0\n            while flag_select:\n                avoid_ = avoid_ + 1\n                t_ = t_ + split_range * 5  # ここを調整することでスピードを上げることができるはず。\n                tim3_end_point_coordinate = tim3_center_crv.PointAt(t_)\n                distance = (tim3_end_point_coordinate - tim3_start_point_coordinate).Length\n                if distance > distance_between:\n                    break\n                if avoid_ > 100:\n                    input(\"infinite loop: select_domain_3_end\")\n\n            # ObjectのMove\n            vec_move = tim1_point - tim3_start_point_coordinate\n            xf = Rhino.Geometry.Transform.Translation(vec_move)\n            tim3_center_crv.Transform(xf)\n            tim3_srf.Transform(xf)\n\n            # 再計測\n            tim3_end_point = tim3_center_crv.PointAt(t_)\n\n            # 1回目のRotate\n            vec1 = tim1_point - tim3_end_point\n            vec2 = tim1_point - tim2_point\n            rotate_angle1 = oriRhino.VectorAngle_RhinoCommon(vec1, vec2)\n            plane1 = Rhino.Geometry.Plane(tim1_point, tim3_end_point, tim2_point)\n            xf = Rhino.Geometry.Transform.Rotation(rotate_angle1, plane1[3], tim1_point)\n            tim3_center_crv.Transform(xf)\n            tim3_srf.Transform(xf)\n\n            # 再計測\n            tim3_end_point = tim3_center_crv.PointAt(t_)\n\n            # 2回目のRotate\n            vec3 = tim3_end_point - tim1_point\n            vec4 = tim2_point - tim1_point\n            rotate_angle2 = oriRhino.VectorAngle_RhinoCommon(vec3, vec4)\n            plane2 = Rhino.Geometry.Plane(tim1_point, tim3_end_point, tim2_point)\n\n            if int(tim3_end_point[0]) - 10 <= int(tim2_point[0]) <= int(tim3_end_point[0]) + 10 or \\\n                    int(tim3_end_point[1]) - 10 <= int(tim2_point[1]) <= int(tim3_end_point[1] + 10 or \\\n                                                                             int(tim3_end_point[2]) - 10 <= int(\n                tim2_point[2]) <= int(tim3_end_point[2])) + 10:  # TODO 範囲の式に書き換える。\n                pass\n            else:\n                xf = Rhino.Geometry.Transform.Rotation(rotate_angle2, plane2[3], tim1_point)\n                tim3_center_crv.Transform(xf)\n                tim3_srf.Transform(xf)\n\n            # 再計測\n            tim3_end_point = tim3_center_crv.PointAt(t_)\n            tim3_start_point = tim3_center_crv.PointAt(t)\n\n            # tim1とtim2のtim3にたいする外積をそれぞれ求める。\n            vec_tim3 = tim3_end_point - tim3_start_point\n            tim1_end_point = tim1_center_crv.PointAtEnd\n            vec_tim1 = tim1_end_point - tim1_point\n            tim2_end_point = tim2_center_crv.PointAtEnd\n            vec_tim2 = tim2_end_point - tim2_point\n\n            cross_vec1 = Rhino.Geometry.Vector3d.CrossProduct(vec_tim3, vec_tim1)\n            cross_vec2 = Rhino.Geometry.Vector3d.CrossProduct(vec_tim3, vec_tim2)\n\n            # 2つの外積で作成したベクトルを合成し描画する。\n            add_vec = cross_vec1 + cross_vec2\n\n            # 接合部の直径を求めることにより、移動距離を決定する。\n            dis1, rp1 = oriRhino.GetTimberSectionLength_RhinoCommon(tim3_srf, tim3_start_point)\n            dis2, rp2 = oriRhino.GetTimberSectionLength_RhinoCommon(tim3_srf, tim3_end_point)\n\n            # 移動距離を決定。\n            if dis1 >= dis2:\n                rc = Rhino.Geometry.Vector3d(add_vec.X, add_vec.Y, add_vec.Z)\n                rc.Unitize()\n                vec_move = rc * dis2\n                xf = Rhino.Geometry.Transform.Translation(vec_move)\n                tim3_srf.Transform(xf)\n                tim3_center_crv.Transform(xf)\n\n            else:\n                rc = Rhino.Geometry.Vector3d(add_vec.X, add_vec.Y, add_vec.Z)\n                rc.Unitize()\n                vec_move = rc * dis1\n                xf = Rhino.Geometry.Transform.Translation(vec_move)\n                tim3_srf.Transform(xf)\n                tim3_center_crv.Transform(xf)\n\n            # ----------------------------------------------------------------------------------------------------------\n            end_p = tim3_center_crv.PointAtEnd\n            start_p = tim3_center_crv.PointAtStart\n\n            if end_p[2] > gl_distance and start_p[2] > gl_distance:\n                flag_gl_distance = True\n                gl_check = True\n            else:\n                gl_check = False\n\n            # 生成可能範囲に収まっているか判定。\n            counter = 0\n            if (self.generate_range * 2) * loop < start_p[0] < (self.generate_range * 2) * (\n                    loop) + self.generate_range \\\n                    and (self.generate_range * 2) * loop < end_p[0] < (self.generate_range * 2) * (\n                    loop) + self.generate_range:\n                counter += 1\n\n            if -(self.generate_range * 2) * (loop_num + 1) + self.generate_range > start_p[1] > -(self.generate_range * 2) * (loop_num + 1) - (self.generate_range * 2) \\\n                    and -(self.generate_range * 2) * (loop_num + 1) + self.generate_range > end_p[1] > -(self.generate_range * 2) * (loop_num + 1) - (self.generate_range * 2):\n                counter += 1\n\n            if counter == 2:\n                range_check = True\n            else:\n                range_check = False\n\n            # 両条件を満たしていればOK\n            if range_check and gl_check:\n                # print('Bridge_specify Success in {}'.format(i))\n                pass\n            else:\n                # print('GL distance is not satisfied')\n                return False\n\n\n            # contact_judge_flag = False\n            contact_judge_flag = self.contact_judgement_bridge_specify(unused_timber.id, used_timber1.id, used_timber2.id, already_regenerated_list)\n            if contact_judge_flag:\n                return False\n            else:\n                # print('bridge contact judgement is success : {}'.format(i))\n                break\n\n        # 使用domainの更新のための値\n        select_domain_3_end = abs(int(t_ // domain_range3))\n        # print(\"select_domain_3_end : %s\" % (select_domain_3_end))\n        used_timber1.select_domain_list.append([select_domain_1, unused_timber.id])\n        used_timber2.select_domain_list.append([select_domain_2, unused_timber.id])\n        unused_timber.select_domain_list.append([select_domain_3_start, used_timber1.id])\n        unused_timber.select_domain_list.append([select_domain_3_end, used_timber2.id])\n\n        # partner_timの更新\n        used_timber1.partner_tim.append(unused_timber.id)\n        used_timber2.partner_tim.append(unused_timber.id)\n\n        unused_timber.partner_tim.append(used_timber1.id)\n        unused_timber.partner_tim.append(used_timber2.id)\n        if unused_timber.id == used_timber1.id:\n            raise Exception('partner_tim renewal fail')\n        if unused_timber.id == used_timber2.id:\n            raise Exception('partner_tim renewal fail')\n\n        # 木材同士の最短距離を計算する。\n        for i in range(len(self.used_list)):\n            already_exist_timber = self.used_list[i]\n            already_exist_timber_name = self.used_list[i].id\n            if already_exist_timber_name in already_regenerated_list:\n                timber.distanceBetweenTimber_RhinoCommon(already_exist_timber, unused_timber)\n\n        return True\n\n      \n    def contact_judgement_cantilever(self, judge_tim_id, ignore_tim_id):\n\n        # 接触判定に使用する部材のsrf情報をリスト内に格納する。\n        # deepcopyを使用するかどうかは挙動を見てから決定する。\n        list_judge_srf = []\n        for i in range(len(self.used_list)):\n            if self.used_list[i].id != ignore_tim_id:\n                # judge_srf = copy.deepcopy(self.used_list[i].surface)\n                judge_srf = self.used_list[i].surface\n                list_judge_srf.append(judge_srf)\n            else:\n                continue\n\n        # print('list_judge_srf', list_judge_srf)\n\n        # 接触判定に使用する部材のsurfaceを取得しておく。\n        if len(self.timber_list) != 0:\n            for i in range(len(self.timber_list)):\n                if judge_tim_id == self.timber_list[i].id:\n                    srf_judge_tim = self.timber_list[i].surface\n                    break\n        else:\n            for i in range(len(self.used_list)):\n                if judge_tim_id == self.used_list[i].id:\n                    srf_judge_tim = self.used_list[i].surface\n                    break\n\n        segment_num = 20\n\n        # surfaceを用いた接触判定をおこなう。\n        # intersection_flag = False\n        for i in range(len(list_judge_srf)):\n            srf = list_judge_srf[i]\n            tim1_segment_points, tim1_diameter = calculate_srf_segment_points(srf, segment_num)\n\n            tim2_segment_points, tim2_diameter = calculate_srf_segment_points(srf_judge_tim, segment_num)\n\n            tim1_index, tim2_index = calculate_connect_part_indices(tim1_segment_points, tim2_segment_points,\n                                                                    segment_num)\n\n            tim1_min_p = tim1_segment_points[tim1_index]\n            tim2_min_p = tim2_segment_points[tim2_index]\n            vec = tim1_min_p - tim2_min_p\n            length = vec.Length\n\n            judge_value = (tim1_diameter[tim1_index] / 2) + (tim2_diameter[tim2_index] / 2)\n\n            # 接触していたらTrueしていなかったらFalse\n            if length <= judge_value:\n                intersection_flag = True\n            else:\n                intersection_flag = False\n\n            if intersection_flag:\n                break\n\n        if intersection_flag:\n            return True\n        else:\n            return False\n\n    def contact_judgement_cantilever_specify(self, judge_tim_id, ignore_tim_id, already_regenerate):\n\n        # 接触判定に使用する部材のsrf情報をリスト内に格納する。\n        # deepcopyを使用するかどうかは挙動を見てから決定する。\n        list_judge_srf = []\n        for i in range(len(already_regenerate)):\n            if already_regenerate[i] != ignore_tim_id:\n                tim_id = already_regenerate[i]\n                for j in range(len(self.used_list)):\n                    if tim_id == self.used_list[j].id:\n                        # judge_srf = copy.deepcopy(self.used_list[j].surface)\n                        judge_srf = self.used_list[j].surface\n                        list_judge_srf.append(judge_srf)\n                        break\n                    else:\n                        continue\n\n        # print('list_judge_srf', list_judge_srf)\n\n        # 接触判定に使用する部材のsurfaceを取得しておく。\n        if len(self.timber_list) != 0:\n            for i in range(len(self.timber_list)):\n                if judge_tim_id == self.timber_list[i].id:\n                    srf_judge_tim = self.timber_list[i].surface\n                    break\n        else:\n            for i in range(len(self.used_list)):\n                if judge_tim_id == self.used_list[i].id:\n                    srf_judge_tim = self.used_list[i].surface\n                    break\n\n        segment_num = 20\n\n        # surfaceを用いた接触判定をおこなう。\n        # intersection_flag = False\n        for i in range(len(list_judge_srf)):\n            srf = list_judge_srf[i]\n            tim1_segment_points, tim1_diameter = calculate_srf_segment_points(srf, segment_num)\n\n            tim2_segment_points, tim2_diameter = calculate_srf_segment_points(srf_judge_tim, segment_num)\n\n            tim1_index, tim2_index = calculate_connect_part_indices(tim1_segment_points, tim2_segment_points,\n                                                                    segment_num)\n\n            tim1_min_p = tim1_segment_points[tim1_index]\n            tim2_min_p = tim2_segment_points[tim2_index]\n            vec = tim1_min_p - tim2_min_p\n            length = vec.Length\n\n            judge_value = (tim1_diameter[tim1_index] / 2) + (tim2_diameter[tim2_index] / 2)\n\n            # 接触していたらTrueしていなかったらFalse\n            if length <= judge_value:\n                intersection_flag = True\n            else:\n                intersection_flag = False\n\n            if intersection_flag:\n                break\n\n        if intersection_flag:\n            return True\n        else:\n            return False\n\n    def contact_judgement_bridge(self, judge_tim_id, ignore_tim_id1, ignore_tim_id2):\n\n        # 接触判定に使用する部材のsrf情報をリスト内に格納する。\n        # deepcopyを使用するかどうかは挙動を見てから決定する。\n        list_judge_srf = []\n        for i in range(len(self.used_list)):\n            if self.used_list[i].id != ignore_tim_id1 or self.used_list[i].id != ignore_tim_id2:\n                # judge_srf = copy.deepcopy(self.used_list[i].surface)\n                judge_srf = self.used_list[i].surface\n                list_judge_srf.append(judge_srf)\n            else:\n                continue\n\n        # print('list_judge_srf', list_judge_srf)\n\n        # 接触判定に使用する部材のsurfaceを取得しておく。\n        if len(self.timber_list) != 0:\n            for i in range(len(self.timber_list)):\n                if judge_tim_id == self.timber_list[i].id:\n                    srf_judge_tim = self.timber_list[i].surface\n                    break\n        else:\n            for i in range(len(self.used_list)):\n                if judge_tim_id == self.used_list[i].id:\n                    srf_judge_tim = self.used_list[i].surface\n                    break\n\n        segment_num = 20\n\n        # surfaceを用いた接触判定をおこなう。\n        # intersection_flag = False\n        for i in range(len(list_judge_srf)):\n            srf = list_judge_srf[i]\n            tim1_segment_points, tim1_diameter = calculate_srf_segment_points(srf, segment_num)\n\n            tim2_segment_points, tim2_diameter = calculate_srf_segment_points(srf_judge_tim, segment_num)\n\n            tim1_index, tim2_index = calculate_connect_part_indices(tim1_segment_points, tim2_segment_points,\n                                                                    segment_num)\n\n            tim1_min_p = tim1_segment_points[tim1_index]\n            tim2_min_p = tim2_segment_points[tim2_index]\n            vec = tim1_min_p - tim2_min_p\n            length = vec.Length\n\n            judge_value = (tim1_diameter[tim1_index] / 2) + (tim2_diameter[tim2_index] / 2)\n\n            # 接触していたらTrueしていなかったらFalse\n            if length <= judge_value:\n                intersection_flag = True\n            else:\n                intersection_flag = False\n\n            if intersection_flag:\n                break\n\n        if intersection_flag:\n            return True\n        else:\n            return False\n\n    def contact_judgement_bridge_specify(self, judge_tim_id, ignore_tim_id1, ignore_tim_id2, already_regenerate):\n\n        # 接触判定に使用する部材のsrf情報をリスト内に格納する。\n        # deepcopyを使用するかどうかは挙動を見てから決定する。\n        list_judge_srf = []\n        for i in range(len(already_regenerate)):\n            if not already_regenerate[i] == ignore_tim_id1 and not already_regenerate[i] == ignore_tim_id2:\n                tim_id = already_regenerate[i]\n                # print('tim_id', tim_id)\n                for j in range(len(self.used_list)):\n                    if tim_id == self.used_list[j].id:\n                        # judge_srf = copy.deepcopy(self.used_list[j].surface)\n                        judge_srf = self.used_list[j].surface\n                        list_judge_srf.append(judge_srf)\n                        break\n                    else:\n                        continue\n\n        # print('list_judge_srf', list_judge_srf)\n\n        # 接触判定に使用する部材のsurfaceを取得しておく。\n        if len(self.timber_list) != 0:\n            for i in range(len(self.timber_list)):\n                if judge_tim_id == self.timber_list[i].id:\n                    srf_judge_tim = self.timber_list[i].surface\n                    break\n        else:\n            for i in range(len(self.used_list)):\n                if judge_tim_id == self.used_list[i].id:\n                    srf_judge_tim = self.used_list[i].surface\n                    break\n\n        segment_num = 20\n\n        # surfaceを用いた接触判定をおこなう。\n        # intersection_flag = False\n        for i in range(len(list_judge_srf)):\n            srf = list_judge_srf[i]\n            tim1_segment_points, tim1_diameter = calculate_srf_segment_points(srf, segment_num)\n\n            tim2_segment_points, tim2_diameter = calculate_srf_segment_points(srf_judge_tim, segment_num)\n\n            tim1_index, tim2_index = calculate_connect_part_indices(tim1_segment_points, tim2_segment_points,\n                                                                    segment_num)\n\n            tim1_min_p = tim1_segment_points[tim1_index]\n            tim2_min_p = tim2_segment_points[tim2_index]\n            vec = tim1_min_p - tim2_min_p\n            length = vec.Length\n\n            judge_value = (tim1_diameter[tim1_index] / 2) + (tim2_diameter[tim2_index] / 2)\n\n            # 接触していたらTrueしていなかったらFalse\n            if length <= judge_value:\n                intersection_flag = True\n            else:\n                intersection_flag = False\n\n            if intersection_flag:\n                break\n\n        if intersection_flag:\n            return True\n        else:\n            return False\n\n\ndef calculate_srf_segment_points(srf, segment_num):\n    srf_domain_u = srf.Faces[0].Domain(0)\n    srf_domain_v = srf.Faces[0].Domain(1)\n\n    srf_domain_u_segment = (srf_domain_u[1] - srf_domain_u[0]) / segment_num\n    srf_domain_v_segment = (srf_domain_v[1] - srf_domain_v[0]) / 10\n\n    segment_points_list = []\n    diameter_list = []\n    for i in range(segment_num + 1):\n        p1_u = srf_domain_u[0] + (srf_domain_u_segment * i)\n        p1_v = srf_domain_v[0] + (srf_domain_v_segment * 0)\n\n        p2_u = srf_domain_u[0] + (srf_domain_u_segment * i)\n        p2_v = srf_domain_v[0] + (srf_domain_v_segment * 5)\n\n        srf_point1 = srf.Faces[0].PointAt(p1_u, p1_v)\n        srf_point2 = srf.Faces[0].PointAt(p2_u, p2_v)\n\n        line = Rhino.Geometry.Line(srf_point2, srf_point1)\n        diameter = line.Length\n\n        center_p = line.PointAt(0.5)\n        segment_points_list.append(center_p)\n        diameter_list.append(diameter)\n\n    return segment_points_list, diameter_list\n\n\ndef calculate_connect_part_indices(tim1_segment_points, tim2_segment_points, segment_num):\n    between_length_list = []\n    for i in range(len(tim1_segment_points)):\n        tim1_p = tim1_segment_points[i]\n        for j in range(len(tim2_segment_points)):\n            tim2_p = tim2_segment_points[j]\n\n            between_vec = tim2_p - tim1_p\n            length = between_vec.Length\n            between_length_list.append(length)\n\n    length_min = min(between_length_list)\n    index = between_length_list.index(length_min)\n\n    tim1_index = index // (segment_num + 1)\n    tim2_index = index % (segment_num + 1)\n\n    return tim1_index, tim2_index\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "scriptcontext"
  ],
  "has_docstring": false
}