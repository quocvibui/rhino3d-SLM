{
  "source_url": "https://github.com/969flash/LausLecture/blob/004c0a8938bf805b8d70c744ddf5eb911fd4277f/Lecture2/02_find_flaglot_parcels.py",
  "repo": "969flash/LausLecture",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "Lecture2/02_find_flaglot_parcels.py",
  "instruction": "02 find flaglot parcels",
  "code": "# r: pyshp\n\nimport Rhino.Geometry as geo\nimport shapefile\nimport os\nfrom typing import List, Tuple, Any, Optional\nimport ghpythonlib.components as ghcomp\nimport utils\nfrom utils import Lot, Road, Parcel\nimport importlib\n\nimportlib.reload(utils)\n\n\n\n\n# ================ 도로 접근성 검사 함수 ================\n\n\ndef check_bounding_boxes_intersect(\n    bbox1: geo.BoundingBox, bbox2: geo.BoundingBox\n) -> bool:\n    \"\"\"두 바운딩박스가 교차하는지 확인\"\"\"\n    return not (\n        bbox1.Max.X < bbox2.Min.X\n        or bbox1.Min.X > bbox2.Max.X\n        or bbox1.Max.Y < bbox2.Min.Y\n        or bbox1.Min.Y > bbox2.Max.Y\n    )\n\n\ndef check_curve_proximity(\n    curve1: geo.Curve, curve2: geo.Curve, tolerance: float = 0.5\n) -> bool:\n    \"\"\"두 커브가 tolerance 거리 이내에 있는지 확인\"\"\"\n    # 바운딩박스 사전 체크\n    bbox1 = curve1.GetBoundingBox(False)\n    bbox2 = curve2.GetBoundingBox(False)\n    bbox1.Inflate(tolerance)\n    bbox2.Inflate(tolerance)\n\n    if not check_bounding_boxes_intersect(bbox1, bbox2):\n        return False\n\n    # 교차점 확인\n    events = geo.Intersect.Intersection.CurveCurve(curve1, curve2, tolerance, tolerance)\n    if events and events.Count > 0:\n        return True\n\n    # 끝점 간 거리 확인\n    start1 = curve1.PointAtStart\n    end1 = curve1.PointAtEnd\n    start2 = curve2.PointAtStart\n    end2 = curve2.PointAtEnd\n\n    if (\n        start1.DistanceTo(start2) <= tolerance\n        or start1.DistanceTo(end2) <= tolerance\n        or end1.DistanceTo(start2) <= tolerance\n        or end1.DistanceTo(end2) <= tolerance\n    ):\n        return True\n\n    # 커브 위의 가장 가까운 점 찾기\n    t1 = curve1.ClosestPoint(start2)[1] if curve1.ClosestPoint(start2)[0] else -1\n    if t1 >= 0 and curve1.PointAt(t1).DistanceTo(start2) <= tolerance:\n        return True\n\n    t2 = curve2.ClosestPoint(start1)[1] if curve2.ClosestPoint(start1)[0] else -1\n    if t2 >= 0 and curve2.PointAt(t2).DistanceTo(start1) <= tolerance:\n        return True\n\n    return False\n\n\ndef create_road_bounding_boxes(\n    road_curves: List[geo.Curve], tolerance: float = 0.5\n) -> List[geo.BoundingBox]:\n    \"\"\"모든 도로 커브의 바운딩박스를 생성하고 tolerance만큼 확장\"\"\"\n    road_bboxes = []\n    for road_curve in road_curves:\n        bbox = road_curve.GetBoundingBox(False)\n        bbox.Inflate(tolerance)\n        road_bboxes.append(bbox)\n    return road_bboxes\n\n\ndef check_lot_road_access(\n    lot: utils.Lot,\n    road_curves: List[geo.Curve],\n    road_bboxes: List[geo.BoundingBox],\n    tolerance: float = 0.5,\n) -> bool:\n    \"\"\"토지가 도로에 접근 가능한지 확인\"\"\"\n    lot_bbox = lot.region.GetBoundingBox(False)\n    lot_bbox.Inflate(tolerance)\n\n    # 바운딩박스로 1차 필터링\n    for idx in range(len(road_curves)):\n        if check_bounding_boxes_intersect(lot_bbox, road_bboxes[idx]):\n            if check_curve_proximity(lot.region, road_curves[idx], tolerance):\n                return True\n\n    return False\n\n\ndef get_all_road_curves(roads: List[utils.Road]) -> List[geo.Curve]:\n    \"\"\"도로의 모든 커브(외부 경계 + 내부 구멍)를 추출\"\"\"\n    curves = []\n    for road in roads:\n        curves.append(road.region)\n        curves.extend(road.hole_regions)\n    return curves\n\n\n# ================ 오프셋 관련 함수 ================\n\n\ndef perform_clipper_offset(\n    curve_crv: geo.Curve, distance: float, get_holes: bool = True\n) -> List[geo.Curve]:\n    \"\"\"Clipper를 사용한 오프셋 수행\"\"\"\n    plane = geo.Plane.WorldXY\n    tolerance = 0.1\n\n    try:\n        result = ghcomp.ClipperComponents.PolylineOffset(\n            curve_crv,\n            distance,\n            plane,\n            tolerance,\n            2,  # closed_fillet: 2 = miter\n            2,  # open_fillet: 2 = butt\n            1,  # miter limit\n        )\n\n        if not result:\n            return []\n\n        # holes (내부 오프셋) 또는 contour (외부 오프셋) 반환\n        output = result.holes if get_holes else result.contour\n\n        if not output:\n            return []\n\n        # 리스트로 변환\n        if hasattr(output, \"__iter__\"):\n            return list(output)\n        return [output]\n\n    except:\n        return []\n\n\ndef is_curve_flag_shaped(\n    curve_crv: geo.Curve,\n    road_curves: List[geo.Curve],\n    road_bboxes: List[geo.BoundingBox],\n    offset_distance: float,\n) -> bool:\n    \"\"\"커브가 자루형인지 판별\n\n    1. 안쪽으로 오프셋\n    2. 다시 바깥쪽으로 오프셋 (복원)\n    3. 복원된 형태가 도로와 접하지 않으면 자루형\n    \"\"\"\n    # 1단계: 안쪽으로 오프셋\n    inner_curves = perform_clipper_offset(curve_crv, offset_distance, get_holes=True)\n\n    if not inner_curves:\n        return False\n\n    # 2단계: 각 내부 커브를 다시 바깥으로 오프셋하여 검사\n    for inner_curve in inner_curves:\n        # 바깥쪽으로 오프셋 (복원)\n        restored_curves = perform_clipper_offset(\n            inner_curve, offset_distance, get_holes=False\n        )\n\n        if not restored_curves:\n            continue\n\n        # 복원된 커브가 도로와 접하는지 확인\n        for restored_curve in restored_curves:\n            restored_bbox = restored_curve.GetBoundingBox(False)\n            restored_bbox.Inflate(0.5)\n\n            # 빠른 바운딩박스 검사\n            for i, road_bbox in enumerate(road_bboxes):\n                if check_bounding_boxes_intersect(restored_bbox, road_bbox):\n                    if check_curve_proximity(restored_curve, road_curves[i], 0.5):\n                        # 하나라도 도로와 접하면 자루형이 아님\n                        return False\n\n    # 모든 복원된 커브가 도로와 접하지 않으면 자루형\n    return True\n\n\n# ================ 자루형 토지 찾기 메인 함수 ================\n\n\ndef find_flag_lots(\n    lots: List[utils.Lot], roads: List[utils.Road], offset_distance: float = 4.0\n) -> List[utils.Lot]:\n    \"\"\"자루형 토지를 찾아서 반환\n\n    자루형 토지: 도로에 접하지만 좁은 통로로만 연결되어 있어\n    offset_distance만큼 안쪽으로 오프셋하면 도로 접근이 사라지는 토지\n    \"\"\"\n    # 준비 작업\n    road_curves = get_all_road_curves(roads)\n    road_bboxes = create_road_bounding_boxes(road_curves)\n\n    # 1단계: 도로에 접한 토지만 필터링\n    accessible_lots = []\n    for lot in lots:\n        if check_lot_road_access(lot, road_curves, road_bboxes):\n            lot.has_road_access = True\n            accessible_lots.append(lot)\n\n    # 2단계: 자루형 토지 판별\n    flag_lots = []\n    for lot in accessible_lots:\n        if is_curve_flag_shaped(lot.region, road_curves, road_bboxes, offset_distance):\n            lot.is_flag_lot = True\n            flag_lots.append(lot)\n\n    return flag_lots\n\n\nif __name__ == \"__main__\":\n    # 파일 경로 설정\n    shp_path = os.path.join(os.path.dirname(__file__), \"AL_D194_11680_20250123.shp\")\n\n    # SHP 파일 읽기\n    shapes, records, fields = utils.read_shp_file(shp_path)\n\n    # Parcel 객체 생성\n    parcels = utils.get_parcels_from_shapes(shapes, records, fields)\n\n    # 필지 분류\n    lots, roads = utils.classify_parcels(parcels)\n    print(f\"대지: {len(lots)}개, 도로: {len(roads)}개\")\n\n    # 자루형 토지 찾기\n    flag_lots = find_flag_lots(lots, roads, offset_distance=4.0)\n\n    # 결과 출력\n    print(f\"\\n전체 대지: {len(lots)}개\")\n    print(f\"자루형 토지: {len(flag_lots)}개\")\n\n    if lots:\n        print(f\"자루형 토지 비율: {len(flag_lots)/len(lots)*100:.1f}%\")\n\n    # 커브만 추출\n    all_lot_crvs = [lot.region for lot in lots]\n    road_crvs = [road.region for road in roads]\n    flag_lot_crvs = [lot.region for lot in flag_lots]\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}