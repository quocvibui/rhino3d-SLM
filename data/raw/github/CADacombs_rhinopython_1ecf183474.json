{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Brep_rebuildEdges.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Brep_rebuildEdges.py",
  "instruction": "Spb brep rebuild edges",
  "code": "\"\"\"\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n160713-14: Created.\r\n...\r\n200204-05: Added bRebuildOnlyOutOfTol and routines to more selectively rebuild edges.\r\n200213: Bug fix.\r\n200507: Improved handling of breps with edges with error in value of Tolerance.\r\n200625: Disabled use of Brep.Standardize due to problems with short edges.\r\n201211: Added check to maximum allowed tolerance before increasing working tolerance.\r\n210122: Bug fix: A variable was not set before use.\r\n210426: Added fSearchTol.\r\n210630: Modified an option default value.  Added fRebuildSharedTol.\r\n250224: Disabled Standardize and Compact. Modified an option default value.\r\n250304: Bug fix that was skipping some rebuilt results.\r\n\r\nTODO:\r\n    Investigate problem with brep as demonstrated by use of Brep.Standardize.\r\n    Standardizing Brep sometimes corrects Edge.Tolerance.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    riAddOpts = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    def addOptionDouble(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionDouble(\r\n            getObj, englishName=names[key], numberValue=riOpts[key])\r\n\r\n\r\n    def addOptionInteger(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionInteger(\r\n            getObj, englishName=names[key], intValue=riOpts[key])\r\n\r\n\r\n    def addOptionList(key, names, listValues, values):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionList(\r\n            getObj,\r\n            englishOptionName=names[key],\r\n            listValues=listValues,\r\n            listCurrentIndex=values[key])\r\n\r\n\r\n    def addOptionToggle(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionToggle(\r\n            getObj, englishName=names[key], toggleValue=riOpts[key])\r\n\r\n\r\n    key = 'fRebuildNakedTol'; keys.append(key)\r\n    values[key] = 1.0 * sc.doc.ModelAbsoluteTolerance\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key])\r\n    riAddOpts[key] = addOptionDouble(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bRebuildOnlyOutOfTol'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(initialValue=values[key], offValue='No', onValue='Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fSearchTol'; keys.append(key)\r\n    values[key] = 1.0 * sc.doc.ModelAbsoluteTolerance\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key])\r\n    riAddOpts[key] = addOptionDouble(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bRebuildSharedEdges'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(initialValue=values[key], offValue='No', onValue='Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fRebuildSharedTol'; keys.append(key)\r\n    values[key] = 10.0 * sc.doc.ModelAbsoluteTolerance\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key])\r\n    riAddOpts[key] = addOptionDouble(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bRebuildVertices'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(initialValue=values[key], offValue='No', onValue='Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bReplace'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'Action'\r\n    riOpts[key] = ri.Custom.OptionToggle(initialValue=values[key], offValue='Add', onValue='Replace')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bAddDot'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'iDotHeight'; keys.append(key)\r\n    values[key] = 11\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionInteger(values[key], setLowerLimit=True, limit=3)\r\n    riAddOpts[key] = addOptionInteger(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(initialValue=values[key], offValue='No', onValue='Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = key[1:]\r\n    riOpts[key] = ri.Custom.OptionToggle(initialValue=values[key], offValue='No', onValue='Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def setValues(cls):\r\n        for key in cls.keys:\r\n            if key in cls.riOpts:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n\r\n\r\n    @classmethod\r\n    def saveSticky(cls):\r\n        for key in cls.stickyKeys:\r\n            if key in cls.riOpts:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.riOpts[key].CurrentValue\r\n            else:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef _get_all_normal_breps():\r\n    oes = rd.ObjectEnumeratorSettings()\r\n    oes.LockedObjects = False # Default is True.\r\n    oes.ObjectTypeFilter = rd.ObjectType.Brep\r\n    return list(sc.doc.Objects.GetObjectList(oes))\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get breps and options values.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select breps\")\r\n    go.SetCommandPromptDefault(\"All normal\")\r\n\r\n    go.AcceptNothing(True)\r\n\r\n    go.GeometryFilter = rd.ObjectType.Brep\r\n    #go.GeometryAttributeFilter = ri.Custom.GeometryAttributeFilter.OpenSurface\r\n\r\n    go.AlreadySelectedObjectSelect = True\r\n    go.DeselectAllBeforePostSelect = False\r\n    go.SubObjectSelect = False\r\n\r\n    go.EnableClearObjectsOnEntry(False)\r\n    #go.EnableUnselectObjectsOnExit(False)\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    idxs_Opts = {}\r\n\r\n    print(\"SearchTol is also the rebuild tolerance for shared edges.\")\r\n\r\n    while True:\r\n        key = 'fRebuildNakedTol'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        key = 'bRebuildOnlyOutOfTol'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        if Opts.values['bRebuildOnlyOutOfTol']:\r\n            key = 'fSearchTol'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        key = 'bRebuildSharedEdges'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        if Opts.values['bRebuildSharedEdges']:\r\n            key = 'fRebuildSharedTol'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        key = 'bRebuildVertices'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        key = 'bReplace'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        key = 'bAddDot'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        key = 'iDotHeight'; idxs_Opts[key] = (Opts.riAddOpts[key](go)\r\n                                              if Opts.values['bAddDot']\r\n                                              else None)\r\n        key = 'bEcho'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        key = 'bDebug'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Nothing:\r\n            go.Dispose()\r\n            return _get_all_normal_breps()\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        # An option was selected or a number was entered.\r\n        key = 'fRebuildNakedTol'\r\n        if res == ri.GetResult.Number:\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n        if Opts.riOpts[key].CurrentValue < 0.0:\r\n            Opts.riOpts[key].CurrentValue = Opts.riOpts[key].InitialValue\r\n        elif Opts.riOpts[key].CurrentValue == 0.0:\r\n            Opts.riOpts[key].CurrentValue = Rhino.RhinoMath.ZeroTolerance\r\n\r\n        key = 'fSearchTol'\r\n        if Opts.riOpts[key].CurrentValue < 0.0:\r\n            Opts.riOpts[key].CurrentValue = Opts.riOpts[key].InitialValue\r\n        elif Opts.riOpts[key].CurrentValue == 0.0:\r\n            Opts.riOpts[key].CurrentValue = Rhino.RhinoMath.ZeroTolerance\r\n\r\n        key = 'fRebuildSharedTol'\r\n        if Opts.riOpts[key].CurrentValue < 0.0:\r\n            Opts.riOpts[key].CurrentValue = Opts.riOpts[key].InitialValue\r\n        elif Opts.riOpts[key].CurrentValue == 0.0:\r\n            Opts.riOpts[key].CurrentValue = Rhino.RhinoMath.ZeroTolerance\r\n\r\n        Opts.setValues()\r\n        Opts.saveSticky()\r\n        go.ClearCommandOptions()\r\n\r\n\r\ndef setTolerancesBoxesAndFlags(rgBrep):\r\n    rgBrep.SetTolerancesBoxesAndFlags(\r\n        bLazy=False,\r\n        bSetVertexTolerances=True,\r\n        bSetEdgeTolerances=True,\r\n        bSetTrimTolerances=True,\r\n        bSetTrimIsoFlags=True,\r\n        bSetTrimTypeFlags=True,\r\n        bSetLoopTypeFlags=True,\r\n        bSetTrimBoxes=True)\r\n\r\n\r\ndef _formatDistance(fDistance):\r\n    if fDistance is None:\r\n        return \"(None)\"\r\n    if fDistance == Rhino.RhinoMath.UnsetValue:\r\n        return \"(Infinite)\"\r\n    if fDistance < 10.0**(-(sc.doc.DistanceDisplayPrecision-1)):\r\n        return \"{:.2e}\".format(fDistance)\r\n    return \"{:.{}f}\".format(fDistance, sc.doc.ModelDistanceDisplayPrecision)\r\n\r\n\r\ndef _compute_max_edge_tol_of_face(rgFace, fRebuildNakedTol=None, bRebuildVertices=None, bEcho=True):\r\n    \"\"\"\r\n    Computes by comparing RebuildEdges with smaller tolerance to the current Edge.Tolerances.\r\n    \"\"\"\r\n\r\n    rgB_1F_NotRebuilt = rgFace.DuplicateFace(False)\r\n    rgB_1F_Rebuilt = rgB_1F_NotRebuilt.DuplicateBrep()\r\n\r\n    #fZeroTol = 1e-6 * Rhino.RhinoMath.UnitScale(\r\n    #    Rhino.UnitSystem.Millimeters, sc.doc.ModelUnitSystem)\r\n\r\n    tolerance = min((0.1*fRebuildNakedTol, 1e-5))\r\n\r\n    rgB_1F_Rebuilt.Faces[0].RebuildEdges(\r\n        tolerance=tolerance,\r\n        rebuildSharedEdges=True,\r\n        rebuildVertices=bRebuildVertices)\r\n\r\n    deviations = []\r\n\r\n    tolerance = min((0.01*fRebuildNakedTol, 1e-6))\r\n\r\n    for iE in rgB_1F_NotRebuilt.Faces[0].AdjacentEdges():\r\n        rc = rg.Curve.GetDistancesBetweenCurves(\r\n            rgB_1F_NotRebuilt.Edges[iE],\r\n            rgB_1F_Rebuilt.Edges[iE],\r\n            tolerance=tolerance)\r\n        if not rc[0]:\r\n            s = \"An EdgeCurve deviation could not be obtained.\"\r\n            if bEcho: print(s)\r\n            return\r\n        else:\r\n            deviations.append(rc[1])\r\n\r\n    rgB_1F_NotRebuilt.Dispose()\r\n    rgB_1F_Rebuilt.Dispose()\r\n\r\n    return max(deviations)\r\n\r\n\r\ndef _facesWithEdgesOutOfTol(rgBrep, fEdgeDevs_perFace, fSearchTol=None):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    idx_Fs_WithOutOfTolEs = [] # Core faces to be rebuilt.\r\n    for iF, fEdgeTol in enumerate(fEdgeDevs_perFace):\r\n        if fEdgeTol is None or fEdgeTol > fSearchTol:\r\n            idx_Fs_WithOutOfTolEs.append(iF)\r\n\r\n    idx_Fs_Adj = []\r\n    for iF in idx_Fs_WithOutOfTolEs:\r\n        idx_Fs_Adj.extend(rgBrep.Faces[iF].AdjacentFaces())\r\n    idx_Fs_Adj = sorted(set(idx_Fs_Adj))\r\n\r\n    return sorted(set(idx_Fs_WithOutOfTolEs + idx_Fs_Adj))\r\n\r\n\r\ndef _faceEdgesControlPointCounts(rgFace, bDebug=None):\r\n    \"\"\"\r\n    Returns: List of control point counts of each edge of face.\r\n    \"\"\"\r\n    \r\n    if bDebug is None: bDebug=Opts.values['bDebug']\r\n    \r\n    rgBrep = rgFace.Loops[0].Brep\r\n    \r\n    iCt_Cp_Face_PreRebuild = []\r\n    for i, iE in enumerate(rgFace.AdjacentEdges()):\r\n        rgEdge = rgBrep.Edges[iE]\r\n        #dotCurveMidpoint(rgEdge, str(i))\r\n        rgNurbsCrv = rgEdge.ToNurbsCurve()\r\n        if rgNurbsCrv is None:\r\n            if bDebug: sEval = 'rgNurbsCrv'; print(sEval+':', eval(sEval))\r\n            continue\r\n        numPts = rgNurbsCrv.Points.Count\r\n        rgNurbsCrv.Dispose()\r\n        iCt_Cp_Face_PreRebuild.append(numPts)\r\n    return iCt_Cp_Face_PreRebuild\r\n\r\n\r\ndef _dotCurveMidpoint(rgCrv, text='', rgb=(255, 255, 255)):\r\n    pt = rgCrv.PointAtNormalizedLength(0.5)\r\n    if pt.X == Rhino.RhinoMath.UnsetValue:\r\n        pt = rgCrv.PointAtStart\r\n    rs.ObjectColor(rs.AddTextDot(text, pt), rgb)\r\n\r\n\r\ndef _get_curve_type_counts(rgBrep):\r\n    nACs = nLCs = nNCs = nPCs = nPLCs = 0\r\n\r\n    for e in rgBrep.Edges:\r\n        c = e.EdgeCurve\r\n        if isinstance(c, rg.ArcCurve):\r\n            nACs += 1\r\n        elif isinstance(c, rg.LineCurve):\r\n            nLCs += 1\r\n        elif isinstance(c, rg.NurbsCurve):\r\n            nNCs += 1\r\n        elif isinstance(c, rg.PolyCurve):\r\n            nPCs += 1\r\n        elif isinstance(c, rg.PolylineCurve):\r\n            nPLCs += 1\r\n        else:\r\n            raise Exception(\"{} is not valid.\".format(c.GetType()))\r\n\r\n        return nACs, nLCs, nNCs, nPCs, nPLCs\r\n\r\n\r\ndef _are_there_any_changes_in_curve_type_counts(rgBrep_A, rgBrep_B):\r\n    rvs_A = _get_curve_type_counts(rgBrep_A)\r\n    rvs_B = _get_curve_type_counts(rgBrep_B)\r\n    for a, b in zip(rvs_A, rvs_B):\r\n        if a != b:\r\n            return True\r\n    return False\r\n\r\n\r\ndef _get_CP_count(rgBrep):\r\n    \"\"\"\r\n    Only CP counts of EdgeCurves that are already NurbsCurves, not translation to NurbsCurves.\r\n    \"\"\"\r\n    nPts = 0\r\n    for edge in rgBrep.Edges:\r\n        ec = edge.EdgeCurve\r\n        if isinstance(ec, rg.NurbsCurve):\r\n            nPts += ec.Points.Count\r\n    return nPts\r\n\r\n\r\ndef _get_rebuilt_devs_of_brep_edge_curves(rgB_In, rgB_Out, fRebuildNakedTol):\r\n    #fZeroTol = 1e-6 * Rhino.RhinoMath.UnitScale(\r\n    #    Rhino.UnitSystem.Millimeters, sc.doc.ModelUnitSystem)\r\n\r\n    tolerance = min((fRebuildNakedTol, 1e-5))\r\n\r\n    fDevs = []\r\n\r\n    for iE in xrange(rgB_In.Edges.Count):\r\n        curveA = rgB_In.Edges[iE].EdgeCurve\r\n        curveB = rgB_Out.Edges[iE].EdgeCurve\r\n        rvs = rg.Curve.GetDistancesBetweenCurves(curveA, curveB, tolerance=0.1*fRebuildNakedTol)\r\n        (\r\n            bSuccess,\r\n            maxDistance,\r\n            maxDistanceParameterA,\r\n            maxDistanceParameterB,\r\n            minDistance,\r\n            minDistanceParameterA,\r\n            minDistanceParameterB,\r\n            ) = rvs\r\n\r\n        if not bSuccess:\r\n            return\r\n\r\n        fDevs.append(maxDistance)\r\n\r\n        continue\r\n\r\n\r\n        # TODO: Decide whether to implement some double check or replacement of GetDistancesBetweenCurves.\r\n    #    ptA_FromGDBC = curveA.PointAt(maxDistanceParameterA)\r\n    #    ptB_FromGDBC = curveB.PointAt(maxDistanceParameterB)\r\n    #    rc = curveA.ClosestPoint(ptB_FromGDBC)\r\n    #    if rc[0]:\r\n    #        ptA_ClosestToOnB = curveA.PointAt(maxDistance)\r\n    #    rc = curveB.ClosestPoint(ptA_FromGDBC)\r\n    #    if rc[0]:\r\n    #        ptB_ClosestToOnA = curveB.PointAt(maxDistance)\r\n    #    if (\r\n    #        ptA_FromGDBC.DistanceTo(ptB_ClosestToOnA) > tolerance\r\n    #        or\r\n    #        ptB_FromGDBC.DistanceTo(ptA_ClosestToOnB) > tolerance\r\n    #    ):\r\n    #        if maxDistance < 0.001:\r\n    #            s += \"  But EdgeCurve deviation of {:.2e} found.\".format(maxDistance)\r\n    #        else:\r\n    #            s += \"  But EdgeCurve deviation of {:.4f} found.\".format(maxDistance)\r\n    #        if bEcho: print(s)\r\n    #        break\r\n    #    if bDebug: print(\"Bad maxDistance from GetDistancesBetweenCurves.\")\r\n    #else:\r\n    #    if None not in fEdgeDevs_perFace:\r\n    #        rgB_Out.Dispose()\r\n    #        return None, s + \" All curve deviations are within {}.\".format(tolerance)\r\n\r\n\r\n    return fDevs\r\n\r\n\r\ndef processBrep(rgBrep, fRebuildNakedTol=None, bRebuildOnlyOutOfTol=True, fSearchTol=None, bRebuildSharedEdges=False, fRebuildSharedTol=None, bRebuildVertices=None, bAddDot=False, iDotHeight=None, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        rgBrep\r\n        fRebuildNakedTol\r\n        bRebuildOnlyOutOfTol\r\n        fSearchTol\r\n        bRebuildSharedEdges\r\n        bRebuildVertices\r\n        bAddDot\r\n        iDotHeight\r\n        bEcho\r\n        bDebug\r\n\r\n    Returns:\r\n        rgBrep, None\r\n        or\r\n        None, str(Explanation of why there is no returned brep)\r\n    \"\"\"\r\n\r\n    if not rgBrep.IsValid:\r\n        return None, \"Invalid brep skipped.\"\r\n\r\n    rgB_In = rgBrep\r\n\r\n    if bRebuildOnlyOutOfTol and (fSearchTol is None):\r\n        fSearchTol = fRebuildNakedTol\r\n\r\n    fEdgeTols_In = [rgE.Tolerance for rgE in rgB_In.Edges]\r\n    if bDebug: sEval = \"max(fEdgeTols_In)\"; print(sEval,'=',eval(sEval))\r\n\r\n    rgB_Out = rgB_In.DuplicateBrep()\r\n\r\n    rgB_Out.Standardize() # See SDK for best documentation for Standardize.\r\n    if bDebug:\r\n        fEdgeTols_after_Standardize = [rgE.Tolerance for rgE in rgB_In.Edges]\r\n        sEval = \"max(fEdgeTols_after_Standardize)\"; print(sEval,'=',eval(sEval))\r\n\r\n    rgB_Out.Compact()\r\n    if bDebug:\r\n        fEdgeTols_after_Compact = [rgE.Tolerance for rgE in rgB_In.Edges]\r\n        sEval = \"max(fEdgeTols_after_Compact)\"; print(sEval,'=',eval(sEval))\r\n\r\n    setTolerancesBoxesAndFlags(rgB_Out)\r\n\r\n    fEdgeTols_after_SetTolBoxesAndFlags = [rgE.Tolerance for rgE in rgB_Out.Edges]\r\n    if bDebug: sEval = \"max(fEdgeTols_after_SetTolBoxesAndFlags)\"; print(sEval,'=',eval(sEval))\r\n\r\n    maxDiscrepancyOfReportedTol = abs(\r\n        max(fEdgeTols_In) -\r\n        max(fEdgeTols_after_SetTolBoxesAndFlags))\r\n\r\n    fZeroTol = 1e-6 * Rhino.RhinoMath.UnitScale(\r\n        Rhino.UnitSystem.Millimeters, sc.doc.ModelUnitSystem)\r\n\r\n    bReportedTolCorrected = maxDiscrepancyOfReportedTol > fZeroTol\r\n\r\n    if bEcho:\r\n        s  = \"Max. of all input brep's BrepEdge.Tolerance\"\r\n        s += \" Before=>After Brep.SetTolerancesBoxesAndFlags\"\r\n        s += \": {}=>{}\".format(\r\n            _formatDistance(max(fEdgeTols_In)),\r\n            _formatDistance(max(fEdgeTols_after_SetTolBoxesAndFlags)))\r\n        print(s)\r\n\r\n    fEdgeDevs_perFace = []\r\n    for rgF in rgB_In.Faces:\r\n        fDev = _compute_max_edge_tol_of_face(\r\n            rgF,\r\n            fRebuildNakedTol=fRebuildNakedTol,\r\n            bRebuildVertices=bRebuildVertices)\r\n        fEdgeDevs_perFace.append(fDev)\r\n\r\n    if bEcho:\r\n        print(\"Computed maximum edge deviation of input brep: {}.\".format(\r\n            _formatDistance(max(fEdgeDevs_perFace))))\r\n\r\n\r\n    if not bRebuildOnlyOutOfTol:\r\n        # Will rebuild all.\r\n        idx_Fs_toRE = range(rgB_Out.Faces.Count)\r\n    else:\r\n        # Wil rebuild only out of tol.\r\n        if all(fEdgeDevs_perFace) and max(fEdgeDevs_perFace) <= fSearchTol:\r\n            idx_Fs_toRE = []\r\n        else:\r\n            idx_Fs_toRE = _facesWithEdgesOutOfTol(\r\n                rgB_Out,\r\n                fEdgeDevs_perFace,\r\n                fSearchTol=fSearchTol,\r\n                )\r\n\r\n        if not idx_Fs_toRE:\r\n            s = \"All curve deviations are within tolerance\"\r\n            if bReportedTolCorrected:\r\n                return rgB_Out, s + \", but Edge.Tolerance value(s) were corrected.\"\r\n            else:\r\n                return None, s + \".\"\r\n\r\n        if bDebug:\r\n            print(\"Up to {} faces will have their edges rebuilt.\".format(\r\n                len(idx_Fs_toRE)))\r\n\r\n\r\n    idx_Fs_withREs = []\r\n\r\n    for iF in idx_Fs_toRE:\r\n\r\n        rgFace0 = rgB_In.Faces[iF]\r\n        rgFace1 = rgB_Out.Faces[iF]\r\n        \r\n        if rgB_In.Faces.Count == 1:\r\n            iCt_Cp_Face_PreRebuild = _faceEdgesControlPointCounts(rgFace0)\r\n            if not iCt_Cp_Face_PreRebuild :\r\n                sEval = 'iCt_Cp_Face_PreRebuild'\r\n                return None, sEval+':', eval(sEval)\r\n            \r\n            if bEcho:\r\n                print(\"Control Point Count of Each Edge\")\r\n                print(\"Original: {}\".format(iCt_Cp_Face_PreRebuild))\r\n        \r\n        # Rebuild to input tolerance.\r\n        \r\n        # TODO: Determine this:\r\n        # Should a seam be considered a naked edge?\r\n        # Currently, it is not\r\n        \r\n        \r\n        \r\n        if (\r\n            fSearchTol is not None and\r\n            None not in fEdgeDevs_perFace and\r\n            fEdgeDevs_perFace[iF] <= fSearchTol\r\n        ):\r\n            # Do not rebuild.\r\n            continue # to next face.\r\n\r\n\r\n        # Rebuild.\r\n        bFaceHasSomeNakedEdges = any(rgB_Out.Edges[iE].Valence == rg.EdgeAdjacency.Naked for iE in rgFace1.AdjacentEdges())\r\n        if bFaceHasSomeNakedEdges:\r\n            bFaceHasAllNakedEdges = all(rgB_Out.Edges[iE].Valence == rg.EdgeAdjacency.Naked for iE in rgFace1.AdjacentEdges())\r\n        else:\r\n            bFaceHasAllNakedEdges = False\r\n\r\n        if bFaceHasAllNakedEdges:\r\n            bFaceHasSomeInteriorEdges = False\r\n            bFaceHasAllInteriorEdges = False\r\n        else:\r\n            bFaceHasSomeInteriorEdges = any(rgB_Out.Edges[iE].Valence == rg.EdgeAdjacency.Interior for iE in rgFace1.AdjacentEdges())\r\n            if bFaceHasSomeInteriorEdges:\r\n                bFaceHasAllInteriorEdges = all(rgB_Out.Edges[iE].Valence == rg.EdgeAdjacency.Interior for iE in rgFace1.AdjacentEdges())\r\n            else:\r\n                bFaceHasAllInteriorEdges = False\r\n        \r\n        if bFaceHasAllNakedEdges:\r\n            # Using fRebuildNakedTol.\r\n            fTolerance_WIP = fRebuildNakedTol\r\n            i = 0\r\n            while i < 10:\r\n                sc.escape_test()\r\n                if not rgFace1.RebuildEdges(\r\n                    tolerance=fTolerance_WIP,\r\n                    rebuildSharedEdges=False,\r\n                    rebuildVertices=bRebuildVertices\r\n                ):\r\n                    raise Exception(\"RebuildEdges failed.\")\r\n                setTolerancesBoxesAndFlags(rgB_Out)\r\n                fEdgeTols_after_SetTolBoxesAndFlags = [rgE.Tolerance for rgE in rgB_Out.Edges]\r\n                if max(fEdgeTols_after_SetTolBoxesAndFlags) <= fRebuildNakedTol:\r\n                    idx_Fs_withREs.append(iF)\r\n                    if fTolerance_WIP < fRebuildNakedTol:\r\n                        print(\"Rebuilt within {} using that value for the tolerance argument failed, so used {} instead.\".format(\r\n                            fRebuildNakedTol,\r\n                            fTolerance_WIP))\r\n                    break\r\n                fTolerance_WIP *= 0.9\r\n                i += 1\r\n            else:\r\n                raise Exception(\"Could not RebuildEdges to tolerance of {}. Last tolerance argument: {}\".format(\r\n                    fRebuildNakedTol,\r\n                    fTolerance_WIP))\r\n        elif bFaceHasAllInteriorEdges:\r\n            if bRebuildSharedEdges:\r\n                if rgFace1.RebuildEdges(\r\n                    tolerance=fRebuildSharedTol,\r\n                    rebuildSharedEdges=True,\r\n                    rebuildVertices=bRebuildVertices\r\n                ):\r\n                    idx_Fs_withREs.append(iF)\r\n        else:\r\n            # Face has a mix of naked and interior edges.\r\n            if bRebuildSharedEdges:\r\n                if rgFace1.RebuildEdges(\r\n                    tolerance=fRebuildSharedTol,\r\n                    rebuildSharedEdges=True,\r\n                    rebuildVertices=bRebuildVertices\r\n                ):\r\n                    idx_Fs_withREs.append(iF)\r\n            \r\n            # If bRebuildSharedEdges, this will be the 2nd RebuildEdges\r\n            # but with different arguments.\r\n            if rgFace1.RebuildEdges(\r\n                tolerance=fRebuildNakedTol,\r\n                rebuildSharedEdges=False,\r\n                rebuildVertices=bRebuildVertices\r\n            ):\r\n                if iF not in idx_Fs_withREs: idx_Fs_withREs.append(iF)\r\n\r\n        #rgB_Out.Compact()\r\n\r\n        # TODO: Standardize can modify the brep edges if any are too short.\r\n        #  Investigate if and how Standardize can be used.  It is now disabled.\r\n        #rgB_Out.Standardize() # See SDK for best documentation for Standardize.\r\n        #rgB_Out.Compact()\r\n        #sc.doc.Objects.AddBrep(rgB_Out); sc.doc.Views.Redraw(); 1/0\r\n\r\n        if rgB_In.Faces.Count == 1:\r\n            # Record new control point counts and dot old and new.\r\n            iCt_Cp_Face_PostRebuild = _faceEdgesControlPointCounts(rgFace1)\r\n            if iCt_Cp_Face_PostRebuild is None:\r\n                sEval = 'iCt_Cp_Face_PostRebuild'\r\n                return None, sEval+':', eval(sEval)\r\n            \r\n            if bAddDot:\r\n                for i, idxEdge in enumerate(rgFace0.AdjacentEdges()):\r\n                    if iCt_Cp_Face_PreRebuild[i] != iCt_Cp_Face_PostRebuild[i]:\r\n                        s = \"{}: {} -> {}\".format(\r\n                                idxEdge, iCt_Cp_Face_PreRebuild[i], iCt_Cp_Face_PostRebuild[i])\r\n                        _dotCurveMidpoint(rgB_In.Edges[idxEdge], s)\r\n            \r\n            if bEcho:\r\n                print(\"Rebuilt:  {}\".format(iCt_Cp_Face_PostRebuild))\r\n\r\n    if bDebug:\r\n        print(\"{} faces had their edges rebuilt.\".format(len(set(idx_Fs_withREs))))\r\n        fEdgeTols_after_Rebuild = [rgE.Tolerance for rgE in rgB_Out.Edges]\r\n        sEval = \"max(fEdgeTols_after_Rebuild)\"; print(sEval,'=',eval(sEval))\r\n\r\n    rgB_Out.Compact()\r\n\r\n    if bDebug:\r\n        fEdgeTols_after_Compact = [rgE.Tolerance for rgE in rgB_Out.Edges]\r\n        sEval = \"max(fEdgeTols_after_Compact)\"; print(sEval,'=',eval(sEval))\r\n\r\n    setTolerancesBoxesAndFlags(rgB_Out)\r\n\r\n    fEdgeTols_after_SetTolBoxesAndFlags = [rgE.Tolerance for rgE in rgB_Out.Edges]\r\n    if bDebug: sEval = \"max(fEdgeTols_after_SetTolBoxesAndFlags)\"; print(sEval,'=',eval(sEval))\r\n\r\n\r\n\r\n    nCPs_In = _get_CP_count(rgB_In)\r\n    nCPs_Out = _get_CP_count(rgB_Out)\r\n    nCPs_delta = nCPs_Out - nCPs_In\r\n    bChangeInNCPtCts = nCPs_Out != nCPs_In\r\n\r\n    bChangeInCrvTypeCts = _are_there_any_changes_in_curve_type_counts(rgB_In, rgB_Out)\r\n\r\n\r\n\r\n    if not bRebuildOnlyOutOfTol:\r\n\r\n        tolerance = min((fRebuildNakedTol, 1e-5))\r\n\r\n        ss = []\r\n        if not (bChangeInCrvTypeCts or bChangeInNCPtCts):\r\n            ss.append(\"No change in curve type counts or NurbsCurve point counts.\")\r\n\r\n        rv = _get_rebuilt_devs_of_brep_edge_curves(rgB_In, rgB_Out, fRebuildNakedTol)\r\n        if rv is None:\r\n            if bEcho:\r\n                ss.append(\" GetDistancesBetweenCurves could not be obtained.\")\r\n                ss.append(\" Assuming edge has changed.\")\r\n                print(\" \".join(ss))\r\n        elif max(rv) > tolerance:\r\n            pass\r\n        else:\r\n            ss.append(\"All curve deviations are within {}.\".format(tolerance))\r\n            rgB_Out.Dispose()\r\n            return None, \" \".join(ss)\r\n\r\n\r\n    if bEcho:\r\n        if not bChangeInCrvTypeCts:\r\n            print(\"No change in curve type counts.\")\r\n\r\n        if nCPs_delta == 0:\r\n            print(\"No change in edge curve control point count of {}.\".format(nCPs_In))\r\n        else:\r\n            print(\"Total edge control point count change: {:+} ({} -> {}).\".format(\r\n                nCPs_delta,\r\n                nCPs_In,\r\n                nCPs_Out))\r\n\r\n        fEdgeDevs_perFace = []\r\n        for rgF in rgB_Out.Faces:\r\n            fDev = _compute_max_edge_tol_of_face(\r\n                rgF,\r\n                fRebuildNakedTol=fRebuildNakedTol,\r\n                bRebuildVertices=bRebuildVertices)\r\n            fEdgeDevs_perFace.append(fDev)\r\n\r\n        print(\"Computed maximum edge tolerance of resultant brep: {}.\".format(\r\n            _formatDistance(max(fEdgeDevs_perFace))))\r\n\r\n\r\n    return rgB_Out, \"Edges were rebuilt.\"\r\n\r\n\r\ndef _coerceBrepObject(rhObj):\r\n    if isinstance(rhObj, rd.BrepObject):\r\n        return rhObj\r\n    if isinstance(rhObj, rd.ObjRef):\r\n        #print(rhObj.GeometryComponentIndex.ComponentIndexType\r\n        rdObj = rhObj.Object()\r\n    elif isinstance(rhObj, Guid):\r\n        rdObj = sc.doc.Objects.FindId(rhObj) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(rhObj)\r\n    return rdObj if isinstance(rdObj, rd.BrepObject) else None\r\n\r\n\r\ndef processBrepObjects(rhBreps, **kwargs):\r\n    \"\"\"\r\n    rhBreps: Can be objrefs, GUIDs, \r\n    \"\"\"\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    fRebuildNakedTol = getOpt('fRebuildNakedTol')\r\n    bRebuildOnlyOutOfTol = getOpt('bRebuildOnlyOutOfTol')\r\n    fSearchTol = getOpt('fSearchTol') if getOpt('bRebuildOnlyOutOfTol') else None\r\n    bRebuildSharedEdges = getOpt('bRebuildSharedEdges')\r\n    fRebuildSharedTol = getOpt('fRebuildSharedTol')\r\n    bRebuildVertices = getOpt('bRebuildVertices')\r\n    bReplace = getOpt('bReplace')\r\n    bAddDot = getOpt('bAddDot')\r\n    iDotHeight = getOpt('iDotHeight')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    rgBreps1 = []\r\n    sLogs = []\r\n    gBreps1 = []\r\n\r\n    for rhBrep0 in rhBreps:\r\n        rdBrep_In = _coerceBrepObject(rhBrep0)\r\n\r\n        if rdBrep_In is None:\r\n            if isinstance(rhBrep0, rg.Brep):\r\n                rgB0 = rhBrep0\r\n                rdBrep_In = None\r\n            else:\r\n                raise ValueError(\r\n                    \"{} passed to processBrepObjects.\" \\\r\n                        \" Only ObjRef, DocObject, Geometry, or an iterable combination\" \\\r\n                        \" are accepted input.\".format(rhBrep0.GetType()))\r\n\r\n        rgB0 = rdBrep_In.BrepGeometry\r\n\r\n        rv = processBrep(\r\n            rgBrep=rgB0,\r\n            fRebuildNakedTol=fRebuildNakedTol,\r\n            bRebuildOnlyOutOfTol=bRebuildOnlyOutOfTol,\r\n            fSearchTol=fSearchTol,\r\n            bRebuildSharedEdges=bRebuildSharedEdges,\r\n            fRebuildSharedTol=fRebuildSharedTol,\r\n            bRebuildVertices=bRebuildVertices,\r\n            bAddDot=bAddDot,\r\n            iDotHeight=iDotHeight,\r\n            bEcho=bEcho if len(rhBreps) == 1 else False,\r\n            bDebug=bDebug\r\n        )\r\n        if not rv:\r\n            raise Exception(\"rv is not supposed to be {}.\".format(rv))\r\n        rgB_Out, sLog = rv\r\n        if not rgB_Out:\r\n            if not sLog:\r\n                raise Exception(\"sLog is not supposed to be {}.\".format(sLog))\r\n            sLogs.append(sLog)\r\n        else:\r\n            if sLog:\r\n                sLogs.append(sLog)\r\n            else:\r\n                sLog\r\n            rgBreps1.append(rgB_Out)\r\n            if bReplace:\r\n                bSuccess = sc.doc.Objects.Replace(rdBrep_In.Id, rgB_Out)\r\n                if bSuccess: gBreps1.append(rdBrep_In.Id)\r\n            else:\r\n                gBrep1 = sc.doc.Objects.AddBrep(rgB_Out)\r\n                bSuccess = gBrep1 != Guid.Empty\r\n                if bSuccess: gBreps1.append(gBrep1)\r\n        rgB0.Dispose()\r\n    \r\n    for b in rgBreps1: b.Dispose()\r\n    \r\n    iBreps0_ct = len(rhBreps)\r\n\r\n    if bEcho:\r\n        if len(rhBreps) == 1:\r\n            s = \"\"\r\n            if sLogs and sLogs[0]:\r\n                s += sLogs[0]\r\n                s += \"  \"\r\n            if bReplace:\r\n                if gBreps1:\r\n                    s += \"Brep was modified.\".format(\r\n                            len(gBreps1), iBreps0_ct)\r\n                else:\r\n                    s +=  \"Brep was not modified.\"\r\n            else:\r\n                if gBreps1:\r\n                    s += \"Brep has been added.\".format(\r\n                            len(gBreps1), iBreps0_ct)\r\n                else:\r\n                    s += \"Brep was not added.\"\r\n            print(s)\r\n        elif len(rhBreps) > 1:\r\n            for sFail in set(sLogs):\r\n                print(\"[{}] {}\".format(sLogs.count(sFail), sFail))\r\n            if bReplace:\r\n                if gBreps1:\r\n                    print(\"{} of {} brep(s) have been modified.\".format(\r\n                            len(gBreps1), iBreps0_ct))\r\n                else:\r\n                    print(\"No breps have been modified.\")\r\n            else:\r\n                if gBreps1:\r\n                    print(\"{} of {} brep(s) have been added.\".format(\r\n                            len(gBreps1), iBreps0_ct))\r\n                else:\r\n                    print(\"No breps have been added.\")\r\n    \r\n    return gBreps1\r\n\r\n\r\ndef main():\r\n    \r\n    rhBreps = getInput()\r\n    if rhBreps is None: return\r\n\r\n    fRebuildNakedTol = Opts.values['fRebuildNakedTol']\r\n    bRebuildOnlyOutOfTol = Opts.values['bRebuildOnlyOutOfTol']\r\n    fSearchTol = Opts.values['fSearchTol']\r\n    bRebuildSharedEdges = Opts.values['bRebuildSharedEdges']\r\n    fRebuildSharedTol = Opts.values['fRebuildSharedTol']\r\n    bRebuildVertices = Opts.values['bRebuildVertices']\r\n    bReplace = Opts.values['bReplace']\r\n    bAddDot = Opts.values['bAddDot']\r\n    iDotHeight = Opts.values['iDotHeight']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    if bDebug:\r\n        pass\r\n    else:\r\n        sc.doc.Views.RedrawEnabled = False\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(\"Working ...\")\r\n\r\n    rc = processBrepObjects(\r\n        rhBreps,\r\n        fRebuildNakedTol=fRebuildNakedTol,\r\n        bRebuildOnlyOutOfTol=bRebuildOnlyOutOfTol,\r\n        fSearchTol=fSearchTol,\r\n        bRebuildSharedEdges=bRebuildSharedEdges,\r\n        fRebuildSharedTol=fRebuildSharedTol,\r\n        bRebuildVertices=bRebuildVertices,\r\n        bReplace=bReplace,\r\n        bAddDot=bAddDot,\r\n        iDotHeight=iDotHeight,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug\r\n        )\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}