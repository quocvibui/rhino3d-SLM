{
  "source_url": "https://github.com/ar0551/Wasp/blob/66f63c018f2420d37aa451ade0178de260946b0c/src/ghComp/Wasp_Connection%20From%20Direction.py",
  "repo": "ar0551/Wasp",
  "repo_stars": 67,
  "repo_description": "Combinatorial Design with Grasshopper plug-in (LGPL) initiated by Andrea Rossi",
  "license": "LGPL-3.0",
  "filepath": "src/ghComp/Wasp_Connection From Direction.py",
  "instruction": "Create a connection on a given part geometry from center and X-asix direction\n(Z direction is determined based on the normals of the component geometry)\n-\nProvided by Wasp 0.6\n    Args:\n        GEO:...",
  "code": "# Wasp: Discrete Design with Grasshopper plug-in (LGPL) initiated by Andrea Rossi\n# \n# This file is part of Wasp.\n# \n# Copyright (c) 2017-2023, Andrea Rossi <a.rossi.andrea@gmail.com>\n# Wasp is free software; you can redistribute it and/or modify \n# it under the terms of the GNU Lesser General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Wasp is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU Lesser General Public License for more details.\n# \n# You should have received a copy of the GNU Lesser General Public License\n# along with Wasp; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license LGPL-3.0 https://www.gnu.org/licenses/lgpl-3.0.html\n#\n# Early development of Wasp has been carried out by Andrea Rossi\n# as part of research on digital materials and discrete design at:\n# DDU Digital Design Unit - Prof. Oliver Tessmann\n# Technische Universitt Darmstadt\n\n\n#########################################################################\n##                            COMPONENT INFO                           ##\n#########################################################################\n\n\"\"\"\nCreate a connection on a given part geometry from center and X-asix direction\n(Z direction is determined based on the normals of the component geometry)\n-\nProvided by Wasp 0.6\n    Args:\n        GEO: Geometry of the part to which the connection belongs\n        CEN: Origin of the connection plane\n        UP: Line idetifying the X-axis of the connection plane - determines the plane orientation to mantain when transforming\n        T: OPTIONAL // Connection type (to be used with Rule Generator component)\n    Returns:\n        CONN: Connection object\n        PLN_OUT: Plane for each connection object (for debugging)\n\"\"\"\n\nghenv.Component.Name = \"Wasp_Connection From Direction\"\nghenv.Component.NickName = 'ConnDir'\nghenv.Component.Message = 'v0.6.001'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"Wasp\"\nghenv.Component.SubCategory = \"1 | Elements\"\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"1\"\nexcept: pass\n\n\nimport sys\nimport Rhino.Geometry as rg\nimport Grasshopper as gh\n\n## add Wasp install directory to system path\nwasp_loaded = False\nghcompfolder = gh.Folders.DefaultAssemblyFolder\nif ghcompfolder not in sys.path:\n    sys.path.append(ghcompfolder)\ntry:\n    from wasp import __version__\n    wasp_loaded = True\nexcept:\n    msg = \"Cannot import Wasp. Is the wasp folder available in \" + ghcompfolder + \"?\"\n    ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Error, msg)\n\n## if Wasp is installed correctly, load the classes required by the component\nif wasp_loaded:\n    from wasp.core import Connection\n    from wasp import global_tolerance\n    from wasp.utilities import reserved_chars\n\n\ndef main(part_geo, conn_centers, conn_ups, conn_type):\n        \n    check_data = True\n    \n    ## check inputs\n    if part_geo is None:\n        check_data = False\n        msg = \"No part geometry provided\"\n        ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Warning, msg)\n    \n    if len(conn_centers) != len(conn_ups):\n        check_data = False\n        msg = \"Different amount of centers and up vectors provided\"\n        ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Error, msg)\n    \n    for ct in conn_type:\n        if any(char in ct for char in reserved_chars):\n            check_data = False\n            msg = \"Connection type \" + ct + \" contains a space or one of the reserved characters: \" + reserved_chars\n            ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Error, msg)\n    \n    types = []\n    if len(conn_type) == 0:\n        for i in range(len(conn_centers)):\n            types.append(\"0\")\n    elif len(conn_type) == 1:\n        for i in range(len(conn_centers)):\n            types.append(conn_type[0])\n    elif len(conn_centers) != len(conn_type):\n        check_data = False\n        msg = \"Different amount of centers and types provided\"\n        ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Error, msg)\n    else:\n        for i in range(len(conn_centers)):\n            types.append(conn_type[i])\n    \n    ## execute main code if all needed inputs are available\n    if check_data:\n        connections = []\n        out_planes = []\n        \n        part_geo.Normals.ComputeNormals()\n        \n        for i in range(len(conn_centers)):\n            center = conn_centers[i]\n            up = conn_ups[i]\n            plane = None\n            \n            up_start = rg.Vector3d(up.PointAtStart)\n            up_end = rg.Vector3d(up.PointAtEnd)\n            up_vec = rg.Vector3d.Subtract(up_end, up_start)\n            \n            mesh_pt = part_geo.ClosestMeshPoint(center, global_tolerance)\n            if mesh_pt is not None:\n                normal = part_geo.NormalAt(mesh_pt)\n                plane = rg.Plane(center, normal)\n                x_axis = plane.XAxis\n                angle = rg.Vector3d.VectorAngle(x_axis, up_vec, plane)\n                plane.Rotate(angle, normal)\n            \n            if plane is None:\n                msg = \"No valid plane provided for connection %d\"%(i)\n                ghenv.Component.AddRuntimeMessage(gh.Kernel.GH_RuntimeMessageLevel.Error, msg)\n            else:\n                conn = Connection(plane, types[i], \"\", -1)\n                connections.append(conn)\n                out_planes.append(plane)\n        \n        return connections, out_planes\n    \n    else:\n        return -1\n\nresult = main(GEO, CEN, UP, T)\n\nif result != -1:\n    CONN = result[0]\n    PLN_OUT = result[1]",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}