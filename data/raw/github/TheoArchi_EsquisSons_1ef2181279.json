{
  "source_url": "https://github.com/TheoArchi/EsquisSons/blob/00d1b02f7ce3e190b5c4c3429d3e84756c29bfdb/WIP_ESQUISSONS%20PYTHON%20FILES/EsquisSons_MainEngine.py",
  "repo": "TheoArchi/EsquisSons",
  "repo_stars": 3,
  "repo_description": "Esquissons is a grasshopper plugin which help you to design with sound ;)",
  "license": "NOASSERTION",
  "filepath": "WIP_ESQUISSONS PYTHON FILES/EsquisSons_MainEngine.py",
  "instruction": "EsquisSons Main Engine will calculate the auralisation.\r\nUse Listener, Sources and Geometry objects to connect them here :)\r\n-\r\nAAU / Theo Marchal / BETA VERSION / MARS2020\r\nWith the Contribution of...",
  "code": "\"\"\"EsquisSons Main Engine will calculate the auralisation.\r\nUse Listener, Sources and Geometry objects to connect them here :)\r\n-\r\nAAU / Theo Marchal / BETA VERSION / MARS2020\r\nWith the Contribution of Manon COUTIER & Domitille GRANDJEAN\"\"\"\r\n\r\nfrom ghpythonlib.componentbase import executingcomponent as component\r\nimport Grasshopper, GhPython\r\nimport System\r\nimport Rhino\r\nimport rhinoscriptsyntax as rs\r\nimport math\r\nimport OSC\r\nimport Grasshopper.Kernel as gh\r\n\r\n\r\nclass EsquissonsMainEngine(component):\r\n\r\n    def RunScript(self, listener, sources, environment, _reverb_on, _lock, _indoor):\r\n\r\n        # bloc init\r\n        __author__ = \"theomarchal\"\r\n        self.Params.Input[0].Description = \"Listener Object (Use Esquissons_Listener component)\"\r\n        self.Params.Input[1].Description = \"Sources Objects (Use Esquissons_Source component)\"\r\n        self.Params.Input[2].Description = \"Built environment (Use Esquissons_Built Environment component)\"\r\n        self.Params.Input[\r\n            3].Description = \"Set Reverb_On to True to activate Reverberation (Boolean input)(default is off)\"\r\n        self.Params.Input[\r\n            4].Description = \"To Lock sources (and sound), set to True, then turn it back to False (Boolean input)(default is unlock)\"\r\n        self.Params.Input[\r\n            5].Description = \"*Optionnal* Set to 'True' if your scene is indoors, otherwise leave the field empty (Boolean input)(default is outdoor)\"\r\n        self.Params.Output[0].Description = \"Visualize output (plug it in visualize components to see rays)\"\r\n        self.Params.Output[1].Description = \"Reverberation time (in second / for each source)\"\r\n        self.Params.Output[2].Description = \"Reverberation Info (Time and mix / for each source)\"\r\n\r\n        self.Name = \"EsquisSons Main engine\"\r\n        self.NickName = \"EsquisSons\"\r\n        self.Message = \"EsquisSons V3.01\"\r\n        self.Category = \"EsquisSons\"\r\n        self.SubCategory = \"0/ EsquisSons\"\r\n\r\n        # check if there is a listener\r\n        # - listener_head : point which represent the head of the listener\r\n        # - listener_height : height of the listener\r\n        try:\r\n            listener_head = ((listener[0])[0])\r\n            listener_height = ((listener[0])[3])\r\n        except:\r\n            self.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Error,\r\n                                   'You must connect a listener component (EsquisSons) !')\r\n            raise Exception('nolistener')\r\n\r\n        # check if there are sources\r\n        if len(sources) <= 0:\r\n            self.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning,\r\n                                   'You must connect at least one Source component (EsquisSons)')\r\n\r\n        # check if there is an environment\r\n        if len(environment) <= 0:\r\n            self.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning,\r\n                                   'You must connect at least one Geometry component (EsquisSons)')\r\n\r\n        # init the reverberation factor regarding if the scene is indoor or not\r\n        if _indoor is True:\r\n            indoor_factor = 1.0\r\n        else:\r\n            indoor_factor = 1.5\r\n\r\n        # This function calculates the proportion of sound to be sent to the left and to the right\r\n        # We draw a line between triangle_left and triangle_right and the source, and we make the difference between the two distances\r\n        # It gives a panoramic value on a potentiometer (which goes from 0 to 127)\r\n        def panoramic(listener, source_location):\r\n            triangle_left = ((listener[0])[1])\r\n            triangle_right = ((listener[0])[2])\r\n            listener_height = ((listener[0])[3])\r\n            panoramic_value = (((rs.Distance(triangle_left, source_location)) - (\r\n                rs.Distance(triangle_right, source_location)) + listener_height) * (127 / (2 * listener_height)))\r\n            return panoramic_value;\r\n\r\n        # This function calculates the impact of the distance on the sound\r\n        # - distance_weighted : scale factor in relation to the height of the listener\r\n        # - sound_attenuation : sound intensity in decibel of sound attenuation with distance\r\n        # - high_cut_frequency : high frequency filter with distance (cut-off frequency)\r\n        def impact_distance(height, distance):\r\n            distance_weighted = (distance * 1.8) / (height)\r\n            sound_attenuation = (10 * math.log10(distance_weighted))\r\n            high_cut_frequency = (1 / distance_weighted) * 15000\r\n            return [-(sound_attenuation), high_cut_frequency];\r\n\r\n        # This function calculates the intersections between the sources and geometries on the source/listener path triangle_left and triangle_right\r\n        # It is done on the left and on the right to differentiate the two ears.\r\n        # - sphere_div : number of divisions of the source's sphere\r\n        def intersection_source_env(sound_source, sphere_div, listener, environment):\r\n\r\n            # - sphere_srf : identifier of the sphere of center source_location and radius source_size*2,5\r\n            # - pt_list : list of points used to form lines\r\n            # - pt = point\r\n            # - sphere_parameter : parameterized surface of the sphere\r\n            # - new_pt : new point obtained from the evaluated surface of the parameterized sphere\r\n            sphere_srf = rs.AddSphere((sound_source[1]), ((sound_source[2]) * 2.5))\r\n            pt_list = []\r\n            for i in range(0, sphere_div + 1, 1):\r\n                for j in range(0, sphere_div + 1, 1):\r\n                    pt = (i / sphere_div, j / sphere_div, 0)\r\n                    sphere_parameter = rs.SurfaceParameter(sphere_srf, pt)\r\n                    new_pt = rs.EvaluateSurface(sphere_srf, sphere_parameter[0], sphere_parameter[1])\r\n                    pt_list.append(rs.AddPoint(new_pt))\r\n\r\n            # - lines_left : list of lines between the points of pts and triangle_left of listener\r\n            # - lines_right : list of lines between the points of pts and triangle_right of listener\r\n            lines_left = []\r\n            lines_right = []\r\n            for p in pt_list:\r\n                lines_left.append(rs.AddLine((listener[0])[1], p))\r\n                lines_right.append(rs.AddLine((listener[0])[2], p))\r\n\r\n            # - intersection_left : list of intersection points/curves between geo_obj from environment and lines_left\r\n            # - intersection_right : list of intersection points/curves between geo_obj from environment and lines_right\r\n            intersection_left = []\r\n            intersection_right = []\r\n\r\n            for i in lines_left:\r\n                for u in environment:\r\n                    if type(rs.CurveBrepIntersect(i, (u[0]))) == tuple:\r\n                        intersection_left.append((rs.CurveBrepIntersect(i, (u[0]))) + (u[1],))\r\n                    else:\r\n                        intersection_left.append((rs.CurveBrepIntersect(i, (u[0]))))\r\n\r\n            for i in lines_right:\r\n                for u in environment:\r\n                    if type(rs.CurveBrepIntersect(i, (u[0]))) == tuple:\r\n                        intersection_right.append((rs.CurveBrepIntersect(i, (u[0]))) + (u[1],))\r\n                    else:\r\n                        intersection_right.append((rs.CurveBrepIntersect(i, (u[0]))))\r\n\r\n            # - inter_point_left :\r\n            # - inter_point_right :\r\n            # - nb_unblocked_lines_left : lines on the left which aren't blocked\r\n            # - nb_unblocked_lines_right : lines on the right which aren't blocked\r\n            inter_point_left = 0\r\n            inter_point_right = 0\r\n\r\n            for i in intersection_left:\r\n                if type(i) is tuple:\r\n                    inter_point_left += (1 * (i[-1]))\r\n            nb_unblocked_lines_left = len(intersection_left) - inter_point_left\r\n\r\n            for i in intersection_right:\r\n                if type(i) is tuple:\r\n                    inter_point_right += (1 * (i[-1]))\r\n            nb_unblocked_lines_right = len(intersection_right) - inter_point_right\r\n\r\n            # be sure that the variables nb_unblocked_lines_left and nb_unblocked_lines_right aren't negative//null to be able to do the following calculation\r\n            if nb_unblocked_lines_left <= 0:\r\n                nb_unblocked_lines_left = 0.1\r\n\r\n            if nb_unblocked_lines_right <= 0:\r\n                nb_unblocked_lines_right = 0.1\r\n\r\n            # - sound_attenuation_env_left : variable which quantify the attenuation of the sound on the left\r\n            # - sound_attenuation_env_right : variable which quantify the attenuation of the sound on the right\r\n            sound_attenuation_env_left = ((math.log10(\r\n                nb_unblocked_lines_left * 100 / len(intersection_left))) * 35.3) - 70.6\r\n            sound_attenuation_env_right = ((math.log10(\r\n                nb_unblocked_lines_right * 100 / len(intersection_right))) * 35.3) - 70.6\r\n\r\n            return [sound_attenuation_env_left, sound_attenuation_env_right];\r\n\r\n        # the function allows to adapt the source volume for the software\r\n        # - source_vol : new volume wich can be used by the software\r\n        def volume_source(sound_source):\r\n            if sound_source[3] == 0 or sound_source[3] > 70:\r\n                source_vol = 0\r\n            else:\r\n                source_vol = (sound_source[3] - 70)\r\n            return source_vol\r\n\r\n        # the function calculates the rays of reverberation\r\n        # - sphere_div : number of divisions of the source's sphere\r\n        def reverberation(environment, listener, sound_source, sphere_div):\r\n\r\n            # - listener_head : point which represent the head of the listener\r\n            # - sphere_srf : identifier of the sphere of center Source_Location and radius Source_Size\r\n            # - source_location : point of the location of the source\r\n            listener_head = listener[0][0]\r\n            sphere_srf = (rs.AddSphere(sound_source[1], sound_source[2]))\r\n            source_location = (sound_source[1])\r\n\r\n            # - geometries : list of environment_geo from environment\r\n            geometries = []\r\n            for i in environment:\r\n                geometries.append(i[0])\r\n\r\n            # - first_reflection_point  : list of components 2 of the lines from reflection_points (these are points), (first point outside the sphere on which there is a reflection)\r\n            # - first_ref_rays : first line of reflected sound\r\n            # - second_ref_rays : second line of reflected sound\r\n            first_reflection_point = []\r\n            first_ref_rays = []\r\n            second_ref_rays = []\r\n\r\n            # - pt : point\r\n            # - sphere_parameter : parameterized surface of the sphere\r\n            # - new_pt : new point obtained from the evaluated surface of the parameterized sphere\r\n            # - pt_ray : point used to form rays\r\n            # - ray_vect : vector created from new_pt and source_location (radius of the source sphere)\r\n            # - reflection_points : points got from the line modeled from the surface array geometries, the starting point of the ray (source_location),\r\n            #                       the direction vector of the ray (ray_vector) and the maximum number of times the ray will be reflected (here 4)\r\n            #                       (points on which the sound line bounces (on the geometries))\r\n            for i in range(0, sphere_div + 1, 1):\r\n                for j in range(0, sphere_div + 1, 1):\r\n                    pt = (i / sphere_div, j / sphere_div, 0)\r\n                    sphere_parameter = rs.SurfaceParameter(sphere_srf, pt)\r\n                    new_pt = rs.EvaluateSurface(sphere_srf, sphere_parameter[0], sphere_parameter[1])\r\n                    pt_ray = rs.AddPoint(new_pt)\r\n                    ray_vect = rs.VectorCreate(pt_ray, source_location)\r\n                    reflection_points = rs.ShootRay(geometries, source_location, ray_vect, reflections=4)\r\n\r\n                    # - reflection_rays : polyline list created from elements from reflection_points\r\n                    # - closest_pt_listener_par : point of the polyline of reflection_rays that is closest to listener_head\r\n                    #                             (parameter of the curve that gives the location of the point in the reflection line that is closest to the listener)\r\n                    # - closest_pt_listener : point resulting from the evaluation of the polyline of reflection_rays with respect to the parameter closest_pt_listener_par\r\n                    #                         (the closest point to listener)\r\n                    # - dist_rays_listener : distance between listener_head and closest_pt_listener\r\n                    try:\r\n                        first_reflection_point.append(reflection_points[1])\r\n                        reflection_rays = rs.AddPolyline(reflection_points)\r\n                        closest_pt_listener_par = rs.CurveClosestPoint(reflection_rays, listener_head)\r\n                        closest_pt_listener = rs.EvaluateCurve(reflection_rays, closest_pt_listener_par)\r\n                        dist_rays_listener = (rs.Distance(listener_head, closest_pt_listener))\r\n\r\n                        # We are only interested in lines that do not pass too far from the listener's head\r\n                        # - first_ref_point_par : parameter of the first reflection point\r\n                        # - second_ref_point_par : parameter of the second reflection point\r\n                        # - end_ref_point_par : point of the reflection_rays-curve closest to the end point of the reflection_rays-curve\r\n                        #                       (parameter of the last reflection point)\r\n                        if dist_rays_listener <= ((listener[0])[3]):\r\n                            first_ref_point_par = rs.CurveClosestPoint(reflection_rays, reflection_points[1])\r\n                            second_ref_point_par = rs.CurveClosestPoint(reflection_rays, reflection_points[2])\r\n                            end_ref_point_par = rs.CurveClosestPoint(reflection_rays,\r\n                                                                     (rs.CurveEndPoint(reflection_rays)))\r\n\r\n                            if closest_pt_listener_par > second_ref_point_par:\r\n                                second_ref_rays.append(\r\n                                    closest_pt_listener_par / end_ref_point_par * (rs.CurveLength(reflection_rays)))\r\n\r\n                            elif closest_pt_listener_par > first_ref_point_par:\r\n                                first_ref_rays.append(\r\n                                    closest_pt_listener_par / end_ref_point_par * (rs.CurveLength(reflection_rays)))\r\n\r\n                    except:\r\n                        pass\r\n\r\n            # - first_ref_srf : list of surfaces on which the first reverberation takes place\r\n            first_ref_srf = []\r\n            for geo in geometries:\r\n                i = 0\r\n                while i < len(first_reflection_point) and rs.Distance(\r\n                        (rs.BrepClosestPoint(geo, first_reflection_point[i])[0]), first_reflection_point[i]) >= 0.1:\r\n                    i += 1\r\n                if i != len(first_reflection_point):\r\n                    first_ref_srf.append(geo)\r\n\r\n            # - first_ref_abscoef : list of absorption coefficient of first reverberation surfaces\r\n            first_ref_abscoef = []\r\n            for x in environment:\r\n                if x[0] in first_ref_srf:\r\n                    first_ref_abscoef.append(x[2])\r\n\r\n            # - first_ref_srf_abscoef : tuple list (reverberation area, absoption coefficient)\r\n            first_ref_srf_abscoef = [(first_ref_srf[i], first_ref_abscoef[i]) for i in range(0, len(first_ref_srf))]\r\n\r\n            # - ref_box : box shape created from the first_reflection_point list -> volume of the reflection scene\r\n            # - ref_box_area : area of the box ref_box rounded to 2 decimal places\r\n            # - ref_box_volume : value of the ref_box volume rounded to the first decimal place\r\n            ref_box = rs.AddBox(rs.BoundingBox(first_reflection_point))\r\n            ref_box_area = round((rs.SurfaceArea(ref_box)[0]), 2)\r\n            ref_box_volume = round(((rs.SurfaceVolume(ref_box))[0]), 1)\r\n\r\n            # - first_ref_positive_srf : for positive first_ref_srf_abscoef volumes, list of first_ref_srf_abscoef geometries\r\n            # - first_ref_positive_abscoef : for positive first_ref_srf_abscoef volumes, list of first_ref_srf_abscoef absorption coefficient\r\n            #                                (the aborption coefficient i is related to the geometry of index i in the list first_ref_positive_srf)\r\n            # - first_ref_negative_area : for negative first_ref_srf_abscoef volumes, list of first_ref_srf_abscoef area of the surfaces\r\n            #                            (areas of the surfaces for which we have reflections)\r\n            # - first_ref_negative_abscoef : for negative first_ref_srf_abscoef volumes, list of first_ref_srf_abscoef absorption coefficient\r\n            first_ref_positive_srf = []\r\n            first_ref_positive_abscoef = []\r\n            first_ref_negative_area = []\r\n            first_ref_negative_abscoef = []\r\n            for i in first_ref_srf_abscoef:\r\n                if rs.SurfaceVolume(i[0]) > 0:\r\n                    first_ref_positive_srf.append(i[0])\r\n                    first_ref_positive_abscoef.append(i[1])\r\n                else:\r\n                    first_ref_negative_area.append((rs.SurfaceArea(i[0]))[0])\r\n                    first_ref_negative_abscoef.append(i[1])\r\n\r\n            # - srf_exploded : object identifiers created by decomposing the first_ref_positive_srf surface into smaller objects, the goal is to explode the volume into lots of small surfaces\r\n            srf_exploded = rs.ExplodePolysurfaces(first_ref_positive_srf)\r\n\r\n            # - srf_center_pt : centroid list of srf_exploded surfaces\r\n            srf_center_pt = []\r\n            for i in srf_exploded:\r\n                p = 0\r\n                while p < len(first_reflection_point) and rs.Distance(\r\n                        (rs.BrepClosestPoint(i, first_reflection_point[p])[0]), first_reflection_point[p]) >= 0.01:\r\n                    p += 1\r\n                if p != len(first_reflection_point):\r\n                    first_ref_negative_area.append(rs.SurfaceArea(i)[0])\r\n                    srf_center_pt.append(rs.SurfaceAreaCentroid(i)[0])\r\n\r\n            # We recover the absorption coefficients corresponding to the new surfaces that we have added in first_ref_negative_area\r\n            for j in range(len(first_ref_positive_srf)):\r\n                for i in srf_center_pt:\r\n                    if rs.Distance((rs.BrepClosestPoint(first_ref_positive_srf[j], i)[0]), i) < 0.01:\r\n                        first_ref_negative_abscoef.append(first_ref_positive_abscoef[j])\r\n\r\n                        # - equivalent_abs_area : equivalent absorption area = multiplication of the absorption coefficient by the real volume (we have a value per surface)\r\n            try:\r\n                equivalent_abs_area = [first_ref_negative_area[i] * (first_ref_negative_abscoef[i]) for i in\r\n                                       range(0, len(first_ref_negative_abscoef))]\r\n            except:\r\n                raise Exception(\r\n                    'One source must be too deep inside a geometry, try to get it out or to move it a little bit !')\r\n\r\n            # - equivalent_abs_area_sum : sum of all of the equivalent absorption area\r\n            # - first_ref_negative_area_sum : sum of all of the area in first_ref_negative_area\r\n            # - empty_area : all the area on which there is no reflection\r\n            equivalent_abs_area_sum = len(equivalent_abs_area)\r\n            first_ref_negative_area_sum = round(len(first_ref_negative_area), 2)\r\n            empty_area = 2 * (round(ref_box_area - first_ref_negative_area_sum, 2))\r\n\r\n            # check the value of empty_area\r\n            if empty_area < 0:\r\n                empty_area = 0\r\n\r\n            # - rev_time : reverberation time\r\n            rev_time = 1000 * (0.16 * ref_box_volume) / (equivalent_abs_area_sum + empty_area)\r\n\r\n            # - first_reflection_sum : amount of first reflection for all of the rays\r\n            # - first_reflection : amount of first reflection for one ray\r\n            first_reflection_sum = 0\r\n            for f in first_ref_rays:\r\n                first_reflection = ((((listener[0])[3]) * 15) / f)\r\n                first_reflection_sum += first_reflection\r\n\r\n            # check the value of first_reflection_sum\r\n            if first_reflection_sum > 125:\r\n                first_reflection_sum = 125\r\n\r\n            # - second_reflection_sum : amount of second reflection for all of the rays\r\n            # - second_reflection : amount of second reflection for one ray\r\n            second_reflection_sum = 0\r\n            for s in second_ref_rays:\r\n                second_reflection = ((((listener[0])[3]) * 20) / s)\r\n                second_reflection_sum += second_reflection\r\n\r\n            # check the value of second_reflection_sum\r\n            if second_reflection_sum > 125:\r\n                second_reflection_sum = 125\r\n\r\n            # - reverb : output variable, list of reverberation time and first and second reflection proportions\r\n            reverb = []\r\n            reverb.append(round(first_reflection_sum))\r\n            reverb.append(round(second_reflection_sum))\r\n            reverb.append(round(rev_time, 2))\r\n\r\n            return reverb\r\n\r\n        def main():\r\n\r\n            # - impact_distance_value : list containing the distance-related sound attenuation and the cutoff frequency\r\n            # - list_sources_path : list of the paths of the sources\r\n            impact_distance_value = []\r\n            list_sources_path = []\r\n\r\n            # - list_sources_panoramic : proportion of sound on the left and on the right\r\n            # - list_sources_intersection_source_env : the intersection of the sound on the left and on the right\r\n            list_sources_panoramic = []\r\n            list_sources_intersection_source_env = []\r\n\r\n            # - list_first_reflection_value : first reflection weighted by the factor (indoor/outdoor)\r\n            # - list_second_reflection_value : second reflection weighted by the factor (indoor/outdoor)\r\n            # - list_rev_time : list of the reverberation times\r\n            # - rev_time_by_source : reverberation time by source\r\n            # - rev_info_by_source : list of strings giving information on the reverberation of the sources\r\n            list_first_reflection_value = []\r\n            list_second_reflection_value = []\r\n            list_rev_time = []\r\n            rev_time_by_source = []\r\n            rev_info_by_source = []\r\n\r\n            # - manual_volume : Manual volume (if not entered, a default value is taken)\r\n            # - randomize : value entered by the user that gives the probability that the sound will be played\r\n            manual_volume = []\r\n            randomize = []\r\n\r\n            for iS in range(len(sources)):\r\n\r\n                # - closest_pt_on_sphere : point of the source sphere that is closest to the listener\r\n                # - dist_listener_source : distance between the source and the listener\r\n                # - source_path_init // source_path_split // source_path_joined => successive modifications of the source path to obtain\r\n                #                                                                  a writing having the correct form, it is then stored\r\n                #                                                                  in list_sources_path\r\n                closest_pt_on_sphere = (\r\n                    rs.BrepClosestPoint((rs.AddSphere((sources[iS])[1], (sources[iS])[2])), listener_head))\r\n                dist_listener_source = (rs.Distance(listener_head, (closest_pt_on_sphere[0])))\r\n                impact_distance_value.append(impact_distance(listener_height, dist_listener_source))\r\n                source_path_init = (sources[iS][0]).replace('\\\\', '/')\r\n                source_path_split = (source_path_init).split()\r\n                source_path_joined = (\"\\ \").join(source_path_split)\r\n                list_sources_path.append(source_path_joined)\r\n\r\n                if _lock == True:\r\n                    list_sources_path[iS] = '/i/NoSource_LOCKED'\r\n                    self.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Remark,\r\n                                           'Your Sketch is locked, no sound until you unlock ;)')\r\n                    self.Message = \"EsquisSons is locked\"\r\n\r\n                list_sources_panoramic.append(panoramic(listener, (sources[iS])[1]))\r\n                list_sources_intersection_source_env.append(\r\n                    intersection_source_env((sources[iS]), 3, listener, environment))\r\n\r\n                # if the reverberations are activated, the values necessary for the execution are calculated\r\n                # - reverb : the output of the function reverberation for the source\r\n                if _reverb_on == True:\r\n                    reverb = reverberation(environment, listener, (sources[iS]), 50)\r\n                    list_first_reflection_value.append((reverb)[0] * indoor_factor)\r\n                    list_second_reflection_value.append((reverb)[1] * indoor_factor)\r\n                    list_rev_time.append((reverb)[2])\r\n                    rev_time_by_source.append(round((reverb)[2] / 1000, 1))\r\n                    rev_info_by_source.append(str(round((reverb)[2] / 1000, 1)) + 'sec // mix : ' + str(\r\n                        (reverb[0] + reverb[1]) * indoor_factor) + '%')\r\n\r\n                # recovery of manual_volume and randomize\r\n                manual_volume.append(volume_source(sources[iS]))\r\n                randomize.append(sources[iS][4])\r\n\r\n            # if the reverberations aren't activated, we display the proper message\r\n            if _reverb_on is not True:\r\n                rev_time_by_source.append('No RT: Reverb is disabled')\r\n                rev_info_by_source.append('No infos: Reverb is disabled')\r\n\r\n            # send information calculated to the Sound Application\r\n\r\n            # - osc_msg : osc message\r\n            # - info_osc : list of information on osc communication\r\n            osc_msg = []\r\n            info_osc = []\r\n\r\n            # allows to display the information about the sources as an output\r\n            for i in range(10):\r\n\r\n                # - osc_port : link port\r\n                iport = (57100 + i)\r\n                info_osc.append(OSC.OSCClient())\r\n                info_osc[i].connect((\"127.0.0.1\", iport))\r\n                osc_msg.append(OSC.OSCMessage())\r\n\r\n                if i < len(sources):\r\n                    osc_msg[i].append(impact_distance_value[i][0])\r\n                    osc_msg[i].append(impact_distance_value[i][1])\r\n                    osc_msg[i].append(list_sources_path[i])\r\n                    osc_msg[i].append(list_sources_panoramic[i])\r\n\r\n                    if _lock is True:\r\n                        osc_msg[i].append(0)\r\n\r\n                    else:\r\n                        osc_msg[i].append(2)\r\n                        osc_msg[i].append(list_sources_intersection_source_env[i])\r\n\r\n                    try:\r\n                        osc_msg[i].append(list_first_reflection_value[i])\r\n                        osc_msg[i].append(list_second_reflection_value[i])\r\n                        osc_msg[i].append(list_rev_time[i])\r\n                    except:\r\n                        osc_msg[i].append(0)\r\n                        osc_msg[i].append(0)\r\n                        osc_msg[i].append(0)\r\n\r\n                    osc_msg[i].append(manual_volume[i])\r\n                    osc_msg[i].append(randomize[i])\r\n                    info_osc[i].send(osc_msg[i])\r\n\r\n                else:\r\n                    osc_msg[i].append(-127)\r\n                    osc_msg[i].append(0)\r\n                    osc_msg[i].append('/i/NoSource')\r\n                    osc_msg[i].append(0)\r\n                    osc_msg[i].append(0)\r\n                    osc_msg[i].append(0)\r\n                    osc_msg[i].append(0)\r\n                    osc_msg[i].append(0)\r\n                    osc_msg[i].append(0)\r\n                    osc_msg[i].append(0)\r\n                    osc_msg[i].append(0)\r\n\r\n                try:\r\n                    info_osc[i].send(osc_msg[i])\r\n                except:\r\n                    self.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Error,\r\n                                           'Connexion Failed, please ensure APP is open (use launcher) then reset the engine (with lock/unlock)')\r\n                    self.Message = 'Connexion Failure'\r\n\r\n                print\r\n                \"message, source {} : {}\".format(i, osc_msg[i])\r\n\r\n            return (rev_time_by_source, rev_info_by_source)\r\n\r\n        if __name__ == \"__main__\":\r\n            rt_by_source, rev_info_by_source = main()\r\n            visualization = [environment, listener, sources]\r\n        return (visualization, rt_by_source, rev_info_by_source)\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}