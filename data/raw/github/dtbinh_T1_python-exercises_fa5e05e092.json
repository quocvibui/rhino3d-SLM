{
  "source_url": "https://github.com/dtbinh/T1_python-exercises/blob/f4710c3dc2ba8ddb3e3e9069ab8d65df674463ab/07_ur_online/shifted_frames_setup/compas/__debugging/objects_to_mesh_in_rhino/objects_to_mesh_short.py",
  "repo": "dtbinh/T1_python-exercises",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "07_ur_online/shifted_frames_setup/compas/__debugging/objects_to_mesh_in_rhino/objects_to_mesh_short.py",
  "instruction": "Objects to mesh short",
  "code": "__author__     = ['Matthias Rippmann <rippmann@ethz.ch>', ]\n__copyright__  = 'Copyright 2016, Block Research Group - ETH Zurich'\n__license__    = 'MIT License'\n__version__    = '0.1'\n__date__       = 'Nov 11, 2016'\n\n\nimport time\nimport math\nimport copy\n\nfrom compas.datastructures.mesh.mesh import Mesh\nfrom compas.datastructures.mesh.algorithms.smoothing import mesh_smooth_centroid\nfrom compas.datastructures.mesh.algorithms.tri.topology import remesh\nfrom compas.datastructures.mesh.algorithms.tri.delaunay import delaunay\n\nimport compas_rhino.utilities as rhino\n\nimport Rhino\nimport scriptcontext\nimport rhinoscriptsyntax as rs  \n\n\n\ndef get_boundary_points(crvs_bound,trg_len):\n    crvs = rs.ExplodeCurves(crvs_bound,True)\n    if not crvs:  crvs = [crvs_bound]\n    div_pts = []\n    for crv in crvs:\n        div = round(rs.CurveLength(crv)/trg_len,0)\n        if div < 1: div = 1\n        pts = rs.DivideCurve(crv,div)\n        div_pts += pts\n        \n    div_pts = rs.CullDuplicatePoints(div_pts)\n    if crvs: rs.DeleteObjects(crvs)\n    return div_pts    \n        \ndef get_boundary_indecies(bound_pts,all_pts): \n    keys = []\n    for bound_pt in bound_pts:\n        for i,pt in enumerate(all_pts):\n            if rs.PointCompare(pt,bound_pt):\n                keys.append(str(i))\n    return keys   \n\ndef draw_light(mesh,temp = True):\n    key_index = dict((key, index) for index, key in mesh.vertices_enum())\n    xyz = mesh.xyz\n    faces = []\n    for fkey in mesh.faces_iter():\n        face = mesh.face_vertices(fkey,True)\n        face.append(face[-1])\n        faces.append([key_index[k] for k in face])\n    guid = rs.AddMesh(xyz, faces) \n    if temp:\n        rs.EnableRedraw(True)\n        rs.EnableRedraw(False)\n        rs.DeleteObject(guid)\n    return guid                  \n\ndef convert_to_uv_space(srf,pts):\n    \n    tol = rs.UnitAbsoluteTolerance()\n    uv_pts = []\n    for pt in pts:\n        #need for issues in cases points lie on a seam\n        if not rs.IsPointOnSurface (srf, pt):\n            pts_dis = []\n            pts_dis.append((pt[0]+tol,pt[1],pt[2]))\n            pts_dis.append((pt[0]-tol,pt[1],pt[2]))\n            pts_dis.append((pt[0],pt[1]+tol,pt[2]))\n            pts_dis.append((pt[0],pt[1]-tol,pt[2]))\n            pts_dis.append((pt[0],pt[1],pt[2]+tol))\n            pts_dis.append((pt[0],pt[1],pt[2]-tol))    \n            for pt_dis in pts_dis:\n                data= rs.BrepClosestPoint(srf,pt_dis)\n                if rs.IsPointOnSurface(srf,data[0]):\n                    pt = data[0]\n                    break\n        u,v = rs.SurfaceClosestPoint(srf,pt)             \n        uv_pts.append((u,v,0))\n        \n        #rs.AddTextDot(str(data[2] ) + \" / \" + str(rs.IsPointOnSurface (srf, pt)) + \" / \" + str(u) + \" / \" + str(v),pt)\n    return uv_pts\n\ndef wrapper(brep,tolerance,fixed,vis):\n    def user_func(mesh,i):\n        \n        \n   \n        #dict((k, i) for i, k in self.vertices_enum())\n        \n        pts = []\n        key_index = {}\n        count = 0\n        for k, a in mesh.vertices_iter(True):\n            if k in fixed:\n                continue\n            pts.append((a['x'], a['y'], a['z'])) \n            key_index[k] = count\n            count += 1\n        if pts:\n            points = rs.coerce3dpointlist(pts, True)      \n            points = brep.Faces[0].PullPointsToFace(points, tolerance)\n            if len(pts) == len(points):\n                #print \"Yes\"\n                for key in key_index:\n                    index = key_index[key]\n                    mesh.vertex[key]['x'] = points[index][0]\n                    mesh.vertex[key]['y'] = points[index][1]\n                    mesh.vertex[key]['z'] = points[index][2]\n            else:\n                print \"No\"\n                pass\n            \n        \n        \n        \n        if vis:\n            if i%vis==0:\n                rs.Prompt(str(i))\n                draw_light(mesh,temp = True) \n                Rhino.RhinoApp.Wait()\n            \n\n        \n        \n        \n            \n    return user_func\n        \ndef wrapper_2(crvs,mesh_rhino_obj,fixed,boundary,vis):\n  \n    def user_func(mesh,i):\n        \n        \n        \n        \n        pts = []\n        key_index = {}\n        count = 0\n        for k, a in mesh.vertices_iter(True):\n            if k in boundary:\n                continue\n            pts.append((a['x'], a['y'], a['z'])) \n            key_index[k] = count\n            count += 1\n        if pts:\n            points = rs.coerce3dpointlist(pts, True)      \n            points = mesh_rhino_obj.PullPointsToMesh(points)\n            if len(pts) == len(points):\n                #print \"Yes\"\n                for key in key_index:\n                    index = key_index[key]\n                    mesh.vertex[key]['x'] = points[index][0]\n                    mesh.vertex[key]['y'] = points[index][1]\n                    mesh.vertex[key]['z'] = points[index][2]\n            else:\n                print \"No\"\n                pass\n        \n        \n        \n        \n        \n        \n        \n        mesh_smooth_boundary(mesh,fixed,crvs, k=1, d=0.5)\n        \n        if vis:\n            if i%vis==0:\n                rs.Prompt(str(i))\n                draw_light(mesh,temp = True) \n                Rhino.RhinoApp.Wait()\n    return user_func\n\n\ndef mesh_smooth_boundary(mesh,fixed,crvs, k=1, d=0.5):\n    \"\"\"Smoothen the input mesh by moving each vertex to the centroid of its\n    neighbours.\n\n    Note:\n        This is a node-per-node version of Laplacian smoothing with umbrella weights.\n\n    Parameters:\n        k (int): The number of smoothing iterations.\n            Defaults to `1`.\n        d (float): Scale factor for (i.e. damping of) the displacement vector.\n            Defaults to `0.5`.\n\n    Returns:\n        None\n    \"\"\"\n    def centroid(points):\n        p = len(points)\n        return [coord / p for coord in map(sum, zip(*points))]\n    boundary = set(mesh.vertices_on_boundary())\n    for _ in range(k):\n        key_xyz = dict((key, (attr['x'], attr['y'], attr['z'])) for key, attr in mesh.vertices_iter(True))\n        for key in key_xyz:\n            if (key in boundary) and (key not in fixed):\n                nbrs       = mesh.vertex_neighbours(key)\n                points     = [key_xyz[nbr] for nbr in nbrs]\n                cx, cy, cz = centroid(points)\n                x, y, z    = key_xyz[key]\n                tx, ty, tz = d * (cx - x), d * (cy - y), d * (cz - z)\n                mesh.vertex[key]['x'] += tx\n                mesh.vertex[key]['y'] += ty\n                mesh.vertex[key]['z'] += tz\n                \n                pt = mesh.vertex[key]['x'],mesh.vertex[key]['y'],mesh.vertex[key]['z']\n                pt = rs.PointClosestObject(pt,crvs)[1]\n                mesh.vertex[key]['x'] = pt[0]\n                mesh.vertex[key]['y'] = pt[1]\n                mesh.vertex[key]['z'] = pt[2]\n                \n                \n\ndef mesh_to_mesh(rhino_mesh,trg_len,vis):\n    \n    print rhino_mesh\n    crvs = rs.DuplicateMeshBorder(rhino_mesh)\n    \n    \n    \n    vertices = [map(float, vertex) for vertex in rs.MeshVertices(rhino_mesh)]\n    faces = map(list, rs.MeshFaceVertices(rhino_mesh))\n    \n    mesh  = Mesh.from_vertices_and_faces(vertices, faces)\n    \n    \n    pts_objs = rs.GetObjects(\"Fixed Points\",1)\n    rs.EnableRedraw(False)\n    if pts_objs:\n        pts_fixed = [rs.PointCoordinates(obj) for obj in pts_objs]\n        \n        pts = []\n        index_key = {}\n        count = 0\n        for k, a in mesh.vertices_iter(True):\n            pts.append((a['x'], a['y'], a['z'])) \n            index_key[count] = k\n            count += 1\n        \n        fixed = [] \n        for pt_fix in pts_fixed:\n            index = rs.PointArrayClosestPoint(pts,pt_fix)\n            fixed.append(index_key[index])\n    \n    \n\n      \n    edge_lengths = []\n    for u, v in mesh.edges():\n        edge_lengths.append(mesh.edge_length(u, v))\n    target_start = max(edge_lengths)/2  \n     \n    id = rs.coerceguid(rhino_mesh, True)\n    mesh_rhino_obj = rs.coercemesh(id, False)\n    \n    boundary = set(mesh.vertices_on_boundary())\n    user_func = wrapper_2(crvs,mesh_rhino_obj,fixed,boundary,vis)\n        \n    rs.HideObject(rhino_mesh)\n        \n    remesh(mesh,trg_len,\n       tol=0.1, divergence=0.01, kmax=400,\n       target_start=target_start, kmax_approach=200,\n       verbose=False, allow_boundary=True,\n       ufunc=user_func)  \n        \n    rs.DeleteObject(rhino_mesh)\n    return draw_light(mesh,temp = False) \n    \n    \n    \n    \n\n\n\n\ndef nurbs_to_mesh(srf,trg_len,vis):\n    \n    crvs = rs.DuplicateEdgeCurves(srf) \n    \n    if len(crvs)>1:\n        joint = rs.JoinCurves(crvs,True)\n        if joint:\n            if len(joint) > 2:\n                print \"hole\" \n    else:\n        if rs.IsCurveClosed(crvs[0]):\n            joint = [crvs[0]]\n            print \"closed\"#e.g. if it is a disk\n        else:\n            print \"Surface need to be split\"#e.g. if it is a sphere\n            return None\n         \n\n    \n    #sort curves (this is cheating: the longer curve is not necessarily the outer boundary!) \n    #todo: an inside outside comparison in uv space\n    crvs_len = [rs.CurveLength(crv) for crv in joint] \n    crvs  = [x for (_,x) in sorted(zip(crvs_len,joint))]\n    \n    outer_crv =  crvs[-1]\n    inner_crvs = crvs[:-1]\n    \n    outer_bound_pts = get_boundary_points(outer_crv,trg_len)\n    if inner_crvs: inner_bounds_pts = [get_boundary_points(crvs,trg_len) for crvs in inner_crvs]\n    \n    all_pts = copy.copy(outer_bound_pts)\n    if inner_crvs: \n        for pts in inner_bounds_pts:\n            all_pts += pts\n    \n    outbound_keys = get_boundary_indecies(outer_bound_pts,all_pts)\n\n    inbounds_keys = []\n    if inner_crvs:\n        for inner_bound_pts in inner_bounds_pts:\n            inbounds_keys.append(get_boundary_indecies(inner_bound_pts,all_pts))   \n     \n\n    rs.DeleteObjects(crvs)        \n\n    all_pts_uv = convert_to_uv_space(srf,all_pts) \n    tris = delaunay(all_pts_uv,outbound_keys,inbounds_keys)\n    \n    mesh = Mesh()\n    \n    for i,pt in enumerate(all_pts):\n        mesh.add_vertex(str(i),{'x' : pt[0], 'y' : pt[1], 'z' : pt[2]})\n    for tri in tris:\n        mesh.add_face(tri)  \n    \n    edge_lengths = []\n    for u, v in mesh.edges():\n        edge_lengths.append(mesh.edge_length(u, v))\n    \n    target_start = max(edge_lengths)/2\n\n    rs.EnableRedraw(False)\n    \n    srf_id = rs.coerceguid(srf, True)\n    brep = rs.coercebrep(srf_id, False)   \n    tolerance = rs.UnitAbsoluteTolerance()\n    \n    fixed = outbound_keys+[item for sublist in inbounds_keys for item in sublist]\n    user_func = wrapper(brep,tolerance,fixed,vis)\n    \n\n    remesh(mesh,trg_len,\n       tol=0.1, divergence=0.01, kmax=300,\n       target_start=target_start, kmax_approach=150,\n       verbose=False, allow_boundary=False,\n       ufunc=user_func)\n \n    for k in xrange(10):\n        mesh_smooth_centroid(mesh,fixed=fixed,kmax=1) \n        user_func(mesh,k)\n    \n    return draw_light(mesh,temp = False) \n    \n\n    \n    \n    \n\n\n    ",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}