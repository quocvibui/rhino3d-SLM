{
  "source_url": "https://github.com/augmentedfabricationlab/robotic_bricklaying/blob/c06382f839cba10598d416651b1e0051bac0d300/build/lib/climate_active_envelopes/assembly/assembly.py",
  "repo": "augmentedfabricationlab/robotic_bricklaying",
  "repo_stars": 0,
  "repo_description": null,
  "license": "MIT",
  "filepath": "build/lib/climate_active_envelopes/assembly/assembly.py",
  "instruction": "Assembly",
  "code": "from __future__ import print_function\nfrom __future__ import absolute_import\nfrom __future__ import division\n\nfrom compas.datastructures import Datastructure\nfrom compas.datastructures import Graph\nfrom compas.datastructures import AssemblyError\nfrom compas.geometry import Frame, Translation, Rotation, Transformation, Vector, Point, normalize_vector\nfrom compas_rhino.conversions import plane_to_compas_frame, point_to_compas, mesh_to_rhino, point_to_rhino, vector_to_rhino\n\nfrom collections import deque\n\nfrom assembly_information_model import Assembly\nfrom .part import CAEPart as Part\n#from .reference_model import CAECellNetwork as CellNetwork\n\n\nimport math\nimport Rhino.Geometry as rg\n\n\n\nclass CAEAssembly(Assembly):\n    \"\"\"A data structure for managing the connections between different parts of an assembly.\n\n    Parameters\n    ----------\n    name : str, optional\n        The name of the assembly.\n    **kwargs : dict, optional\n        Additional keyword arguments, which are stored in the attributes dict.\n\n    Attributes\n    ----------\n    graph : :class:`compas.datastructures.Graph`\n        The graph that is used under the hood to store the parts and their connections.\n\n    See Also\n    --------\n    :class:`compas.datastructures.Graph`\n    :class:`compas.datastructures.Mesh`\n    :class:`compas.datastructures.VolMesh`\n\n    \"\"\"\n\n    def __init__(self, name=None, brick_full=None, brick_insulated=None, brick_half=None, **kwargs):\n        super(CAEAssembly, self).__init__()\n        self.brick_params = None\n        if brick_full and brick_insulated and brick_half:\n            self.set_brick_params(brick_full, brick_insulated, brick_half, brick_air_dried)\n\n\n    def export_to_json(self, path, is_built=False):\n\n        # TODO!\n        self.graph.update_default_node_attributes({\"is_built\":False})\n        for key in self.parts():\n            self.graph.node_attribute(key, \"is_built\", is_built)\n\n        self.to_json(path)\n\n\n    def set_brick_params(self, brick_full, brick_insulated, brick_half, brick_air_dried):\n\n        self.brick_params = {\n            \"brick_full\": brick_full,\n            \"brick_insulated\": brick_insulated,\n            \"brick_half\": brick_half,\n            \"brick_air_dried\": brick_air_dried,\n        }\n\n        return self.brick_params\n\n    def get_brick_dimensions(self):\n\n        \"\"\"\n        Get the dimensions of the bricks\n        \n        Parameters\n        ----------\n        brick_full : :class:`CAEPart`\n            The full brick to use for the wall\n        brick_insulated : :class:`CAEPart`\n            The insulated brick to use for the wall\n        \"\"\"\n\n        if self.brick_params is None:\n            raise ValueError(\"brick_params is not set. Please set brick_params using set_brick_params method before calling get_brick_dimensions.\")\n\n        brick_full = self.brick_params[\"brick_full\"]\n        brick_half = self.brick_params[\"brick_half\"]\n\n        brick_length = brick_full.shape.ysize\n        brick_height = brick_full.shape.zsize\n        brick_width = brick_full.shape.xsize\n        brick_length_h = brick_half.shape.ysize\n\n        return brick_length, brick_height, brick_width, brick_length_h\n    \n    def compute_brick_layout(self, cell_network, course_height, brick_spacing):\n\n        # get the dimensions of the bricks\n        brick_length, _, brick_width, _, = self.get_brick_dimensions()\n\n        # get the assembly data from the cell network\n        assembly_data = cell_network.generate_assembly_data_from_cellnetwork(cell_network, course_height)\n\n        direction_vector = assembly_data['direction_vector']\n        edge_length = assembly_data['edge_length']\n        start_edge_type = assembly_data['start_edge_type']\n        end_edge_type = assembly_data['end_edge_type']\n        num_courses = assembly_data['num_courses']\n        curve_start_point = assembly_data['curve_start_point']\n        curve_end_point = assembly_data['curve_end_point']\n\n\n        course_brick_data = []\n        for course in range(math.ceil(num_courses + 1)):    \n\n            # Check if the course is odd         \n            course_is_odd = course % 2 != 0\n\n            # Calculate the number of bricks per course\n            bricks_per_course = math.floor(edge_length / ((brick_width + brick_length) / 2 + brick_spacing))\n\n            # Adjust the z-coordinate of the curves_start_point for each course\n            adjusted_start_point = rg.Point3d(curve_start_point[0], curve_start_point[1], curve_start_point[2] + course * course_height)\n            adjusted_end_point = rg.Point3d(curve_end_point[0], curve_end_point[1], curve_end_point[2] + course * course_height)\n\n            # Calculate the midpoint of the contour curve\n            curve_midpoint = point_to_rhino((adjusted_start_point + adjusted_end_point) / 2)\n            \n            # Number of bricks per course are always odd\n            if bricks_per_course % 2 == 0:\n                bricks_per_course -= 1\n\n            #If course is odd and number of bricks per course is even, subtract 1\n            if course_is_odd and bricks_per_course % 2 != 0:\n                bricks_per_course -= 1\n\n            course_brick_data.append((bricks_per_course, course_is_odd, direction_vector, start_edge_type,\n                                    end_edge_type, curve_midpoint, adjusted_start_point, adjusted_end_point))\n\n        return course_brick_data\n\n    def generate_wall(self, \n                      cell_network,\n                      bond_type, \n                      wall_system,  \n                      brick_spacing, \n                      course_height, \n                      ):\n\n        course_brick_data = self.compute_brick_layout(cell_network, course_height, brick_spacing)\n        \n        for data in course_brick_data:\n            bricks_per_course, course_is_odd, direction_vector, start_edge_type, end_edge_type, curve_midpoint, adjusted_start_point, adjusted_end_point  = data\n\n            if bond_type == \"flemish_bond\":\n                # Calculate the total length of the course\n                total_length = self.calculate_flemish_course_length(\n                    bricks_per_course=bricks_per_course,\n                    brick_spacing=brick_spacing,\n                    course_is_odd=course_is_odd)                              \n\n                # Adjust the initial brick position based on corner detection\n                # if start_edge_type == \"corner\":\n                #     initial_brick_position = adjusted_start_point\n                # if end_edge_type == \"corner\":\n                #     initial_brick_position = adjusted_end_point - (direction_vector * (total_length))\n                # else:\n                initial_brick_position = curve_midpoint - (direction_vector * (total_length / 2))\n\n\n                self.generate_flemish_bond(\n                    initial_brick_position=initial_brick_position,\n                    bricks_per_course=bricks_per_course,\n                    course_is_odd=course_is_odd,\n                    direction_vector=direction_vector,\n                    wall_system=wall_system,\n                    brick_spacing=brick_spacing,\n                    start_edge_type=start_edge_type,\n                    end_edge_type=end_edge_type,\n                    )\n\n    def create_brick_and_add_to_assembly(self,\n                        brick_type, \n                        transform_type, \n                        frame=None,\n                        ): \n        \"\"\"Create a brick with a specified type and add it to the assembly\n\n        Parameters\n        ----------\n        brick_type : str\n            The type of brick to create (\"full\" or \"insulated\").\n        brick_full : :class:`CAEPart`\n            The full brick to use for the wall.\n        brick_insulated : :class:`CAEPart`\n            The insulated brick to use for the wall.\n        transform_type : str\n            Type of transformation to apply (\"translate\" or \"rotate\").\n        frame : :class:`compas.geometry.Frame`, optional\n            The frame of the brick.\n        \n        Returns\n        -------\n        Part\n            The brick part that is added to the assembly. \n        \"\"\"\n\n        brick_full = self.brick_params[\"brick_full\"]\n        brick_insulated = self.brick_params[\"brick_insulated\"]\n        brick_half = self.brick_params[\"brick_half\"]\n        brick_air_dried = self.brick_params[\"brick_air_dried\"]\n\n        if frame is None:\n            frame = frame\n\n        if brick_type == \"full\":\n            brick = brick_full\n\n        if brick_type == \"insulated\":\n            brick = brick_insulated\n\n        if brick_type == \"half\":\n            brick = brick_half\n\n        if brick_type == \"air_dried\":\n            brick = brick_air_dried\n            \n        my_brick = brick.transformed(Transformation.from_frame(frame))\n\n        # Adjust the gripping frame by translating it along the z-axis to account for the brick height\n        gripping_frame = frame.transformed(Translation.from_vector(frame.zaxis*((brick_full.shape.zsize - 0.020)/2)))\n\n        # Rotate the gripping frame by 180 degrees around the x-axis\n        R = Rotation.from_axis_and_angle(gripping_frame.xaxis, math.radians(180), gripping_frame.point)\n        gripping_frame.transform(R)\n        # Set the gripping frame of the brick \n        my_brick.gripping_frame = gripping_frame\n        my_brick.frame = frame\n\n        self.add_part(my_brick, attr_dict={\"brick_type\": brick_type, \"transform_type\": transform_type})\n\n    def generate_french_bond(self,\n                    brick_full,\n                    brick_insulated,\n                    initial_brick_position,\n                    line_length,          \n                    plane,\n                    course_is_odd,\n                    j,\n                    wall_system):\n\n        brick_spacing = 0.015\n        mortar_joint_height = 0.015\n        brick_width_i, brick_length_i, brick_length, brick_height, brick_width = self.get_brick_dimensions(brick_full, brick_insulated)\n      \n        brick_params = {\"brick_full\": brick_full, \n                  \"brick_insulated\": brick_insulated \n                }\n\n        \n        center_brick_frame = plane_to_compas_frame(plane)\n        num_bricks1 = math.floor(line_length / (((brick_width+2*brick_length) + 3*brick_spacing)))\n\n        for i in range(num_bricks1):\n            T = plane.XAxis * -(i*(2*(brick_spacing+brick_length)))\n            translation = Translation.from_vector(T)\n            \n            # Apply translation to the initial brick center\n            brick_center = initial_brick_position + T\n            brick_frame = Frame(point_to_compas(brick_center), center_brick_frame.xaxis, center_brick_frame.yaxis)\n            \n            # Transform the frame with translation\n            current_frame = brick_frame.transformed(translation)\n            # Add the brick to the assembly\n            if course_is_odd:\n                if wall_system == \"single_layer\" or wall_system == \"double_layer\":\n                    self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"translate\", frame=current_frame, **brick_params)\n            else:\n                T = plane.XAxis * -((((brick_length+brick_spacing+brick_width)/2)))\n                translation = Translation.from_vector(T)\n                current_frame = current_frame.transformed(translation)\n                if wall_system == \"single_layer\" or wall_system == \"double_layer\":\n                    self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"translate\", frame=current_frame, **brick_params)\n\n            \n            T = plane.XAxis * -((((brick_length+brick_spacing)*1.5)))\n            T2 = plane.XAxis * -(i*(((2*(brick_length+brick_spacing)))))\n            T1 = plane.YAxis * ((brick_width-brick_length)/2)\n            \n            translation = Translation.from_vector(T)\n            Translation2 = Translation.from_vector(T1)\n            Translation3 = Translation.from_vector(T2)\n            \n            # Create a rotation transformation (90 degrees around Z-axis)\n            R = Rotation.from_axis_and_angle(current_frame.zaxis, math.radians(90), brick_frame.point)\n            \n            # Apply rotation\n            rotated_frame = brick_frame.transformed(R)\n            \n            # Apply translation to the rotated frame\n            current_frame = rotated_frame.transformed(translation*Translation2*Translation3)\n            \n            # Add the rotated brick to the assembly\n            if course_is_odd:\n                if wall_system == \"single_layer\" or wall_system == \"double_layer\":\n                    self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"fixed\", frame=current_frame, **brick_params)\n                    T = plane.XAxis * -((((brick_length+brick_spacing))))\n                    translation = Translation.from_vector(T)\n                    current_frame = current_frame.transformed(translation)\n                    if wall_system == \"single_layer\" or wall_system == \"double_layer\":\n                        self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"fixed\", frame=current_frame, **brick_params)\n\n                if wall_system == \"double_layer\":\n                    T = plane.YAxis * (brick_spacing+brick_width)\n                    translation = Translation.from_vector(T)\n                    current_frame = current_frame.transformed(translation)\n                    self.create_brick_and_add_to_assembly(brick_type=\"insulated\", transform_type = \"fixed\", frame=current_frame, **brick_params)\n\n            else:\n                T = plane.XAxis * -((((brick_length+brick_spacing+brick_width)/2)))\n                translation = Translation.from_vector(T)\n                current_frame = current_frame.transformed(translation)\n                if wall_system == \"single_layer\" or wall_system == \"double_layer\":\n                    self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"fixed\", frame=current_frame, **brick_params)\n                    T = plane.XAxis * -((((brick_length+brick_spacing))))\n                    translation = Translation.from_vector(T)\n                    current_frame = current_frame.transformed(translation)\n                    if wall_system == \"single_layer\" or wall_system == \"double_layer\":\n                        self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"fixed\", frame=current_frame, **brick_params)\n                        \n                if wall_system == \"double_layer\":\n                    T = plane.YAxis * (brick_spacing+brick_width)\n                    translation = Translation.from_vector(T)\n                    current_frame = current_frame.transformed(translation)\n                    self.create_brick_and_add_to_assembly(brick_type=\"insulated\", transform_type = \"fixed\", frame=current_frame, **brick_params)\n\n    def generate_vertical_bond(self,\n                            brick_full,\n                            brick_insulated,\n                            initial_brick_position,\n                            line_length,          \n                            plane,\n                            course_is_odd,\n                            j,\n                            direction_vector,\n                            wall_system):\n        \"\"\"\n        Generates a Cross Bond pattern of bricks.\n\n        Parameters\n        ----------\n        brick_full : :class:`CAEPart`\n            The full brick to use for the wall.\n        brick_insulated : :class:`CAEPart`\n            The insulated brick to use for the wall.\n        initial_brick_position : :class:`compas.geometry.Point`\n            Starting center point for brick placement.\n        line_length : float\n            The length of the wall (the line along which bricks are laid).\n        plane : :class:`compas.geometry.Plane`\n            The reference plane for brick placement.\n        course_is_odd : bool\n            Boolean indicating if the course is odd.\n        j : int\n            Course index (used here for pattern ornamentation).\n        wall_system : str\n            The type of wall system to generate (\"single_layer\" or \"double_layer\").\n        \"\"\"\n        \n        brick_spacing = 0.015\n        mortar_joint_height = 0.015\n        brick_width_i, brick_length_i, brick_length, brick_height, brick_width = self.get_brick_dimensions(brick_full, brick_insulated)\n      \n        brick_params = {\"brick_full\": brick_full, \n                  \"brick_insulated\": brick_insulated \n                }\n\n        \n        center_brick_frame = plane_to_compas_frame(plane)\n        ornament = \"cross\"  #name it\n\n        if course_is_odd:\n            num_bricks1 = math.floor(line_length / (brick_width+brick_spacing))\n            num_bricks2 = math.floor(line_length / (brick_length+brick_spacing))\n            # Odd courses: Bricks laid with the long side facing out\n            for i in range(num_bricks1):\n\n                # Calculate translation vector for the current brick\n                T = plane.XAxis * -(i * (((brick_width+ brick_spacing)/2)))\n                translation = Translation.from_vector(T)\n                \n                # Apply translation to the initial brick center\n                brick_center = initial_brick_position + T\n                brick_frame = Frame(point_to_compas(brick_center), center_brick_frame.xaxis, center_brick_frame.yaxis)\n                \n                # Transform the frame with translation\n                current_frame = brick_frame.transformed(translation)\n                # Add the brick to the assembly\n                if ornament == \"cross\" or ornament ==\"straight\":\n                    self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"fixed\", frame=current_frame, **brick_params)\n\n                T1 = plane.YAxis * ((brick_width+ brick_length + (2*brick_spacing)))\n                T2 = plane.XAxis * -((brick_length + brick_spacing)/2)\n                translation1 = Translation.from_vector(T1)\n                translation2 = Translation.from_vector(T2)\n                current_frame = current_frame.transformed(translation1*translation2)\n                if wall_system == \"double_layer\":\n                    self.create_brick_and_add_to_assembly(brick_type=\"insulated\", transform_type = \"fixed\", frame=current_frame, **brick_params) #maybe ornament can be here\n\n\n\n\n            for i in range(num_bricks2):\n                T = plane.XAxis * -(i * (((brick_length+brick_spacing)/2)))\n                T1 = plane.YAxis * (((brick_width-brick_length)/2)+ (brick_length+brick_spacing))\n                \n                translation = Translation.from_vector(T)\n                Translation2 = Translation.from_vector(T1)\n                \n                # Create the initial brick frame\n                brick_center = initial_brick_position + T\n                brick_frame = Frame(point_to_compas(brick_center), center_brick_frame.xaxis, center_brick_frame.yaxis)\n                \n                # Create a rotation transformation (90 degrees around Z-axis)\n                R = Rotation.from_axis_and_angle(brick_frame.zaxis, math.radians(90), brick_frame.point)\n                \n                # Apply rotation\n                rotated_frame = brick_frame.transformed(R)\n                \n                # Apply translation to the rotated frame\n                current_frame = rotated_frame.transformed(translation*Translation2)\n                \n    \n                if wall_system == \"double_layer\":\n                   self.create_brick_and_add_to_assembly(brick_type=\"insulated\", transform_type = \"fixed\", frame=current_frame, **brick_params)\n\n\n\n                        \n        elif not course_is_odd:\n            num_bricks = math.floor(line_length / (brick_length+brick_spacing))\n            # Even courses: Bricks laid with the short side facing out (rotated by 90 degrees)\n            for i in range(num_bricks):\n                # Calculate translation vector based on brick length\n                T = plane.XAxis * -(i * (((brick_length+brick_spacing)/2)))\n                T1 = plane.YAxis * ((brick_width-brick_length)/2)\n                \n                translation = Translation.from_vector(T)\n                Translation2 = Translation.from_vector(T1)\n                \n                # Create the initial brick frame\n                brick_center = initial_brick_position + T\n                brick_frame = Frame(point_to_compas(brick_center), center_brick_frame.xaxis, center_brick_frame.yaxis)\n                \n                # Create a rotation transformation (90 degrees around Z-axis)\n                R = Rotation.from_axis_and_angle(brick_frame.zaxis, math.radians(90), brick_frame.point)\n                \n                # Apply rotation\n                rotated_frame = brick_frame.transformed(R)\n                \n                # Apply translation to the rotated frame\n                current_frame = rotated_frame.transformed(translation*Translation2)\n                \n                # Add the rotated brick to the assembly\n  \n    \n                if ornament == \"cross\": \n                    if i % 2 == 0 and j% 4 == 0:\n                        self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"translate\", frame=current_frame, **brick_params)\n                    elif i % 2 != 0 and j% 4 != 0:\n                        self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"translate\", frame=current_frame, **brick_params)\n                    else:\n                        self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"fixed\", frame=current_frame, **brick_params)\n\n                if ornament == \"straight\": \n                    if i % 2 == 0:\n                        self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"translate\", frame=current_frame, **brick_params)\n                    else:\n                        self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"fixed\", frame=current_frame, **brick_params)\n\n\n                if ornament == \"diamond\": \n                    if i % 2 == 0:\n                        self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"translate\", frame=current_frame, **brick_params)\n                    else:\n                        self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"fixed\", frame=current_frame, **brick_params)\n\n\n                T2 = plane.YAxis * (brick_width+ brick_spacing)\n                T3 = plane.XAxis * ((brick_length+brick_spacing)/2)\n                Translation3 = Translation.from_vector(T2)\n                Translation4= Translation.from_vector(T3)\n                current_frame = current_frame.transformed(Translation3 * Translation4)\n                if wall_system == \"double_layer\":\n                    self.create_brick_and_add_to_assembly(brick_type=\"insulated\", transform_type = \"fixed\", frame=current_frame, **brick_params)\n  \n    def generate_flemish_bond(self,\n                                initial_brick_position,\n                                bricks_per_course,\n                                course_is_odd,\n                                direction_vector,\n                                wall_system,\n                                brick_spacing, \n                                start_edge_type,\n                                end_edge_type,                                                          \n                                ):\n        \n        \n        brick_length, _, brick_width, _ = self.get_brick_dimensions()\n        brick_full = self.brick_params[\"brick_full\"]\n        center_brick_frame = brick_full.frame\n\n        shift_vector = direction_vector * ((brick_length + brick_width)/2 + brick_spacing)\n        \n        if not course_is_odd:\n            if start_edge_type == \"corner\":\n                self.generate_corner_flemish_bond(\n                    initial_brick_position=initial_brick_position,\n                    bricks_per_course=bricks_per_course,\n                    course_is_odd=course_is_odd,\n                    direction_vector=direction_vector,\n                    brick_spacing=brick_spacing,\n                    start_edge_type=start_edge_type,\n                    end_edge_type=end_edge_type                        \n                )\n    \n            elif end_edge_type == \"corner\":\n                self.generate_corner_flemish_bond(\n                    initial_brick_position=initial_brick_position,\n                    bricks_per_course=bricks_per_course,\n                    course_is_odd=course_is_odd,\n                    direction_vector=direction_vector,\n                    brick_spacing=brick_spacing,\n                    start_edge_type=start_edge_type,\n                    end_edge_type=end_edge_type,\n                )\n                    \n            else:\n                for brick in range(bricks_per_course):\n                    T = direction_vector * (brick * ((brick_length + brick_width)/2 + brick_spacing))\n                    if course_is_odd:\n                        T += shift_vector\n\n                    brick_position = initial_brick_position + T                    \n                    if direction_vector[1] in [-1, 1]:\n                        brick_frame = Frame(brick_position, direction_vector, center_brick_frame.xaxis)\n                    else:\n                        brick_frame = Frame(brick_position, direction_vector, center_brick_frame.yaxis)\n\n                    if brick % 2 != 0: #brick is odd - header\n                        R1 = Rotation.from_axis_and_angle(brick_frame.zaxis, math.radians(90), point=brick_frame.point)  \n                        T1 = Translation.from_vector(brick_frame.xaxis * (brick_length + brick_spacing)/2)\n                        current_frame = brick_frame.transformed(R1*T1)\n                        self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"translate\", frame=current_frame) \n\n                        # second row - insulated bricks - header bricks\n                        T2 = Translation.from_vector(current_frame.xaxis * (brick_width + brick_spacing))\n                        copy_current_frame = current_frame.transformed(T2)\n                        if wall_system == \"double_layer\":\n                            self.create_brick_and_add_to_assembly(brick_type = \"insulated\", transform_type = \"fixed\", frame = copy_current_frame) \n\n                    else: #strecther bricks - first row\n                        self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"rotate\", frame=brick_frame) \n                        \n                        # second row - full bricks - stretcher bricks\n                        if wall_system == \"single_layer\":                      \n                            T3 = Translation.from_vector(brick_frame.yaxis * (brick_length + brick_spacing))\n                            current_frame = brick_frame.transformed(T3)\n                            self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"fixed\", frame=current_frame)\n                        \n                        if wall_system == \"double_layer\":\n                            T4 = Translation.from_vector(brick_frame.yaxis * (brick_length + brick_width + 2 * brick_spacing))\n                            current_frame = brick_frame.transformed(T4)\n                            self.create_brick_and_add_to_assembly(brick_type = \"insulated\", transform_type = \"fixed\", frame = current_frame) \n\n                            # middle bricks in the row\n                            R2 = Rotation.from_axis_and_angle(current_frame.zaxis, math.radians(90), point=current_frame.point)\n                            T5 = Translation.from_vector(current_frame.yaxis * ((brick_width - brick_length)/2 + brick_spacing/4))\n                            T6 = Translation.from_vector(current_frame.xaxis * - ((brick_width + brick_length)/2 + brick_spacing))\n                            current_frame = current_frame.transformed(R2 * T5 * T6)\n                            self.create_brick_and_add_to_assembly(brick_type = \"insulated\", transform_type = \"fixed\", frame = current_frame )\n\n                            T7 = Translation.from_vector(current_frame.yaxis * - (brick_length + brick_spacing))\n                            current_frame = current_frame.transformed(T7)\n                            self.create_brick_and_add_to_assembly( brick_type = \"insulated\", transform_type = \"fixed\", frame = current_frame )\n\n        else: #if course_is_odd:\n            for brick in range(bricks_per_course):\n                T = direction_vector * (brick * ((brick_length + brick_width)/2 + brick_spacing))\n                if course_is_odd:\n                    T += shift_vector\n\n                brick_position = initial_brick_position + T\n                if direction_vector[1] in [-1, 1]:\n                    brick_frame = Frame(brick_position, direction_vector, center_brick_frame.xaxis)\n                else:\n                    brick_frame = Frame(brick_position, direction_vector, center_brick_frame.yaxis)\n                \n                if brick == 0:  # first brick in course\n                    R3 = Rotation.from_axis_and_angle(brick_frame.zaxis, math.radians(90), point=brick_frame.point)  \n                    current_frame = brick_frame.transformed(R3)\n                    T8 = Translation.from_vector(current_frame.xaxis * ((brick_length + brick_spacing)/2))\n                    T9 = Translation.from_vector(current_frame.yaxis * ((brick_length + brick_width)/2 + brick_spacing))\n                    current_frame = current_frame.transformed(T9 * T8)\n                    self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"translate\", frame=current_frame)\n\n                    if wall_system == \"double_layer\":\n                        # first insulated brick\n                        T10 = Translation.from_vector(current_frame.xaxis *((brick_width + brick_spacing)))\n                        current_frame = current_frame.transformed(T10)\n                        self.create_brick_and_add_to_assembly(brick_type = \"insulated\", transform_type = \"fixed\", frame = current_frame) \n\n                if brick >= 0 and brick < bricks_per_course - 1: \n                    if brick % 2 != 0: #brick is even               \n                        # first row - header bricks\n                        R4 = Rotation.from_axis_and_angle(brick_frame.zaxis, math.radians(90), point=brick_frame.point)  \n                        T11 = Translation.from_vector(brick_frame.xaxis * (brick_length + brick_spacing)/2)\n                        current_frame = brick_frame.transformed(R4 * T11)\n                        self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"translate\", frame=current_frame)\n\n                        # second row - insulated bricks - header bricks\n                        T13 = Translation.from_vector(current_frame.xaxis * (brick_width + brick_spacing))\n                        copy_current_frame = current_frame.transformed(T13)\n                        if wall_system == \"double_layer\":                        \n                            self.create_brick_and_add_to_assembly(brick_type = \"insulated\", transform_type = \"fixed\", frame = copy_current_frame)\n\n                    else:\n                        # first row - self-shading bricks - stretcher bricks\n                        T14 = Translation.from_vector(brick_frame.xaxis * (brick_length + brick_spacing))\n                        current_frame = brick_frame.transformed(T14)\n                        self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"rotate\", frame=brick_frame) \n\n                        if wall_system == \"single_layer\": # stretcher bricks - copy\n                            T15 = Translation.from_vector(brick_frame.yaxis * (brick_length + brick_spacing))\n                            current_frame = brick_frame.transformed(T15)\n                            self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"fixed\", frame=current_frame)\n\n                        if wall_system == \"double_layer\":\n                            # last brick in the row\n                            T14 = Translation.from_vector(brick_frame.yaxis * (brick_length + brick_width + 2 * brick_spacing))\n                            current_frame = brick_frame.transformed(T14)\n                            self.create_brick_and_add_to_assembly(brick_type = \"insulated\", transform_type = \"fixed\", frame = current_frame) \n\n                            # middle bricks in the row\n                            R5 = Rotation.from_axis_and_angle(current_frame.zaxis, math.radians(90), point=current_frame.point)\n                            T15 = Translation.from_vector(current_frame.yaxis * ((brick_width - brick_length)/2 + brick_spacing/4))\n                            T16 = Translation.from_vector(current_frame.xaxis * - ((brick_width + brick_length)/2 + brick_spacing))\n                            current_frame = current_frame.transformed(R5 * T15 * T16)\n                            self.create_brick_and_add_to_assembly(brick_type = \"insulated\", transform_type = \"fixed\", frame = current_frame)\n\n                            T17 = Translation.from_vector(current_frame.yaxis * -(brick_length + brick_spacing))\n                            current_frame = current_frame.transformed(T17)\n                            self.create_brick_and_add_to_assembly( brick_type = \"insulated\", transform_type = \"fixed\", frame = current_frame)\n\n                elif brick == bricks_per_course - 1: # last brick even courses\n                    R6 = Rotation.from_axis_and_angle(brick_frame.zaxis, math.radians(90), point=brick_frame.point)  \n                    current_frame = brick_frame.transformed(R6)\n                    T18 = Translation.from_vector(current_frame.xaxis * ((brick_length + brick_spacing)/2))\n                    current_frame = current_frame.transformed(T18)\n                    self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type = \"translate\", frame=current_frame)\n\n                    if wall_system == \"double_layer\":\n                        # last insulated brick\n                        T19 = Translation.from_vector(current_frame.xaxis *((brick_width + brick_spacing)))\n                        current_frame = current_frame.transformed(T19)\n                        self.create_brick_and_add_to_assembly(brick_type = \"insulated\", transform_type = \"fixed\", frame = current_frame)\n\n    def generate_corner_flemish_bond(self, \n                                    initial_brick_position,\n                                    bricks_per_course,\n                                    course_is_odd,\n                                    direction_vector,\n                                    brick_spacing,\n                                    start_edge_type,\n                                    end_edge_type,\n                                    ):\n        \n        \n        brick_length, _, brick_width, brick_length_h = self.get_brick_dimensions()\n        brick_full = self.brick_params[\"brick_full\"]\n        center_brick_frame = brick_full.frame\n\n        shift_vector = direction_vector * ((brick_length + brick_width)/2 + brick_spacing)\n        for brick in range(bricks_per_course):\n            T = direction_vector * (brick * ((brick_length + brick_width)/2 + brick_spacing))\n            if course_is_odd:\n                T += shift_vector\n\n            brick_position = initial_brick_position + T\n\n            if direction_vector[1] in [-1, 1]:\n                brick_frame = Frame(brick_position, direction_vector, center_brick_frame.xaxis)\n            else:\n                brick_frame = Frame(brick_position, direction_vector, center_brick_frame.yaxis)\n\n            if not course_is_odd:\n                if brick % 2 != 0:  # last header brick\n                    R1 = Rotation.from_axis_and_angle(brick_frame.zaxis, math.radians(90), point=brick_frame.point)\n                    T1 = Translation.from_vector(brick_frame.xaxis * (brick_length + brick_spacing) / 2)\n                    current_frame = brick_frame.transformed(R1 * T1)\n                    \n                    if start_edge_type == 'corner' and brick == 1:\n                        T2 = Translation.from_vector(brick_frame.xaxis * (brick_length_h / 2))\n                        current_frame = current_frame.transformed(T2)\n                        self.create_brick_and_add_to_assembly(brick_type=\"half\", transform_type=\"translate\", frame=current_frame)\n\n                    elif end_edge_type == 'corner' and brick == bricks_per_course - 2:\n                        T3 = Translation.from_vector(brick_frame.xaxis * (-brick_length_h / 2))\n                        current_frame = current_frame.transformed(T3)\n                        self.create_brick_and_add_to_assembly(brick_type=\"half\", transform_type=\"translate\", frame=current_frame)\n\n                    else: # end_edge_type == 'corner':\n                        self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type=\"translate\", frame=current_frame)\n\n                else:\n                    if start_edge_type == 'corner' and brick == 0:\n                        T4 = Translation.from_vector(brick_frame.xaxis * (brick_length_h))\n                        current_frame = brick_frame.transformed(T4)\n                        self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type=\"rotate\", frame=current_frame)\n\n                        #T8 = Translation.from_vector(brick_frame.yaxis * (brick_length + brick_spacing))\n                        #current_frame = current_frame.transformed(T8)\n                        #self.create_brick_and_add_to_assembly(brick_type=\"insulated\", transform_type=\"fixed\", frame=current_frame)\n                        \n                    elif end_edge_type == 'corner' and brick == bricks_per_course - 1:\n                        T5 = Translation.from_vector(brick_frame.xaxis * (-brick_length_h))\n                        current_frame = brick_frame.transformed(T5)\n                        self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type=\"rotate\", frame=current_frame)\n\n                        #T6 = Translation.from_vector(current_frame.yaxis * (brick_length + brick_spacing))\n                        #current_frame = current_frame.transformed(T6)\n                        #self.create_brick_and_add_to_assembly(brick_type=\"insulated\", transform_type=\"fixed\", frame=current_frame)\n\n                    else: #end_edge_type == 'corner':\n                        self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type=\"rotate\", frame=brick_frame)\n\n                        T7 = Translation.from_vector(brick_frame.yaxis * (brick_length + brick_spacing))\n                        current_frame = brick_frame.transformed(T7)\n                        self.create_brick_and_add_to_assembly(brick_type=\"full\", transform_type=\"fixed\", frame=current_frame)\n\n    def calculate_flemish_course_length(self,\n                                        bricks_per_course,\n                                        brick_spacing,\n                                        course_is_odd):\n        \"\"\"\n        Calculate the total length of a Flemish bond course \n\n        Parameters\n        ----------\n        brick_full : :class:`CAEPart`\n            The full brick to use for the wall.\n        bricks_per_course : int\n            The number of bricks in the course.\n        brick_spacing : float\n            The spacing between bricks.\n        course_is_odd : bool\n            True if the course is an odd-numbered course, False otherwise.\n\n        Returns\n        -------\n        float\n            The total length of the brick bond course.\n        \"\"\"\n\n        brick_length, _, brick_width, _ = self.get_brick_dimensions()\n\n        # Calculate the total length based on the pattern\n        if course_is_odd:\n            # Odd courses start and end with a header, alternate in between\n            total_length = (bricks_per_course // 2) * (brick_width + brick_length + 2 * brick_spacing)\n        else:\n            # Even courses start and end with a stretcher, alternate in between\n            total_length = (bricks_per_course // 2) * (brick_length + brick_width + 2 * brick_spacing)\n\n        return total_length\n\n    def apply_gradient(self, values, keys, transform_type):\n        \"\"\"\n        Apply a gradient transformation to the parts.\n\n        Parameters\n        ----------\n        values : list\n            List of values to determine the transformation.\n        keys : list\n            List of keys identifying the parts.\n        transform_type : str, optional\n            Type of transformation to apply (\"translate\" or \"rotate\"). \n        \"\"\"\n\n        sorted_keys_values = sorted(zip(keys, values), key=lambda kv: kv[1])\n        sorted_keys, sorted_values = zip(*sorted_keys_values)\n\n        for i, key in enumerate(keys):\n            part = self.part(key)\n            if i < len(sorted_values):\n                translation_factor = sorted_values[i] * -0.08  # factor for translation\n                rotation_factor = sorted_values[i] * -0.4     # factor for rotation\n            else:\n                translation_factor = 0  # Default value if sorted_values list is shorter than sorted_keys list\n                rotation_factor = 0  # Default value for rotation factor\n\n            if transform_type == \"translate\":\n                translation_vector = part.frame.xaxis * translation_factor\n                T = Translation.from_vector(translation_vector)\n               \n            elif transform_type == \"rotate\":\n                center_brick_frame = part.frame\n                R = Rotation.from_axis_and_angle(center_brick_frame.zaxis, rotation_factor, point=center_brick_frame.point)\n                translation_vector = center_brick_frame.yaxis * (0.1 * rotation_factor)\n                T = R * Translation.from_vector(translation_vector)\n            \n            part.transform(T)\n\n    def add_part(self, part, key=None, attr_dict=None, **kwargs):\n        \"\"\"Add a part to the assembly.\n\n        Parameters\n        ----------\n        part : :class:`compas.datastructures.Part`\n            The part to add.\n        key : int | str, optional\n            The identifier of the part in the assembly.\n            Note that the key is unique only in the context of the current assembly.\n            Nested assemblies may have the same `key` value for one of their parts.\n            Default is None in which case the key will be an automatically assigned integer value.\n        **kwargs: dict[str, Any], optional\n            Additional named parameters collected in a dict.\n\n        Returns\n        -------\n        int | str\n            The identifier of the part in the current assembly graph.\n\n        \"\"\"\n        if part.guid in self._parts:\n            raise AssemblyError(\"Part already added to the assembly\")\n        \n        key = self.graph.add_node(key=key, part=part, x=part.frame.point.x, y=part.frame.point.y, z=part.frame.point.z, **kwargs)\n        part.key = key\n        self._parts[part.guid] = part.key\n\n        if attr_dict:\n            for attr, value in attr_dict.items():\n                part.attributes[attr] = value\n\n        return key\n    \n    def add_connection(self, a_key, b_key, **kwargs):\n        \"\"\"Add a connection between two parts.\n\n        Parameters\n        ----------\n        a_key : int | str\n            The identifier of the \"from\" part.\n        b_key : int | str\n            The identifier of the \"to\" part.\n        **kwargs : dict[str, Any], optional\n            Attribute dict compiled from named arguments.\n\n        Returns\n        -------\n        tuple[int | str, int | str]\n            The tuple of node identifiers that identifies the connection.\n\n        Raises\n        ------\n        :class:`AssemblyError`\n            If `a_key` and/or `b_key` are not in the assembly.\n\n        \"\"\"\n        error_msg = \"Both parts have to be added to the assembly before a connection can be created.\"\n        if not self.graph.has_node(a_key) or not self.graph.has_node(b_key):\n            raise AssemblyError(error_msg)\n        #print(f\"Adding connection between {a_key} and {b_key}\")\n        return self.graph.add_edge(a_key, b_key, **kwargs)\n\n    def assembly_courses(self, tol=0.01):\n        \"\"\"Identify the courses in a wall of bricks.\n\n        Parameters\n        ----------\n        tol : float, optional\n            Tolerance for identifying courses.\n\n        Examples\n        --------\n        .. code-block:: python\n\n            pass\n\n        \"\"\"\n        courses = []\n\n        # all element keys\n        elements = set(self.graph.nodes())\n        #print(f\"All element keys: {elements}\")\n\n        # base course keys\n        c_min = min(self.graph.nodes_attribute('z'))\n        #print(f\"Minimum z value: {c_min}\")\n\n        base = set()\n        for e in elements:\n            z = self.graph.node_attribute(key=e, name='z')\n            #print(f\"Element key: {e}, z value: {z}\")\n            if abs(z - c_min) < tol:\n                base.add(e)\n\n        if base:\n            courses.append(list(base))\n            elements -= base\n\n            while elements:\n                c_min = min([self.graph.node_attribute(key=key, name='z') for key in elements])\n                base = set()\n                for e in elements:\n                    z = self.graph.node_attribute(key=e, name='z')\n                    if abs(z - c_min) < tol:\n                        base.add(e)\n\n                if base:\n                    courses.append(list(base))\n                    elements -= base\n\n        # Sort courses by their minimum z value\n        courses.sort(key=lambda course: min(self.graph.node_attribute(key, 'z') for key in course))\n\n        # Sort nodes within each course by proximity using graph.neighbors\n        for i, course in enumerate(courses):\n            sorted_course = []\n            remaining_nodes = set(course)\n            current_node = remaining_nodes.pop()\n            sorted_course.append(current_node)\n\n            while remaining_nodes:\n                neighbors = set(self.graph.neighbors(current_node))\n                next_node = neighbors.intersection(remaining_nodes)\n                if next_node:\n                    next_node = next_node.pop()\n                    sorted_course.append(next_node)\n                    remaining_nodes.remove(next_node)\n                    current_node = next_node\n                else:\n                    # If no direct neighbor is found, pick the closest remaining node\n                    closest_node = min(remaining_nodes, key=lambda node: self.distance_xy(current_node, node))\n                    sorted_course.append(closest_node)\n                    remaining_nodes.remove(closest_node)\n                    current_node = closest_node\n\n                courses[i] = sorted_course\n\n        # Calculate neighbors in the z-direction\n        z_neighbors = self.calculate_z_neighbors(courses, tol)\n        \n        return courses\n\n    def calculate_z_neighbors(self, courses, tol=0.02):\n        \"\"\"Calculate the neighbors in the z-direction for each node in the courses.\n\n        Parameters\n        ----------\n        courses : list\n            List of courses, where each course is a list of node identifiers.\n        tol : float\n            Tolerance for identifying neighbors in the z-direction.\n\n        Returns\n        -------\n        dict\n            Dictionary where keys are node identifiers and values are lists of z-neighbors.\n        \"\"\"\n        z_neighbors = {}\n        for course, nodes in enumerate(courses[:-1]):\n            next_course = courses[course + 1]\n            for node in nodes:\n                z_neighbors[node] = []\n                z1 = self.graph.node_attribute(node, 'z')\n                for next_node in next_course:\n                    z2 = self.graph.node_attribute(next_node, 'z')\n                    if abs(z1 - z2) < tol:\n                        z_neighbors[node].append(next_node)\n                        self.add_connection(node, next_node) \n                        #print(f\"Course {course} and next_course {course + 1} Node {node} has z-neighbor {next_node}\")\n        return z_neighbors\n\n    def calculate_neighbors(self, key, tol=0.02):\n        \"\"\"Calculate the neighbors in the x, y, and z directions for a given node.\n\n        Parameters\n        ----------\n        key : hashable\n            The node identifier.\n        tol : float\n            Tolerance for identifying neighbors.\n\n        Returns\n        -------\n        dict\n            Dictionary with keys 'x', 'y', and 'z' where values are lists of neighbors in respective directions.\n        \"\"\"\n        neighbors = {'x': [], 'y': [], 'z': []}\n        x1, y1, z1 = self.graph.node_attributes(key, ['x', 'y', 'z'])\n\n        # Calculate x and y neighbors\n        for node in self.graph.nodes():\n            if node == key:\n                continue\n            x2, y2, z2 = self.graph.node_attributes(node, ['x', 'y', 'z'])\n            if abs(x1 - x2) < tol and abs(y1 - y2) < tol:\n                if abs(z1 - z2) < tol:\n                    neighbors['z'].append(node)\n                elif abs(z1 - z2) < tol:\n                    neighbors['x'].append(node)\n                elif abs(y1 - y2) < tol:\n                    neighbors['y'].append(node)\n\n        # Calculate z neighbors using the existing method\n        courses = self.assembly_courses(tol)\n        z_neighbors = self.calculate_z_neighbors(courses, tol)\n        if key in z_neighbors:\n            neighbors['z'].extend(z_neighbors[key])\n\n        return neighbors\n\n    def distance_xy(self, node1, node2):\n        \"\"\"Calculate the distance between two nodes in the x and y directions.\"\"\"\n        x1, y1, _ = self.graph.node_attributes(node1, ['x', 'y', 'z'])\n        x2, y2, _ = self.graph.node_attributes(node2, ['x', 'y', 'z'])\n        return abs(x1 - x2) + abs(y1 - y2)\n\n\n    def assembly_building_sequence(assembly, key):\n        \"\"\"Determine the sequence of bricks that need to be assembled to be able to\n        place a target brick.\n\n        Parameters\n        ----------\n        assembly : Assembly\n            An assembly data structure.\n        key : hashable\n            The block identifier.\n\n        Returns\n        -------\n        list\n            A sequence of block identifiers.\n        Notes\n        -----\n        This will only work for properly supported *wall* assemblies of which the\n        interfaces and courses have been identified.\n\n        Examples\n        --------\n        .. code-block:: python\n\n            # this code only works in Rhino\n\n            assembly = Assembly.from_json(...)\n\n            placed = list(assembly.nodes_where({'is_placed': True}))\n\n            artist = AssemblyArtist(assembly, layer=\"Assembly\")\n\n            artist.clear_layer()\n            artist.draw_nodes()\n            artist.draw_blocks(show_faces=False, show_edges=True)\n\n            if placed:\n                artist.draw_blocks(keys=placed, show_faces=True, show_edges=False)\n\n            artist.redraw()\n\n            key = AssemblyHelper.select_node(assembly)\n\n            sequence = assembly_block_building_sequence(assembly, key)\n\n            print(sequence)\n\n            keys = list(set(sequence) - set(placed))\n\n            artist.draw_blocks(keys=keys, show_faces=True, show_edges=False)\n            artist.redraw()\n\n        \"\"\"\n\n        course = assembly.network.node_attribute(key, 'course')\n\n        if course is None:\n            raise Exception(\"The courses of the assembly have not been identified.\")\n\n        sequence = []\n        seen = set()\n        tovisit = deque([(key, course + 1)])\n\n        while tovisit:\n            k, course_above = tovisit.popleft()\n\n            if k not in seen:\n                seen.add(k)\n                course = assembly.network.node_attribute(k, 'course')\n\n                if course_above == course + 1:\n                    sequence.append(k)\n                    for nbr in assembly.network.neighbors(k):\n                        if nbr not in seen:\n                            tovisit.append((nbr, course))\n\n        return sequence[::-1]\n\n\n\n\n\n\n\n\n\n\n\n\n        # def assembly_courses(self, tol=0.01):\n\n\n\n\n\n\n    #     \"\"\"Identify the courses in a wall of bricks.\n\n    #     Parameters\n    #     ----------\n    #     tol : float, optional\n    #         Tolerance for identifying courses.\n\n    #     Examples\n    #     --------\n    #     .. code-block:: python\n\n    #         pass\n\n    #     \"\"\"\n        # courses = []\n\n        # # all element keys\n        # elements = set(self.graph.nodes())\n        # #print(f\"All element keys: {elements}\")\n\n        # # base course keys\n        # c_min = min(self.graph.nodes_attribute('z'))\n        # #print(f\"Minimum z value: {c_min}\")\n\n        # base = set()\n        # for e in elements:\n        #     z = self.graph.node_attribute(key=e, name='z')\n        #     #print(f\"Element key: {e}, z value: {z}\")\n        #     if abs(z - c_min) < tol:\n        #         base.add(e)\n\n        # if base:\n        #     courses.append(list(base))\n        #     elements -= base\n\n        #     while elements:\n        #         c_min = min([self.graph.node_attribute(key=key, name='z') for key in elements])\n        #         base = set()\n        #         for e in elements:\n        #             z = self.graph.node_attribute(key=e, name='z')\n        #             if abs(z - c_min) < tol:\n        #                 base.add(e)\n\n        #         if base:\n        #             courses.append(list(base))\n        #             elements -= base\n\n        # # Sort courses by their minimum z value\n        # courses.sort(key=lambda course: min(self.graph.node_attribute(key, 'z') for key in course))\n\n        # # Print the sorted courses for debugging\n        # for i, course in enumerate(courses):\n        #     course_z_values = [self.graph.node_attribute(key, 'z') for key in course]\n        #     #print(f\"Course {i}: {course} with z values {course_z_values}\")\n\n        # # assign course id's to the corresponding blocks\n        # for i, course in enumerate(courses):\n        #     self.graph.nodes_attribute(name='course', value=i, keys=course)\n        #     # Print the course assignment for debugging\n        #     for key in course:\n        #         assigned_course = self.graph.node_attribute(key, 'course')\n        #         #print(f\"Node {key} assigned to course {assigned_course}\")\n\n        # #print(\"Reached the end of the method\")\n        # return courses",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}