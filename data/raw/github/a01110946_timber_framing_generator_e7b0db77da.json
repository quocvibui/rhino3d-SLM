{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/scripts/gh_sheathing_geometry_converter.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "scripts/gh_sheathing_geometry_converter.py",
  "instruction": "Sheathing Geometry Converter for Grasshopper.",
  "code": "# File: scripts/gh_sheathing_geometry_converter.py\n\"\"\"Sheathing Geometry Converter for Grasshopper.\n\nConverts sheathing JSON data to RhinoCommon geometry (Breps). This component\nis the final stage of the sheathing pipeline, transforming panel definitions\nwith UVW coordinates into 3D geometry using the wall's base plane.\n\nSupports both single-layer sheathing (from Sheathing Generator) and\nmulti-layer assemblies (from Multi-Layer Sheathing Generator). Multi-layer\nJSON is automatically flattened so all layer panels are converted uniformly.\n\nKey Features:\n1. Assembly-Safe Geometry Creation\n   - Uses RhinoCommonFactory for correct RhinoCommon assembly\n   - Avoids Rhino3dmIO/RhinoCommon mismatch issues\n   - Geometry verified for Grasshopper compatibility\n\n2. Wall-Aware Panel Placement\n   - Uses wall base_plane for UVW to world coordinate transformation\n   - Supports both exterior and interior face placement\n   - Handles panels with opening cutouts (boolean difference)\n\n3. Multi-Layer Support\n   - Accepts multi_layer_json from Multi-Layer Sheathing Generator\n   - Automatically flattens layer_results into single panel list per wall\n   - Preserves layer_name and w_offset metadata on each panel\n\n4. Flexible Filtering and Organization\n   - Filter by wall ID for single-wall visualization\n   - Multiple output formats (flat list, by-wall DataTree)\n   - Panel IDs and summary statistics\n\nEnvironment:\n    Rhino 8\n    Grasshopper\n    Python component (CPython 3)\n\nDependencies:\n    - Rhino.Geometry: Core geometry types\n    - Grasshopper: DataTree for organized output\n    - timber_framing_generator.utils.geometry_factory: RhinoCommonFactory\n    - timber_framing_generator.sheathing.sheathing_geometry: create_sheathing_breps\n\nPerformance Considerations:\n    - Processing time scales linearly with panel count\n    - Boolean difference for cutouts adds processing time\n    - Large walls with many openings may take several seconds\n\nUsage:\n    1. Connect 'sheathing_json' from Sheathing Generator\n    2. Connect 'walls_json' from Wall Analyzer (provides base planes)\n    3. Optionally set 'filter_wall' to show only one wall's sheathing\n    4. Set 'run' to True to execute\n    5. Connect 'breps' to display or bake geometry\n\nInput Requirements:\n    Sheathing JSON (sheathing_json) - str:\n        JSON string from Sheathing Generator or Multi-Layer Sheathing Generator.\n        Accepts both single-layer and multi-layer formats.\n        Required: Yes\n        Access: Item\n\n    Walls JSON (walls_json) - str:\n        JSON string from Wall Analyzer with base_plane for each wall\n        Required: Yes\n        Access: Item\n\n    Filter Wall (filter_wall) - str:\n        Wall ID to filter (e.g., \"1234567\" for single wall view)\n        Required: No (shows all walls)\n        Access: Item\n\n    Run (run) - bool:\n        Boolean to trigger execution\n        Required: Yes\n        Access: Item\n\nOutputs:\n    Breps (breps) - list[Brep]:\n        All sheathing panels as Brep geometry\n\n    By Wall (by_wall) - DataTree[Brep]:\n        Breps organized by wall ID in branches\n\n    Panel IDs (panel_ids) - list[str]:\n        Panel IDs for selection feedback\n\n    Panel Functions (panel_functions) - list[str]:\n        Layer function per panel (e.g., \"finish\", \"substrate\", \"structure\").\n        Parallel to breps and panel_ids. Use to group/filter panels by function.\n\n    Summary (summary) - str:\n        Text summary with panel counts and areas\n\n    Debug Info (debug_info) - str:\n        Debug information and status messages\n\nTechnical Details:\n    - Uses RhinoCommonFactory for correct assembly\n    - Panel geometry created from UVW corners and extrusion vector\n    - Wall base_plane provides coordinate transformation\n    - Cutouts use boolean difference operations\n\nError Handling:\n    - Invalid JSON returns empty outputs with error in debug_info\n    - Missing wall data logged but doesn't halt execution\n    - Invalid geometry creation logged and skipped\n\nAuthor: Timber Framing Generator\nVersion: 1.0.0\n\"\"\"\n\n# =============================================================================\n# Imports\n# =============================================================================\n\n# Standard library\nimport sys\nimport json\nimport traceback\n\n# .NET / CLR\nimport clr\nclr.AddReference(\"Grasshopper\")\nclr.AddReference(\"RhinoCommon\")\n\n# Rhino / Grasshopper\nimport Rhino.Geometry as rg\nimport Grasshopper\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\n\n# =============================================================================\n# Project Setup\n# =============================================================================\n\n# Primary: worktree / feature-branch path (contains latest sheathing code)\n# Fallback: main repo path (for when this file is used from the main checkout)\n_WORKTREE_PATH = r\"C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\tfg-sheathing-junctions\"\n_MAIN_REPO_PATH = r\"C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\timber_framing_generator\"\n\n# Clear timber_framing_generator modules AND 'src' to force fresh imports\n_modules_to_clear = [k for k in sys.modules.keys()\n                     if 'timber_framing_generator' in k or k == 'src']\nfor mod in _modules_to_clear:\n    del sys.modules[mod]\n\n# Ensure worktree path has highest priority (index 0) in sys.path.\nfor _p in (_WORKTREE_PATH, _MAIN_REPO_PATH):\n    while _p in sys.path:\n        sys.path.remove(_p)\nsys.path.insert(0, _MAIN_REPO_PATH)\nsys.path.insert(0, _WORKTREE_PATH)\n\nfrom src.timber_framing_generator.utils.geometry_factory import get_factory\nfrom src.timber_framing_generator.sheathing.sheathing_geometry import (\n    create_sheathing_breps,\n    create_sheathing_breps_batch,\n    SheathingPanelGeometry,\n)\n\n# =============================================================================\n# Constants\n# =============================================================================\n\nCOMPONENT_NAME = \"Sheathing Geometry Converter\"\nCOMPONENT_NICKNAME = \"SheathGeo\"\nCOMPONENT_MESSAGE = \"v1.4\"\n\n# Version marker â€” confirms updated script is running in GH\nprint(\"[SheathGeo] Script version v1.4 loaded (panel_functions output)\")\nCOMPONENT_CATEGORY = \"Timber Framing\"\nCOMPONENT_SUBCATEGORY = \"Geometry\"\n\n# =============================================================================\n# Logging Utilities\n# =============================================================================\n\ndef log_message(message, level=\"info\"):\n    \"\"\"Log to console and optionally add GH runtime message.\"\"\"\n    print(f\"[{level.upper()}] {message}\")\n\n    if level == \"warning\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning, message)\n    elif level == \"error\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Error, message)\n\n\ndef log_debug(message):\n    \"\"\"Log debug message (console only).\"\"\"\n    print(f\"[DEBUG] {message}\")\n\n\ndef log_info(message):\n    \"\"\"Log info message (console only).\"\"\"\n    print(f\"[INFO] {message}\")\n\n\ndef log_warning(message):\n    \"\"\"Log warning message (console + GH UI).\"\"\"\n    log_message(message, \"warning\")\n\n\ndef log_error(message):\n    \"\"\"Log error message (console + GH UI).\"\"\"\n    log_message(message, \"error\")\n\n# =============================================================================\n# Component Setup\n# =============================================================================\n\ndef setup_component():\n    \"\"\"Initialize and configure the Grasshopper component.\n\n    Configures:\n    1. Component metadata (name, category, etc.)\n    2. Input parameter names, descriptions, and access\n    3. Output parameter names and descriptions\n\n    Note: Output[0] is reserved for GH's internal 'out' - start from Output[1]\n\n    IMPORTANT: Type Hints cannot be set programmatically in Rhino 8.\n    They must be configured via UI: Right-click input -> Type hint -> Select type\n    \"\"\"\n    ghenv.Component.Name = COMPONENT_NAME\n    ghenv.Component.NickName = COMPONENT_NICKNAME\n    ghenv.Component.Message = COMPONENT_MESSAGE\n    ghenv.Component.Category = COMPONENT_CATEGORY\n    ghenv.Component.SubCategory = COMPONENT_SUBCATEGORY\n\n    # Configure inputs\n    # NOTE: Type Hints must be set via GH UI (right-click -> Type hint)\n    inputs = ghenv.Component.Params.Input\n    input_config = [\n        (\"Sheathing JSON\", \"sheathing_json\", \"JSON string from Sheathing Generator\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Walls JSON\", \"walls_json\", \"JSON string from Wall Analyzer (provides base_plane)\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Filter Wall\", \"filter_wall\", \"Wall ID to filter (single wall view)\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Run\", \"run\", \"Boolean to trigger execution\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n    ]\n\n    for i, (name, nick, desc, access) in enumerate(input_config):\n        if i < inputs.Count:\n            inputs[i].Name = name\n            inputs[i].NickName = nick\n            inputs[i].Description = desc\n            inputs[i].Access = access\n\n    # Configure outputs (start from index 1)\n    outputs = ghenv.Component.Params.Output\n    output_config = [\n        (\"Breps\", \"breps\", \"All sheathing panels as Breps\"),\n        (\"By Wall\", \"by_wall\", \"DataTree of Breps by wall ID\"),\n        (\"Panel IDs\", \"panel_ids\", \"Panel IDs for selection\"),\n        (\"Panel Functions\", \"panel_functions\", \"Layer function per panel (finish/substrate/structure)\"),\n        (\"Summary\", \"summary\", \"Panel counts and area summary\"),\n        (\"Debug Info\", \"debug_info\", \"Debug information and status\"),\n    ]\n\n    for i, (name, nick, desc) in enumerate(output_config):\n        idx = i + 1\n        if idx < outputs.Count:\n            outputs[idx].Name = name\n            outputs[idx].NickName = nick\n            outputs[idx].Description = desc\n\n# =============================================================================\n# Helper Functions\n# =============================================================================\n\ndef validate_inputs(sheathing_json, walls_json, run):\n    \"\"\"Validate component inputs.\n\n    Args:\n        sheathing_json: JSON string with sheathing data\n        walls_json: JSON string with wall data\n        run: Boolean trigger\n\n    Returns:\n        tuple: (is_valid, error_message)\n    \"\"\"\n    if not run:\n        return False, \"Component not running. Set 'run' to True.\"\n\n    if not sheathing_json:\n        return False, \"No sheathing_json input provided\"\n\n    if not walls_json:\n        return False, \"No walls_json input provided\"\n\n    try:\n        json.loads(sheathing_json)\n    except json.JSONDecodeError as e:\n        return False, f\"Invalid JSON in sheathing_json: {e}\"\n\n    try:\n        json.loads(walls_json)\n    except json.JSONDecodeError as e:\n        return False, f\"Invalid JSON in walls_json: {e}\"\n\n    return True, None\n\n\ndef parse_sheathing_json(sheathing_json):\n    \"\"\"Parse sheathing JSON, handling single-layer, multi-layer, and multi-wall formats.\n\n    Supports three formats:\n    1. Single-layer (from Sheathing Generator):\n       [{\"wall_id\": \"...\", \"sheathing_panels\": [...]}]\n    2. Multi-layer (from Multi-Layer Sheathing Generator):\n       [{\"wall_id\": \"...\", \"layer_results\": [{\"panels\": [...]}]}]\n    3. Single wall dict (either format)\n\n    Multi-layer results are flattened: per-layer panels are merged into a\n    single \"sheathing_panels\" list per wall so the geometry converter can\n    process them uniformly.\n\n    Args:\n        sheathing_json: JSON string with sheathing data\n\n    Returns:\n        list: List of sheathing data dictionaries (one per wall),\n              each containing \"sheathing_panels\" list\n    \"\"\"\n    data = json.loads(sheathing_json)\n\n    # Normalize to list\n    if isinstance(data, dict):\n        if \"wall_id\" in data:\n            data = [data]\n        elif \"walls\" in data and isinstance(data[\"walls\"], list):\n            data = data[\"walls\"]\n        elif \"results\" in data and isinstance(data[\"results\"], list):\n            data = data[\"results\"]\n        else:\n            data = [data]\n    elif not isinstance(data, list):\n        return []\n\n    # Check each entry for multi-layer format and flatten if needed\n    result = []\n    for entry in data:\n        if not isinstance(entry, dict):\n            continue\n\n        # Multi-layer format: has \"layer_results\" instead of \"sheathing_panels\"\n        if \"layer_results\" in entry and \"sheathing_panels\" not in entry:\n            flattened = _flatten_multi_layer_entry(entry)\n            result.append(flattened)\n        else:\n            # Standard single-layer format or already has sheathing_panels\n            result.append(entry)\n\n    return result\n\n\ndef _flatten_multi_layer_entry(entry):\n    \"\"\"Flatten multi-layer result into standard sheathing format.\n\n    Merges panels from all layer_results into a single sheathing_panels list,\n    adding layer_name and w_offset metadata to each panel dict.\n\n    Args:\n        entry: Multi-layer result dict with \"layer_results\" list.\n\n    Returns:\n        Dict with \"wall_id\" and \"sheathing_panels\" in standard format.\n    \"\"\"\n    wall_id = entry.get(\"wall_id\", \"unknown\")\n    all_panels = []\n\n    for layer_result in entry.get(\"layer_results\", []):\n        layer_name = layer_result.get(\"layer_name\", \"unknown\")\n        w_offset = layer_result.get(\"w_offset\")\n\n        layer_function = layer_result.get(\"layer_function\", \"unknown\")\n\n        for panel in layer_result.get(\"panels\", []):\n            # Add layer metadata to each panel for downstream use\n            enriched_panel = dict(panel)\n            enriched_panel[\"layer_name\"] = layer_name\n            enriched_panel[\"layer_function\"] = layer_function\n            if w_offset is not None:\n                enriched_panel[\"layer_w_offset\"] = w_offset\n            all_panels.append(enriched_panel)\n\n    log_info(\n        f\"Flattened multi-layer wall {wall_id}: \"\n        f\"{len(entry.get('layer_results', []))} layers -> \"\n        f\"{len(all_panels)} panels\"\n    )\n\n    return {\n        \"wall_id\": wall_id,\n        \"sheathing_panels\": all_panels,\n    }\n\n\ndef parse_walls_json(walls_json):\n    \"\"\"Parse walls JSON and index by wall_id.\n\n    Args:\n        walls_json: JSON string with wall data\n\n    Returns:\n        dict: Dictionary mapping wall_id to wall data\n    \"\"\"\n    data = json.loads(walls_json)\n\n    walls_by_id = {}\n\n    # If it's a list of walls\n    if isinstance(data, list):\n        for wall in data:\n            wall_id = str(wall.get(\"wall_id\", wall.get(\"id\", \"unknown\")))\n            walls_by_id[wall_id] = wall\n    # If it's a single wall\n    elif isinstance(data, dict):\n        if \"wall_id\" in data or \"id\" in data:\n            wall_id = str(data.get(\"wall_id\", data.get(\"id\", \"unknown\")))\n            walls_by_id[wall_id] = data\n        # Check if it has a \"walls\" key\n        elif \"walls\" in data and isinstance(data[\"walls\"], list):\n            for wall in data[\"walls\"]:\n                wall_id = str(wall.get(\"wall_id\", wall.get(\"id\", \"unknown\")))\n                walls_by_id[wall_id] = wall\n\n    return walls_by_id\n\n\ndef process_sheathing_geometry(sheathing_list, walls_by_id, wall_filter, factory):\n    \"\"\"Process all sheathing panels to geometry.\n\n    Args:\n        sheathing_list: List of sheathing data dictionaries\n        walls_by_id: Dictionary mapping wall_id to wall data\n        wall_filter: Wall ID to filter (or None for all)\n        factory: RhinoCommonFactory instance\n\n    Returns:\n        tuple: (breps, wall_groups, panel_ids, panel_functions, stats)\n    \"\"\"\n    breps = []\n    wall_groups = {}\n    panel_ids = []\n    panel_functions = []\n    stats = {\n        \"total_panels\": 0,\n        \"panels_with_cutouts\": 0,\n        \"total_area_gross\": 0.0,\n        \"total_area_net\": 0.0,\n        \"walls_processed\": set(),\n    }\n\n    # W offset diagnostics: track which path panels use\n    w_offset_diag = {\"layer_w\": 0, \"fallback\": 0, \"sample\": None}\n\n    for sheathing_data in sheathing_list:\n        wall_id = str(sheathing_data.get(\"wall_id\", \"unknown\"))\n\n        # Apply wall filter\n        if wall_filter and wall_id != wall_filter:\n            continue\n\n        # Get wall data for base_plane\n        wall_data = walls_by_id.get(wall_id, {})\n\n        # Skip if no base_plane available\n        if \"base_plane\" not in wall_data:\n            log_warning(f\"Wall {wall_id}: No base_plane found, skipping\")\n            continue\n\n        # W offset diagnostics: check first few panels for layer_w_offset\n        panels = sheathing_data.get(\"sheathing_panels\", [])\n        for p in panels[:3]:\n            lw = p.get(\"layer_w_offset\")\n            if lw is not None:\n                w_offset_diag[\"layer_w\"] += 1\n            else:\n                w_offset_diag[\"fallback\"] += 1\n            if w_offset_diag[\"sample\"] is None:\n                wall_t = wall_data.get(\"thickness\", wall_data.get(\"wall_thickness\", 0.5))\n                has_asm = \"wall_assembly\" in wall_data\n                w_offset_diag[\"sample\"] = (\n                    f\"wall={wall_id}, panel={p.get('id','?')}, \"\n                    f\"layer_w_offset={lw}, face={p.get('face','?')}, \"\n                    f\"wall_thickness={wall_t}, has_assembly={has_asm}\"\n                )\n        # Count remaining panels (beyond first 3)\n        for p in panels[3:]:\n            if p.get(\"layer_w_offset\") is not None:\n                w_offset_diag[\"layer_w\"] += 1\n            else:\n                w_offset_diag[\"fallback\"] += 1\n\n        # Build panel_id -> layer_function lookup from raw panel dicts\n        func_lookup = {}\n        for p in panels:\n            pid = p.get(\"id\")\n            if pid:\n                func_lookup[pid] = p.get(\"layer_function\", \"unknown\")\n\n        # Create geometry for this wall's panels\n        geometries = create_sheathing_breps(sheathing_data, wall_data, factory)\n\n        for geom in geometries:\n            if geom.brep is not None:\n                breps.append(geom.brep)\n                panel_ids.append(geom.panel_id)\n                panel_functions.append(func_lookup.get(geom.panel_id, \"unknown\"))\n\n                # Group by wall\n                if wall_id not in wall_groups:\n                    wall_groups[wall_id] = []\n                wall_groups[wall_id].append(geom.brep)\n\n                # Update stats\n                stats[\"total_panels\"] += 1\n                if geom.has_cutouts:\n                    stats[\"panels_with_cutouts\"] += 1\n                stats[\"total_area_gross\"] += geom.area_gross\n                stats[\"total_area_net\"] += geom.area_net\n                stats[\"walls_processed\"].add(wall_id)\n\n    # Append W offset diagnostics to stats\n    stats[\"w_offset_diag\"] = w_offset_diag\n\n    return breps, wall_groups, panel_ids, panel_functions, stats\n\n\ndef format_summary(stats):\n    \"\"\"Format summary statistics as text.\n\n    Args:\n        stats: Statistics dictionary from process_sheathing_geometry\n\n    Returns:\n        str: Formatted summary text\n    \"\"\"\n    lines = [\n        \"=== Sheathing Summary ===\",\n        f\"Total Panels: {stats['total_panels']}\",\n        f\"Panels with Cutouts: {stats['panels_with_cutouts']}\",\n        f\"Walls Processed: {len(stats['walls_processed'])}\",\n        f\"\",\n        f\"Gross Area: {stats['total_area_gross']:.1f} sq ft\",\n        f\"Net Area: {stats['total_area_net']:.1f} sq ft\",\n    ]\n\n    if stats[\"total_area_gross\"] > 0:\n        waste_pct = (1 - stats[\"total_area_net\"] / stats[\"total_area_gross\"]) * 100\n        lines.append(f\"Waste: {waste_pct:.1f}%\")\n\n    return \"\\n\".join(lines)\n\n# =============================================================================\n# Main Function\n# =============================================================================\n\ndef main():\n    \"\"\"Main entry point for the component.\n\n    Returns:\n        tuple: (breps, by_wall, panel_ids, panel_functions, summary, debug_info)\n    \"\"\"\n    setup_component()\n\n    # Initialize outputs\n    breps = []\n    by_wall = DataTree[object]()\n    panel_ids = []\n    panel_functions = []\n    summary = \"\"\n    log_lines = []\n\n    try:\n        # Unwrap Grasshopper list wrappers\n        sheathing_json_input = sheathing_json\n        if isinstance(sheathing_json, (list, tuple)):\n            sheathing_json_input = sheathing_json[0] if sheathing_json else None\n\n        walls_json_input = walls_json\n        if isinstance(walls_json, (list, tuple)):\n            walls_json_input = walls_json[0] if walls_json else None\n\n        filter_wall_input = filter_wall if filter_wall else None\n        if isinstance(filter_wall, (list, tuple)):\n            filter_wall_input = filter_wall[0] if filter_wall else None\n\n        # Validate inputs\n        is_valid, error_msg = validate_inputs(sheathing_json_input, walls_json_input, run)\n        if not is_valid:\n            if error_msg and \"not running\" not in error_msg.lower():\n                log_warning(error_msg)\n            return breps, by_wall, panel_ids, panel_functions, summary, error_msg\n\n        # Get geometry factory\n        factory = get_factory()\n\n        # Parse JSON inputs\n        sheathing_list = parse_sheathing_json(sheathing_json_input)\n        walls_by_id = parse_walls_json(walls_json_input)\n\n        log_lines.append(f\"Sheathing Geometry Converter v1.4\")\n        log_lines.append(f\"Sheathing entries: {len(sheathing_list)}\")\n        log_lines.append(f\"Walls available: {len(walls_by_id)}\")\n\n        # Panel U-position diagnostic: show first panel's u_start per wall/layer\n        log_lines.append(\"\")\n        log_lines.append(\"=== Panel U-Position Diagnostic ===\")\n        for sh_entry in sheathing_list:\n            sh_wid = sh_entry.get(\"wall_id\", \"?\")\n            sh_panels = sh_entry.get(\"sheathing_panels\", [])\n            # Group first panel per layer_name\n            seen_layers = set()\n            for p in sh_panels:\n                lname = p.get(\"layer_name\", p.get(\"face\", \"unknown\"))\n                if lname in seen_layers:\n                    continue\n                seen_layers.add(lname)\n                log_lines.append(\n                    f\"  Wall {sh_wid} | {lname}: \"\n                    f\"first_panel u_start={p.get('u_start', '?'):.4f}, \"\n                    f\"u_end={p.get('u_end', '?'):.4f}\"\n                )\n        log_lines.append(\"\")\n\n        # Wall orientation diagnostic: print base_plane for each wall\n        for wid, wdata in walls_by_id.items():\n            bp = wdata.get(\"base_plane\", {})\n            orig = bp.get(\"origin\", {})\n            zax = bp.get(\"z_axis\", {})\n            xax = bp.get(\"x_axis\", {})\n            log_lines.append(\n                f\"  Wall {wid}: origin=({orig.get('x',0):.4f}, \"\n                f\"{orig.get('y',0):.4f}, {orig.get('z',0):.4f}), \"\n                f\"x_axis=({xax.get('x',0):.3f}, {xax.get('y',0):.3f}, \"\n                f\"{xax.get('z',0):.3f}), \"\n                f\"z_axis=({zax.get('x',0):.3f}, {zax.get('y',0):.3f}, \"\n                f\"{zax.get('z',0):.3f})\"\n            )\n        log_lines.append(\"\")\n\n        # Parse filter_wall\n        wall_filter = str(filter_wall_input).strip() if filter_wall_input else None\n        if wall_filter:\n            log_lines.append(f\"Wall Filter: {wall_filter}\")\n\n        # Process geometry\n        breps, wall_groups, panel_ids, panel_functions, stats = process_sheathing_geometry(\n            sheathing_list, walls_by_id, wall_filter, factory\n        )\n\n        # Build by_wall DataTree\n        sorted_walls = sorted(wall_groups.keys())\n        for branch_idx, wall_id_key in enumerate(sorted_walls):\n            path = GH_Path(branch_idx)\n            for brep in wall_groups[wall_id_key]:\n                by_wall.Add(brep, path)\n\n        # Create summary\n        summary = format_summary(stats)\n\n        # Debug info\n        log_lines.append(\"\")\n        log_lines.append(f\"Walls Processed: {len(stats['walls_processed'])}\")\n        log_lines.append(f\"Wall IDs: {sorted(stats['walls_processed'])}\")\n        log_lines.append(\"\")\n        log_lines.append(f\"Total Breps: {len(breps)}\")\n        log_lines.append(f\"Panels with Cutouts: {stats['panels_with_cutouts']}\")\n\n        # W offset diagnostics\n        w_diag = stats.get(\"w_offset_diag\", {})\n        log_lines.append(\"\")\n        log_lines.append(\"=== W Offset Diagnostics ===\")\n        log_lines.append(\n            f\"Panels with layer_w_offset: {w_diag.get('layer_w', 0)}\"\n        )\n        log_lines.append(\n            f\"Panels using fallback: {w_diag.get('fallback', 0)}\"\n        )\n        if w_diag.get(\"sample\"):\n            log_lines.append(f\"Sample: {w_diag['sample']}\")\n\n        # === BBOX DIAGNOSTICS ===\n        # Show actual world-space bounding boxes to verify sheathing positions\n        log_lines.append(\"\")\n        log_lines.append(\"=== Sheathing BBOX Diagnostic ===\")\n        for pi, pbrep in enumerate(breps[:4]):\n            try:\n                bb = pbrep.GetBoundingBox(True)\n                pid = panel_ids[pi] if pi < len(panel_ids) else \"?\"\n                log_lines.append(\n                    f\"  Panel[{pi}] ({pid}): \"\n                    f\"min=({bb.Min.X:.4f}, {bb.Min.Y:.4f}, {bb.Min.Z:.4f})  \"\n                    f\"max=({bb.Max.X:.4f}, {bb.Max.Y:.4f}, {bb.Max.Z:.4f})  \"\n                    f\"size=({bb.Max.X-bb.Min.X:.4f}, \"\n                    f\"{bb.Max.Y-bb.Min.Y:.4f}, \"\n                    f\"{bb.Max.Z-bb.Min.Z:.4f})\"\n                )\n            except Exception as ex:\n                log_lines.append(f\"  Panel[{pi}]: bbox error: {ex}\")\n\n    except Exception as e:\n        log_error(f\"Unexpected error: {str(e)}\")\n        log_lines.append(f\"ERROR: {str(e)}\")\n        log_lines.append(traceback.format_exc())\n\n    # Diagnostic: confirm panel_functions data\n    print(f\"[DEBUG] panel_functions: {len(panel_functions)} items, \"\n          f\"sample={panel_functions[:3] if panel_functions else 'empty'}\")\n\n    return breps, by_wall, panel_ids, panel_functions, summary, \"\\n\".join(log_lines)\n\n# =============================================================================\n# Execution\n# =============================================================================\n\n# Set default values for optional inputs\ntry:\n    sheathing_json\nexcept NameError:\n    sheathing_json = None\n\ntry:\n    walls_json\nexcept NameError:\n    walls_json = None\n\ntry:\n    filter_wall\nexcept NameError:\n    filter_wall = None\n\ntry:\n    run\nexcept NameError:\n    run = False\n\n# Execute main\nif __name__ == \"__main__\":\n    breps, by_wall, panel_ids, panel_functions, summary, debug_info = main()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}