{
  "source_url": "https://github.com/andrewili/shape-grammar-engine/blob/2859d8021442542561bdd1387deebc85e26f2d03/package_package/package/translators/exporter_old.py",
  "repo": "andrewili/shape-grammar-engine",
  "repo_stars": 1,
  "repo_description": null,
  "license": "unknown",
  "filepath": "package_package/package/translators/exporter_old.py",
  "instruction": "Exporter old",
  "code": "from package.scripts import component_name as cn\nfrom package.scripts import layer as l\nfrom package.model import labeled_shape as ls\nfrom package.model import point\nfrom package.scripts import rule as r\nimport rhinoscriptsyntax as rs\n\nclass Exporter(object):\n    def __init__(self):\n        self.class_name = 'Exporter'\n\n    ### Initial shape methods\n    def export_initial_shape(self):             ##  03-02 16:00\n        \"\"\"Writes the repr string of an initial shape to a file named \n        <initial_shape>.is. Returns:\n            str             the repr string\n        \"\"\"\n        new_shape = self._get_labeled_shape()\n        shape_repr = repr(new_shape)\n        self._write_file('is', shape_repr)\n\n    def _get_labeled_shape(self):               ##  03-02 16:57\n        \"\"\"Returns:\n            LabeledShape    the SG object identified by the user\n        \"\"\"\n        labeled_shape_name = self._get_labeled_shape_name()\n        new_labeled_shape = self._get_labeled_shape_from_labeled_shape_name(\n            labeled_shape_name)\n        return new_labeled_shape\n\n    def _get_labeled_shape_name(self):          ##  03-02 16:03\n        \"\"\"Prompts the user to select a labeled shape tag, if one is not \n        already selected. Returns:\n            str             the name of a shape\n        \"\"\"                                     ##  How about entering name?\n        labeled_shape_tag = rs.GetObject(filter='annotation')\n        labeled_shape_name = rs.get_name_from_tag(labeled_shape_tag)\n        return labeled_shape_name\n\n    ### Rule methods\n    def export_rule(self):                      ##  04-21 11:27 03-02 16:00\n        \"\"\"Prompts the user to select a rule name tag. Writes the rule's repr \n        string to a file named <rule_name>.rul. Returns:\n            str             the repr string\n        \"\"\"\n        rule_name = self._get_rule_name()\n        rule_spec = self._get_spec_from_rule_name(rule_name)\n        rule_repr = self._get_repr_from_rule_spec(rule_spec)\n        self._write_file('rul', rule_repr)\n\n    def _get_rule_name(self):\n        \"\"\"Prompts the user to select a rule name tag, if one is not already \n        selected. Returns:\n            str             the name of a rule\n        \"\"\"\n        while not self._a_rule_name_tag_is_selected():\n            rule_name_tag = self._get_rule_name_tag()\n            rs.SelectObject(rule_name_tag)\n        rule_name = self._get_rule_name_from(rule_name_tag)\n        return rule_name\n\n    def _a_rule_name_tag_is_selected(self):\n        \"\"\"Returns:\n            boolean         True, if the selected object is a rule name tag\n                            False, otherwise\n        \"\"\"\n        return_value = True\n        selected_objects = rs.SelectedObjects()\n        if not len(selected_objects) == 1:\n            return_value = False\n        else:\n            selected_object = selected_objects[0]\n            if not (\n                rs.IsText(selected_object) and\n                cn.ComponentName._component_name_is_listed(\n                    'rule', \n                    rs.TextObjectText(selected_object))\n            ):\n                return_value = False\n        return return_value\n\n    def _get_rule_name_tag(self):\n        \"\"\"Prompts the user to select a rule name tag. Returns:\n            guid            the guid of a rule name tag\n        \"\"\"\n        message = \"Select a rule name tag\"\n        text_filter = 512\n        rule_name_tag = rs.GetObject(message, text_filter)\n        return rule_name_tag\n\n    def _get_rule_name_from(self, rule_name_tag):\n        \"\"\"Receives:\n            rule_name_tag   the guid of a text object; the type is guaranteed \n                            by the calling method\n        Returns:\n            str             the text of the text object, i.e., the rule name\n        \"\"\"\n        return_value = rs.TextObjectText(rule_name_tag)\n        return return_value\n\n    def _get_spec_from_rule_name(self, rule_name):  ##  05-09 08:43\n        \"\"\"Receives:\n            rule_name       str; value guaranteed by the calling method\n        Returns:\n            rule_spec       (rule_name, left_shape_spec, right_shape_spec), if\n                            successful\n                            rule_name       str\n                            left_shape_spec (   shape_name,\n                                                line_specs,\n                                                lpoint_specs)\n                            right_shape_spec\n                                            (   shape_name,\n                                                line_specs,\n                                                lpoint_specs)\n            None otherwise  ##  implement!\n        \"\"\"\n        method_name = '_get_spec_from_rule_name'\n        left_shape_name = r.Rule._get_shape_name_from_rule_name('left')\n        right_shape_name = r.Rule._get_shape_name_from_rule_name('right')\n        left_shape_spec = self._get_spec_from_labeled_shape_name(\n            left_shape_name)\n        right_shape_spec = self._get_spec_from_labeled_shape_name(\n            right_shape_name)\n        rule_spec = (rule_name, left_shape_spec, right_shape_spec)\n        return rule_spec\n\n    def _get_spec_from_labeled_shape_name(self, shape_name):    ##  05-09 08:58\n        \"\"\"Receives:\n            shape_name      str; value guaranteed?\n        Returns:\n            shape_spec      (   shape_name,\n                                ordered_line_specs,\n                                ordered_lpoint_specs)\n                            shape_name:     str\n                            ordered_line_specs:\n                                            [line_spec, ...]\n                            ordered_lpoint_specs:\n                                            [lpoint_spec, ...]\n                            line_spec:      (point_spec, point_spec)\n                            lpoint_spec:    (str, point_spec)\n                            point_spec:     (num, num, num)\n        \"\"\"\n        guids = self._get_guids_from_shape_name(shape_name)\n        line_guids, lpoint_guids = self._sort_guids(guids)\n        ordered_line_specs = self._get_ordered_specs_from_line_guids(\n            line_guids)\n        ordered_lpoint_specs = self._get_ordered_specs_from_lpoint_guids(\n            lpoint_guids)\n        shape_spec = (shape_name, ordered_line_specs, ordered_lpoint_specs)\n        return shape_spec\n\n    def _get_guids_from_shape_name(self, shape_name):   ##  05-10 06:47\n        \"\"\"Receives:\n            shape_name      the name of a shape in a rule; type and value\n                            guaranteed by the calling function\n        Returns:\n            [guid, ...]     a list of the guids (lines and text objects) in\n                            the shape, i.e., excluding the frame\n        \"\"\"\n        guids = rs.ObjectsByLayer(shape_name)\n        shape_guids = []\n        for guid in guids:\n            if not rs.IsBlockInstance(guid):\n                shape_guids.append(guid)\n        return shape_guids\n\n    def _get_ordered_specs_from_line_guids(self, line_guids):   ##  05-10 06:50\n        \"\"\"Receives:\n            line_guids  [guid, ...]; a list of line guids\n        Returns:\n            ordered_line_specs\n                        [line_spec, ...], if successful\n                        line_spec:      (point_spec, point_spec)\n                        point_spec:     (num, num, num)\n            None        otherwise\n        \"\"\"\n        line_specs = []\n        for line_guid in line_guids:\n            # line_spec = self._get_ordered_spec_from_line_guid(line_guid)\n            line_spec = self._get_spec_from_line_guid(line_guid)\n            line_specs.append(line_spec)\n        ordered_line_specs = sorted(line_specs)\n        return ordered_line_specs\n\n    # def _get_ordered_spec_from_line_guid(self, line_guid):  ##  05-10 07:26\n        # \"\"\"Receives:\n        #     line_guid\n        # Returns:\n        #     ordered_line_spec\n        #                 (p1_spec, p2_spec), where p1 < p2\n        # \"\"\"\n        # point1_guid, point2_guid = self._get_point_guids_from_line_guid(\n        #     line_guid)\n        # p1_spec = self._get_spec_from_point_guid(point1_guid)\n        # p2_spec = self._get_spec_from_point_guid(point2_guid)\n        # line_spec = (p1_spec, p2_spec)\n        # ordered_line_spec = sorted(line_spec)\n        # return ordered_line_spec\n\n    # def _get_point_guids_from_line_guid(self, line_guid):   ##  05-10 07:28\n        # \"\"\"Receives:\n        #     line_guid\n        # Returns:\n        #     (point_guid, point_guid)\n        # \"\"\"\n        # return (point1_guid, point2_guid)\n\n    # def _get_spec_from_point_guid(self, point_guid):    ##  05-10 07:29\n        # \"\"\"Receives:\n        #     point_guid\n        # Returns:\n        #     (num, num, num)\n        # \"\"\"\n        # return point_spec\n\n    def _get_ordered_specs_from_lpoint_guids(self, lpoint_guids):\n        \"\"\"Receives:\n            lpoint_guids\n                        [guid, ...]; a list of lpoint guids\n        Returns:\n            ordered_lpoint_specs\n                        [lpoint_spec, ...], if successful\n                        lpoint_spec:    (label, point_spec)\n                        label:          str\n                        point_spec:     (num, num, num)\n            None        otherwise\n        \"\"\"\n        lpoint_specs = []\n        for lpoint_guid in lpoint_guids:\n            lpoint_spec = self._get_spec_from_lpoint_guid(lpoint_guid)\n            lpoint_specs.append(lpoint_spec)\n        ordered_lpoint_specs = sorted(lpoint_specs)\n        return ordered_lpoint_specs\n\n    # def _get_shape_guids_from_rule_name(self, rule_name):   ##  05-02 10:17\n        # \"\"\"Receives:\n        #     rule_name       str; the name of a rule; type and value guaranteed \n        #                     by the calling method\n        # Returns:\n        #     (   [guid, ...] the left shape guids (lines and text objects)\n        #         [guid, ...] the right shape guids (lines and text objects)\n        #     )               if successful       ##  shape names?\n        #     None            otherwise\n        # \"\"\"\n        # left_shape_name, right_shape_name = (\n        #     self._get_shape_names_from_rule_name(rule_name))\n        # left_shape_guids = self._get_guids_from_shape_name(\n        #     left_shape_name)\n        # right_shape_guids = self._get_guids_from_shape_name(\n        #     right_shape_name)\n        # return (left_shape_guids, right_shape_guids)\n\n    # def _get_shape_names_from_rule_name(self, rule_name):\n        # \"\"\"Receives:\n        #     rule_name       str; the name of a rule; type and value guaranteed\n        #                     upstream\n        # Returns:\n        #     str             the name of the left shape\n        #     str             the name of the right shape\n        # \"\"\"\n        # left_shape_name = r.Rule._get_shape_name_from_rule_name(\n        #     rule_name, 'left')\n        # right_shape_name = r.Rule._get_shape_name_from_rule_name(\n        #     rule_name, 'right')\n        # return (left_shape_name, right_shape_name)\n\n    # def _get_shape_spec_from_shape_guids(self, shape_guids):    ##  05-09 08:20\n        # \"\"\"Receives:\n        #     shape_guids     [guid, ...]\n        # Returns:\n        #     shape_name      str\n        #     line_specs      [((num, num, num), (num, num, num)), ...]. A list\n        #                     of line specs\n        #     lpoint_specs    [(str, (num, num, num)), ...]. A list of labeled \n        #                     point specs\n        # \"\"\"\n        # return (shape_name, line_specs, lpoint_specs)\n\n    # def _get_rule_spec_from_guids(\n        # self, rule_name, left_shape_guids, right_shape_guids\n    # ):                                          ##  04-23 09:05\n        # \"\"\"Receives:\n        #     rule_name       str. The name of a rule\n        #     left_shape_guids\n        #                     [guid, ...]. The guids of the left shape\n        #     right_shape_guids\n        #                     [guid, ...]. The guids of the right shape\n        # Returns:\n        #     rule_name       str\n        #     left_shape_spec ([line_spec, ...], [lpoint_spec, ...])\n        #     right_shape_spec\n        #                     ([line_spec, ...], [lpoint_spec, ...])\n        # \"\"\"\n        \n                                                ##  to do\n    def _get_repr_from_rule_spec(self, rule_spec):\n        \"\"\"Receives:\n            rule_spec: (rule_name, left_shape_spec, right_shape_spec)\n                            rule_name: str\n                            left_shape_spec:\n                                ([line_spec, ...], [lpoint_spec, ...])\n                            right_shape_spec:\n                                ([line_spec, ...], [lpoint_spec, ...])\n        Returns:\n            str             the rule's repr, i.e., rul-format string\n        \"\"\"\n        pass\n\n    # def _get_rule(self):\n        # \"\"\"Returns:\n        #     Rule            the SG object identified by the user\n        # \"\"\"\n        # rule_name = self._get_selected_rule_name()\n        # labeled_shape_names = (\n        #     self._get_labeled_shape_names_from_rule_name(rule_name))\n        # left_labeled_shape, right_labeled_shape = (\n        #     self._get_labeled_shapes_from_labeled_shape_names(\n        #         labeled_shape_names))\n        # new_rule = rule.Rule.new(left_labeled_shape, right_labeled_shape)\n        # return new_rule\n\n    # def _get_selected_rule_name(self):          ##  03-03 08:15\n        # \"\"\"Prompts the user to select a rule name tag, if one is not already \n        # selected. Returns:\n        #     str             the name of a rule\n        # \"\"\"\n        # selected_objects = rs.SelectedObjects()\n        # rule_name_tag = self._get_rule_name_tag_from(selected_objects)\n        # if not rule_name_tag:\n        #     message = \"Please select the name tag of a rule\"\n        #     annotation_filter = 512\n        #     rule_name_tag = rs.GetObject(message, annotation_filter)\n        # rule_name = rs.TextObjectText(rule_name_tag)\n        # return rule_name\n\n    # def _get_rule_name_tag_from(self, objects): ##  03-13 10:21\n        # \"\"\"Extracts a rule name tag from a list of objects. Receives: \n        #     objects         [guid, ...]\n        # Returns:\n        #     guid            the guid of a rule name tag, if any\n        #     None            otherwise\n        # \"\"\"\n        # pass\n\n    # def _get_labeled_shape_names_from_rule_name(self, rule_name):\n        # \"\"\"Gets the labeled shape names associated with the rule name. \n        # Receives:\n        #     rule_name       str\n        # Returns:\n        #     (str, str)      the left and right labeled shape names\n        # \"\"\"\n        # left_and_right_labeled_shape_names = 'shape_names'\n        # return left_and_right_labeled_shape_names\n\n    # def _get_labeled_shapes_from_labeled_shape_names(\n    #     self, labeled_shape_names\n    # ):\n        # \"\"\"Receives:\n        #     labeled_shape_names\n        #                     (str, str). The names of the left and right \n        #                     labeled shapes\n        # Returns:\n        #     [LabeledShape, LabeledShape]\n        #                     the left and right labeled shapes\n        # \"\"\"\n        # labeled_shapes = []\n        # for name in labeled_shape_names:\n        #     labeled_shape = self._get_labeled_shape_from_labeled_shape_name(\n        #         name)\n        #     labeled_shapes.append(labeled_shape)\n        # return labeled_shapes\n\n    ### Shared methods\n    def _get_labeled_shape_from_labeled_shape_name(\n        self, labeled_shape_name\n    ):                                          ##  03-14 08:10\n        \"\"\"Receives:\n            labeled_shape_name\n                            str; type guaranteed by the calling method\n        Returns:\n            LabeledShape    the SG labeled shape identified by the name, if\n                            successful\n            None            otherwise\n        \"\"\"\n        method_name = '_get_labeled_shape_from_labeled_shape_name'\n        try:\n            if not l.Layer.layer_name_is_in_use(labeled_shape_name):\n                raise ValueError\n        except ValueError:\n            message = \"There is no labeled shape with that name\"\n            print(\"%s.%s:\\n    %s\" % (self.class_name, method_name, message))\n            return_value = None\n        else:\n            line_specs, lpoint_specs = (\n                self._get_specs_from_labeled_shape_name(\n                    labeled_shape_name))\n            new_labeled_shape = ls.LabeledShape.new_from_specs(\n                line_specs, lpoint_specs)            ##  trouble here\n            return_value = new_labeled_shape\n        finally:\n            return return_value\n\n    def _get_specs_from_labeled_shape_name(self, labeled_shape_name):\n        \"\"\"Gets the specs of a labeled shape. Receives:\n            labeled_shape_name\n                            str. Value confirmed by the calling method\n        Returns:\n            ([line_spec, ..], [labeled_point_spec, ...])\n                            1. A list of line specs (point3d, point3d)\n                            2. A list of labeled point specs: (point3d, str)\n                            if successful\n            None            otherwise\n        \"\"\"\n        selected = True\n        guids = rs.ObjectsByLayer(labeled_shape_name)\n        line_guids, lpoint_guids = self._sort_guids(guids)\n        line_specs = self._get_line_specs(line_guids)\n        lpoint_specs = self._get_lpoint_specs(lpoint_guids)\n        return (line_specs, lpoint_specs)\n\n    def _sort_guids(self, guids):\n        \"\"\"Sorts guids by object type. Receives:\n            guids           [guid, ...], n >= 0\n        Returns:\n            (line_guids, labeled_point_guids)\n                            labeled_point_guids (textdot guids)\n        \"\"\"\n        curve_type = 4\n        textdot_type = 8192\n        line_guids = self._extract_line_guids(guids)\n        lpoint_guids = self._extract_lpoint_guids(guids)\n        return (line_guids, lpoint_guids)\n\n    def _extract_line_guids(self, guids):\n        \"\"\"Receives:\n            [guid, ...]\n        Returns:\n            [guid, ...]     a list of line guids\n        \"\"\"\n        line_guids = []\n        for guid in guids:\n            if rs.IsCurve(guid):\n                line_guids.append(guid)\n        return line_guids\n\n    def _extract_lpoint_guids(self, guids):\n        \"\"\"Receives:\n            [guid, ...]\n        Returns:\n            [guid, ...]     a list of lpoint guids\n        \"\"\"\n        lpoint_guids = []\n        for guid in guids:\n            if rs.IsTextDot(guid):\n                lpoint_guids.append(guid)\n        return lpoint_guids\n\n    def _get_line_specs(self, line_guids):\n        \"\"\"Receives:\n            line_guids      [line_guid, ...], n >= 0\n        Returns:\n            [line_spec, ...], ordered\n                            line_spec: ((num, num, num), (num, num, num)),\n                            if successful\n            None            otherwise\n        \"\"\"\n        method_name = \"_get_line_specs\"\n        try:\n            if not (\n                type(line_guids) == list and\n                self._are_line_guids(line_guids)\n            ):\n                raise TypeError\n        except TypeError:\n            message = \"The argument must be a list of line guids\"\n            print(\"%s.%s:\\n    %s\" % (self.class_name, method_name, message))\n            return_value = None\n        else:\n            line_specs = []\n            for line_guid in line_guids:\n                line_spec = self._get_spec_from_line_guid(line_guid)\n                line_specs.append(line_spec)\n            return_value = sorted(line_specs)\n        finally:\n            return return_value\n\n    def _are_line_guids(self, guids):\n        value = True\n        for guid in guids:\n            if not rs.IsLine(guid):\n                value = False\n                break\n        return value\n\n    def _get_spec_from_line_guid(self, line_guid):  ##  05-10 08:26\n        \"\"\"Receives:\n            line_guid\n        Returns:\n            ((num, num, num), (num, num, num))\n                            line spec\n        \"\"\"\n        x1, y1, z1 = rs.CurveStartPoint(line_guid)\n        x2, y2, z2 = rs.CurveEndPoint(line_guid)\n        sg_p1 = point.Point(x1, y1, z1)\n        sg_p2 = point.Point(x2, y2, z2)\n        spec1 = sg_p1.spec\n        spec2 = sg_p2.spec\n        return (spec1, spec2)\n\n    def _get_lpoint_specs(self, lpoint_guids):\n        \"\"\"Receives:\n            lpoint_guids    [lpoint_guid, ...], n >= 0\n        Returns:\n            [lpoint_spec, ...], ordered\n                            lpoint_spec: ((num, num, num), str), if \n                            successful\n            None            otherwise\n        \"\"\"\n        method_name = \"_get_lpoint_specs\"\n        try:\n            if not (\n                type(lpoint_guids) == list and\n                self._are_lpoint_guids(lpoint_guids)\n            ):\n                raise TypeError\n        except TypeError:\n            message = \"The argument must be a list of labeled point guids\"\n            print(\"%s.%s:\\n    %s\" % (self.class_name, method_name, message))\n            return_value = None\n        else:\n            lpoint_specs = []\n            for lpoint_guid in lpoint_guids:\n                lpoint_spec = self._get_lpoint_spec(lpoint_guid)\n                lpoint_specs.append(lpoint_spec)\n            return_value = sorted(lpoint_specs)\n        finally:\n            return return_value\n\n    def _are_lpoint_guids(self, guids):\n        value = True\n        for guid in guids:\n            if not rs.IsTextDot(guid):\n                value = False\n                break\n        return value\n\n    def _get_lpoint_spec(self, lpoint_guid):\n        \"\"\"Receives:\n            lpoint_guid     textdot guid. Verified by calling method\n        Returns:\n            ((num, num, num), str)              ##  Note: SG spec: (x, y, str)\n                            the labeled point spec\n        \"\"\"\n        point = rs.TextDotPoint(lpoint_guid)\n        point_spec = tuple(point)\n        label = rs.TextDotText(lpoint_guid)\n        return (point_spec, label)\n\n    def _write_file(self, file_type, shape_name, string):\n        \"\"\"Writes a string to a file with the name shape_name and the \n        appropriate suffix. Receives:\n            file_type       str: 'is' | 'rul' | 'dat'\n            shape_name      str\n            string          str\n        Returns:\n            str             the string, if successful\n            None            otherwise\n        \"\"\"\n        method_name = \"_write_file\"\n        legal_file_types = ['is', 'rul', 'dat']\n        try:\n            if not (\n                type(file_type) == str and\n                type(string) == str\n            ):\n                raise TypeError\n            if not file_type in legal_file_types:\n                raise ValueError\n        except TypeError:\n            message = \"The file_type and string must both be strings\"\n            print(\"%s.%s:\\n    %s\" % (self.class_name, method_name, message))\n            return_value = None\n        except ValueError:\n            message = \"The file type must be 'is', 'rul', or 'dat\"\n            print(\"%s.%s:\\n    %s\" % (self.class_name, method_name, message))\n            return_value = None\n        else:\n            filter = self._get_filter_from_file_type(file_type)\n            file_name = (\n                rs.SaveFileName('Save shape as', filter, '', shape_name))\n            if not file_name:\n                return\n            file = open(file_name, 'w')\n            empty_line = ''\n            shape_string = '\\n'.join([\n                string,\n                empty_line])\n            file.write(shape_string)\n            file.close()\n            print(shape_string)\n            return_value = string\n        finally:\n            return return_value\n\n    def _get_filter_from_file_type(self, file_type):\n        \"\"\"Constructs the filter string appropriate to the file type. \n        Receives:\n            file_type       str\n        Returns:\n            str             the filter string\n        \"\"\"\n        file_type_caps = file_type.upper()\n        filter_string = \"%s file (*.%s)|*.%s|All files (*.*)|*.*||\" % (\n            file_type_caps, file_type, file_type)\n        return filter_string\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}