{
  "source_url": "https://github.com/bsamiee/Parametric_Arsenal/blob/54ec3f5a7fc2c671cb7bc4601772820e625a1904/rhino/plugins/ArchBuilder/libs/geometry/curves.py",
  "repo": "bsamiee/Parametric_Arsenal",
  "repo_stars": 0,
  "repo_description": "Rhino 8 Plugins and Scripts - A comprehensive monorepo for architectural automation, parametric design, and creative workflows",
  "license": "MIT",
  "filepath": "rhino/plugins/ArchBuilder/libs/geometry/curves.py",
  "instruction": "Title         : curves.py\nAuthor        : Bardia Samiee\nProject       : Parametric Forge\nLicense       : MIT\nPath          : rhino/plugins/ArchBuilder/libs/geometry/curves.py",
  "code": "\"\"\"\nTitle         : curves.py\nAuthor        : Bardia Samiee\nProject       : Parametric Forge\nLicense       : MIT\nPath          : rhino/plugins/ArchBuilder/libs/geometry/curves.py\n\nDescription\n----------------------------------------------------------------------------\nCurve construction utilities for arch geometry.\nProvides functions to create and manipulate Rhino curves for arch profiles.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom typing import Callable\n\nimport numpy as np\nimport Rhino.Geometry as rg\n\n\n# --- Circular Segment Radius ----------------------------------------------\ndef circular_segment_radius(half_span: float, rise: float) -> float:\n    \"\"\"Calculate radius for a circular segment given span and rise.\n\n    For a circular arc passing through three points (left base, apex, right base),\n    this calculates the required radius using the chord-sagitta relationship.\n\n    Args:\n        half_span: Half the horizontal span of the arch\n        rise: Maximum vertical height of the arch\n\n    Returns:\n        Radius of the circular arc\n    \"\"\"\n    return (half_span**2) / (2.0 * rise) + 0.5 * rise\n\n\n# --- Arc from Center Endpoints --------------------------------------------\ndef arc_from_center_endpoints(center: rg.Point3d, start: rg.Point3d, end: rg.Point3d) -> rg.Arc:\n    \"\"\"Create arc from center point and two endpoints.\n\n    Uses the proper Rhino Arc constructor with Circle and angle interval.\n    Ensures the arc takes the shorter path between endpoints.\n\n    Args:\n        center: Center point of the arc\n        start: Start point on the arc\n        end: End point on the arc\n\n    Returns:\n        Arc passing through both endpoints with given center\n\n    Note:\n        The function validates that both endpoints are equidistant from center\n        and uses the average radius if there are minor discrepancies.\n    \"\"\"\n    # Calculate radius (should be same for both points)\n    radius_start = center.DistanceTo(start)\n    radius_end = center.DistanceTo(end)\n\n    # Use average radius if there's a small discrepancy\n    radius = (radius_start + radius_end) * 0.5\n\n    # Create plane at center with Z-axis normal\n    plane = rg.Plane(center, rg.Vector3d.ZAxis)\n    circle = rg.Circle(plane, radius)\n\n    # Calculate angles using atan2 (robust for all quadrants)\n    angle_start = math.atan2(start.Y - center.Y, start.X - center.X)\n    angle_end = math.atan2(end.Y - center.Y, end.X - center.X)\n\n    # Ensure we take the shorter arc path (< π)\n    # Adjust end angle to be within π of start angle\n    angle_diff = angle_end - angle_start\n\n    # Normalize angle difference to [-π, π]\n    while angle_diff > math.pi:\n        angle_end -= 2 * math.pi\n        angle_diff -= 2 * math.pi\n    while angle_diff < -math.pi:\n        angle_end += 2 * math.pi\n        angle_diff += 2 * math.pi\n\n    # Create arc with the angle interval\n    return rg.Arc(circle, rg.Interval(angle_start, angle_end))\n\n\ndef arc_curve(points: list[rg.Point3d]) -> rg.Curve:\n    \"\"\"Create a smooth curve through a list of points.\n\n    Args:\n        points: List of points to interpolate\n\n    Returns:\n        NURBS curve passing through all points\n\n    Raises:\n        ValueError: If fewer than 3 points are provided\n    \"\"\"\n    if len(points) < 3:\n        raise ValueError(\"At least three points required to build a curve.\")\n    return rg.NurbsCurve.CreateInterpolatedCurve(points, 3)\n\n\n# --- Profile Curve --------------------------------------------------------\ndef profile_curve(span: float, func: Callable[[float], float], samples: int = 64) -> rg.Curve:\n    \"\"\"Create a curve from a mathematical function.\n\n    Generates a curve by sampling a function over the span interval.\n\n    Args:\n        span: Total horizontal span of the curve\n        func: Function mapping x-coordinate to y-coordinate\n        samples: Number of points to sample along the curve\n\n    Returns:\n        NURBS curve representing the function profile\n    \"\"\"\n    b = span * 0.5\n    xs = np.linspace(-b, b, samples)\n    points = [rg.Point3d(float(x), float(func(x)), 0.0) for x in xs]\n    return arc_curve(points)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}