{
  "source_url": "https://github.com/evdanil/cn-tool/blob/d83b0c68efb5aaf10f09f1b77ddd5c992157f4af/utils/diagnostics.py",
  "repo": "evdanil/cn-tool",
  "repo_stars": 1,
  "repo_description": "Utility allowing to receive information from Infoblox API",
  "license": "unknown",
  "filepath": "utils/diagnostics.py",
  "instruction": "utils/diagnostics.py",
  "code": "# utils/diagnostics.py\n\nimport re\nimport ipaddress\nimport subprocess\nimport socket\nfrom typing import Dict, Any\n\nfrom core.base import ScriptContext\n\n\ndef _validate_ip(ip_str: str) -> bool:\n    \"\"\"A simple local validator for IP addresses.\"\"\"\n    if not isinstance(ip_str, str):\n        return False\n    # This regex is sufficient for basic validation.\n    ip_regex = r\"^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])$\"\n    return bool(re.match(ip_regex, ip_str))\n\n\ndef _resolve_hostname(ctx: ScriptContext, ip_address: str) -> str:\n    \"\"\"Performs a reverse DNS lookup for a given IP address.\"\"\"\n    if not ip_address or not _validate_ip(ip_address):\n        return \"Invalid IP\"\n    try:\n        # Use a timeout to prevent long hangs on unresponsive DNS servers.\n        socket.setdefaulttimeout(3)\n        hostname, _, _ = socket.gethostbyaddr(ip_address)\n        return hostname.rstrip('.').split('.')[0]\n    except (socket.herror, socket.gaierror, socket.timeout):\n        ctx.logger.debug(f\"DNS resolution failed for {ip_address}\")\n        return ip_address  # Return the IP itself on failure\n    except Exception as e:\n        ctx.logger.warning(f\"Unexpected error resolving hostname for {ip_address}: {e}\")\n        return ip_address\n    finally:\n        socket.setdefaulttimeout(None)  # Reset to default\n\n\ndef _run_mtr_and_get_last_hop(ctx: ScriptContext, target_ip: str) -> Dict[str, Any]:\n    \"\"\"\n    Runs MTR, parses the output, and returns the IP, hostname, and number of the last responding hop.\n    \"\"\"\n    result = {'pre_last_hop_ip': \"Unreachable\", 'last_hop_ip': \"Unreachable\", 'last_hop_hostname': \"N/A\", 'hop_count': 0, 'mtr_output': ''}\n\n    mtr_base_cmd_str = 'mtr --report --report-cycles=1 --timeout=1 --max-ttl=30 --no-dns '\n    mtr_hop_re_str = re.compile(r\"^\\s*(\\d+)\\.\\|--\\s*([\\w.-]+|\\?\\?\\?)(?:\\s+\\(([\\d\\.]+)\\))?\\s*\")\n\n    mtr_command = mtr_base_cmd_str.split() + [target_ip]\n    ctx.logger.info(f\"Running MTR: {' '.join(mtr_command)}\")\n\n    try:\n        process = subprocess.run(\n            mtr_command,\n            capture_output=True,\n            text=True,\n            timeout=45,  # Generous timeout for the whole MTR process\n            check=False\n        )\n        mtr_output = process.stdout\n    except FileNotFoundError:\n        ctx.logger.error(f\"MTR command not found. Ensure '{mtr_base_cmd_str.split()[0]}' is in system PATH.\")\n        result['last_hop_ip'] = \"MTR_NOT_FOUND\"\n        return result\n    except subprocess.TimeoutExpired:\n        ctx.logger.warning(f\"MTR command timed out for {target_ip}\")\n        result['last_hop_ip'] = \"MTR_TIMEOUT\"\n        return result\n    except Exception as e:\n        ctx.logger.error(f\"An unexpected error occurred while running MTR for {target_ip}: {e}\", exc_info=True)\n        result['last_hop_ip'] = \"MTR_EXEC_ERROR\"\n        return result\n\n    valid_hops = []\n    result['mtr_output'] = mtr_output\n    for line in mtr_output.splitlines():\n        match = re.match(mtr_hop_re_str, line)\n        if match:\n            # Group 2 is display name (host or IP or ???), Group 3 is IP in parens (optional)\n            display_name, ip_in_parens = match.group(2), match.group(3)\n            hop_ip = ip_in_parens if ip_in_parens and _validate_ip(ip_in_parens) else display_name\n\n            if hop_ip != \"???\" and _validate_ip(hop_ip):\n                valid_hops.append({'hop_num': int(match.group(1)), 'ip': hop_ip})\n\n    if valid_hops:\n        ctx.logger.debug(f'Dumping valid_hops: {valid_hops}')\n        last_hop = valid_hops[-1]\n        # If the last hop is the target itself, we are more interested in the hop *before* it.\n        if last_hop['ip'] == target_ip and len(valid_hops) > 1:\n            result['pre_last_hop_ip'] = valid_hops[-2]['ip']\n\n        result['last_hop_ip'] = last_hop['ip']\n        result['last_hop_hostname'] = _resolve_hostname(ctx, last_hop['ip'])\n        result['hop_count'] = last_hop['hop_num']\n\n    return result\n\n\ndef process_mtr_target(ctx: ScriptContext, original_target: str) -> Dict[str, Any]:\n    \"\"\"\n    Processes a single target: resolves it to an IP and runs MTR.\n    Returns a generic dictionary for the core module and plugins.\n    \"\"\"\n    result = {\n        'target': original_target,\n        'pre_last_hop_ip': \"Unreachable\",\n        'last_hop_ip': \"Unreachable\",\n        'last_hop_hostname': \"N/A\",\n        'hop_count': 0,\n        'status': \"OK\",  # Default status, can be overwritten\n        'mtr_output': ''\n    }\n\n    try:\n        # Use ipaddress to handle both single IPs and networks gracefully\n        net = ipaddress.ip_network(original_target, strict=False)\n        # For networks, pick the first usable host to trace to\n        if isinstance(net, (ipaddress.IPv4Network, ipaddress.IPv6Network)) and net.num_addresses > 2:\n            mtr_target_ip = str(next(net.hosts()))\n        else:\n            mtr_target_ip = str(net.network_address)\n    except ValueError:\n        result['status'] = \"Invalid Input\"\n        return result\n\n    mtr_result = _run_mtr_and_get_last_hop(ctx, mtr_target_ip)\n    result.update(mtr_result)\n\n    if result['last_hop_ip'] in [\"Unreachable\", \"MTR_TIMEOUT\", \"MTR_NOT_FOUND\", \"MTR_EXEC_ERROR\"]:\n        result['status'] = result['last_hop_ip']  # The status is the error itself\n\n    return result\n",
  "language": "python",
  "imports": [],
  "has_docstring": true
}