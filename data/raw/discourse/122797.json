{
  "source_url": "https://discourse.mcneel.com/t/creating-a-geometry-in-python-using-curves-from-mesh/122797",
  "topic_id": 122797,
  "title": "Creating a geometry in python using curves from mesh",
  "question": "Hello, im trying to recreate this type of component (hexagonal) using GhPython. I created the mesh and have the curves from the mesh, and i also have the normal center point for each hexagone. Im trying to create the geometry in Python to loft, extrude and create a circle in the middle using random values as radius.\n\n\nI dont really know where to start in my script and i was wondering if someone could help me!\n\n\nThank you\n\n\nLa+Voute+de+LeFevre5\n1000×666 261 KB\n\n\n \n\n\nCapture d’écran, le 2021-04-21 à 17.59.18\n1422×702 499 KB",
  "code_blocks": [
    {
      "code": "from ghpythonlib import treehelpers\nimport Rhino.Geometry as rg\nimport random\nimport math\n\nrandom.seed(Seed)\n\n\ndef normal_at(mesh, test_pt, max_distance=0.01):\n    \"\"\"Gets the normal at a mesh point that is close the the test point.\n\n    Args:\n      mesh (Rhino.Geometry.NgonMesh): A mesh with computed face normals\n      test_pt (Rhino.Geometry.Point3d): A test point to search from\n      max_distance (float): Optional upper bound on the distance\n        from the test point to the mesh, by default 0.01\n\n    Returns:\n      The normal at the closest mesh point.\n    \"\"\"\n    closest_mesh_pt = mesh.ClosestMeshPoint(test_pt, max_distance)\n    if closest_mesh_pt is None:\n        return\n    return mesh.NormalAt(closest_mesh_pt)\n\n\ndef average_vector(vectors):\n    \"\"\"Returns the arithmetic average vector of a list of vectors.\"\"\"\n    a = rg.Vector3d.Zero\n    for v in vectors:\n        a += v\n    a /= len(vectors)\n    return a\n\n\ndef average_point(points):\n    \"\"\"Returns the arithmetic average point of a list of points.\"\"\"\n    a = rg.Point3d.Origin\n    for pt in points:\n        a += pt\n    a /= len(points)\n    return a\n\n\ndef create_polyline(vertices, closed=True):\n    \"\"\"Returns a polyline connecting a number of vertices.\"\"\"\n    pline = rg.Polyline()\n    for v in vertices:\n        pline.Add(v)\n    if closed:\n        pline.Add(vertices[0])\n    return pline\n\n\ndef tween_between(a, b, count):\n    \"\"\"Returns an x-amount of tween curves between the polylines a and b.\n        Both polylines must have the same number of vertices.\"\"\"\n    div_pts = []\n    if count < 1:\n        return []\n    for j in xrange(len(a)):\n        line = rg.LineCurve(a[j], b[j])\n        params = line.DivideByCount(count + 1, False)\n        div_pts.append([line.PointAt(t) for t in params])        \n    tween_crvs = []\n    for j in xrange(count):\n        pline = rg.Polyline()\n        for pts in div_pts:\n            pline.Add(pts[j])\n        tween_crvs.append(rg.PolylineCurve(pline))\n    return tween_crvs\n\n\na = []\n\nif __name__ == \"__main__\":\n\n    NPB = []  # non-planar boundaries\n    BDS = []  # boundary-defining side subdivisions\n    OPB = []  # offset, planar boundaries\n    OPS = []  # planar, offset face-defining subdivisions\n    CHB = []  # circular, planar hole boundaries\n    DDA = []  # dome-defining arcs\n    DDR = []  # dome-defining rings\n\n    if NgonMesh is not None:\n        NgonMesh.FaceNormals.ComputeFaceNormals()\n        section_arcs = []\n        section_rings = []\n        offset_subdivs = []\n        boundary_subdivs = []\n        \n        for i in xrange(NgonMesh.Ngons.Count):  # loop each ngon face\n            vertex_indices = NgonMesh.Ngons.GetNgon(i).BoundaryVertexIndexList()\n            vertices = [\n                rg.Point3d(NgonMesh.Vertices[j]) for j in vertex_indices\n            ]\n            boundary_pline = create_polyline(vertices)  # face boundary\n            boundary_pline.MergeColinearSegments(AngleTol, True)\n\n            # Divide the initial, non-planar boundary\n            div_pts = []  # face boundary division points\n            ia = NumArcs + 1\n            for j in xrange(boundary_pline.SegmentCount):\n                segment = boundary_pline.SegmentAt(j)\n                div_pts.append(segment.From)\n                crv = rg.LineCurve(segment)\n                params = crv.DivideByCount(ia, False)\n                for t in params:\n                    div_pts.append(crv.PointAt(t))\n\n            div_pts_normals = [\n                normal_at(NgonMesh, p, float(\"inf\")) for p in div_pts\n            ]\n            ngon_pline = create_polyline(div_pts)\n            NPB.append(ngon_pline)\n\n            ngon_center = NgonMesh.ClosestPoint(average_point(div_pts))\n            ngon_normal = average_vector(div_pts_normals)\n            ngon_normal.Unitize()\n            if Flip:\n                ngon_normal.Reverse()\n\n            # Define the offset, planar boundary\n            offset_center = ngon_center + ngon_normal * OutHeight\n            plane = rg.Plane(offset_center, ngon_normal)\n\n            ll = 1.0 if OutHeight == 0.0 else OutHeight + OutHeight * 0.5\n            offset_pts = []\n            for j in xrange(len(div_pts)):\n                start = div_pts[j]\n                end = start + (div_pts_normals[j] * ll)\n                ray = rg.Line(start, end)\n                _, t = rg.Intersect.Intersection.LinePlane(ray, plane)\n                offset_pts.append(ray.PointAt(t))\n\n            offset_pline = create_polyline(offset_pts)  # is planar\n            OPB.append(offset_pline)\n            offset_center = average_point(offset_pts)\n\n            # Evaluate the random center hole radius\n            max_ngon_radius = float(\"inf\")\n            for j in xrange(offset_pline.Count - 1):\n                dist2_vertex = offset_center.DistanceToSquared(offset_pline[j])\n                midpt = (offset_pline[j] + offset_pline[j + 1]) * 0.5\n                dist2_midpt = offset_center.DistanceToSquared(midpt)\n                min_dist = math.sqrt(min(dist2_vertex, dist2_midpt))\n                if min_dist < max_ngon_radius:\n                    max_ngon_radius = min_dist\n            max_radius = max_ngon_radius - max_ngon_radius * MinOffset\n            min_radius = min(MinRadius, max_radius)\n            radius = random.uniform(min_radius, max_radius)\n            rest_radius = max_ngon_radius - radius\n            \n            # Construct the backset circle which can define an inner thickness\n            backset_height = max(0.0, min(InHeight, OutHeight))\n            backset_center = offset_center - (plane.ZAxis * backset_height)\n            backset_plane = rg.Plane(backset_center, plane.ZAxis)\n            backset_circle = rg.Circle(backset_plane, backset_center, radius)\n\n            # Construct the dome-defining arcs\n            arcs = []\n            for j in xrange(len(offset_pts)):\n                closest_pt = backset_circle.ClosestPoint(offset_pts[j])\n                end_pts = [closest_pt, div_pts[j]]  # arc start and end points\n                end_indices = [0, 1]  # indices of the end points\n                lengths = [p.DistanceToSquared(offset_pts[j]) for p in end_pts]\n                sorted_indices = [\n                    p for _, p in sorted(zip(lengths, end_indices))\n                ]\n                fi = sorted_indices[-1]\n                li = sorted_indices[0]\n                tangent = offset_pts[j] - end_pts[fi]\n                arc = rg.Arc(end_pts[fi], tangent, end_pts[li])\n                if fi == end_indices[-1]:\n                    arc.Reverse()\n                arcs.append(arc)\n            section_arcs.append(arcs)\n\n            # Divide the arcs\n            r = NumRings + 1  # number of rings\n            arc_pts = []\n            min_arc_div_dist2 = float(\"inf\")\n            for arc in arcs:\n                crv = rg.ArcCurve(arc)\n                params = crv.DivideByCount(r, True)\n                div_pts = [crv.PointAt(t) for t in params]\n                dist2 = div_pts[0].DistanceToSquared(div_pts[1])\n                if dist2 < min_arc_div_dist2:\n                    min_arc_div_dist2 = dist2\n                arc_pts.append(div_pts)\n\n            # Construct the dome-defining rings\n            rings = []\n            for j in xrange(r):\n                ring_pts = []\n                for points in arc_pts:\n                    ring_pts.append(points[j])\n                ring_pline = create_polyline(ring_pts)\n                rings.append(ring_pline)\n\n                # Construct the offset center hole boundary\n            backset_ring = rings[0]\n            offset_ring = rg.Polyline()\n            for vtx in backset_ring:\n                offset_vtx = vtx + backset_plane.ZAxis * backset_height\n                offset_ring.Add(offset_vtx)\n            CHB.append(offset_ring)\n\n            if backset_height == 0.0:  # backset_ring == rings[0]\n                rings.pop(0)  # avoid duplicate polylines\n            section_rings.append([r.ToPolylineCurve() for r in rings])\n\n            # Subdivide the planar, offset face in relation to the arc divisions\n            num = math.floor((rest_radius) / math.sqrt(min_arc_div_dist2)) - 1\n            face_subdivs = tween_between(offset_pline, offset_ring, num)\n            offset_subdivs.append(face_subdivs)\n            \n            # Subdivide the side faces in relation to the arc divisions\n            sides_subdivs = tween_between(ngon_pline, offset_pline, SideDivs)\n            boundary_subdivs.append(sides_subdivs)\n\n    BDS = treehelpers.list_to_tree(boundary_subdivs)\n    OPS = treehelpers.list_to_tree(offset_subdivs)\n    DDA = treehelpers.list_to_tree(section_arcs)\n    DDR = treehelpers.list_to_tree(section_rings)",
      "language": "python",
      "author": "diff-arch",
      "post_number": 17,
      "is_solution": false
    }
  ],
  "tags": [
    "file-io",
    "geometry",
    "grasshopper",
    "mesh",
    "python",
    "rhinocommon"
  ],
  "has_accepted_answer": false,
  "category_id": 2,
  "posts_count": 19,
  "views": 3222
}