{
  "source_url": "https://github.com/eastnoob/TianParameterModelForOpt/blob/b463c06915742c215bc8077d7de086e369f03299/python_scripts/SplitBase.py",
  "repo": "eastnoob/TianParameterModelForOpt",
  "repo_stars": 0,
  "repo_description": "对于硕士论文参数化模型的C#重置，目标为提升可控性",
  "license": "unknown",
  "filepath": "python_scripts/SplitBase.py",
  "instruction": "Split base",
  "code": "﻿# coding=utf-8\n\"\"\"\n                       _oo0oo_\n                      o8888888o\n                      88\" . \"88\n                      (| -_- |)\n                      0\\  =  /0\n                    ___/`---'\\___\n                  .' \\\\|     |// '.\n                 / \\\\|||  :  |||// \\\n                / _||||| -:- |||||- \\\n               |   | \\\\\\  - /// |   |\n               | \\_|  ''\\---/''  |_/ |\n               \\  .-\\__  '-'  ___/-. /\n             ___'. .'  /--.--\\  `. .'___\n          .\"\" '<  `.___\\_<|>_/___.' >' \"\".\n         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /\n     =====`-.____`.___ \\_____/___.-`___.-'=====\n                       `=---='\n\n\n     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n           佛祖保佑       永不宕机     永无BUG\n\"\"\"\n\nimport Rhino.Geometry as rh\nfrom scriptcontext import doc\nimport rhinoscriptsyntax as rs\n\nds = _split_direction\nss = _split_degree\n#curve = _project_base\n\ntol = doc.ModelAbsoluteTolerance\n\n## setback the base\nbase_polyline = rh.PolylineCurve.ToPolyline(rh.Curve.ToPolyline(_project_base, tol, tol, 1000, 1000))\ncentpt = rh.Polyline.CenterPoint(base_polyline)\nXYplane = rh.Plane(centpt, rs.coerce3dvector([0, 0, 1]))\n\ncondition = rh.CurveOffsetCornerStyle.Sharp\narray_setback = rh.Curve.Offset(_project_base, XYplane, _setback, tol, condition)\n\nif len(array_setback) > 1:\n    jointed_setback = rh.Curve.JoinCurves(array_setback)\nelse:\n    jointed_setback = array_setback\n\ncurve = jointed_setback[0]\n\n## function to split one curve by direction (d) and split (s) parameter\n\ndef rotate_bounding_box(base, bounding, angle):\n    ## Not be used\n    \n    centpt = rh.AreaMassProperties.Compute(_project_base).Centroid\n    scale = rh.Transform.Scale(rh.Plane.WorldXY, 5, 5, 1)\n    rotate = rh.Transform.Rotation(angle, rh.Plane.WorldXY.ZAxis, centpt)\n    \n    bounding.Transform(scale)\n    bounding.Transform(rotate)\n    \n    return bounding\n\ndef split_curve(curve, d, s):\n    #    bb = rh.Curve.GetBoundingBox(\n    \n    bb = curve.GetBoundingBox(True)\n#    bbo = curve.GetBoundingBox(True)\n#    bb = rotate_bounding_box(curve, bbo, _rotate_angle)\n    \n    base_pt = rh.Point3d(bb.Min.X, bb.Min.Y, 0.0)\n    \n    x = bb.Max.X - bb.Min.X\n    y = bb.Max.Y - bb.Min.Y\n#    print(x, y)\n    dims = [x, y]\n    vecs = [rh.Vector3d(1,0,0), rh.Vector3d(0,1,0)]\n    \n    vec_1 = vecs[d] * dims[d] * s\n    new_pt_1 = rh.Point3d(base_pt)\n    new_pt_1.Transform(rh.Transform.Translation(vec_1))\n    \n    other_dir = abs(d - 1)\n    \n    vec_2 = vecs[other_dir] * dims[other_dir]\n    new_pt_2 = rh.Point3d(new_pt_1)\n    new_pt_2.Transform(rh.Transform.Translation(vec_2))\n    \n    \n    split_line = rh.Line(new_pt_1, new_pt_2).ToNurbsCurve()\n    \n    inter = rh.Intersect.Intersection.CurveCurve(curve, split_line, tol, tol)\n    p = [i.ParameterA for i in inter]\n    \n    if len(p) > 2:\n        for i in range(len(p)):\n            \n            pt1 = curve.PointAt(p[i-1])\n            pt2 = curve.PointAt(p[i])\n            \n            line = rh.Line(pt1, pt2).ToNurbsCurve()\n            cp = line.PointAtNormalizedLength(0.5)\n            \n            if (curve.Contains(cp) == rh.PointContainment.Inside and \n                    len(rh.Intersect.Intersection.CurveCurve(curve, line, tol, tol)) <= 2):\n                p = [p[i-1], p[i]]\n                break\n    \n    pieces = curve.Split(p)\n    \n    curves = []\n    \n    for piece in pieces:\n        line = rh.Line(piece.PointAtStart, piece.PointAtEnd)\n        curve = rh.NurbsCurve.JoinCurves([piece, line.ToNurbsCurve()])\n        curves += curve\n    \n    return curves\n\n\ndef split_recursively(curves, ds, ss):\n    \n    if len(ds) == 0 or len(ss) == 0:\n        return curves\n    \n    curve = curves.pop(0)\n    d = ds.pop(0)\n    s = ss.pop(0)\n    \n    curves += split_curve(curve, d, s)\n    \n    print(len(curves))\n    \n    return split_recursively(curves, ds, ss)\nprint(curve)\nprint(ds)\nprint(ss)\n\nsplited_space_ = split_recursively([curve], ds, ss)\nsetbacked_base_ = curve",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}