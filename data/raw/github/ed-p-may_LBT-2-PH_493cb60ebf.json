{
  "source_url": "https://github.com/ed-p-may/LBT-2-PH/blob/3c2bbdf0cb26deb92d36b870aeb920cbc31d8da2/scripts/LBT2PH/ground.py",
  "repo": "ed-p-may/LBT-2-PH",
  "repo_stars": 12,
  "repo_description": "LBT2PH is a free toolkit for creating PHPP energy models from Ladybug Tools v1.0+ definitions.",
  "license": "GPL-3.0",
  "filepath": "scripts/LBT2PH/ground.py",
  "instruction": "Ground",
  "code": "import ghpythonlib.components as ghc\nimport rhinoscriptsyntax as rs\nimport json\nimport Grasshopper.Kernel as ghK\nimport random\nfrom ladybug_rhino.fromgeometry import from_face3d \n\nclass PHPP_Ground_Floor_Element:\n    \"\"\" A 'Floor' surface element for a ground object \"\"\"\n\n    def __init__(self, _ghenv):\n        self.default_perim_psi = 0.5 #W/mk\n        self.ghenv = _ghenv\n        self.id = random.randint(1000,9999)\n        self.hb_host_room_name = None\n        self.floor_area = None\n        self.floor_U_value = None\n        self.perim_len = None\n        self.perim_psi_X_len = None\n    \n    def set_values_by_hb_room(self, _hb_room ):\n        \"\"\" Finds the Floor-Type face(s) in a Honeybee Room and gets Params\n        \n        Resets self.floor_area and self.floor_U_value based on the values found in\n        the Honeybee Zone. If more than one Floor face is found, creates a \n        weighted U-Value average of all the faces.\n        \n        Args:\n            self:\n            _hb_room: A Single Honeybee Room object\n        Returns:\n            None\n        \"\"\"\n        def is_floor(_face):\n            if str(face.type) != 'Floor':\n                return False\n            if str(face.boundary_condition) != 'Ground' and str(face.boundary_condition) != 'Outdoors':\n                return False\n            return True\n        \n        #-----------------------------------------------------------------------\n        # Get all the data from the HB-Room Floor surfaces\n        floor_areas = []\n        area_weighted_u_values = []\n        perim_curve_lengths = []\n        for face in _hb_room:\n            if not is_floor(face):\n                continue\n            \n            u_floor =  face.properties.energy.construction.u_factor\n            floor_areas.append( face.area )\n            area_weighted_u_values.append( u_floor * face.area )\n            \n            face_surface = from_face3d( face.geometry )\n            perim_curve = ghc.JoinCurves(list(face_surface.DuplicateEdgeCurves()), False)\n            perim_curve_lengths.append( ghc.Length( perim_curve ) )\n\n        #-----------------------------------------------------------------------\n        # Set the Floor Element params\n        if floor_areas and area_weighted_u_values:\n            self.floor_area = sum(floor_areas)\n            self.floor_U_value = sum(area_weighted_u_values) / sum(floor_areas)\n            self.perim_len = sum( perim_curve_lengths )\n\n    def set_surface_values(self, _srfc_guids):\n        \"\"\"Pulls Rhino Scene parameters for a list of Surface Object Guids\n        \n        Takes in a list of surface GUIDs and goes to Rhino. Looks in their\n        UserText to get any user applied parameter data. Will also find the\n        surface area of each surface in the list. \n        \n        Calculates the total surface area of all surfaces in the list, as well as\n        the area-weighted U-Value of the total.\n        \n        Will return tuple(0, 0) on any trouble getting parameter values or any fails\n        \n        Args:\n            self:\n            _flrSrfcs (list): A list of Surface GUIDs to look at in the Rhino Scene\n        Returns:\n            totalFloorArea, floorUValue (tuple): The total floor area (m2) and the area weighted U-Value\n        \"\"\"\n        \n        if _srfc_guids == None:\n            return 0, 0\n        \n        if len(_srfc_guids) > 0:\n            floorAreas = []\n            weightedUvales = []\n            \n            for srfcGUID in _srfc_guids:\n                # Get the Surface Area Params\n                srfcGeom = rs.coercebrep(srfcGUID)\n                if srfcGeom:\n                    srfcArea = ghc.Area(srfcGeom).area\n                    floorAreas.append( srfcArea )\n                    \n                    # Get the Surface U-Values Params\n                    srfcUvalue = self._get_surface_U_value(srfcGUID)\n                    weightedUvales.append(srfcUvalue * srfcArea )\n                else:\n                    floorAreas.append( 1 )\n                    weightedUvales.append( 1 )\n                    \n                    warning = 'Error: Input into _floor_surfaces is not a Surface?\\n'\\\n                    'Please ensure inputs are Surface Breps only.'\n                    self.ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Warning, warning)\n            \n            totalFloorArea = sum(floorAreas)\n            floorUValue = sum(weightedUvales) / totalFloorArea\n        \n        else:\n            totalFloorArea = 0\n            floorUValue = 0\n        \n        self.floor_area = totalFloorArea\n        self.floor_U_value = floorUValue\n    \n    def set_perim_edge_values(self, _crv_guids, _ud_psi):\n        \"\"\"Pulls Rhino Scene parameters for a list of Curve Objects\n        \n        Takes in a list of curve GUIDs and goes to Rhino. Looks in their\n        UserText to get any user applied parameter data.\n        \n        Calculates the sum of all curve lengths (m) in the list, as well as\n        the total Psi-Value * Length (W/m) of all curves in the list.\n        \n        Will return tuple(0, 0) on any trouble getting parameter values or any fails\n        \n        Args:\n            self:\n            _perimCrvs (list): A list of Curve GUIDs to look at in the Rhino Scene\n        Returns:\n            totalLen, psiXlen (tuple): The total length of all curves in the list (m) and the total Psi*Len value (W/m)\n        \"\"\"\n        \n        def _getLengthIfNumber(_in, _psi):\n            try:\n                length = float(_in)\n            except:\n                length = None\n            \n            try:\n                psi = float(_psi)\n            except:\n                psi = self.default_perim_psi\n        \n            return length, psi\n        \n        if _crv_guids == None:\n            return None\n\n        if len(_crv_guids)==0:\n            return None\n        \n        psiXlen = 0\n        totalLen = 0\n        for crvGUID in _crv_guids:                \n            # See if its just Numbers passed in. If so, use them and break out\n            length, crvPsiValue = _getLengthIfNumber(crvGUID, _ud_psi)\n            if length and crvPsiValue:\n                totalLen += length\n                psiXlen += (length * crvPsiValue)\n                continue\n            \n            isCrvGeom = rs.coercecurve(crvGUID)\n            isBrepGeom = rs.coercebrep(crvGUID)\n            \n            if isCrvGeom:\n                crvLen = ghc.Length(isCrvGeom)\n                try:\n                    crvPsiValue = float(_ud_psi)\n                except:\n                    crvPsiValue, warning = self._get_curve_psi_value(crvGUID)\n                \n                totalLen += crvLen\n                psiXlen += (crvLen * crvPsiValue)\n            elif isBrepGeom:\n                srfcEdges = ghc.DeconstructBrep(isBrepGeom).edges\n                srfcPerim = ghc.JoinCurves(srfcEdges, False)\n                crvLen = ghc.Length(srfcPerim)\n                \n                try:\n                    crvPsiValue = float(_ud_psi)\n                except:\n                    crvPsiValue = self.default_perim_psi # Default 0.05 W/mk\n                    warning = 'Note: You passed in a surface without any Psi-Values applied.\\n'\\\n                    'I will apply a default {} W/mk Psi-Value to ALL the edges of the\\n'\\\n                    'surface passed in.'.format( self.default_perim_psi )\n                    self.ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Warning, warning)\n                \n                totalLen += crvLen\n                psiXlen += (crvLen * crvPsiValue)\n            else:\n                warning = 'Error in GROUND: Input into _exposedPerimCrvs is not a Curve or Surface?\\n'\\\n                'Please ensure inputs are Curve / Polyline or Surface only.'\n                self.ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Warning, warning)\n        self.perim_len = totalLen\n        self.perim_psi_X_len = psiXlen\n            \n    def _get_curve_psi_value(self, _perimCrvGUID):\n        \"\"\"Takes in a single Curve GUID and returns its length and Psi*Len\n        \n        Will look at the UserText of the curve to get the Psi Value Type\n        Name and then the Document UserText library to get the Psi-Value of the\n        Type. \n        \n        Returns 0.5 W/mk as default on any errors.\n        \n        Args:\n            self:\n            _perimCrvGUID (GUID): A single GUID \n        Returns:\n            crvPsiValue (float): The Curve's UserText Param for 'Psi-Value' if found.\n        \"\"\"\n        \n        warning = None\n        crvPsiValueName = rs.GetUserText(_perimCrvGUID, 'Typename')\n        if crvPsiValueName:\n            for k in rs.GetDocumentUserText():\n                if 'PHPP_lib_TB' not in k:\n                    continue\n                \n                try:\n                    d = json.loads(rs.GetDocumentUserText(k))\n                    if d.get('Name', None) == crvPsiValueName:\n                        psiValParams = rs.GetDocumentUserText(k)\n                        break\n                except:\n                    psiValParams = None\n            else:\n                psiValParams = None\n            \n            if psiValParams:\n                psiValParams = json.loads(psiValParams)\n                crvPsiValue = psiValParams.get('psiValue', self.default_perim_psi)\n                if crvPsiValue < 0:\n                    warning = 'Warning: Negative Psi-Value found for type: \"{}\"\\nApplying 0.0 W/mk for that edge.'.format(crvPsiValueName)\n                    self.ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Warning, warning)\n                    crvPsiValue = 0\n            else:   \n                warning = ('Warning: Could not find a Psi-Value type in the',\n                'Rhino Document UserText with the name \"{}?\"'.format(crvPsiValueName.upper()),\n                'Check your Document UserText library to make sure that you have',\n                'your most recent Thermal Bridge library file loaded?',\n                'For now applying a Psi-Value of {} w/mk for this edge.'.format(self.default_perim_psi))\n                self.ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Warning, warning)\n                crvPsiValue = self.default_perim_psi\n        else:\n            warning = 'Warning: could not find a Psi-Value type in the\\n'\\\n            'UserText document library for one or more edges?\\n'\\\n            'Check your Document UserText library to make sure that you have\\n'\\\n            'your most recent Thermal Bridge library file loaded?\\n'\\\n            'For now applying a Psi-Value of {} w/mk for this edge.'.format(self.default_perim_psi)\n            self.ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Warning, warning)\n            crvPsiValue = self.default_perim_psi\n        \n        return crvPsiValue, warning\n    \n    def _get_surface_U_value(self, _srfcGUID):\n        \"\"\"Takes in a single Surface GUID and returns its U-Value Param\n        \n        Will look at the UserText of the surface to get the EP Construction\n        Name and then the Document UserText library to get the U-Value of tha\n        Construction Type. \n        \n        Returns 0.5 W/m2k as default on any errors.\n        \n        Args:\n            self:\n            _srfcGUID (GUID): A single GUID value\n        Returns:\n            srfcUvalue (float): The Surface's UserText Param for 'U-Value' if found\n        \"\"\"\n        \n        srfcConstructionName = rs.GetUserText(_srfcGUID, 'EPConstruction')\n        if srfcConstructionName:\n            constParams = rs.GetDocumentUserText('PHPP_lib_Assmbly_' + srfcConstructionName)\n            \n            for k in rs.GetDocumentUserText():\n                if 'PHPP_lib_Assmbly' not in k:\n                    continue\n                try:\n                    d = json.loads(rs.GetDocumentUserText(k))\n                    if d.get('Name', None) == srfcConstructionName:\n                        constParams = rs.GetDocumentUserText(k)\n                        break\n                except:\n                    constParams = None\n            else:\n                constParams = None\n            \n            if constParams:\n                constParams = json.loads(constParams)\n                srfcUvalue = constParams.get('uValue', 1)\n            else:\n                warning = ('Warning: Could not find a construction type in the',\n                'Rhino Document UserText with the name \"{}?\"'.format(srfcConstructionName.upper()),\n                'Check your Document UserText library to make sure that you have',\n                'your most recent assembly library file loaded?',\n                'For now applying a U-Value of 0.5 w/m2k (R11 hr-sf-F/Btu)  for this surface.')\n                self.ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Warning, warning)\n                srfcUvalue = 0.5\n        else:\n            warning = 'Warning: could not find a construction type in the\\n'\\\n            'UserText for one or more surfaces? Are you sure you assigned a\\n'\\\n            '\"EPConstruction\" parameter to the Floor Surface being input?\\n'\\\n            'For now applying a U-Value of 0.5 w/m2k (R11 hr-sf-F/Btu) for this surface.'\n            self.ghenv.Component.AddRuntimeMessage(ghK.GH_RuntimeMessageLevel.Warning, warning)\n            srfcUvalue = 0.5\n        \n        return srfcUvalue\n\n    def to_dict(self):\n        d = {}\n        \n        d.update( {'id':self.id} )\n        d.update( {'hb_host_room_name':self.hb_host_room_name} )\n        d.update( {'floor_area': self.floor_area} )\n        d.update( {'floor_U_value': self.floor_U_value} )\n        d.update( {'perim_len': self.perim_len} )\n        d.update( {'perim_psi_X_len': self.perim_psi_X_len} )\n\n        return d\n\n    @classmethod\n    def from_dict(cls, _dict, _ghenv):\n        new_obj = cls(_ghenv)\n\n        new_obj.id = _dict.get('id')\n        new_obj.hb_host_room_name = _dict.get('hb_host_room_name')\n        new_obj.floor_area = _dict.get('floor_area')\n        new_obj.floor_U_value = _dict.get('floor_U_value')\n        new_obj.perim_len = _dict.get('perim_len')\n        new_obj.perim_psi_X_len = _dict.get('perim_psi_X_len')\n\n        return new_obj\n\n    def __unicode__(self):\n        return u'A PHPP Ground Floor Element: < {} >'.format(self.id)\n    def __str__(self):\n        return unicode(self).encode('utf-8')\n    def __repr__(self):\n       return \"{}(_ghenv={!r})\".format(\n            self.__class__.__name__,\n            self.ghenv)\n\n\nclass PHPP_Ground():\n    \"\"\" General 'getters' common to all Ground classes \"\"\"\n    \n    @property\n    def host_room_name(self):\n        return self.floor_element.hb_host_room_name\n\n    @property\n    def floor_area(self):\n        return self.floor_element.floor_area\n\n    @property\n    def floor_U_value(self):\n        return self.floor_element.floor_U_value\n\n    @property\n    def perim_len(self):\n        return self.floor_element.perim_len\n\n    @property\n    def perim_psi(self):\n        try: \n            return float(self.PerimPsiVal)\n        except:\n            if self.perim_len:\n                return float(self.floor_element.default_perim_psi)\n            else:\n                return None\n\n    @property\n    def perim_psi_X_len(self):\n        try:\n            return float( self.perim_len * self.perim_psi)\n        except TypeError as e:\n            return None\n    \n    def __unicode__(self):\n        return u'A PHPP Ground Element: < {} >'.format(self.id)\n    def __str__(self):\n        return unicode(self).encode('utf-8')\n\n\nclass PHPP_Ground_Slab_on_Grade( PHPP_Ground ):\n    def __init__(self, _floor_element=None, _perimPsi=0.5, _depth=1.0, \n                        _thick=0.1, _cond=0.04, _orient='Vertical'):\n        \n        self.id = random.randint(1000,9999)\n        self.Type = '01_SlabOnGrade'\n        self.soilThermalConductivity = 2.0 # MJ/m3-K\n        self.soilHeatCapacity = 2.0 # W/mk\n        self.groundWaterDepth = 3.0 # m\n        self.groundWaterFlowrate = 0.05 # m/d \n\n        self.floor_element = _floor_element\n        self.PerimPsiVal = _perimPsi\n        self.perimInsulDepth = _depth\n        self.perimInsulThick = _thick\n        self.perimInsulConductivity = _cond\n        self.perimInsulOrientation = _orient\n\n    def to_dict(self):\n        d ={}\n        \n        d.update( {'id':self.id} )\n        d.update( {'type': self.Type} )\n        d.update( {'floor_element':self.floor_element.to_dict() } )\n        d.update( {'PerimPsiVal':self.PerimPsiVal } )\n        d.update( {'perimInsulDepth':self.perimInsulDepth } )\n        d.update( {'perimInsulThick':self.perimInsulThick } )\n        d.update( {'perimInsulConductivity':self.perimInsulConductivity } )\n        d.update( {'perimInsulOrientation':self.perimInsulOrientation } )\n        \n        return d\n\n    @classmethod\n    def from_dict(cls, _dict, _ghenv):\n        new_obj = cls()\n        \n        new_obj.id = _dict.get('id')\n        floor_element = PHPP_Ground_Floor_Element.from_dict(_dict.get('floor_element'), _ghenv)\n        new_obj.floor_element = floor_element\n        new_obj.PerimPsiVal = _dict.get('PerimPsiVal')\n        new_obj.perimInsulDepth = _dict.get('perimInsulDepth')\n        new_obj.perimInsulThick = _dict.get('perimInsulThick')\n        new_obj.perimInsulConductivity = _dict.get('perimInsulConductivity')\n        new_obj.perimInsulOrientation = _dict.get('perimInsulOrientation')\n\n        return new_obj\n\n    def __unicode__(self):\n        return u'A PHPP Ground Slab-On-Grade Object: < {} >'.format(self.id)\n    def __str__(self):\n        return unicode(self).encode('utf-8')\n    def __repr__(self):\n       return \"{}(_floor_element={!r}, _perimPsi={!r},, _depth={!r},\"\\\n                        \"_thick={!r},, _cond={!r}, _orient={!r},)\".format(\n            self.__class__.__name__,\n            self.floor_element,\n            self.PerimPsiVal,\n            self.perimInsulDepth,\n            self.perimInsulThick,\n            self.perimInsulConductivity,\n            self.perimInsulOrientation)\n\n\nclass PHPP_Ground_Heated_Basement( PHPP_Ground ):\n    def __init__(self, _floor_element=None, _perimPsi=0.5,\n                        _wallHeight_BG=1.0, _wallU_BG=1.0):\n        \n        self.id = random.randint(1000,9999)\n        self.Type = '02_HeatedBasement'\n        self.soilThermalConductivity = 2.0 # MJ/m3-K\n        self.soilHeatCapacity = 2.0 # W/mk\n        self.groundWaterDepth = 3.0 # m\n        self.groundWaterFlowrate = 0.05 # m/d \n        \n        self.floor_element = _floor_element\n        self.PerimPsiVal = _perimPsi\n        self.WallHeight_BG = _wallHeight_BG\n        self.WallU_BG = _wallU_BG\n\n    def to_dict(self):\n        d = {}\n\n        d.update( {'id':self.id} )\n        d.update( {'type': self.Type} )\n        d.update( {'floor_element':self.floor_element.to_dict() } )\n        d.update( {'PerimPsiVal':self.PerimPsiVal } )\n        d.update( {'WallHeight_BG':self.WallHeight_BG } )\n        d.update( {'WallU_BG':self.WallU_BG } )\n        \n        return d\n\n    @classmethod\n    def from_dict(cls, _dict, _ghenv):\n        new_obj = cls()\n        \n        new_obj.id = _dict.get('id')\n        floor_element = PHPP_Ground_Floor_Element.from_dict(_dict.get('floor_element'), _ghenv)\n        new_obj.floor_element = floor_element\n        new_obj.PerimPsiVal = _dict.get('PerimPsiVal')\n        new_obj.WallHeight_BG = _dict.get('WallHeight_BG')\n        new_obj.WallU_BG = _dict.get('WallU_BG')\n\n        return new_obj\n\n    def __unicode__(self):\n        return u'A PHPP Ground Heated Basement Object: < {} >'.format(self.id)\n    def __str__(self):\n        return unicode(self).encode('utf-8')\n    def __repr__(self):\n       return \"{}(_floor_element={!r}, _perimPsi={!r},\"\\\n                        \"_wallHeight_BG={!r}, _wallU_BG={!r})\".format(\n            self.__class__.__name__,\n            self.floor_element,\n            self.PerimPsiVal,\n            self.WallHeight_BG,\n            self.WallU_BG)\n\n\nclass PHPP_Ground_Unheated_Basement( PHPP_Ground ):\n    def __init__(self, _floor_element=None, _perimPsi=0.5, _wallHeight_AG=1.0,\n                        _wallU_AG=1.0, _wallHeight_BG=1.0, _wallU_BG=1.0, \n                        _flrU=1.0, _ach=1.0, _vol=1.0):\n        \n        self.id = random.randint(1000,9999)\n        self.Type = '03_UnheatedBasement'\n        self.soilThermalConductivity = 2.0 # MJ/m3-K\n        self.soilHeatCapacity = 2.0 # W/mk\n        self.groundWaterDepth = 3.0 # m\n        self.groundWaterFlowrate = 0.05 # m/d \n        \n        self.floor_element = _floor_element        \n        self.PerimPsiVal = _perimPsi\n        self.WallHeight_AG = _wallHeight_AG\n        self.WallU_AG = _wallU_AG  \n        self.WallHeight_BG = _wallHeight_BG\n        self.WallU_BG = _wallU_BG\n        self.FloorU = _flrU\n        self.ACH = _ach\n        self.Volume = _vol\n\n    def to_dict(self):\n        d = {}\n\n        d.update( {'id':self.id} )\n        d.update( {'type': self.Type} )\n        d.update( {'floor_element':self.floor_element.to_dict() } )\n        d.update( {'PerimPsiVal':self.PerimPsiVal } )\n        d.update( {'WallHeight_BG':self.WallHeight_BG } )\n        d.update( {'WallU_BG':self.WallU_BG } )\n        d.update( {'WallHeight_AG':self.WallHeight_AG } )\n        d.update( {'WallU_AG':self.WallU_AG } )\n        d.update( {'FloorU':self.FloorU } )\n        d.update( {'ACH':self.ACH } )\n        d.update( {'Volume':self.Volume } )\n\n        return d\n\n    @classmethod\n    def from_dict(cls, _dict, _ghenv):\n        new_obj = cls()\n\n        new_obj.id = _dict.get('id')\n        floor_element = PHPP_Ground_Floor_Element.from_dict(_dict.get('floor_element'), _ghenv)\n        new_obj.floor_element = floor_element\n        new_obj.PerimPsiVal = _dict.get('PerimPsiVal')\n        new_obj.WallHeight_BG = _dict.get('WallHeight_BG')\n        new_obj.WallU_BG = _dict.get('WallU_BG')\n        new_obj.WallHeight_AG = _dict.get('WallHeight_AG')\n        new_obj.WallU_AG = _dict.get('WallU_AG')\n        new_obj.FloorU = _dict.get('FloorU')\n        new_obj.ACH = _dict.get('ACH')\n        new_obj.Volume = _dict.get('Volume')\n\n        return new_obj\n    \n    def __unicode__(self):\n        return u'A PHPP Ground Un-heated Basement Object: < {} >'.format(self.id)\n    def __str__(self):\n        return unicode(self).encode('utf-8')\n    def __repr__(self):\n       return \"{}( _floor_element={!r}, _perimPsi={!r}, _wallHeight_AG={!r},\"\\\n                        \"_wallU_AG={!r}, _wallHeight_BG={!r}, _wallU_BG={!r},\"\\\n                        \"_flrU={!r}, _ach={!r}, _vol={!r})\".format(\n                self.__class__.__name__,\n                self.floor_element,        \n                self.PerimPsiVal,\n                self.WallHeight_AG,\n                self.WallU_AG,\n                self.WallHeight_BG,\n                self.WallU_BG,\n                self.FloorU,\n                self.ACH,\n                self.Volume)\n\n\nclass PHPP_Ground_Crawl_Space( PHPP_Ground ):\n    def __init__(self, _floor_element=None, _perimPsi=0.5, _wallHeight=1.0, _wallU=1.0,\n                    _crawlU=1.0, _ventOpen=1.0, _windVel=4.0, _windFac=0.05):\n        \n        self.id = random.randint(1000,9999)\n        self.Type = '04_SuspenedFlrOverCrawl'\n        self.soilThermalConductivity = 2.0 # MJ/m3-K\n        self.soilHeatCapacity = 2.0 # W/mk\n        self.groundWaterDepth = 3.0 # m\n        self.groundWaterFlowrate = 0.05 # m/d \n        \n        self.floor_element = _floor_element\n        self.PerimPsiVal = _perimPsi\n        self.WallHeight = _wallHeight\n        self.WallU = _wallU\n        self.CrawlU = _crawlU\n        self.VentOpeningArea = _ventOpen\n        self.windVelocity = _windVel\n        self.windFactor = _windFac\n\n    def to_dict(self):\n        d = {}\n\n        d.update( {'id':self.id} )\n        d.update( {'type': self.Type} )\n        d.update( {'floor_element':self.floor_element.to_dict() } )\n        d.update( {'PerimPsiVal':self.PerimPsiVal } )\n        d.update( {'WallHeight':self.WallHeight } )\n        d.update( {'WallU':self.WallU } )\n        d.update( {'CrawlU':self.CrawlU } )\n        d.update( {'VentOpeningArea':self.VentOpeningArea } )\n        d.update( {'windVelocity':self.windVelocity } )\n        d.update( {'windFactor':self.windFactor } )\n\n        return d\n\n    @classmethod\n    def from_dict(cls, _dict, _ghenv):\n        new_obj = cls()\n\n        new_obj.id = _dict.get('id')\n        floor_element = PHPP_Ground_Floor_Element.from_dict(_dict.get('floor_element'), _ghenv)\n        new_obj.floor_element = floor_element\n        new_obj.PerimPsiVal = _dict.get('PerimPsiVal')\n        new_obj.WallHeight = _dict.get('WallHeight')\n        new_obj.WallU = _dict.get('WallU')\n        new_obj.CrawlU = _dict.get('CrawlU')\n        new_obj.VentOpeningArea = _dict.get('VentOpeningArea')\n        new_obj.windVelocity = _dict.get('windVelocity')\n        new_obj.windFactor = _dict.get('windFactor')\n\n        return new_obj\n    \n    def __unicode__(self):\n        return u'A PHPP Ground Crawl-Space Object: < {} >'.format(self.id)\n    def __str__(self):\n        return unicode(self).encode('utf-8')\n    def __repr__(self):\n       return \"{}( _floor_element={!r}, _perimPsi={!r}, _wallHeight={!r}, _wallU={!r},\"\\\n                    \"_crawlU={!r}, _ventOpen={!r}, _windVel={!r}, _windFac={!r})\".format(\n                self.__class__.__name__,\n                self.floor_element,\n                self.PerimPsiVal,\n                self.WallHeight,\n                self.WallU,\n                self.CrawlU,\n                self.VentOpeningArea,\n                self.windVelocity,\n                self.windFactor)\n\n",
  "language": "python",
  "imports": [
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}