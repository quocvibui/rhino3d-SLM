{
  "source_url": "https://github.com/ed-p-may/LBT-2-PH/blob/3c2bbdf0cb26deb92d36b870aeb920cbc31d8da2/scripts/LBT2PH/shading.py",
  "repo": "ed-p-may/LBT-2-PH",
  "repo_stars": 12,
  "repo_description": "LBT2PH is a free toolkit for creating PHPP energy models from Ladybug Tools v1.0+ definitions.",
  "license": "GPL-3.0",
  "filepath": "scripts/LBT2PH/shading.py",
  "instruction": "Shading",
  "code": "from collections import namedtuple\nimport math\nimport ghpythonlib.components as ghc\nfrom System import Object\nfrom ladybug_rhino.fromgeometry import from_linesegment3d\n\n\nclass PHPP_Shading_Dims(Object):\n    \"\"\" PHPP-Style dimensions to shading objects \"\"\"\n    \n    Horizon = namedtuple('Horizon', ['h_hori', 'd_hori', 'checkline'])\n    Overhang = namedtuple('Overhang', ['d_over', 'o_over', 'checkline'])\n    Reveal = namedtuple('Reveal', ['o_reveal', 'd_reveal', 'checkline1', 'checkline2'])\n    \n    def __init__(self):\n        self._horizon = None\n        self._overhang = None\n        self._reveal = None\n\n    def __bool__(self):\n        if self.horizon.h_hori or self.horizon.d_hori:\n            return True\n        if self.overhang.d_over or self.overhang.o_over:\n            return True\n        if self.reveal.o_reveal or self.reveal.d_reveal:\n            return True\n              \n        return False\n        \n    def __nonzero__(self):\n        return self.__bool__()\n\n    @property\n    def horizon(self):\n        if self._horizon:\n            return self._horizon\n        else:\n            return self.Horizon(None, None, None)\n    \n    @horizon.setter\n    def horizon(self, _in):\n        if not _in:\n            pass\n        \n        if len(_in) == 3:\n            self._horizon = self.Horizon(*_in)\n        else:\n            print('Horizon input should be list/tuple of length 3?')\n            pass\n\n    @property\n    def overhang(self):\n        if self._overhang:\n            return self._overhang\n        else:\n            return self.Overhang(None, None, None)\n\n    @overhang.setter\n    def overhang(self, _in):\n        if not _in:\n            pass\n    \n        if len(_in) == 3:\n            self._overhang = self.Overhang(*_in)\n        else:\n            print('Overhang input should be list/tuple of length 3?')\n            pass\n    \n    @property\n    def reveal(self):\n        if self._reveal:\n            return self._reveal\n        else:\n            return self.Reveal(None, None, None, None)\n\n    @reveal.setter\n    def reveal(self, _in):\n        if not _in:\n            pass\n        \n        if len(_in) == 4:\n            self._reveal = self.Reveal(*_in)\n        else:\n            print('Reveal input should be list/tuple of length 4?')\n            pass\n\n    def to_dict(self):\n        d = {}\n        d.update( {'_horizon':self._horizon } )\n        d.update( {'_overhang':self._overhang } )\n        d.update( {'_reveal':self._reveal } )\n        \n        return d\n\n    @classmethod\n    def from_dict(cls, _dict):\n        new_obj = cls()\n        \n        if not _dict:\n            return new_obj\n\n        new_obj._horizon = _dict.get('_horizon')\n        new_obj._overhang = _dict.get('_overhang')\n        new_obj._reveal = _dict.get('_reveal')\n        \n        return new_obj\n\n    def __unicode__(self):\n        return u'A PHPP Shading Dims Object'\n    def __str__(self):\n        return unicode(self).encode('utf-8')\n    def __repr__(self):\n        return \"{}( _horizon={!r}, _overhang={!r}, _reveal={!r})\".format(\n               self.__class__.__name__,\n               self.horizon,\n               self.overhang,\n               self.reveal)\n    def ToString(self):\n        return str(self)\n\ndef calc_shading_dims_simple(_phpp_window_obj, _shading_objs, _limit=99):\n    \"\"\"Finds PHPP-Style dimensions to relevant shading objects\"\"\"\n    \n    shading_dims_obj = PHPP_Shading_Dims()\n    if not _shading_objs:\n        return shading_dims_obj\n    \n    # ----------------------------------------------------------------------\n    # Find the relevant geometry in the scene and figures out the critical dimensions from the window\n    h_hori, d_hori, checkline_hori = find_horizon_shading(_phpp_window_obj, _shading_objs, _limit)\n    d_over, o_over, checkline_over = find_overhang_shading(_phpp_window_obj, _shading_objs, _limit)\n    o_reveal, d_reveal, checkline_1, checkline_2 = find_reveal_shading(_phpp_window_obj, _shading_objs, _limit)\n\n    # ----------------------------------------------------------------------\n    # Package for output\n    shading_dims_obj.horizon = (h_hori, d_hori, checkline_hori)\n    shading_dims_obj.overhang = (d_over, o_over, checkline_over)\n    shading_dims_obj.reveal = (o_reveal, d_reveal, checkline_1, checkline_2)\n\n    return shading_dims_obj\n\ndef find_horizon_shading(_phpp_window_obj, _shadingGeom, _extents=99):\n    \"\"\"\n    Arguments:\n        _phpp_winddow_obj: The PHPP_Window object to calcualte the values for\n        _shadingGeom: (list) A list of possible shading objects to test against\n        _extents: (float) A number (m) to limit the shading search to. Default = 99m\n    Returns:\n        h_hori: Distance (m) out from the glazing surface of any horizontal shading objects found\n        d_hori: Distance (m) up from the base of the window to the top of any horizontal shading objects found\n    \"\"\"\n    surface_normal = _phpp_window_obj.surface_normal\n\n    #-----------------------------------------------------------------------\n    # Find Starting Point\n    glazingEdges = _phpp_window_obj._get_edges_in_order( _phpp_window_obj.glazing_surface )\n    glazingBottomEdge = glazingEdges.Bottom\n    ShadingOrigin = ghc.CurveMiddle( from_linesegment3d(glazingBottomEdge) )\n    UpVector = ghc.VectorXYZ(0,0,1).vector\n    \n    #-----------------------------------------------------------------------\n    # Find if there are any shading objects and if so put them in a list\n    HorizonShading = []\n    \n    HorizontalLine = ghc.LineSDL(ShadingOrigin, surface_normal, _extents)\n    VerticalLine = ghc.LineSDL(ShadingOrigin, UpVector, _extents)\n    for shadingObj in _shadingGeom:\n        if ghc.BrepXCurve(shadingObj, HorizontalLine).points != None:\n            HorizonShading.append( shadingObj )\n    \n    #-----------------------------------------------------------------------\n    # Find any intersection Curves with the shading objects\n    IntersectionSurface = ghc.SumSurface(HorizontalLine, VerticalLine)\n    IntersectionCurve = []\n    IntersectionPoints = []\n    \n    for shadingObj in HorizonShading:\n        if ghc.BrepXBrep(shadingObj, IntersectionSurface).curves != None:\n            IntersectionCurve.append(ghc.BrepXBrep(shadingObj, IntersectionSurface))\n    for pnt in IntersectionCurve:\n        IntersectionPoints.append(ghc.ControlPoints(pnt).points)\n    \n    #-----------------------------------------------------------------------\n    # Run the \"Top-Corner-Finder\" if there are any intersecting objects...\n    if len(IntersectionPoints) != 0:\n        # Find the top/closets point for each of the objects that could possibly shade\n        KeyPoints = []\n        for pnt in IntersectionPoints:\n            Rays = []\n            Angles = []\n            if pnt:\n                for k in range(len(pnt)):\n                    Rays.append(ghc.Vector2Pt(ShadingOrigin,pnt[k], False).vector)\n                    Angles.append(ghc.Angle(surface_normal , Rays[k]).angle)\n                KeyPoints.append(pnt[Angles.index(max(Angles))])\n    \n        # Find the relevant highest / closest point\n        Rays = []\n        Angles = []\n        for i in range(len(KeyPoints)):\n            Rays.append(ghc.Vector2Pt(surface_normal, KeyPoints[i], False).vector)\n            Angles.append(ghc.Angle(surface_normal, Rays[i]).angle)\n        KeyPoint = KeyPoints[Angles.index(max(Angles))]\n    \n        # Use the point it finds to deliver the Height and Distance for the PHPP Shading Calculator\n        h_hori = KeyPoint.Z - ShadingOrigin.Z #Vertical distance\n        Hypot = ghc.Length(ghc.Line(ShadingOrigin, KeyPoint))\n        d_hori = math.sqrt(Hypot**2 - h_hori**2)\n        CheckLine = ghc.Line(ShadingOrigin, KeyPoint)\n    else:\n        h_hori = None\n        d_hori = None\n        CheckLine = HorizontalLine\n    \n    return h_hori, d_hori, CheckLine\n\ndef find_overhang_shading(_phpp_window_obj, _shadingGeom, _extents=99):\n    # Figure out the glass surface (inset a bit) and then\n    # find the origin point for all the subsequent shading calcs (top, middle)\n    glzgCenter = ghc.Area(_phpp_window_obj.glazing_surface).centroid\n    glazingEdges = _phpp_window_obj._get_edges_in_order( _phpp_window_obj.glazing_surface )\n    glazingTopEdge = from_linesegment3d(glazingEdges.Top)\n    ShadingOrigin = ghc.CurveMiddle(glazingTopEdge)\n    \n    # In order to also work for windows which are not vertical, find the \n    # 'direction' from the glazing origin and the top/middle ege point\n    UpVector = ghc.Vector2Pt(glzgCenter, ShadingOrigin, True).vector\n    \n    #-----------------------------------------------------------------------\n    # First, need to filter the scene to find the objects that are 'above'\n    # the window. Create a 'test plane' that is _extents (99m) tall and 0.5m past the wall surface, test if\n    # any objects intersect that plane. If so, add them to the set of things\n    # test in the next step\n    depth = float(_phpp_window_obj.install_depth) + 0.5\n    edge1 = ghc.LineSDL(ShadingOrigin, UpVector, _extents)\n    edge2 = ghc.LineSDL(ShadingOrigin, _phpp_window_obj.surface_normal, depth)\n    intersectionTestPlane = ghc.SumSurface(edge1, edge2)\n    \n    OverhangShadingObjs = (x for x in _shadingGeom \n                    if ghc.BrepXBrep(intersectionTestPlane, x).curves != None)\n    \n    #-----------------------------------------------------------------------\n    # Using the filtered set of shading objects, find the 'edges' of shading \n    # geom and then decide where the maximums shading point is\n    # Create a new 'test' plane coming off the origin (99m in both directions this time).\n    # Test to find any intersection shading objs and all their crvs/points with this plane\n    HorizontalLine = ghc.LineSDL(ShadingOrigin, _phpp_window_obj.surface_normal, _extents)\n    VerticalLine = ghc.LineSDL(ShadingOrigin, UpVector, _extents)\n    \n    IntersectionSurface = ghc.SumSurface(HorizontalLine, VerticalLine)\n    IntersectionCurves = (ghc.BrepXBrep(obj, IntersectionSurface).curves \n                            for obj in OverhangShadingObjs\n                            if ghc.BrepXBrep(obj, IntersectionSurface).curves != None)\n    IntersectionPointsList = (ghc.ControlPoints(crv).points for crv in IntersectionCurves)\n    IntersectionPoints = (pt for list_of_pts in IntersectionPointsList for pt in list_of_pts)\n    \n    #-----------------------------------------------------------------------\n    # If there are any intersection Points found, choose the right one to use to calc shading....\n    # Find the top/closets point for each of the objects that could possibly shade\n    smallest_angle_found = 2 * math.pi\n    key_point = None\n    \n    for pt in IntersectionPoints:\n        if pt == None:        \n            continue\n        \n        # Protect against Zero-Length error\n        ray = ghc.Vector2Pt(ShadingOrigin, pt, False).vector\n        if ray.Length < 0.001:\n            continue\n        \n        this_ray_angle = ghc.Angle(_phpp_window_obj.surface_normal , ray).angle\n        if this_ray_angle < 0.001:\n            continue\n        \n        if this_ray_angle <= smallest_angle_found:\n            smallest_angle_found = this_ray_angle\n            key_point = pt\n    \n    #-----------------------------------------------------------------------\n    # Use the 'key point' found to deliver the Height and Distance for the PHPP Shading Calculator\n    if not key_point:\n        d_over = None\n        o_over = None\n        CheckLine = VerticalLine\n    else:\n        d_over = key_point.Z - ShadingOrigin.Z                              # Vertical distance\n        Hypot = ghc.Length(ghc.Line(ShadingOrigin, key_point))              # Hypot\n        o_over = math.sqrt(Hypot**2 - d_over**2)                            # Horizontal distance\n        CheckLine = ghc.Line(ShadingOrigin, key_point)\n    \n    return d_over, o_over, CheckLine\n\ndef find_reveal_shading(_phpp_window_obj, _shadingGeom, _extents=99):\n    \n    WinCenter = ghc.Area(_phpp_window_obj.glazing_surface).centroid\n    edges = _phpp_window_obj._get_edges_in_order( _phpp_window_obj.glazing_surface )\n    surface_normal = _phpp_window_obj.surface_normal\n\n    #Create the Intersection Surface for each side\n    Side1_OriginPt = ghc.CurveMiddle( from_linesegment3d(edges.Left) )\n    Side1_NormalLine = ghc.LineSDL(Side1_OriginPt, surface_normal, _extents)\n    Side1_Direction = ghc.Vector2Pt(WinCenter, Side1_OriginPt, False).vector\n    Side1_HorizLine = ghc.LineSDL(Side1_OriginPt, Side1_Direction, _extents)\n    Side1_IntersectionSurface = ghc.SumSurface(Side1_NormalLine, Side1_HorizLine)\n    \n    #Side2_OriginPt = SideMidPoints[1] #ghc.CurveMiddle(self.Edge_Left)\n    Side2_OriginPt = ghc.CurveMiddle( from_linesegment3d(edges.Right) )\n    Side2_NormalLine = ghc.LineSDL(Side2_OriginPt, surface_normal, _extents)\n    Side2_Direction = ghc.Vector2Pt(WinCenter, Side2_OriginPt, False).vector\n    Side2_HorizLine = ghc.LineSDL(Side2_OriginPt, Side2_Direction, _extents)\n    Side2_IntersectionSurface = ghc.SumSurface(Side2_NormalLine, Side2_HorizLine)\n    \n    #Find any Shader Objects and put them all into a list\n    Side1_RevealShaderObjs = []\n    testStartPt = ghc.Move(WinCenter, ghc.Amplitude(surface_normal, 0.1)).geometry #Offsets the test line just a bit\n    Side1_TesterLine = ghc.LineSDL(testStartPt, Side1_Direction, _extents) #extend a line off to side 1\n    for i in range(len(_shadingGeom)):\n        if ghc.BrepXCurve(_shadingGeom[i],Side1_TesterLine).points != None:\n            Side1_RevealShaderObjs.append(_shadingGeom[i])\n    \n    Side2_RevealShaderObjs = []\n    Side2_TesterLine = ghc.LineSDL(testStartPt, Side2_Direction, _extents) #extend a line off to side 2\n    for i in range(len(_shadingGeom)):\n        if ghc.BrepXCurve(_shadingGeom[i],Side2_TesterLine).points != None:\n            Side2_RevealShaderObjs.append(_shadingGeom[i])\n    \n    #---------------------------------------------------------------------------\n    # Calc Shading reveal dims\n    NumShadedSides = 0\n    if len(Side1_RevealShaderObjs) != 0:\n        Side1_o_reveal = CalcRevealDims(_phpp_window_obj, Side1_RevealShaderObjs, Side1_IntersectionSurface, Side1_OriginPt, Side1_Direction)[0]\n        Side1_d_reveal = CalcRevealDims(_phpp_window_obj, Side1_RevealShaderObjs, Side1_IntersectionSurface, Side1_OriginPt, Side1_Direction)[1]\n        Side1_CheckLine = CalcRevealDims(_phpp_window_obj, Side1_RevealShaderObjs, Side1_IntersectionSurface, Side1_OriginPt, Side1_Direction)[2]\n        NumShadedSides = NumShadedSides + 1\n    else:\n        Side1_o_reveal =  None\n        Side1_d_reveal = None\n        Side1_CheckLine = Side1_HorizLine\n    \n    if len(Side2_RevealShaderObjs) != 0:\n        Side2_o_reveal = CalcRevealDims(_phpp_window_obj, Side2_RevealShaderObjs, Side2_IntersectionSurface, Side2_OriginPt, Side2_Direction)[0]\n        Side2_d_reveal = CalcRevealDims(_phpp_window_obj, Side2_RevealShaderObjs, Side2_IntersectionSurface, Side2_OriginPt, Side2_Direction)[1]\n        Side2_CheckLine = CalcRevealDims(_phpp_window_obj, Side2_RevealShaderObjs, Side2_IntersectionSurface, Side2_OriginPt, Side2_Direction)[2]\n        NumShadedSides = NumShadedSides + 1\n    else:\n        Side2_o_reveal =  None\n        Side2_d_reveal = None\n        Side2_CheckLine = Side2_HorizLine\n    \n    #\n    #\n    #\n    # TODO: how to handel asymetrical reveals????\n\n    o_reveal = Side1_o_reveal#(Side1_o_reveal + Side2_o_reveal )/ max(1,NumShadedSides)\n    d_reveal = Side1_d_reveal#(Side1_d_reveal + Side2_d_reveal )/ max(1,NumShadedSides)\n    \n    #\n    #\n    #\n    #\n    #\n\n    return o_reveal, d_reveal, Side1_CheckLine, Side2_CheckLine\n\ndef CalcRevealDims(_phpp_window_obj, RevealShaderObjs_input, SideIntersectionSurface, Side_OriginPt, Side_Direction):\n    #Test shading objects for their edge points\n    Side_IntersectionCurve = []\n    Side_IntersectionPoints = []\n    for i in range(len(RevealShaderObjs_input)): #This is the list of shading objects to filter\n        if ghc.BrepXBrep(RevealShaderObjs_input[i], SideIntersectionSurface).curves != None:\n            Side_IntersectionCurve.append(ghc.BrepXBrep(RevealShaderObjs_input[i], SideIntersectionSurface).curves)\n    for i in range(len(Side_IntersectionCurve)):\n        for k in range(len(ghc.ControlPoints(Side_IntersectionCurve[i]).points)):\n            Side_IntersectionPoints.append(ghc.ControlPoints(Side_IntersectionCurve[i]).points[k])\n    \n    #Find the top/closets point for each of the objects that could possibly shade\n    Side_KeyPoints = []\n    Side_Rays = []\n    Side_Angles = []\n    for i in range(len(Side_IntersectionPoints)):\n        if Side_OriginPt != Side_IntersectionPoints[i]:\n            Ray = ghc.Vector2Pt(Side_OriginPt, Side_IntersectionPoints[i], False).vector\n            Angle = math.degrees(ghc.Angle(_phpp_window_obj.surface_normal, Ray).angle)\n            if  Angle < 89.9:\n                Side_Rays.append(Ray)\n                Side_Angles.append(float(Angle))\n                Side_KeyPoints.append(Side_IntersectionPoints[i])\n    Side_KeyPoint = Side_KeyPoints[Side_Angles.index(min(Side_Angles))]\n    Side_KeyRay = Side_Rays[Side_Angles.index(min(Side_Angles))]\n    \n    #use the Key point found to calculte the Distances for the PHPP Shading Calculator\n    Side_Hypot = ghc.Length(ghc.Line(Side_OriginPt, Side_KeyPoint))\n    Deg = (ghc.Angle(Side_Direction, Side_KeyRay).angle) #note this is in Radians\n    Side_o_reveal =  math.sin(Deg) * Side_Hypot\n    Side_d_reveal = math.sqrt(Side_Hypot**2 - Side_o_reveal**2)\n    Side_CheckLine = ghc.Line(Side_OriginPt, Side_KeyPoint)\n    \n    return [Side_o_reveal, Side_d_reveal, Side_CheckLine]\n",
  "language": "python",
  "imports": [
    "ghpythonlib"
  ],
  "has_docstring": false
}