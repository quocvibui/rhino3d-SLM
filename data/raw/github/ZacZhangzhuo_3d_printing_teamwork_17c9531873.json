{
  "source_url": "https://github.com/ZacZhangzhuo/3d_printing_teamwork/blob/1ae8e701e83329eb292170fc8bc483fa912b639b/Design_Substructure/Archive/Agents%20Generation/substructure_khara.py",
  "repo": "ZacZhangzhuo/3d_printing_teamwork",
  "repo_stars": 1,
  "repo_description": "This is the 3D Printing teamwork repository of team 4 of MAS dfab 2023",
  "license": "MIT",
  "filepath": "Design_Substructure/Archive/Agents Generation/substructure_khara.py",
  "instruction": "Substructure khara",
  "code": "import Rhino.Geometry as rg\nimport ghpythonlib.treehelpers as th\n\n\ntolerance = 0.001\n\n\n#this class is focused on the properties and methods of each instance MAS (multi agent system)\n\nclass Environment(object):\n    \n    def __init__(self, u_div, v_div, surface, agents_list = []):\n        #self.num_agents = 0    #total number of agents\n        self.u_div = u_div\n        self.v_div = v_div\n        self.surface = surface\n        self.agents = []\n        if len(agents_list) > 0:\n            self.agents = agents_list\n\n    #this function takes the u values and transform them into agents\n    def populate_agents(self, u_vals, target_factors):\n        # instantiatie all agents\n        for u, t_fac in zip(u_vals,target_factors) :\n            self.agents.append(Agent(u, 0, 0, t_fac / self.v_div, self.surface)) \n\n    def update_agents_pos (self, coherence_rad, coherence_fac, align_rad, align_fac, avoid_rad, avoid_fac):\n        # generate the new position of each agent by calculating their new direction and velocity\n        #for each agent apply all the functions on it given the required factors for each parameter\n        #if the agent arrives we pop out this agent from the list and add it to the finished list \n        # add a function that if everything is arrived just stop \n        #list of all effects so as not to change the behaviour of the agents during update\n        effects_list = []\n        for agent in self.agents:\n            effects_vector = rg.Vector2d(0,0)  \n\n            coherence_vector = agent.Coherence(coherence_rad, self.agents, self.u_div, self.v_div, coherence_fac)\n            effects_vector += coherence_vector\n\n            alignment_vector = agent.Alignment(align_rad, self.agents, self.u_div, self.v_div, align_fac)\n            effects_vector += alignment_vector\n\n            separation_vector = agent.Separation(avoid_rad, self.agents, self.u_div, self.v_div, avoid_fac)\n            effects_vector += separation_vector\n\n            #sum all of the vectors + the actual du and dv of the agent + unitize --> do nothing but add them to the effects_list\n            agent.AddTotalEffect(self.u_div, self.v_div, effects_vector)\n\n        for agent, effect in zip(self.agents, effects_list):\n            agent.AgentStep(effect)\n\n    #function that ensures the agent has reached the final destination\n\nclass Agent(object):\n\n#the main parameters are poisiton on the surface, velocity in both directions \n    def __init__(self, u, v, du, dv, surface):\n        self.u = u\n        self.v = v\n        self.surface = surface\n        pos_3d = self.surface.PointAt(self.u, self.v)\n        self.position = rg.Point2d(pos_3d.X, pos_3d.Y) ##for the surface\n\n        self.du = du\n        self.dv = dv\n        self.pts = []\n        self.pts.append(self.surface.PointAt(self.u, self.v))\n        self.arrived = False\n        \n\n    def Coherence(self, radius, agents, u_div, v_div, coh_fac):\n        # agents : list of agents in the environment\n        # fx for Coherence\n        \"\"\" \n        --- within the specified radius we need to iterate over each agent apart from ours and do the following:\n        -> calculate the center (u,v) of the surrounding by 2 getting the average over all of the points \n        -> this shall be the point to aim at from the agent position \n        -> unitize the produced vector \n        \"\"\"\n        #coherence_distance = ra\n        centerU= 0\n        centerV= 0\n        num_neighbors = 0\n        for agent in agents:\n            if not agent == self:\n                dist = self.position.DistanceTo(agent.position)\n                if dist<= radius:\n                    num_neighbors +=1\n                    centerU += agent.u\n                    centerV += agent.v\n\n        #get the average vector\n        if  num_neighbors > 0:\n            centerU /= num_neighbors\n            centerV /= num_neighbors\n\n            #unitize the product vector of the coherence  \n            cohesion_unit_vect = rg.Vector2d(centerU-self.u, centerV-self.v)\n            cohesion_unit_vect = self.UnitizeEffect(u_div, v_div,cohesion_unit_vect) * coh_fac\n\n            return cohesion_unit_vect\n\n        else:\n            return rg.Vector2d(0,0)\n\n    def Alignment(self, radius, agents, u_div, v_div, align_fac):\n        # fx for Alignment (match velocity)\n        \"\"\"within the specified radius we need to iterate over each agent apart from ours and do the following:\n        -> calculate the average velocity [adding all the velocities and dividing the result with the total number of neighbors]\n        \"\"\"\n        #radius = 10\n\n        average_du = 0\n        average_dv = 0\n        num_neighbors = 0\n\n        for agent in agents:\n            if not agent == self:\n                dist = self.position.DistanceTo(agent.position)\n                if dist <= radius:\n                    num_neighbors +=1\n                    average_du += agent.du\n                    average_dv += agent.dv\n        \n        if  num_neighbors > 0:\n            average_du /= num_neighbors\n            average_dv /= num_neighbors\n\n            align_unit_vect = rg.Vector2d(average_du, average_dv)\n            align_unit_vect = self.UnitizeEffect(u_div, v_div,align_unit_vect) * align_fac\n\n            return align_unit_vect\n\n        else:\n            return rg.Vector2d(0,0)\n\n\n    def Separation (self, radius, agents, u_div, v_div, avoid_fac):\n        # fx for Separation\n        \"\"\"within the specified radius we need to iterate over each agent apart from ours and do the following:\n        -> define how close two agents can be [min distance before collision]\n        -> define a new direction [maybe reversed]\n        \"\"\"\n        num_neighbors =0\n        moveU=0\n        moveV=0\n        for agent in agents:\n            if not agent == self:\n                dist = self.position.DistanceTo(agent.position)\n                if dist<= radius:\n                    num_neighbors =-1\n                    moveU = self.u - agent.u\n                    moveY = self.v - agent.v\n\n        if  num_neighbors > 0:\n\n            avoid_unit_vect = rg.Vector2d(moveU, moveV)\n            avoid_unit_vect = self.UnitizeEffect(u_div, v_div,avoid_unit_vect) * avoid_fac\n\n            return avoid_unit_vect\n        else\n            return rg.Vector2d(0,0)\n\n        \n    # fx for Target reach\n    \"\"\"\n    -> adds an upward vector to the velocity based on a certain criteria \n    \"\"\"\n\n    def withinBounds (self):\n        # fx to keep within Bounds\n        \"\"\"\n        ->check if (0<=u,v<=1)\n        ->if not mirror u (*-1)\n        ->\n        \"\"\"\n        #to be cheked!!\n        if self.u <= 0:\n            self.u = 0\n            self.du *= -1\n\n        elif self.u >=1:\n            self.u = 1\n            self.du *= -1\n\n        #pending: we need to rethink this point and check again!!!  \n\n        if self.v >=1:\n            self.v =1\n            self.arrived =True\n\n\n    # pending: fx for limiting speed?\n\n    # helper fxs:7\n\n    # add the effect to the new veloctity vector of the agent that will be added later to its current velocity\n    # as an input is the vector of a certain effect, the function does the following\n    # --> unitize the vector\n    # --> multiply by the effect value \n    # --> add this value to sum of new velocity vector \n    # --> this fx is called in each effect fx \n    def UnitizeEffect(self, u_div, v_div, vector_2b_unitised):           \n        vector_2b_unitised.Unitize()\n        vector_2b_unitised = rg.Vector2d(vector_2b_unitised.X/u_div, vector_2b_unitised.Y/v_div)\n        return vector_2b_unitised\n\n    # adds the new velocty vector to the current velocity vector and unitizes it \n    def AddTotalEffect(self, u_div, v_div, effects_vector):\n        effects_vector += rg.Vector2d(self.du, self.dv)\n        return self.UnitizeEffect(u_div, v_div, effects_vector)\n\n    # update the agent's params and move it one step forward\n    def AgentStep(self, effects_vector):\n        self.du = effects_vector.x\n        self.dv = effects_vector.y\n        self.u += self.du\n        self.v += self.dv\n        self.pts.append(self.surface.PointAt(self.u, self.v))\n       \n\n    #hello Eleniiiii\n    #hello Ahmed\n######################################################################################################################################\n# the execution function:\n# given the list of different points to initiate the agents do:\n# a for loop iterating over the lists, instantiating each agent in the list then instantaiting an environment given all these agents\n# afterwards, for each environment do some action till a certain time t\n# afterwards instantiate a bigger environment containing all agents and giving it a certain value for all parameters.\n\n\n#Swap UV directions of surface if needed\ncorner_b= surface.PointAt(1,0)\ncorner_d= surface.PointAt(0,1)\n\nif corner_b.Z > corner_d.Z:\n    surface.Transpose(True)\n\n\n\ninitial_env_list = []\nu_lists = th.tree_to_list(u_lists)\ntarget_factors = th.tree_to_list(target_factors)\nfor u_list, t_factor in zip(u_lists, target_factors):\n    #instantiate an instance of the environment:\n    new_env = Environment(u_div, v_div, surface)\n    new_env.populate_agents(u_list, t_factor)\n    initial_env_list.append(new_env)\n\n#depending on the input timestep we update the agents\nfor t in range(time_1):\n    for env in initial_env_list:\n        env.update_agents_pos(coherence_rad, coherence_fac, align_rad, align_fac, avoid_rad, avoid_fac)\n\nlist_pts = []\npaths=[]\nfor env in initial_env_list:\n    list_pts.append([agent.pts for agent in env.agents])\n    path = surface.InterpolatedCurveOnSurface([agent.pts for agent in env.agents],tolerance)\n    paths.append(path)\n\npaths = th.list_to_tree(paths)\nlist_pts = th.list_to_tree(list_pts)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}