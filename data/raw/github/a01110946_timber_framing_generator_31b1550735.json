{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/src/timber_framing_generator/utils/geometry_helpers.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "src/timber_framing_generator/utils/geometry_helpers.py",
  "instruction": "File: timber_framing_generator/utils/geometry_helpers.py",
  "code": "# File: timber_framing_generator/utils/geometry_helpers.py\n\nimport Rhino.Geometry as rg\nfrom src.timber_framing_generator.utils.logging_config import get_logger\n\n# Initialize logger for this module\nlogger = get_logger(__name__)\n\ndef create_extruded_solid(line: rg.Line, profile: rg.Rectangle3d) -> rg.Brep:\n    \"\"\"\n    Extrude a profile along a line to create a solid.\n    \"\"\"\n    # Create a planar surface from the profile rectangle.\n    profile_surface = rg.Surface.CreateExtrusion(\n        profile.ToNurbsCurve(), rg.Vector3d(0, 0, 1)\n    )\n    # Extrude along the given line direction.\n    vec = rg.Vector3d(line.To - line.From)\n    brep = rg.Brep.CreateFromExtrusion(profile_surface, vec)\n    return brep\n\ndef points_equal(p1, p2, tol=1e-6):\n    \"\"\"Return True if p1 and p2 are within tol distance.\n\n    Assumes both p1 and p2 are valid Rhino.Geometry.Point3d objects.\n    \"\"\"\n    logger.trace(f\"Type of p1: {type(p1)}\")\n    logger.trace(f\"Type of p2: {type(p2)}\")\n    return p1.DistanceTo(p2) < tol\n\ndef curve_closest_point(curve, test_point):\n    \"\"\"\n    Universal helper for finding closest point on any curve type.\n    Works consistently across different RhinoCommon implementations.\n    \n    Args:\n        curve: Any curve type (Curve, LineCurve, etc.)\n        test_point: The point to find closest position to\n        \n    Returns:\n        tuple: (success, parameter)\n    \"\"\"\n    # Try various approaches in order of preference\n    try:\n        # 1. Try direct method if available\n        if hasattr(curve, 'ClosestPoint'):\n            return curve.ClosestPoint(test_point)\n            \n        # 2. Try converting to NurbsCurve\n        nurbs = curve.ToNurbsCurve()\n        if nurbs and hasattr(nurbs, 'ClosestPoint'):\n            return nurbs.ClosestPoint(test_point)\n        \n        # 3. For LineCurve, try manual calculation\n        if isinstance(curve, rg.LineCurve):\n            line = curve.Line\n            v = rg.Vector3d(line.To - line.From)\n            w = rg.Vector3d(test_point - line.From)\n            \n            # Project w onto v (dot product divided by squared length)\n            c1 = w.X * v.X + w.Y * v.Y + w.Z * v.Z\n            c2 = v.X * v.X + v.Y * v.Y + v.Z * v.Z\n            \n            if c2 < 1e-10:  # Avoid division by near-zero\n                return True, 0.0\n                \n            t = c1 / c2\n            t = max(0.0, min(1.0, t))  # Clamp to [0,1]\n            \n            return True, t\n        \n        # Final fallback\n        raise NotImplementedError(\"Could not find method to get closest point\")\n            \n    except Exception as e:\n        logger.error(f\"Error in curve_closest_point: {str(e)}\")\n        return False, 0.0\n\ndef curve_length(curve):\n    \"\"\"\n    Get the length of a curve, handling LineCurve's missing GetLength method.\n    \n    Args:\n        curve: Any curve object\n        \n    Returns:\n        float: Length of the curve\n    \"\"\"\n    # Try standard method first\n    if hasattr(curve, 'GetLength'):\n        return curve.GetLength()\n        \n    # For LineCurve, calculate from the Line property\n    if isinstance(curve, rg.LineCurve) and hasattr(curve, 'Line'):\n        line = curve.Line\n        # Use distance between endpoints\n        return line.From.DistanceTo(line.To)\n        \n    # Final fallback - try to get endpoints\n    try:\n        start = curve.PointAtStart\n        end = curve.PointAtEnd\n        return start.DistanceTo(end)\n    except:\n        # Last resort - return a reasonable default\n        logger.warning(\"Could not calculate curve length, using default\")\n\ndef create_extrusion(profile_curve, direction_vector):\n    \"\"\"\n    Create an extrusion of a profile curve along a direction vector.\n    Compatible with various RhinoCommon implementations.\n    \n    Args:\n        profile_curve: Curve to extrude\n        direction_vector: Vector defining direction and length of extrusion\n        \n    Returns:\n        rg.Brep: Extrusion geometry as a Brep\n    \"\"\"\n    try:\n        # 1. Try standard method if available\n        if hasattr(rg.Extrusion, 'CreateExtrusion'):\n            extrusion = safe_create_extrusion(profile_curve, direction_vector)\n            if extrusion and extrusion.IsValid:\n                return extrusion.ToBrep()\n        \n        # 2. Try using Sweep1 as an alternative\n        rail_curve = rg.Line(\n            rg.Point3d(0, 0, 0),\n            rg.Point3d(\n                direction_vector.X,\n                direction_vector.Y,\n                direction_vector.Z\n            )\n        ).ToNurbsCurve()\n        \n        # Create transformation to move rail to profile location\n        if hasattr(profile_curve, 'PointAtStart'):\n            start_point = profile_curve.PointAtStart\n            transform = rg.Transform.Translation(\n                start_point.X, start_point.Y, start_point.Z\n            )\n            rail_curve.Transform(transform)\n        \n        # Use sweep instead\n        sweep_breps = rg.Brep.CreateFromSweep(\n            rail_curve,\n            profile_curve,\n            closed=False,\n            tolerance=0.001\n        )\n        \n        if sweep_breps and len(sweep_breps) > 0:\n            # Join all pieces if multiple were created\n            if len(sweep_breps) > 1:\n                joined_breps = rg.Brep.JoinBreps(sweep_breps, 0.001)\n                if joined_breps and len(joined_breps) > 0:\n                    return joined_breps[0]\n            return sweep_breps[0]\n        \n        # 3. Final fallback - try to create using a surface extrusion\n        try:\n            # Create a surface from the profile curve\n            profile_surface = rg.Surface.CreateExtrusion(\n                profile_curve, \n                rg.Vector3d(0, 0, 1)\n            )\n            \n            # Create the extrusion from the surface\n            brep = rg.Brep.CreateFromSurface(profile_surface)\n            \n            # Transform to the correct position and orientation\n            transform = rg.Transform.PlaneToPlane(\n                rg.Plane.WorldXY,\n                rg.Plane(\n                    rg.Point3d(0, 0, 0),\n                    rg.Vector3d(direction_vector)\n                )\n            )\n            brep.Transform(transform)\n            \n            return brep\n            \n        except:\n            # Last resort - create a box as a placeholder\n            logger.warning(\"Could not create extrusion, using box placeholder\")\n            # Analyze profile to get size\n            bbox = profile_curve.GetBoundingBox(True)\n            width = bbox.Max.X - bbox.Min.X\n            height = bbox.Max.Y - bbox.Min.Y\n            depth = direction_vector.Length\n            \n            # Create box\n            center = rg.Point3d(\n                (bbox.Min.X + bbox.Max.X) / 2,\n                (bbox.Min.Y + bbox.Max.Y) / 2,\n                0\n            )\n            box = rg.Box(\n                rg.Plane(center, rg.Vector3d.ZAxis),\n                rg.Interval(-width/2, width/2),\n                rg.Interval(-height/2, height/2),\n                rg.Interval(0, depth)\n            )\n            \n            return box.ToBrep()\n            \n    except Exception as e:\n        logger.error(f\"Error creating extrusion: {str(e)}\")\n        import traceback\n        logger.error(traceback.format_exc())\n        return None\n\ndef create_box_brep(center, width, height, depth):\n    \"\"\"Create a simple box as Brep - ultimate fallback.\"\"\"\n    try:\n        # Create corners\n        corners = []\n        for x in [-width/2, width/2]:\n            for y in [-height/2, height/2]:\n                for z in [-depth/2, depth/2]:\n                    corners.append(rg.Point3d(\n                        center.X + x,\n                        center.Y + y,\n                        center.Z + z\n                    ))\n        \n        # Create a simple box manually\n        brep = rg.Brep()\n        \n        # Return empty Brep if we can't create geometry\n        return brep\n    except:\n        # Return an empty brep as last resort\n        logger.error(\"Failed to create box brep\")\n        return rg.Brep()\n\ndef create_simple_extrusion(profile, vector):\n    \"\"\"\n    Extremely simplified extrusion using direct geometry creation.\n    Last resort when no other methods are available.\n    \"\"\"\n    try:\n        # Get bounding box of profile\n        bbox = profile.GetBoundingBox(True)\n        if not bbox.IsValid:\n            return rg.Brep()\n            \n        # Calculate center and dimensions\n        center = rg.Point3d(\n            (bbox.Min.X + bbox.Max.X) / 2,\n            (bbox.Min.Y + bbox.Max.Y) / 2,\n            (bbox.Min.Z + bbox.Max.Z) / 2\n        )\n        \n        width = bbox.Max.X - bbox.Min.X\n        height = bbox.Max.Y - bbox.Min.Y\n        depth = vector.Length\n        \n        # Create simple box as fallback\n        return create_box_brep(center, width, height, depth)\n    except Exception as e:\n        logger.error(f\"Error in create_simple_extrusion: {e}\")\n        return rg.Brep()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}