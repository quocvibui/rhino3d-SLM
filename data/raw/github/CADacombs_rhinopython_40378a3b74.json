{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_NurbsSrf_convertToBezier.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_NurbsSrf_convertToBezier.py",
  "instruction": "Spb nurbs srf convert to bezier",
  "code": "\"\"\"\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n190204-05: Created.\r\n...\r\n190817: Changed face iteration status from count to percent.\r\n190907: Added bLimitDeviation.  Now checks areas of surface against brep before attempting trim.\r\n191031, 1109, 1206, 0202, 0224: Import-related update.\r\n200515: Added options including changing surface degrees.\r\n200518: Minor bug fix.\r\n200527-28: Bug fix.  Refactored.  Import-related update.\r\n        Now checks for and processes differently surfaces with Bezier patterns in one direction.\r\n200616: Modified printed output.\r\n200619: Import-related update.\r\n210209: Refactored.  createSurface split into 4 functions.\r\n210220: Bug fix.\r\n210301: Bug fix.\r\n210909: Bug fix.  Refactored same degree routine.\r\n211113: Replaced an import with a local function.\r\n220701: Refactored.\r\n221227: WIP: Refactored.\r\n\r\nTODO:\r\n    If bShrinkFirst and the Rebuild fails, try Rebuild before shrinking.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\n\r\nimport xBrep_getDistancesBetween2\r\nimport xBrepFace\r\nimport xBrepObject\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bLimitDeviation'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fDevTol'; keys.append(key)\r\n    values[key] = 0.1 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bMatchInSrfDegs'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDeg1'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'TryDeg1'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDeg2'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDeg3'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDeg5'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bSkipConical'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bShrinkFirst'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bReplace'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'Action'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Add', 'Replace')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bExtract'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fDevTol':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < 1e-6:\r\n                cls.riOpts[key].CurrentValue = 1e-6\r\n\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get brep faces without optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select breps and/or faces\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Brep | rd.ObjectType.Surface\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Do not clear objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False) # Do not unselect object when an option selected, a number is entered, etc.\r\n\r\n    bPreselectedObjsChecked = False\r\n\r\n    idxs_Opt = {}\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n        addOption('bLimitDeviation')\r\n        if Opts.values['bLimitDeviation']:\r\n            addOption('fDevTol')\r\n        addOption('bMatchInSrfDegs')\r\n        if not Opts.values['bMatchInSrfDegs']:\r\n            addOption('bDeg1')\r\n            addOption('bDeg2')\r\n            addOption('bDeg3')\r\n            addOption('bDeg5')\r\n        addOption('bSkipConical')\r\n        addOption('bShrinkFirst')\r\n        addOption('bReplace')\r\n        if Opts.values['bReplace']:\r\n            addOption('bExtract')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        # Use bPreselectedObjsChecked so that only objects before the\r\n        # first call to go.GetMultiple is considered.\r\n        if not bPreselectedObjsChecked and go.ObjectsWerePreselected:\r\n            bPreselectedObjsChecked = True\r\n            go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n\r\n            if Opts.values['bLimitDeviation']:\r\n                fDevTol = Opts.values['fDevTol']\r\n            else:\r\n                fDevTol = None\r\n\r\n            if Opts.values['bMatchInSrfDegs']:\r\n                iDegsToTry = None\r\n            else:\r\n                iDegsToTry = []\r\n                if Opts.values['bDeg1']:\r\n                    iDegsToTry.append(1)\r\n                if Opts.values['bDeg2']:\r\n                    iDegsToTry.append(2)\r\n                if Opts.values['bDeg3']:\r\n                    iDegsToTry.append(3)\r\n                if Opts.values['bDeg5']:\r\n                    iDegsToTry.append(5)\r\n                iDegsToTry = tuple(iDegsToTry)\r\n\r\n            return (\r\n                objrefs,\r\n                fDevTol,\r\n                iDegsToTry,\r\n                Opts.values['bSkipConical'],\r\n                Opts.values['bShrinkFirst'],\r\n                Opts.values['bReplace'],\r\n                Opts.values['bExtract'],\r\n                Opts.values['bEcho'],\r\n                Opts.values['bDebug'],\r\n                )\r\n\r\n        if res == ri.GetResult.Number:\r\n            if Opts.values['bLimitDeviation']:\r\n                key = 'fDevTol'\r\n                Opts.riOpts[key].CurrentValue = go.Number()\r\n                Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef doesSurfaceContainConicSection(rgSrf):\r\n    if isinstance(rgSrf, rg.RevSurface):\r\n        return \"RevSurface.\"\r\n    if isinstance(rgSrf, rg.NurbsSurface):\r\n        if rgSrf.IsRational:\r\n            #return \"rational NurbsSurface.\"\r\n\r\n            c_UDom_Start = rgSrf.IsoCurve(1, rgSrf.Domain(0).T0)\r\n            if isinstance(c_UDom_Start, rg.NurbsCurve):\r\n                if c_UDom_Start.IsRational:\r\n                    if c_UDom_Start.IsArc(1e-9):\r\n                        return \"NurbsSurface with circular arc NurbsCurve isocurve.\"\r\n                    if c_UDom_Start.IsEllipse(1e-9):\r\n                        return \"NurbsSurface with elliptical NurbsCurve isocurve.\"\r\n            c_VDom_Start = rgSrf.IsoCurve(0, rgSrf.Domain(1).T0)\r\n            if isinstance(c_VDom_Start, rg.NurbsCurve):\r\n                if c_VDom_Start.IsRational:\r\n                    if c_VDom_Start.IsArc(1e-9):\r\n                        return \"NurbsSurface with circular arc NurbsCurve isocurve.\"\r\n                    if c_VDom_Start.IsEllipse(1e-9):\r\n                        return \"NurbsSurface with elliptical NurbsCurve isocurve.\"\r\n    if isinstance(rgSrf, rg.SumSurface):\r\n        #ns = rgSrf.ToNurbsSurface()\r\n        #if ns.IsRational:\r\n        #    ns.Dispose()\r\n        #    return \"SumSurface with rational isocurve.\"\r\n\r\n        c_UDom_Start = rgSrf.IsoCurve(1, rgSrf.Domain(0).T0)\r\n        if isinstance(c_UDom_Start, rg.ArcCurve):\r\n            return \"SumSurface with conic section isocurve.\"\r\n            return \"SumSurface with ArcCurve isocurve at U T0.\"\r\n        if isinstance(c_UDom_Start, rg.NurbsCurve):\r\n            if c_UDom_Start.IsRational:\r\n                if c_UDom_Start.IsEllipse(1e-9):\r\n                    return \"SumSurface with elliptical NurbsCurve isocurve.\"\r\n                return \"SumSurface with rational NurbsCurve isocurve at U T0.\"\r\n        c_VDom_Start = rgSrf.IsoCurve(0, rgSrf.Domain(1).T0)\r\n        if isinstance(c_VDom_Start, rg.ArcCurve):\r\n            return \"SumSurface with conic section isocurve.\"\r\n            return \"SumSurface with ArcCurve isocurve at V T0.\"\r\n        if isinstance(c_VDom_Start, rg.NurbsCurve):\r\n            if c_VDom_Start.IsRational:\r\n                if c_VDom_Start.IsEllipse(1e-9):\r\n                    return \"SumSurface with elliptical NurbsCurve isocurve.\"\r\n                return \"SumSurface with rational NurbsCurve isocurve at V T0.\"\r\n    return False\r\n\r\n\r\ndef isSrfValidForConversion(rgSrf, bSkipConical=True):\r\n    \"\"\"\r\n    return tuple of bool and string (log) or None)\r\n    \"\"\"\r\n    \r\n    if Rhino.RhinoApp.ExeVersion < 6:\r\n        print(\"This script doesn't work in Rhino versions previous to 6.\")\r\n        return\r\n    \r\n    if isinstance(rgSrf, rg.PlaneSurface):\r\n        return False, \"Skipped Planesurface.\"\r\n\r\n    if bSkipConical:\r\n        rc = doesSurfaceContainConicSection(rgSrf)\r\n        if rc:\r\n            return False, \"Skipped \" + rc\r\n\r\n    ns = rgSrf.ToNurbsSurface()\r\n    \r\n    # Skip if no interior knots.\r\n    for iDir in 0, 1:\r\n        spanCt = ns.SpanCount(iDir)\r\n        if ns.IsPeriodic(iDir):\r\n            iCt_Pt = ns.Points.CountU if iDir == 0 else ns.Points.CountV\r\n            if spanCt > iCt_Pt - ns.Degree(iDir):\r\n                ns.Dispose()\r\n                return True, None\r\n        else:\r\n            if spanCt > 1:\r\n                ns.Dispose()\r\n                return True, None\r\n    else:\r\n        ns.Dispose()\r\n        return False, \"Skipped {} with single Bezier patch.\".format(rgSrf.GetType().Name)\r\n\r\n\r\ndef createSurface_SameDegs(rgSrf_In, fDevTol=None, bDebug=False):\r\n    \"\"\"\r\n    Create surface at same degrees as input.\r\n    \"\"\"\r\n\r\n    if Rhino.RhinoApp.ExeVersion < 6:\r\n        print(\"This script doesn't work in Rhino versions previous to 6.\")\r\n        return\r\n\r\n    ns_fromIn = rgSrf_In.ToNurbsSurface()\r\n\r\n\r\n    bSkipRebuildU = ns_fromIn.SpanCount(0)\r\n    bSkipRebuildV = ns_fromIn.SpanCount(1)\r\n\r\n    if bSkipRebuildU and bSkipRebuildV:\r\n        return None, \"Surface is already a Bezier patch.\"\r\n\r\n    nss_Res = []\r\n    devs = []\r\n    sLogs = []\r\n\r\n\r\n    def getDistancesBetweenBreps(nsA, nsB, bDebug=False):\r\n        rc = xBrep_getDistancesBetween2.getDistancesBetweenBreps(\r\n                nsB,\r\n                nsA,\r\n                bIncludeEdges=True,\r\n                rgMeshParams=None,\r\n                bFineMesh=False,\r\n                bCalcBrepIntersection=False,\r\n                bDebug=bDebug\r\n                )\r\n\r\n        return rc[1] if rc[0] else None\r\n\r\n\r\n    def createSurface_RemoveInteriorKnots(ns_In, bDebug=False):\r\n        \"\"\"\r\n        \"\"\"\r\n\r\n        # Duplicating because RemoveKnots modifies the NurbsSurface of the provided knot vector.\r\n        ns_Out = ns_In.Duplicate()\r\n    \r\n        degrees = ns_Out.OrderU-1, ns_Out.OrderV-1\r\n    \r\n        knots = ns_Out.KnotsU, ns_Out.KnotsV\r\n    \r\n        # Remove all interior knots.\r\n        # Notice that index 1 is one more than the maximum index to remove.\r\n    \r\n        for iDir in 0,1:\r\n            if knots[iDir].Count == 2 * degrees[iDir]:\r\n                # There are no interior knots in iDir direction.\r\n                continue\r\n        \r\n            if not knots[iDir].RemoveKnots(\r\n                    index0=degrees[iDir],\r\n                    index1=knots[iDir].Count-degrees[iDir]\r\n            ):\r\n                ns_Out.Dispose()\r\n                if bDebug: print(\"RemoveKnots failed.\")\r\n                return\r\n\r\n        return ns_Out\r\n\r\n    ns_Res = createSurface_RemoveInteriorKnots(ns_fromIn, bDebug)\r\n\r\n    if ns_Res is not None:\r\n        nss_Res.append(ns_Res)\r\n        dev = getDistancesBetweenBreps(ns_Res, ns_fromIn, bDebug)\r\n        devs.append(dev)\r\n        sLogs.append(None)\r\n\r\n\r\n    if (\r\n        (bSkipRebuildU and ns_fromIn.Degree(1) == 3)\r\n        or\r\n        (bSkipRebuildV and ns_fromIn.Degree(0) == 3)\r\n    ):\r\n        def createSurface_RebuildOneDirection(ns_In, direction, bDebug=False):\r\n            return ns_fromIn.RebuildOneDirection(\r\n                direction=direction,\r\n                pointCount=4,\r\n                loftType=rg.LoftType.Normal,\r\n                refitTolerance=0.5*sc.doc.ModelAbsoluteTolerance)\r\n\r\n        ns_Res = createSurface_RebuildOneDirection(\r\n            ns_fromIn,\r\n            direction=1 if bSkipRebuildU else 0,\r\n            bDebug=bDebug)\r\n\r\n        if ns_Res is not None:\r\n            nss_Res.append(ns_Res)\r\n            dev = getDistancesBetweenBreps(ns_Res, ns_fromIn, bDebug)\r\n            devs.append(dev)\r\n            sLogs.append(None)\r\n\r\n\r\n    def createSurface_Rebuild(ns_In):\r\n        ns_Out = ns_In.Rebuild(\r\n            uDegree=ns_In.Degree(0),\r\n            vDegree=ns_In.Degree(1),\r\n            uPointCount=ns_In.Degree(0)+1,\r\n            vPointCount=ns_In.Degree(1)+1)\r\n        if ns_Out is None:\r\n            return None, \"Rebuild returned None.  Check for internal knots near surface boundary.\"\r\n        return ns_Out, None\r\n\r\n    ns_Res, sLog = createSurface_Rebuild(ns_fromIn)\r\n\r\n    if ns_Res is not None:\r\n        nss_Res.append(ns_Res)\r\n        dev = getDistancesBetweenBreps(ns_Res, ns_fromIn, bDebug)\r\n        devs.append(dev)\r\n        sLogs.append(sLog)\r\n    elif bDebug:\r\n        print(sLog)\r\n\r\n\r\n    ns_fromIn.Dispose()\r\n\r\n\r\n    if len(nss_Res) == 0:\r\n        return None, sLogs\r\n\r\n\r\n    #for ns in nss_Res:\r\n    #    sc.doc.Objects.AddSurface(ns)\r\n    #sc.doc.Views.Redraw()\r\n    #return\r\n\r\n\r\n    dev_Min = min(devs)\r\n    idx_MinDev = devs.index(dev_Min)\r\n\r\n    ns_MinDev = nss_Res[idx_MinDev]\r\n\r\n\r\n    for i, ns in enumerate(nss_Res):\r\n        if i != idx_MinDev:\r\n            ns.Dispose()\r\n\r\n\r\n    if fDevTol is None:\r\n        return (ns_MinDev, dev_Min), None\r\n\r\n\r\n    if dev_Min <= fDevTol:\r\n        return (ns_MinDev, dev_Min), None\r\n\r\n    # Fail.\r\n    ns_MinDev.Dispose()\r\n\r\n    return (None, dev_Min), None\r\n\r\n\r\ndef createSurface_NoDevLimit_NewDegs(rgSrf_In, iDeg, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    if Rhino.RhinoApp.ExeVersion < 6:\r\n        print(\"This script doesn't work in Rhino versions previous to 6.\")\r\n        return\r\n\r\n    ns_fromIn = rgSrf_In.ToNurbsSurface()\r\n\r\n    bSkipRebuildU = (iDeg == ns_fromIn.Degree(direction=0)) and ns_fromIn.SpanCount(0)\r\n    bSkipRebuildV = (iDeg == ns_fromIn.Degree(direction=1)) and ns_fromIn.SpanCount(1)\r\n\r\n    if bSkipRebuildU and bSkipRebuildV:\r\n        return None, \"Surface is already a Bezier patch.\"\r\n\r\n    if iDeg == 3 and bSkipRebuildU or bSkipRebuildV:\r\n        rgNurbsSrf_Res = ns_fromIn.RebuildOneDirection(\r\n            direction=1 if bSkipRebuildU else 0,\r\n            pointCount=4,\r\n            loftType=rg.LoftType.Normal,\r\n            refitTolerance=0.1*fDevTol)\r\n        if rgNurbsSrf_Res is None:\r\n            ns_fromIn.Dispose()\r\n            return None, \"RebuildOneDirection returned None.\"\r\n    else:\r\n        rgNurbsSrf_Res = ns_fromIn.Rebuild(\r\n            uDegree=iDeg,\r\n            vDegree=iDeg,\r\n            uPointCount=iDeg+1,\r\n            vPointCount=iDeg+1)\r\n\r\n        if rgNurbsSrf_Res is None:\r\n            ns_fromIn.Dispose()\r\n            return None, \"Rebuild returned None.  Check for internal knots near surface boundary.\"\r\n\r\n    rc = xBrep_getDistancesBetween2.getDistancesBetweenBreps(\r\n            ns_fromIn,\r\n            rgNurbsSrf_Res,\r\n            bIncludeEdges=True,\r\n            rgMeshParams=None,\r\n            bFineMesh=False,\r\n            bCalcBrepIntersection=False,\r\n            bDebug=bDebug\r\n            )\r\n        \r\n    srf_dev = rc[1] if rc[0] else None\r\n        \r\n    ns_fromIn.Dispose()\r\n    return (rgNurbsSrf_Res, srf_dev), None\r\n\r\n\r\ndef createSurface_DevLimit_TryDegs(rgSrf_In, fDevTol, iDegs_toTry=(1,2,3,5), bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        rgSrf_In\r\n        fDevTol=,\r\n        iDegsToTry=,\r\n        bDebug=,\r\n    Returns when passing surface found:\r\n        tuple(\r\n            tuple(rg.NurbsSurface, float(Maximum deviation from rgSrf_In)),\r\n            None)\r\n    Returns when passing surface NOT found:\r\n        tuple(\r\n            tuple(None, float(Maximum deviation from closest solution to rgSrf_In))\r\n            None)\r\n    Returns on other fails:\r\n        tuple(None, str(Description of failure))\r\n    \"\"\"\r\n    \r\n    if Rhino.RhinoApp.ExeVersion < 6:\r\n        print(\"This script doesn't work in Rhino versions previous to 6.\")\r\n        return\r\n\r\n\r\n    ns_fromIn = rgSrf_In.ToNurbsSurface()\r\n\r\n    iDegs_toTry = sorted(iDegs_toTry)\r\n\r\n\r\n    bSkipRebuildU = ns_fromIn.Degree(direction=0) in iDegs_toTry and ns_fromIn.SpanCount(0)\r\n    bSkipRebuildV = ns_fromIn.Degree(direction=1) in iDegs_toTry and ns_fromIn.SpanCount(1)\r\n\r\n    if bSkipRebuildU and bSkipRebuildV:\r\n        return None, \"Surface is already a Bezier patch.\"\r\n\r\n    srf_devs = []\r\n\r\n\r\n    if 1 not in iDegs_toTry:\r\n        iDegs_toTry_U = iDegs_toTry[:]\r\n        iDegs_toTry_V = iDegs_toTry[:]\r\n    else:\r\n        # Quick check for not linear.\r\n\r\n        c_VDom_Start = ns_fromIn.IsoCurve(0, ns_fromIn.Domain(1).T0)\r\n        c_VDom_End = ns_fromIn.IsoCurve(0, ns_fromIn.Domain(1).T1)\r\n        #sc.doc.Objects.AddCurve(c); sc.doc.Views.Redraw(); return\r\n    \r\n        if c_VDom_Start.IsLinear(fDevTol) and c_VDom_End.IsLinear(fDevTol):\r\n            iDegs_toTry_U = iDegs_toTry[:]\r\n        else:\r\n            if len(iDegs_toTry) > 1:\r\n                # Next degree after 1.\r\n                iDegs_toTry_U = iDegs_toTry[1:]\r\n            else:\r\n                return None, \"Surface is not linear along U.\"\r\n\r\n        c_UDom_Start = ns_fromIn.IsoCurve(1, ns_fromIn.Domain(0).T0)\r\n        c_UDom_End = ns_fromIn.IsoCurve(1, ns_fromIn.Domain(0).T1)\r\n        #map(sc.doc.Objects.AddCurve, (c_UDom_Start, c_UDom_End)); sc.doc.Views.Redraw(); return\r\n\r\n        if c_UDom_Start.IsLinear(fDevTol) and c_UDom_End.IsLinear(fDevTol):\r\n            iDegs_toTry_V = iDegs_toTry[:]\r\n        else:\r\n            if len(iDegs_toTry) > 1:\r\n                # Next degree after 1.\r\n                iDegs_toTry_V = iDegs_toTry[1:]\r\n            else:\r\n                return None, \"Surface is not linear along V.\"\r\n\r\n\r\n    # Try rebuilding at various allowed degrees.\r\n    for iDeg_U in iDegs_toTry_U:\r\n        for iDeg_V in iDegs_toTry_V:\r\n            \r\n            #print(iDegreeU, iDegreeV\r\n\r\n            if bSkipRebuildU or bSkipRebuildV:\r\n                # Surface.RebuildOneDirection only seems to output degree 3\r\n                # in rebuilt direction.  Therefore, use pointCount of 4 for Bezier.\r\n                pointCount = ns_fromIn.Degree(1 if bSkipRebuildU else 0)+1\r\n                # For loftType, Developable, Loose, Normal, Straight, and Tight work.\r\n                # Uniform doesn't.\r\n                rgNurbsSrf_Res = ns_fromIn.RebuildOneDirection(\r\n                    direction=1 if bSkipRebuildU else 0,\r\n                    pointCount=4,\r\n                    loftType=rg.LoftType.Normal,\r\n                    refitTolerance=0.1*fDevTol)\r\n                if rgNurbsSrf_Res is None:\r\n                    continue # to next degree V.\r\n            else:\r\n                rgNurbsSrf_Res = ns_fromIn.Rebuild(\r\n                    uDegree=iDeg_U,\r\n                    vDegree=iDeg_V,\r\n                    uPointCount=iDeg_U+1,\r\n                    vPointCount=iDeg_V+1)\r\n\r\n                if rgNurbsSrf_Res is None:\r\n                    ns_fromIn.Dispose()\r\n                    return None, \"Rebuild returned None.  Check for internal knots near surface boundary.\"\r\n\r\n            rc = xBrep_getDistancesBetween2.getDistancesBetweenBreps(\r\n                    ns_fromIn,\r\n                    rgNurbsSrf_Res,\r\n                    bIncludeEdges=True,\r\n                    rgMeshParams=None,\r\n                    bFineMesh=False,\r\n                    bCalcBrepIntersection=False,\r\n                    bDebug=bDebug\r\n                    )\r\n        \r\n            srf_dev = rc[1] if rc[0] else None\r\n        \r\n            if fDevTol is None:\r\n                ns_fromIn.Dispose()\r\n                return (rgNurbsSrf_Res, srf_dev), None\r\n        \r\n            if rc[0] and srf_dev <= fDevTol:\r\n                # Success.\r\n                ns_fromIn.Dispose()\r\n                return (rgNurbsSrf_Res, srf_dev), None\r\n        \r\n            # Surface isn't within deviation tolerance.\r\n            rgNurbsSrf_Res.Dispose()\r\n            srf_devs.append(srf_dev)\r\n            \r\n            if bSkipRebuildU or bSkipRebuildV:\r\n                # Don't bother looping because RebuildOneDirection only rebuilds\r\n                # to degree 3.\r\n                return(None, min(srf_devs) if srf_devs else None), None\r\n\r\n    return (None, min(srf_devs) if srf_devs else None), None\r\n\r\n\r\ndef processFace(rgFace_In, fDevTol=None, iDegsToTry=None, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        BrepFace\r\n        fDevTol\r\n        iDegsToTry\r\n        bDebug\r\n    Returns:\r\n        (rg.Brep (1-face), float(deviation)), None\r\n        (None, float(deviation needed)), sLog\r\n        None, None\r\n    \"\"\"\r\n    \r\n    if Rhino.RhinoApp.ExeVersion < 6:\r\n        print(\"This script doesn't work in Rhino versions previous to 6.\")\r\n        return\r\n\r\n\r\n    rgSrf_In = rgFace_In.UnderlyingSurface()\r\n\r\n\r\n    rgNurbsSrf0 = rgSrf_In\r\n\r\n    if iDegsToTry is None:\r\n        rc = createSurface_SameDegs(\r\n            rgNurbsSrf0,\r\n            fDevTol=fDevTol,\r\n            bDebug=bDebug\r\n            )\r\n    else:\r\n        # New degrees.\r\n        if fDevTol is None:\r\n            rc = createSurface_NoDevLimit_NewDegs(\r\n                rgNurbsSrf0,\r\n                iDeg=min(iDegsToTry),\r\n                bDebug=bDebug\r\n                )\r\n        else:\r\n            rc = createSurface_DevLimit_TryDegs(\r\n                rgNurbsSrf0,\r\n                fDevTol=fDevTol,\r\n                iDegs_toTry=iDegsToTry,\r\n                bDebug=bDebug\r\n                )\r\n    \r\n    if rc[0] is None or rc[0][0] is None: return rc\r\n    \r\n    rgNurbsSrf_Converted, srf_dev = rc[0]\r\n    \r\n    # Success in creating NurbsSurface.  Now, create correctly trimmed brep.\r\n    \r\n    rgBrep0_1Face = rgFace_In.DuplicateFace(duplicateMeshes=False)\r\n    \r\n    rgBrep0_1Face.Faces[0].RebuildEdges(0.1*sc.doc.ModelAbsoluteTolerance, True, True)\r\n    #rgBrep0_1Face.Faces.ShrinkFaces()\r\n    \r\n    if rgBrep0_1Face.IsSurface:\r\n        rgBrep0_1Face.Dispose()\r\n        rgBrep1_1Face = rgNurbsSrf_Converted.ToBrep()\r\n        rgNurbsSrf_Converted.Dispose()\r\n        if not rgBrep1_1Face.IsValid:\r\n            rgBrep1_1Face.Dispose()\r\n            return None, \"Invalid brep geometry after ToBrep.\"\r\n        return (rgBrep1_1Face, srf_dev), None\r\n    \r\n    # Test areas before trimming.\r\n    fArea_Trimmed = rgBrep0_1Face.GetArea()\r\n    if fArea_Trimmed:\r\n        rgBrep_Untrimmed = rgBrep0_1Face.Faces[0].UnderlyingSurface().ToBrep()\r\n        fArea_Untrimmed = rgBrep_Untrimmed.GetArea()\r\n        rgBrep_Untrimmed.Dispose()\r\n        if fArea_Untrimmed:\r\n            if abs(fArea_Trimmed - fArea_Untrimmed) <= sc.doc.ModelAbsoluteTolerance:\r\n                rgBrep1_1Face = rgNurbsSrf_Converted.ToBrep()\r\n                rgNurbsSrf_Converted.Dispose()\r\n                if not rgBrep1_1Face.IsValid:\r\n                    rgBrep1_1Face.Dispose()\r\n                    return None, \"Invalid brep geometry after ToBrep.\"\r\n                return (rgBrep1_1Face, srf_dev), None\r\n\r\n    rgBrep1_1Face = xBrepFace.retrimFace(\r\n            rgBrep0_1Face.Faces[0],\r\n            rgSrf_Replacement=rgNurbsSrf_Converted,\r\n            fSplitTol=1.0*sc.doc.ModelAbsoluteTolerance if fDevTol is None else fDevTol,\r\n            bDebug=bDebug\r\n    )\r\n    rgNurbsSrf_Converted.Dispose()\r\n    rgBrep0_1Face.Dispose()\r\n\r\n    if rgBrep1_1Face is None:\r\n        return None, \"xBrepFace.createMonofaceBrep returned None.\"\r\n\r\n    if not rgBrep1_1Face.IsValid:\r\n        rgBrep1_1Face.Dispose()\r\n        return None, \"An invalid brep was skipped.\"\r\n\r\n    return (rgBrep1_1Face, srf_dev), None\r\n\r\n\r\ndef processBrep(rgBrep_In, idxs_rgFaces, fDevTol=None, iDegsToTry=None, **kwargs):\r\n    \"\"\"\r\n    Returns:\r\n        (rgBreps_1F_Mod, idxs_rgFaces_Rebuilt, srf_devs), sLogs\r\n        None\r\n    \"\"\"\r\n    \r\n    if Rhino.RhinoApp.ExeVersion < 6:\r\n        print(\"This script doesn't work in Rhino versions previous to 6.\")\r\n        return\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    bSkipConical = getOpt('bSkipConical')\r\n    bShrinkFirst = getOpt('bShrinkFirst')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    rgBreps_1F_Mod = []\r\n    idxs_rgFaces_Rebuilt = []\r\n    srf_devs = []\r\n    srf_devs_Needed = []\r\n    \r\n    rgB_WIP = rgBrep_In.DuplicateBrep()\r\n    \r\n    if bShrinkFirst:\r\n        rgB_WIP.Faces.ShrinkFaces()\r\n    \r\n    sLogs = []\r\n    \r\n    sCmdPrompt0 = Rhino.RhinoApp.CommandPrompt\r\n    \r\n    idxs_AtTenths = [int(round(0.1*i*len(idxs_rgFaces),0)) for i in range(10)]\r\n    \r\n    for iF, idx_rgFace in enumerate(idxs_rgFaces):\r\n        if sc.escape_test(False):\r\n            print(\"Searching interrupted by user.\")\r\n            return\r\n        \r\n        if iF in idxs_AtTenths:\r\n            s = sCmdPrompt0 + \", {:d}% of {} faces in current brep ...\".format(\r\n                int(100.0 * (iF+1) / len(idxs_rgFaces)), len(idxs_rgFaces))\r\n            \r\n            if bDebug:\r\n                print(s)\r\n            else:\r\n                Rhino.RhinoApp.SetCommandPrompt(s)\r\n        \r\n        rgFace_In = rgB_WIP.Faces[idx_rgFace]\r\n\r\n\r\n        if bSkipConical:\r\n            rc = doesSurfaceContainConicSection(rgFace_In.UnderlyingSurface())\r\n            if rc:\r\n                sLogs.append(\"Skipped \" + rc)\r\n                continue\r\n\r\n            #if isinstance(rgFace_In.UnderlyingSurface(), rg.RevSurface):\r\n            #    sLogs.append(\"Skipped RevSurface.\")\r\n            #    continue\r\n            #elif isinstance(rgFace_In.UnderlyingSurface(), rg.NurbsSurface):\r\n            #    if rgFace_In.UnderlyingSurface().IsRational:\r\n            #        sLogs.append(\"Skipped rational NurbsSurface.\")\r\n            #        continue\r\n\r\n\r\n        rc = processFace(\r\n            rgFace_In,\r\n            fDevTol=fDevTol,\r\n            iDegsToTry=iDegsToTry,\r\n            bDebug=bDebug\r\n            )\r\n\r\n\r\n        if rc[0] is None:\r\n            sLogs.append(rc[1])\r\n            continue\r\n        \r\n        rgBrep_1F_Converted, srf_dev = rc[0]\r\n        if rgBrep_1F_Converted is None:\r\n            if srf_dev is not None:\r\n                srf_devs_Needed.append(srf_dev)\r\n            continue\r\n\r\n        rgBreps_1F_Mod.append(rgBrep_1F_Converted)\r\n        idxs_rgFaces_Rebuilt.append(idx_rgFace)\r\n        srf_devs.append(srf_dev)\r\n    \r\n    rgB_WIP.Dispose()\r\n    \r\n    if srf_devs_Needed:\r\n        s  = \"Need tolerances of {:.2e} through {:.2e}\".format(\r\n                min(srf_devs_Needed), max(srf_devs_Needed))\r\n        s += \" to convert remaining convertible surfaces.\"\r\n        sLogs.append(s)\r\n    \r\n    return (rgBreps_1F_Mod, idxs_rgFaces_Rebuilt, srf_devs), sLogs\r\n\r\n\r\ndef processBrepObjects(rhBreps, idx_Faces=None, fDevTol=None, iDegsToTry=None, **kwargs):\r\n    \"\"\"\r\n    Parameters:\r\n        rhBreps: Objrefs of brep with face components, GUIDs, rd.Breps.\r\n    \"\"\"\r\n    \r\n    if Rhino.RhinoApp.ExeVersion < 6:\r\n        print(\"This script doesn't work in Rhino versions previous to 6.\")\r\n        return\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    bSkipConical = getOpt('bSkipConical')\r\n    bShrinkFirst = getOpt('bShrinkFirst')\r\n    bReplace = getOpt('bReplace')\r\n    bExtract = getOpt('bExtract')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    def getRhinoObject(rhObj):\r\n        \"\"\"\r\n        'Deleted objects cannot be found by id.'\r\n        (https://developer.rhino3d.com/api/RhinoCommon/html/M_Rhino_DocObjects_Tables_ObjectTable_FindId.htm)\r\n        \"\"\"\r\n        rdObj = None\r\n        if isinstance(rhObj, rd.RhinoObject):\r\n            rdObj = rhObj\r\n        elif isinstance(rhObj, rd.ObjRef):\r\n            rdObj = rhObj.Object()\r\n        elif isinstance(rhObj, Guid):\r\n            rdObj = sc.doc.Objects.FindId(rhObj) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(rhObj)\r\n        return rdObj\r\n\r\n\r\n    def getBrepObject(rhObj):\r\n        rdObj = getRhinoObject(rhObj)\r\n        if rdObj and (rdObj.ObjectType == rd.ObjectType.Brep):\r\n            return rdObj\r\n\r\n\r\n    def getSortedBrepIdsAndFaces(objrefs):\r\n        \"\"\"\r\n        Parameters:\r\n            list(objrefs)\r\n        Returns:\r\n            list(Brep GUIDs)\r\n            list(lists(integers of Face indices) per brep)\r\n        \"\"\"\r\n        \r\n        gBreps0 = []\r\n        idxs_Faces_perBrep = []\r\n    \r\n        for o in objrefs:\r\n            gBrep0 = o.ObjectId\r\n            rdBrep_In = o.Object()\r\n            rgBrep_In = o.Brep()\r\n        \r\n            if not rgBrep_In.IsValid:\r\n                print(\"Brep {} is invalid.  Fix first.\".format(gBrep0))\r\n                rgBrep_In.Dispose()\r\n                continue\r\n        \r\n            idx_CompIdx = o.GeometryComponentIndex.Index\r\n            if idx_CompIdx == -1:\r\n                if gBrep0 in gBreps0:\r\n                    idxs_Faces_perBrep[gBreps0.index(gBrep0)] = range(rgBrep_In.Faces.Count)\r\n                else:\r\n                    gBreps0.append(gBrep0)\r\n                    idxs_Faces_perBrep.append(range(rgBrep_In.Faces.Count))\r\n            else:\r\n                rgFace_Brep0 = o.Face()\r\n                if gBrep0 in gBreps0:\r\n                    if rgFace_Brep0 in idxs_Faces_perBrep[gBreps0.index(gBrep0)]:\r\n                        continue\r\n                    else:\r\n                        idxs_Faces_perBrep[gBreps0.index(gBrep0)].append(rgFace_Brep0.FaceIndex)\r\n                else:\r\n                    gBreps0.append(gBrep0)\r\n                    idxs_Faces_perBrep.append([rgFace_Brep0.FaceIndex])\r\n\r\n        return gBreps0, idxs_Faces_perBrep\r\n\r\n\r\n    def isKnotVectorUniform(knots):\r\n        return (\r\n            (knots.KnotStyle == rg.KnotStyle.Uniform) or\r\n            (knots.KnotStyle == rg.KnotStyle.QuasiUniform) or\r\n            (\r\n                (knots.KnotStyle == rg.KnotStyle.PiecewiseBezier) and\r\n                knots.Count == knots.KnotMultiplicity(0) * 2)\r\n            )\r\n\r\n\r\n    def getNurbsSurfaceChangeDescription(rgNurbsSrf1, rgNurbsSrf2):\r\n        s  = \"  Prop:I->O\"\r\n        s += \"  {}:({}->{})x({}->{})\".format(\r\n                \"Deg\",\r\n                rgNurbsSrf1.OrderU-1,\r\n                rgNurbsSrf2.OrderU-1,\r\n                rgNurbsSrf1.OrderV-1,\r\n                rgNurbsSrf2.OrderV-1,\r\n        )\r\n        s += \"  {}:({}->{})x({}->{})\".format(\r\n                \"PtCt\",\r\n                rgNurbsSrf1.Points.CountU,\r\n                rgNurbsSrf2.Points.CountU,\r\n                rgNurbsSrf1.Points.CountV,\r\n                rgNurbsSrf2.Points.CountV,\r\n        )\r\n        if Rhino.RhinoApp.ExeVersion >= 7:\r\n            s += \"  {}:({}->{})x({}->{})\".format(\r\n                    \"IsUniform\",\r\n                    str(isKnotVectorUniform(rgNurbsSrf1.KnotsU))[0],\r\n                    str(isKnotVectorUniform(rgNurbsSrf2.KnotsU))[0],\r\n                    str(isKnotVectorUniform(rgNurbsSrf1.KnotsV))[0],\r\n                    str(isKnotVectorUniform(rgNurbsSrf2.KnotsV))[0],\r\n            )\r\n        s += \"  {}:{}->{}\".format(\r\n                \"IsRational\",\r\n                str(rgNurbsSrf1.IsRational)[0],\r\n                str(rgNurbsSrf2.IsRational)[0],\r\n        )\r\n        s += \"  {}:({}->{})x({}->{})\".format(\r\n                \"IsClosed\",\r\n                str(rgNurbsSrf1.IsClosed(0))[0],\r\n                str(rgNurbsSrf2.IsClosed(0))[0],\r\n                str(rgNurbsSrf1.IsClosed(1))[0],\r\n                str(rgNurbsSrf2.IsClosed(1))[0],\r\n        )\r\n        if (    rgNurbsSrf1.IsClosed(0) or rgNurbsSrf1.IsClosed(1) or\r\n                rgNurbsSrf2.IsClosed(0) or rgNurbsSrf2.IsClosed(1)\r\n        ):\r\n            s += \"  {}:{}->{}\".format(\r\n                    \"IsPeriodic\",\r\n                    str(rgNurbsSrf1.IsPeriodic)[0],\r\n                    str(rgNurbsSrf2.IsPeriodic)[0],\r\n            )\r\n        return s\r\n\r\n\r\n    gBreps0, idxs_rgFace_PerBrep = getSortedBrepIdsAndFaces(rhBreps)\r\n    if not gBreps0: return\r\n\r\n    gBs1_perB0 = []\r\n    srf_devs_All = []\r\n    sLogs_All = []\r\n    \r\n    len_gBreps0 = len(gBreps0)\r\n    idxs_AtTenths = [int(round(0.1*i*len_gBreps0,0)) for i in range(10)]\r\n    \r\n    sCmdPrompt0 = Rhino.RhinoApp.CommandPrompt\r\n    \r\n    if len(rhBreps) == 1:\r\n        s = sCmdPrompt0 + \"Brep\"\r\n        Rhino.RhinoApp.SetCommandPrompt(s)\r\n    \r\n    for iB, (gBrep0, idxFaces) in enumerate(zip(gBreps0, idxs_rgFace_PerBrep)):\r\n        rdBrep_In = getBrepObject(gBrep0)\r\n        rgBrep_In = rdBrep_In.Geometry\r\n\r\n        if len(rhBreps) > 1:\r\n            if iB in idxs_AtTenths:\r\n                s = sCmdPrompt0 + \"  At {:d}% of {} breps\".format(\r\n                    int(100.0 * (iB+1) / len_gBreps0), len_gBreps0)\r\n        \r\n            if bDebug:\r\n                print(s)\r\n            else:\r\n                Rhino.RhinoApp.SetCommandPrompt(s)\r\n        \r\n        rc = processBrep(\r\n                rgBrep_In,\r\n                idxFaces,\r\n                fDevTol=fDevTol,\r\n                iDegsToTry=iDegsToTry,\r\n                bSkipConical=bSkipConical,\r\n                bShrinkFirst=bShrinkFirst,\r\n                bDebug=bDebug)\r\n        if rc is None: return\r\n        sLogs_All.extend(rc[1])\r\n        if not rc[0]: continue\r\n        rgBreps_1F_Mod_thisBrep, idxsFs_Mod, srf_devs = rc[0]\r\n        \r\n        if not rgBreps_1F_Mod_thisBrep:\r\n            rgBrep_In.Dispose()\r\n            continue\r\n        \r\n        srf_devs_All.extend(srf_devs)\r\n        \r\n        if not bReplace:\r\n            gBrep1_thisBrep = []\r\n            for rgBrep_1F_New, idxF in zip(rgBreps_1F_Mod_thisBrep, idxsFs_Mod):\r\n                gBrep1 = sc.doc.Objects.AddBrep(rgBrep_1F_New)\r\n                if gBrep1 != Guid.Empty:\r\n                    gBrep1_thisBrep.append(gBrep1)\r\n            gBs1_perB0.append(gBrep1_thisBrep)\r\n        else:\r\n            # bReplace==True.\r\n            if bExtract:\r\n                rc = xBrepObject.replaceFaces(\r\n                        rdBrep_In,\r\n                        idxsFs_Mod,\r\n                        rgBreps_1F_Mod_thisBrep,\r\n                        bExtract=True,\r\n                        fTolerance_Join=max(srf_devs))\r\n                if rc:\r\n                    gBreps1_NewFaces_thisBrep, gBreps_RemainingBrep = rc\r\n                    gBs1_perB0.append(gBreps1_NewFaces_thisBrep)\r\n            else:\r\n                fTols_Edges = [edge.Tolerance for edge in rgBrep_In.Edges]\r\n                fTolerance_Join = max((\r\n                        2.0*fDevTol if fDevTol is not None else 0.0,\r\n                        1.1*max(fTols_Edges),\r\n                        sc.doc.ModelAbsoluteTolerance))\r\n                rc = xBrepObject.replaceFaces(\r\n                        rdBrep_In,\r\n                        idxsFs_Mod,\r\n                        rgBreps_1F_Mod_thisBrep,\r\n                        bExtract=False,\r\n                        fTolerance_Join=fTolerance_Join)\r\n                if rc:\r\n                    gBreps_withReplacedFaces_thisBrep = rc\r\n                    gBs1_perB0.append(gBreps_withReplacedFaces_thisBrep)\r\n\r\n        if bDebug or bEcho and len(gBreps0) == 1 and len(idxsFs_Mod)==1:\r\n            rgBrep_1F_Mod = rgBreps_1F_Mod_thisBrep[0]\r\n            s  = getNurbsSurfaceChangeDescription(\r\n                    rgBrep_In.Faces[idxsFs_Mod[0]].UnderlyingSurface(),\r\n                    rgBrep_1F_Mod.Surfaces[0])\r\n            s += \"  Deviation: {0:.2e}\".format(srf_devs[0])\r\n            print(s)\r\n\r\n        for brep in rgBreps_1F_Mod_thisBrep: brep.Dispose()\r\n        rgBrep_In.Dispose()\r\n\r\n        if (\r\n                any(g for gs in gBs1_perB0 for g in gs) and\r\n                len(gBreps0)==1\r\n                and (bDebug or bEcho)\r\n        ):\r\n            sc.doc.Objects.UnselectAll()\r\n            if bReplace:\r\n                if bExtract:\r\n                    print(\"{} face(s) extracted from brep and replaced.\".format(\r\n                        len(gBreps1_NewFaces_thisBrep)))\r\n                else:\r\n                    print(\"{} face(s) replaced in brep.\".format(len(idxsFs_Mod)))\r\n            else:\r\n                print(\"{} monoface brep(s) added.\".format(\r\n                    sum(len(bs) for bs in rgBreps_1F_Mod_thisBrep)))\r\n    \r\n    return (gBs1_perB0, srf_devs_All), sLogs_All\r\n\r\n\r\ndef main():\r\n    \r\n    if Rhino.RhinoApp.ExeVersion < 6:\r\n        print(\"This script doesn't work in Rhino versions previous to 6.\")\r\n        return\r\n    \r\n    rc = getInput()\r\n    if rc is None: return\r\n\r\n    (\r\n        objrefs0,\r\n        fDevTol,\r\n        iDegsToTry,\r\n        bSkipConical,\r\n        bShrinkFirst,\r\n        bReplace,\r\n        bExtract,\r\n        bEcho,\r\n        bDebug,\r\n        ) = rc\r\n\r\n\r\n    if not bDebug:\r\n        sc.doc.Views.RedrawEnabled = False\r\n    \r\n    Rhino.RhinoApp.SetCommandPrompt(\"Working ...\")\r\n    \r\n    rc = processBrepObjects(\r\n        rhBreps=objrefs0,\r\n        idxs_Faces=None,\r\n        fDevTol=fDevTol,\r\n        iDegsToTry=iDegsToTry,\r\n        bSkipConical=bSkipConical,\r\n        bShrinkFirst=bShrinkFirst,\r\n        bReplace=bReplace,\r\n        bExtract=bExtract,\r\n        bEcho=bEcho,\r\n        bDebug=bDebug,\r\n        )\r\n    (gBreps1, srf_devs_All), sLogs = rc\r\n\r\n    iCt_NeedLargerTol = 0\r\n    \r\n    for sLog in set(sLogs):\r\n        if not bDebug and len(sLogs) > 1 and \"Need tolerances\" in sLog:\r\n            iCt_NeedLargerTol += 1\r\n        else:\r\n            print(\"[{}] {}\".format(sLogs.count(sLog), sLog))\r\n    \r\n    if iCt_NeedLargerTol:\r\n        print(\"[{}] Need larger tolerance to convert.\".format(iCt_NeedLargerTol))\r\n\r\n    if not gBreps1:\r\n        print(\"Nothing was converted.\")\r\n    elif gBreps1 and len(gBreps1)>1 and (bDebug or bEcho):\r\n        print(\"Maximum deviations: [{:.2e},{:.2e}]\".format(\r\n            min(srf_devs_All), max(srf_devs_All)))\r\n    \r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "scriptcontext"
  ],
  "has_docstring": false
}