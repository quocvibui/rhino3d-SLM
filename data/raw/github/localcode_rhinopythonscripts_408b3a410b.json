{
  "source_url": "https://github.com/localcode/rhinopythonscripts/blob/34c5314a276e9d4d79a62da6bed96a8112552c2f/GeoJson2Rhino.py",
  "repo": "localcode/rhinopythonscripts",
  "repo_stars": 62,
  "repo_description": "A place to dump and share python scripts for use in McNeel's Rhino and Grasshopper",
  "license": "unknown",
  "filepath": "GeoJson2Rhino.py",
  "instruction": "Allows for the translation of GeoJSON data to Rhino objects",
  "code": "\"\"\"\nAllows for the translation of GeoJSON data to Rhino objects\n\nGeoJSON _does_ support 3d, so this can take 3d coordinates for 3d GeoJSONs\n\nThe GeoJSON Format Specification can be found here:\n    http://geojson.org/geojson-spec.html\n\nThe RhinoCommon SDK (where all the Rhino.Geometry objects are documented) is\nhere:\n    http://www.rhino3d.com/5/rhinocommon/\n\nI have decided to extend the GeoJSON specification by adding support for one\nmore type of geometry that would be really useful in Rhino (and elsewhere),\nthe Mesh. Here is an example of a json Mesh:\n\n    {\"type\": \"Feature\",\n     \"geometry\": {\n                  \"type\": \"Mesh\",\n                  \"coordinates\": [\n                                  [3.43, 54.234, 2343.23],\n                                  [...],\n                                  [...],\n                                  ...,\n                                  ]\n                  \"faces\": [\n                            [0,3,2],\n                            [5,32,1],\n                            ...,\n                            ]\n                  }\n      \"properties\": {\"prop0\": \"value0\"}\n      }\n\n\nExample of Use:\n    >>> import GeoJson2Rhino as geoj\n    >>> myGeoJson = '''\n{ \"type\": \"FeatureCollection\",\n  \"features\": [\n    { \"type\": \"Feature\",\n      \"geometry\": {\"type\": \"Point\", \"coordinates\": [102.0, 0.5]},\n      \"properties\": {\"prop0\": \"value0\"}\n      },\n    { \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"LineString\",\n        \"coordinates\": [\n          [102.0, 0.0], [103.0, 1.0], [104.0, 0.0], [105.0, 1.0]\n          ]\n        },\n      \"properties\": {\n        \"prop0\": \"value0\",\n        \"prop1\": 0.0\n        }\n      },\n    { \"type\": \"Feature\",\n       \"geometry\": {\n         \"type\": \"Polygon\",\n         \"coordinates\": [\n           [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],\n             [100.0, 1.0], [100.0, 0.0] ]\n           ]\n       },\n       \"properties\": {\n         \"prop0\": \"value0\",\n         \"prop1\": {\"this\": \"that\"}\n         }\n       }\n     ]\n   }'''\n   >>> guidList = geoj.load(myGeoJson) #stores guids of new rhino objects\n\n\"\"\"\n\n# Import standard library modules\nimport json\n\n# Import Rhino modules\nimport Rhino\nfrom Rhino.Geometry import *\nfrom scriptcontext import doc\n\n# import .NET libraries\nimport System\n\n\ndef addRhinoLayer(layerName, layerColor=System.Drawing.Color.Black):\n    \"\"\"Creates a Layer in Rhino using a name and optional color. Returns the\n    index of the layer requested. If the layer\n    already exists, the color is updated and no new layer is created.\"\"\"\n    docLyrs = doc.Layers\n    layerIndex = docLyrs.Find(layerName, True)\n    if layerIndex == -1:\n        layerIndex = docLyrs.Add(layerName,layerColor)\n    else: # it exists\n        layer = docLyrs[layerIndex] # so get it\n        if layer.Color != layerColor: # if it has a different color\n            layer.Color = layerColor # reset the color\n    return layerIndex\n\ndef PointToRhinoPoint(coordinates):\n    if len(coordinates) > 2:\n        z = coordinates[2]\n    else:\n        z = 0.0\n    x, y = coordinates[0], coordinates[1]\n    return Point3d(x, y, z)\n\ndef MultiPointToRhinoPoint(coordinates):\n    rhPointList = []\n    for point in coordinates:\n        rhPointList.append(PointToRhinoPoint(point))\n    return rhPointList\n\ndef MeshToRhinoMesh(coordinates, faces):\n    rhMesh = Mesh()\n    for point in coordinates:\n        rhPoint = PointToRhinoPoint(point)\n        rhMesh.Vertices.Add(rhPoint)\n    for face in faces:\n        i, j, k = tuple(face)\n        mFace = MeshFace(i, j, k)\n        rhMesh.Faces.AddFace(mFace)\n    rhMesh.Normals.ComputeNormals()\n    rhMesh.Compact()\n    return rhMesh\n\ndef LineStringToRhinoCurve(coordinates):\n    rhPoints = MultiPointToRhinoPoint(coordinates)\n    return Curve.CreateControlPointCurve(rhPoints, 1)\n\ndef MultiLineStringToRhinoCurve(coordinates):\n    rhCurveList = []\n    for lineString in coordinates:\n        rhCurveList.append(LineStringToRhinoCurve(lineString))\n    return rhCurveList\n\ndef PolygonToRhinoCurve(coordinates):\n    # each ring is a separate list of coordinates\n    ringList = []\n    for ring in coordinates:\n        ringList.append(LineStringToRhinoCurve(ring))\n    return ringList\n\ndef MultiPolygonToRhinoCurve(coordinates):\n    polygonList = []\n    for polygon in coordinates:\n        polygonList.append(PolygonToRhinoCurve(polygon))\n    return polygonList\n\ndef GeometryCollectionToParser(geometries):\n    pass # I need to figure this one out still\n\ndef addPoint(rhPoint, objAtt):\n    return doc.Objects.AddPoint(rhPoint, objAtt)\n\ndef addPoints(rhPoints, objAtt):\n    guidList = []\n    for rhPoint in rhPoints:\n        guidList.append(doc.Objects.AddPoint(rhPoint, objAtt))\n    return guidList\n\ndef addCurve(rhCurve, objAtt):\n    return doc.Objects.AddCurve(rhCurve, objAtt)\n\ndef addCurves(rhCurves, objAtt):\n    guidList = []\n    for curve in rhCurves:\n        guidList.append(addCurve(curve, objAtt))\n    return guidList\n\ndef addPolygon(ringList, objAtt):\n    # for now this just makes curves\n    # but maybe it should make TrimmedSrfs\n    # or should group the rings\n    return addCurves(ringList, objAtt)\n\ndef addPolygons(polygonList, objAtt):\n    guidList = []\n    for polygon in polygonList:\n        # !! Extending the guid list !!!\n        guidList.extend(addPolygon(polygon, objAtt))\n    return guidList\n\ndef addMesh(rhMesh, objAtt):\n    return doc.Objects.AddMesh(rhMesh, objAtt)\n\ngeoJsonGeometryMap = {\n        'Point':(PointToRhinoPoint, addPoint),\n        'MultiPoint':(MultiPointToRhinoPoint, addPoints),\n        'LineString':(LineStringToRhinoCurve, addCurve),\n        'MultiLineString':(MultiLineStringToRhinoCurve, addCurves),\n        'Polygon':(PolygonToRhinoCurve, addPolygon),\n        'MultiPolygon':(MultiPolygonToRhinoCurve, addPolygons),\n        'Mesh':(MeshToRhinoMesh, addMesh),\n        'GeometryCollection':(GeometryCollectionToParser),\n        }\n\ndef setUserKeys(properties, objAttributes):\n    for key in properties:\n        objAttributes.SetUserString(key, str(properties[key]))\n    return objAttributes\n\ndef jsonToRhinoCommon(jsonFeature):\n        # deal with the geometry\n        geom = jsonFeature['geometry']\n        geomType = geom['type'] # this will return a mappable string\n        coordinates = geom['coordinates']\n        # if this is a mesh, pass the faces\n        if geomType == 'Mesh':\n            faces = geom['faces']\n            rhFeature = geoJsonGeometryMap[geomType][0](coordinates, faces)\n        # translate the coordinates to Rhino.Geometry objects\n        else:\n            rhFeature = geoJsonGeometryMap[geomType][0](coordinates)\n        return rhFeature\n\ndef addJsonFeature(jsonFeature, objAttributes):\n        # deal with the properties\n        if jsonFeature['properties']:\n            objAttributes = setUserKeys(jsonFeature['properties'], objAttributes)\n        geomType = jsonFeature['geometry']['type']\n        rhFeature = jsonToRhinoCommon(jsonFeature)\n        # return the GUID(s) for the feature\n        return geoJsonGeometryMap[geomType][1](rhFeature, objAttributes)\n\ndef processGeoJson(parsedGeoJson,\n         destinationLayer=None,\n         destinationLayerColor=System.Drawing.Color.Black):\n    # get the features\n    jsonFeatures = parsedGeoJson['features']\n    guidResults = []\n    # set up object attributes\n    for jsonFeature in jsonFeatures: # for each feature\n        att = Rhino.DocObjects.ObjectAttributes()\n        # setup layer if requested\n        if destinationLayer != None:\n            att.LayerIndex = addRhinoLayer(destinationLayer,\n                                           destinationLayerColor)\n        guidResults.append(addJsonFeature(jsonFeature, att))\n    # return all the guids\n    return guidResults\n\ndef load(rawJsonData,\n         destinationLayer=None,\n         destinationLayerColor=System.Drawing.Color.Black):\n    # if the data already appears to be a dict literal ...\n    if type(rawJsonData) == dict:\n        jsonData = rawJsonData\n    else: # otherwise, just try to load it\n        jsonData = json.loads(rawJsonData)\n    # if this is just a GeoJSON ...\n    if jsonData[\"type\"] == \"FeatureCollection\":\n        # process the GeoJSON, pass the layer and color in\n        return processGeoJson(jsonData, destinationLayer,\n                              destinationLayerColor)\n    # or if this is a set of layers from PostSites ...\n    elif jsonData[\"type\"] == \"LayerCollection\":\n        # make a list for all the guids\n        allResults = []\n        layersList = jsonData['layers']\n        for layer in layersList: # for each layer\n            name = layer['name'] # get the name\n            if 'color' in layer: # get the color if it exists\n                color = layer['color']\n            else:\n                color = destinationLayerColor # or just make it black\n            geoJson = layer['contents'] # get the GeoJSON for this layer\n            # make it\n            layerResults = processGeoJson( geoJson, name, color )\n            allResults.append(layerResults)\n        return allResults\n    else:\n        return \"This doesn't look like correctly formatted GeoJSON data.\\nI'm not sure what to do with it, sorry.\"\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "scriptcontext"
  ],
  "has_docstring": true
}