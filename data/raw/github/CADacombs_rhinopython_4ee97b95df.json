{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Crv_convertSpansToLines.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Crv_convertSpansToLines.py",
  "instruction": "This script will convert linear contiguous spans to LineCurves.\r\nIt can be used as an alternative to _SimplifyCrv and _Convert _Output=Lines.\r\n\r\nMerge=No means not to combine spans.\r\n\r\nSend any...",
  "code": "\"\"\"\r\nThis script will convert linear contiguous spans to LineCurves.\r\nIt can be used as an alternative to _SimplifyCrv and _Convert _Output=Lines.\r\n\r\nMerge=No means not to combine spans.\r\n\r\nSend any questions, comments, or script development service needs to\r\n@spb on the McNeel Forums, https://discourse.mcneel.com/\r\n\"\"\"\r\n\r\n#! python 2  Must be on a line number less than 32.\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n180905: Created.\r\n...\r\n230824: Reenabled allowance of modifying options when curves are preselected.\r\n        Fixed bug that continued to process whole curves that were found to be arc, etc., -shaped.\r\n241220,21: Bug fix: Whole-curve conversion to a single line is no longer attempted on closed curves.\r\n        Added tolerance per length deviation option.\r\n241222: Now can optionally create a single line through end-start of closed curve when they are collinear.\r\n        Now merge is optional.\r\n241223: Refactored.\r\n\r\nTODO:\r\n    Add an angle tolerance?\r\n\r\n\r\n\r\nFrom https://developer.rhino3d.com/api/rhinocommon :\r\n    Curve.DuplicateSegments  Curve[] of segments  Duplicates curve segments. Explodes polylines, polycurves and G1 discontinuous NURBS curves. Single segment curves, such as lines, arcs, unkinked NURBS curves, are duplicated.\r\n    PolyCurve.Explode  Curve[] of polycurve segments  Explodes this PolyCurve into a list of Curve segments. This willnot explodenested polycurves. Call RemoveNesting first if you need all individual segments.\r\n    PolyCurve.RemoveNesting  bool  Explodes nested polycurve segments and reconstructs this curve from the shattered remains. The result will have not have any PolyCurves as segments but it will have identical locus and parameterization.\r\n    PolyCurve.CleanUp  Curve or None  Removes any nesting of polycurves. If this polycurve has just a single segment, the segment is returned. If, after nest removal, there are adjacent segments which are polylines, they are combined into a single polyline. The new curve may have a different domain from this polycurve. If the start and end segments of a closed input are polylines, the result may have a different seam location since the start and end segments will be combined.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'fDevTol'; keys.append(key)\r\n    values[key] = max((0.1 * sc.doc.ModelAbsoluteTolerance, 1e-6))\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bAlsoRatioTol'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fTolPerLengthUnit'; keys.append(key)\r\n    values[key] = 0.001\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fMinLineLength'; keys.append(key)\r\n    values[key] = 100.0 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bProcessArcs'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bMerge'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'MergeContiguousSegs'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bMergeThruSeam'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bReplace'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'Action'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Add', 'Replace')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        if not idxOpt: print(\"Add option for {} failed.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key in ('fDevTol', 'fMinLineLength', 'fTolPerLengthUnit'):\r\n            if cls.riOpts[key].CurrentValue <= 1e-6:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef addGeoms(geoms, bRedraw=True):\r\n    \"\"\" For debugging. \"\"\"\r\n\r\n    gOuts = []\r\n\r\n    if not hasattr(geoms, '__iter__'):\r\n        geoms = [geoms]\r\n\r\n    for geom in geoms:\r\n        try:\r\n            rc = geom.IsValidWithLog()\r\n            if not rc[0]:\r\n                print(\"{} skipped.\\n  {}\".format(geom.GetType().Name, rc[1]))\r\n                continue\r\n        except:\r\n            pass\r\n        if isinstance(geom, tuple):\r\n            gOut = sc.doc.Objects.AddSurface(geom[1])\r\n        elif isinstance(geom, rg.Line):\r\n            gOut = sc.doc.Objects.AddLine(geom)\r\n        elif isinstance(geom, rg.Curve):\r\n            gOut = sc.doc.Objects.AddCurve(geom)\r\n        elif isinstance(geom, rg.Surface):\r\n            gOut = sc.doc.Objects.AddSurface(geom)\r\n        elif isinstance(geom, rg.Point3d):\r\n            gOut = sc.doc.Objects.AddPoint(geom)\r\n        elif isinstance(geom, rg.Plane):\r\n            intrvl = rg.Interval(-sc.doc.ModelAbsoluteTolerance*1000.0, sc.doc.ModelAbsoluteTolerance*1000.0)\r\n            psrf = rg.PlaneSurface(geom, intrvl, intrvl)\r\n            gOut = sc.doc.Objects.AddSurface(psrf)\r\n        else:\r\n            raise ValueError(\"Method to add {} missing from addGeoms.\".format(geom.GetType().Name))\r\n        if gOut == gOut.Empty:\r\n            print(\"{} could not be added to document.\".format(rc.GetType().Name))\r\n        else:\r\n            gOuts.append(gOut)\r\n    if bRedraw: sc.doc.Views.Redraw()\r\n    return gOuts\r\n\r\n\r\ndef getFormattedDistance(fDistance):\r\n    if fDistance is None: return \"(No deviation provided)\"\r\n    if fDistance < 0.001:\r\n        return \"{:.2e}\".format(fDistance)\r\n    else:\r\n        return \"{:.{}f}\".format(fDistance, sc.doc.ModelDistanceDisplayPrecision)\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get curves with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select curves\")\r\n    \r\n    go.GeometryFilter = rd.ObjectType.Curve\r\n    \r\n    go.AcceptNumber(True, acceptZero=True)\r\n    \r\n    go.AlreadySelectedObjectSelect = True\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Keep objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False)\r\n    \r\n    bPreselectedObjsChecked = False\r\n\r\n    idxs_Opt = {}\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n        addOption('fDevTol')\r\n        addOption('fMinLineLength')\r\n        addOption('bAlsoRatioTol')\r\n        if Opts.values['bAlsoRatioTol']:\r\n            addOption('fTolPerLengthUnit')\r\n        addOption('bProcessArcs')\r\n        addOption('bMerge')\r\n        if Opts.values['bMerge']:\r\n            addOption('bMergeThruSeam')\r\n        addOption('bReplace')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        # Use bPreselectedObjsChecked so that only objects before the\r\n        # first call to go.GetMultiple is considered.\r\n        if not bPreselectedObjsChecked and go.ObjectsWerePreselected:\r\n            bPreselectedObjsChecked = True\r\n            go.EnablePreSelect(False, True)\r\n            continue\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n\r\n            gCrvs0 = []; rgEdges = []\r\n\r\n            for objref in go.Objects():\r\n                if objref.GeometryComponentIndex.Index == -1:\r\n                    gCrvs0.append(objref.ObjectId)\r\n                else:\r\n                    rdObj = objref.Object()\r\n                    if rdObj.ObjectType == rd.ObjectType.InstanceReference:\r\n                        print(\"Objects in block instances are not supported.\")\r\n                        continue\r\n                    rgEdges.append(objref.Geometry())\r\n\r\n            objrefs = go.Objects()\r\n\r\n            go.Dispose()\r\n\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fDevTol'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef getPassingLineCurve(rgCrv_In, bProcessArcs=False, fDevTol=None, fTolPerLengthUnit=None, fMinLineLength=123, bDebug=False):\r\n    \"\"\"\r\n    Returns on success: rg.LineCurve, float(Deviation), None\r\n    Returns on deviation fail: None, float(Deviation), None\r\n    Returns on other fails: None, None, str(Description of fail)\r\n    \"\"\"\r\n\r\n    if rgCrv_In is None:\r\n        return None, None, \"Geometry not found!  It will be skipped.\"\r\n\r\n\r\n    if not bProcessArcs:\r\n        if isinstance(rgCrv_In, rg.ArcCurve):\r\n            return None, None, \"Skipped ArcCurve.\"\r\n            \r\n            \r\n        def tryGetPracticalArc(rgCrv_In):\r\n            tol_IsArc = Rhino.RhinoMath.ZeroTolerance #max((1e-6, 0.001*sc.doc.ModelAbsoluteTolerance))\r\n            bSuccess, arc = rgCrv_In.TryGetArc(tol_IsArc)\r\n            if not bSuccess: return\r\n            maxRadius = sc.doc.ModelAbsoluteTolerance * 1e6\r\n            if arc.Radius > maxRadius:\r\n                if bDebug: print(\"Skipped arc shape with radius {}\".format(arc.Radius))\r\n                return\r\n            minAngleDegrees = 0.1*sc.doc.ModelAngleToleranceDegrees\r\n            if arc.AngleDegrees < minAngleDegrees:\r\n                if bDebug: print(\"Skipped arc shape with AngleDegrees {}\".format(arc.AngleDegrees))\r\n                return\r\n            if bDebug:\r\n                sEval = \"arc.AngleDegrees\"; print(sEval,'=',eval(sEval))\r\n                sEval = \"arc.Circumference\"; print(sEval,'=',eval(sEval))\r\n                sEval = \"arc.Radius\"; print(sEval,'=',eval(sEval))\r\n            return arc\r\n        \r\n        arc = tryGetPracticalArc(rgCrv_In)\r\n        if arc:\r\n            #sc.doc.Objects.AddArc(arc)\r\n            return None, None, \"Skipped arc-shaped non-ArcCurve.\"\r\n        #if rgCrv_In.IsArc(tol_IsArc):\r\n        #    return None, None, \"Skipped arc-shaped non-ArcCurve.\"\r\n\r\n    rgLc_Out = rg.LineCurve(rgCrv_In.PointAtStart, rgCrv_In.PointAtEnd)\r\n\r\n    if fMinLineLength is not None:\r\n        length_crv1 = rgLc_Out.GetLength()\r\n        if length_crv1 < fMinLineLength:\r\n            return None, None, \"Curve is too short.\"\r\n\r\n    if fDevTol is None:\r\n        fDevTol = 0.1 * sc.doc.ModelAbsoluteTolerance\r\n\r\n    if fTolPerLengthUnit:\r\n        fLength = rgCrv_In.GetLength()\r\n        fDevTol_Abs = min((fTolPerLengthUnit * fLength), fDevTol)\r\n    else:\r\n        fDevTol_Abs = fDevTol\r\n\r\n\r\n    tol_GDBC = 0.1*min(sc.doc.ModelAbsoluteTolerance, fDevTol_Abs)\r\n\r\n    rc = rg.Curve.GetDistancesBetweenCurves(\r\n        rgCrv_In,\r\n        rgLc_Out,\r\n        tolerance=tol_GDBC)\r\n\r\n    if not rc[0]:\r\n        return None, None, \"Deviation could not be determined by Curve.GetDistancesBetweenCurves.\"\r\n\r\n    fDev = rc[1]\r\n\r\n    if fDev <= fDevTol_Abs:\r\n        return rgLc_Out, fDev, None\r\n\r\n    return None, fDev, None\r\n\r\n\r\ndef _getUniqueKnots(nc, bDebug=False):\r\n    # All unique knots along curve domain except allow\r\n    # a single repeat for closed curves, but\r\n    # no additional duplicates for periodic curves.\r\n    # These start and stop work regardless of IsClosed and IsPeriodic.\r\n    start = nc.Degree-1\r\n    stop = nc.Knots.Count - nc.Degree + 1\r\n\r\n    ts_knots = []\r\n    for i in range(start, stop):\r\n        t = nc.Knots[i]\r\n        if t not in ts_knots:\r\n            ts_knots.append(t)\r\n            if bDebug: rs.AddTextDot('{0:.4f}'.format(t), nc.PointAt(t))\r\n\r\n    return ts_knots\r\n\r\n\r\ndef _getArcEndsParameterPairs(pc):\r\n    ts = []\r\n    for i in range(pc.SegmentCount):\r\n        seg = pc.SegmentCurve(i)\r\n        if isinstance(seg, rg.ArcCurve):\r\n            ts.append((\r\n                rg.PolyCurve.PolyCurveParameter(pc, i, seg.Domain.T0),\r\n                rg.PolyCurve.PolyCurveParameter(pc, i, seg.Domain.T1),\r\n                ))\r\n    return ts\r\n\r\n\r\ndef _removeInteriorArcParameters(rgC_In, ts_knots):\r\n    ts_arcPairs = _getArcEndsParameterPairs(rgC_In)\r\n\r\n    for t0, t1 in ts_arcPairs:\r\n        for tK in reversed(ts_knots):\r\n            if (t0 + Rhino.RhinoMath.ZeroTolerance) < tK < (t1 - Rhino.RhinoMath.ZeroTolerance):\r\n                ts_knots.remove(tK)\r\n\r\n\r\ndef _doesPolyCrvContainArcCrvs(pc):\r\n    for i in range(pc.SegmentCount):\r\n        seg = pc.SegmentCurve(i)\r\n        if isinstance(seg, rg.ArcCurve):\r\n            return True\r\n        if seg.IsArc():\r\n            return True\r\n    return False\r\n\r\n\r\ndef _doesPolyCrvContainNurbsCrvs(pc):\r\n    for i in range(pc.SegmentCount):\r\n        seg = pc.SegmentCurve(i)\r\n        if isinstance(seg, rg.NurbsCurve):\r\n            return True\r\n    return False\r\n\r\n\r\ndef _splitPolyCrvByParams(pc_In, ts):\r\n    pc_Segs_All = list(pc_In.Split(ts))\r\n    for i in range(len(pc_Segs_All)):\r\n        if pc_Segs_All[i].SpanCount != 1:\r\n            raise\r\n        # Overwrite PolyCurve-type segment with the\r\n        # single non-PolyCurve-type segment in segment.\r\n        pc_Segs_All[i] = pc_Segs_All[i].SegmentCurve(0)\r\n    return pc_Segs_All\r\n\r\n\r\ndef convertSpans_of_PolylineCrv(plc_In, fDevTol=None, fTolPerLengthUnit=None, fMinLineLength=None, bProcessArcs=False, bMergeThruSeam=True, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    if not isinstance(plc_In, rg.PolylineCurve):\r\n        raise Exception(\"{} passed to convertSpans_of_PolylineCrv.\".format(plc_In.GetType().Name))\r\n\r\n    segs_All = plc_In.DuplicateSegments()\r\n    pLine = plc_In.ToPolyline()\r\n    pts_All = pLine.ToArray()\r\n\r\n    idx_Pts_toKeep = [0]\r\n\r\n    idx_t_linear_start = 0\r\n    devs = []\r\n\r\n    for i in range(1, pLine.Count-1):\r\n        if sc.escape_test(throw_exception=False):\r\n            raise Exception(\"Break at index {}.\".format(i))\r\n\r\n        if bDebug: sEval = \"i\"; print(sEval,'=',eval(sEval))\r\n\r\n        pts_forSection = [pts_All[j] for j in range(idx_t_linear_start, i+1+1)]\r\n\r\n        linearSection = rg.PolylineCurve(pts_forSection)\r\n\r\n        rc = getPassingLineCurve(\r\n            linearSection,\r\n            bProcessArcs=False,\r\n            fDevTol=fDevTol,\r\n            fMinLineLength=None)\r\n\r\n        linearSection.Dispose()\r\n\r\n        if rc[0] is not None:\r\n            bContiguousLinearFound = True\r\n            devs.append(rc[1])\r\n\r\n            continue # to the next index.\r\n\r\n        # Failed, so record up to the current index.\r\n\r\n        idx_Pts_toKeep.append(i)\r\n        idx_t_linear_start = i\r\n\r\n    # Record the last section.\r\n    idx_Pts_toKeep.append(pLine.Count-1)\r\n\r\n\r\n    if plc_In.IsClosed and bMergeThruSeam and len(idx_Pts_toKeep) > 3:\r\n        pts_forSection = []\r\n        pts_forSection = [pts_All[j] for j in\r\n                         (idx_Pts_toKeep[-2], idx_Pts_toKeep[0], idx_Pts_toKeep[1])]\r\n        linearSection = rg.PolylineCurve(pts_forSection)\r\n\r\n        rc = getPassingLineCurve(\r\n            linearSection,\r\n            bProcessArcs=False,\r\n            fDevTol=fDevTol,\r\n            fMinLineLength=None)\r\n\r\n        if rc[0] is not None:\r\n            bContiguousLinearFound = True\r\n            devs.append(rc[1])\r\n        idx_Pts_toKeep[0] = idx_Pts_toKeep[-2]\r\n        del idx_Pts_toKeep[-1]\r\n\r\n    if not devs:\r\n        return None, None, \"No segments of PolylineCurve were combined.\"\r\n\r\n    pLc_Out = rg.PolylineCurve([pts_All[i] for i in idx_Pts_toKeep])\r\n\r\n    return (\r\n        pLc_Out,\r\n        max(devs),\r\n        None,\r\n        )\r\n\r\n\r\ndef convertSpans_withMerging(rgC_In, fDevTol=None, fTolPerLengthUnit=None, fMinLineLength=None, bProcessArcs=False, bMergeThruSeam=True, bDebug=False):\r\n    \"\"\"\r\n    Processes NURBS-form of input curve even if it is a PolyCurve.\r\n    \"\"\"\r\n\r\n    if isinstance(rgC_In, rg.PolylineCurve):\r\n        return convertSpans_of_PolylineCrv(\r\n            cleaned,\r\n            fDevTol=fDevTol,\r\n            fTolPerLengthUnit=fTolPerLengthUnit,\r\n            fMinLineLength=fMinLineLength,\r\n            bProcessArcs=bProcessArcs,\r\n            bMergeThruSeam=bMergeThruSeam,\r\n            bDebug=bDebug,\r\n            )\r\n\r\n    if isinstance(rgC_In, rg.NurbsCurve):\r\n        nc_FromIn = rgC_In.Duplicate()\r\n        ts_knots = _getUniqueKnots(nc_FromIn, bDebug=bDebug)\r\n        segs_All = nc_FromIn.Split(ts_knots)\r\n    elif isinstance(rgC_In, rg.PolyCurve):\r\n        cleaned = rgC_In.CleanUp()\r\n\r\n        if cleaned is None:\r\n            pc_fromIn = rgC_In.Duplicate()\r\n        else:\r\n            if isinstance(cleaned, rg.LineCurve):\r\n                return cleaned, 0.0, \"PolyCurve contained just one LineCurve.\"\r\n            if isinstance(cleaned, rg.PolylineCurve):\r\n                return convertSpans_of_PolylineCrv(\r\n                    cleaned,\r\n                    fDevTol=fDevTol,\r\n                    fTolPerLengthUnit=fTolPerLengthUnit,\r\n                    fMinLineLength=fMinLineLength,\r\n                    bProcessArcs=bProcessArcs,\r\n                    bMergeThruSeam=bMergeThruSeam,\r\n                    bDebug=bDebug,\r\n                    )\r\n\r\n            pc_fromIn = cleaned\r\n\r\n        nc_FromIn = pc_fromIn.ToNurbsCurve()\r\n\r\n        if not rgC_In.Domain.EpsilonEquals(nc_FromIn.Domain, 1e-9):\r\n            raise Exception(\r\n                \"NurbsCurve's domain doesn't EpsilonEqual the input curve's.\")\r\n\r\n        ts_knots = _getUniqueKnots(nc_FromIn, bDebug=bDebug)\r\n\r\n        if bDebug: print(ts_knots)\r\n        _removeInteriorArcParameters(rgC_In, ts_knots)\r\n        if bDebug: print(ts_knots)\r\n\r\n        segs_All = _splitPolyCrvByParams(rgC_In, ts_knots)\r\n\r\n    if bDebug:\r\n        sEval = 'len(ts_knots)'; print(sEval + ':' , eval(sEval))\r\n        sEval = 'ts_knots[0]'; print(sEval + ':' , eval(sEval))\r\n        #rs.AddTextDot(\"t:{}\".format(0), nc0.PointAt(ts_knots[0]))\r\n        sEval = 'ts_knots[-1]'; print(sEval + ':' , eval(sEval))\r\n        #rs.AddTextDot(\"t:{}\".format(-1), nc0.PointAt(ts_knots[-1]))\r\n        # Add segment index.\r\n        for i in range(len(ts_knots)-1):\r\n            t = (ts_knots[i] + ts_knots[i+1]) / 2.0\r\n            rs.AddTextDot(str(i), nc_FromIn.PointAt(t))\r\n\r\n\r\n    bools_IsSegLinear = []\r\n    devs = []\r\n    tols_Needed = []\r\n\r\n    for i, seg in enumerate(segs_All):\r\n        if i == 2:\r\n            pass\r\n        rc = getPassingLineCurve(\r\n            seg,\r\n            bProcessArcs=bProcessArcs,\r\n            fDevTol=fDevTol,\r\n            fTolPerLengthUnit=None, # Will later be checked for each tuples_splits.\r\n            fMinLineLength=None, # Will later be checked for each tuples_splits.\r\n            )\r\n        if rc and rc[0]:\r\n            bools_IsSegLinear.append(True)\r\n            devs.append(rc[1])\r\n        else:\r\n            bools_IsSegLinear.append(False)\r\n            tols_Needed.append(rc[1])\r\n\r\n    if not any(bools_IsSegLinear):\r\n        return None, None, \"No linear segments in input.\"\r\n\r\n    i = 0 # Segment and parameter index.\r\n    idx_t_linear_start = None\r\n    idx_t_nonlinear_start = None\r\n    tuples_splits = [] # tuple(tuple(int(beginning nc segment index), int(ending nc segment index)), bool(True if indices are linear section))\r\n    #bLinearFound = False\r\n    bContiguousLinearFound = False\r\n\r\n    while i < len(segs_All):\r\n        if sc.escape_test(throw_exception=False):\r\n            raise Exception(\"Break at index {}.\".format(i))\r\n\r\n        if bDebug: sEval = \"i\"; print(sEval,'=',eval(sEval))\r\n\r\n        if not bools_IsSegLinear[i]:\r\n            # Start of non-linear, contiguous group.\r\n\r\n            if idx_t_nonlinear_start is None:\r\n                idx_t_nonlinear_start = i\r\n\r\n            if idx_t_linear_start is not None:\r\n                # Record linear section.\r\n                if bContiguousLinearFound:\r\n                    tuples_splits.append(((idx_t_linear_start, i), True))\r\n                else:\r\n                    tuples_splits.append(((idx_t_linear_start, i), False))\r\n\r\n                bContiguousLinearFound = False\r\n                idx_t_linear_start = None\r\n\r\n            i += 1\r\n            continue\r\n\r\n        # Start of linear, contiguous group.\r\n\r\n        #bLinearFound = True\r\n\r\n        if idx_t_linear_start is None:\r\n            idx_t_linear_start = i\r\n\r\n            if idx_t_nonlinear_start is not None:\r\n                tuples_splits.append(((idx_t_nonlinear_start, i), False))\r\n                idx_t_nonlinear_start = None\r\n\r\n            #devs.append(devs_1stPass[i])\r\n\r\n            i += 1\r\n            continue\r\n\r\n        # Create a temporary curve and test for its total linearity.\r\n        seg = nc_FromIn.Trim(\r\n            rg.Interval(\r\n                ts_knots[idx_t_linear_start],\r\n                ts_knots[i+1]))\r\n\r\n        rc = getPassingLineCurve(\r\n            seg,\r\n            bProcessArcs=bProcessArcs,\r\n            fDevTol=fDevTol,\r\n            fTolPerLengthUnit=None,\r\n            fMinLineLength=None)\r\n        #addGeoms(seg)\r\n        #print(rc[2])\r\n        if rc[0]:\r\n\r\n            # Now test with length checks.\r\n            rc = getPassingLineCurve(\r\n                seg,\r\n                bProcessArcs=bProcessArcs,\r\n                fDevTol=fDevTol,\r\n                fTolPerLengthUnit=fTolPerLengthUnit,\r\n                fMinLineLength=fMinLineLength)\r\n\r\n            if rc[0]:\r\n                bContiguousLinearFound = True\r\n                devs.append(rc[1])\r\n\r\n            seg.Dispose()\r\n\r\n            # Try the next index.\r\n\r\n            i += 1\r\n            continue\r\n\r\n        seg.Dispose()\r\n\r\n        # MultiLinear failed.  Record up to the current index.\r\n\r\n        if bContiguousLinearFound:\r\n            tuples_splits.append(((idx_t_linear_start, i), True))\r\n        else:\r\n            tuples_splits.append(((idx_t_linear_start, i), False))\r\n\r\n        bContiguousLinearFound = False\r\n        idx_t_linear_start = None\r\n\r\n    # Record the last section.\r\n    if idx_t_linear_start is None:\r\n        tuples_splits.append(((idx_t_nonlinear_start, i), False))\r\n    else:\r\n        if bContiguousLinearFound:\r\n            tuples_splits.append(((idx_t_linear_start, i), True))\r\n        else:\r\n            tuples_splits.append(((idx_t_linear_start, i), False))\r\n\r\n\r\n    def tryMergeThruStart(rgC_In, ts_knots, tuples_splits):\r\n        #sEval = \"rgC_In.IsClosed\"; print(sEval,'=',eval(sEval))\r\n        if not rgC_In.IsClosed:\r\n            return\r\n\r\n        #sEval = \"tuples_splits[0]\"; print(sEval,'=',eval(sEval))\r\n        #sEval = \"tuples_splits[-1]\"; print(sEval,'=',eval(sEval))\r\n\r\n        if not (tuples_splits[0] and tuples_splits[-1]):\r\n            return\r\n\r\n        seg_Start = nc_FromIn.Trim(\r\n            rg.Interval(\r\n                ts_knots[tuples_splits[0][0][0]],\r\n                ts_knots[tuples_splits[0][0][1]]))\r\n\r\n        seg_End = nc_FromIn.Trim(\r\n            rg.Interval(\r\n                ts_knots[tuples_splits[-1][0][0]],\r\n                ts_knots[tuples_splits[-1][0][1]]))\r\n\r\n        rv = rg.Curve.JoinCurves([seg_Start, seg_End])\r\n        if rv.Count != 1:\r\n            return\r\n\r\n        joined = rv[0]\r\n\r\n        rc = getPassingLineCurve(\r\n            joined,\r\n            fDevTol=fDevTol,\r\n            fTolPerLengthUnit=fTolPerLengthUnit,\r\n            fMinLineLength=fMinLineLength)\r\n        #addGeoms(joined)\r\n        #print(rc[2])\r\n        joined.Dispose()\r\n        if bool(rc[0]):\r\n            return rc[1]\r\n\r\n    if bMergeThruSeam:\r\n        rv = tryMergeThruStart(rgC_In, ts_knots, tuples_splits)\r\n        sEval = \"rv\"; print(sEval,'=',eval(sEval))\r\n        if rv is not None:\r\n            #sEval = \"tuples_splits\"; print(sEval,'=',eval(sEval))\r\n            tuples_splits[0] = (tuples_splits[-1][0][0], tuples_splits[0][0][1]), True\r\n            #sEval = \"tuples_splits[0]\"; print(sEval,'=',eval(sEval))\r\n            del tuples_splits[-1]\r\n            #sEval = \"tuples_splits\"; print(sEval,'=',eval(sEval))\r\n            bContiguousLinearFound = True\r\n            devs.append(rv)\r\n\r\n\r\n    # Combine any contiguous non-linear tuples_splits.\r\n    tuples_splits_before_combines = tuples_splits[:]\r\n    i = len(tuples_splits) - 2\r\n    while i >= 0:\r\n        sc.escape_test()\r\n        if not tuples_splits[i][1] and not tuples_splits[i+1][1]:\r\n            tuples_splits[i] = (tuples_splits[i][0][0], tuples_splits[i+1][0][1]), False\r\n            del tuples_splits[i+1]\r\n        i -= 1\r\n\r\n\r\n    #if not bLinearFound:\r\n    #    return None, None, \"No linear segments found.\"\r\n\r\n\r\n    # Proceed replacing segments with LineCurves.\r\n    bLineSubstitutions = False\r\n    pc_Out = rg.PolyCurve()\r\n\r\n    for (idxS, idxE), bLinear in tuples_splits:\r\n        if bLinear:\r\n            line = rg.Line(nc_FromIn.PointAt(ts_knots[idxS]),\r\n                nc_FromIn.PointAt(ts_knots[idxE]))\r\n            if line.Length >= fMinLineLength:\r\n                pc_Out.Append(line)\r\n                bLineSubstitutions = True\r\n                #addGeoms(line)\r\n                continue # to next tuples_splits.\r\n\r\n        # Using rgC_In instead of nc_FromIn so as to not increase the degree of any NurbsCurves.\r\n        seg_ForOut = rgC_In.Trim(\r\n            rg.Interval(ts_knots[idxS], ts_knots[idxE]))\r\n        pc_Out.Append(seg_ForOut)\r\n        #addGeoms(seg_ForOut)\r\n\r\n    if not bLineSubstitutions:\r\n        pc_Out.Dispose()\r\n        return None, None, \"No lines replaced any part of curve.\"\r\n\r\n\r\n    # Success:\r\n\r\n    bSuccess, plc = pc_Out.TryGetPolyline()\r\n    if bSuccess:\r\n        return (\r\n            plc,\r\n            max(devs),\r\n            None,\r\n            )\r\n\r\n    return (\r\n        pc_Out,\r\n        max(devs),\r\n        None,\r\n        )\r\n\r\n\r\ndef convertSpans_NoMerging(rgC_In, fDevTol=None, fTolPerLengthUnit=None, fMinLineLength=None, bProcessArcs=False, bDebug=False):\r\n    \"\"\"\r\n    Processes NURBS-form of input curve even if it is a PolyCurve.\r\n    \"\"\"\r\n\r\n    if isinstance(rgC_In, rg.PolylineCurve):\r\n        return None, None, \"PolylineCurve cannot be processed without allowing segment merging.\"\r\n\r\n\r\n    # Process PolyCurve first in case other curve types are just hidden within nesting and a single segment.\r\n\r\n    if isinstance(rgC_In, rg.NurbsCurve):\r\n        nc_FromIn = rgC_In.Duplicate()\r\n        ts_knots = _getUniqueKnots(nc_FromIn, bDebug=bDebug)\r\n        segs_All = nc_FromIn.Split(ts_knots)\r\n    elif isinstance(rgC_In, rg.PolyCurve):\r\n        cleaned = rgC_In.CleanUp()\r\n\r\n        if cleaned is None:\r\n            pc_fromIn = rgC_In.Duplicate()\r\n        else:\r\n            if isinstance(cleaned, rg.LineCurve):\r\n                return cleaned, 0.0, \"PolyCurve contained just one LineCurve.\"\r\n            if isinstance(cleaned, rg.PolylineCurve):\r\n                return cleaned, 0.0, \"PolyCurve simplified to PolylineCurve but cannot be further processed without allowing segment merging.\"\r\n\r\n            pc_fromIn = cleaned\r\n\r\n        if bProcessArcs:\r\n            if not(_doesPolyCrvContainArcCrvs(pc_fromIn) or _doesPolyCrvContainNurbsCrvs(pc_fromIn)):\r\n                pc_fromIn.Dispose()\r\n                return None, None, \"No ArcCurves or NurbsCurve segments found for further processing.\"\r\n        else:\r\n            if not _doesPolyCrvContainNurbsCrvs(pc_fromIn):\r\n                pc_fromIn.Dispose()\r\n                return None, None, \"No NurbsCurve segments found for further processing.\"\r\n\r\n        nc_FromIn = pc_fromIn.ToNurbsCurve()\r\n\r\n        if not rgC_In.Domain.EpsilonEquals(nc_FromIn.Domain, 1e-9):\r\n            raise Exception(\r\n                \"NurbsCurve's domain doesn't EpsilonEqual the input curve's.\")\r\n\r\n        ts_knots = _getUniqueKnots(nc_FromIn, bDebug=bDebug)\r\n\r\n        if bDebug: print(ts_knots)\r\n        _removeInteriorArcParameters(rgC_In, ts_knots)\r\n        if bDebug: print(ts_knots)\r\n\r\n        segs_All = _splitPolyCrvByParams(rgC_In, ts_knots)\r\n\r\n    if bDebug:\r\n        sEval = 'len(ts_knots)'; print(sEval + ':' , eval(sEval))\r\n        sEval = 'ts_knots[0]'; print(sEval + ':' , eval(sEval))\r\n        #rs.AddTextDot(\"t:{}\".format(0), nc0.PointAt(ts_knots[0]))\r\n        sEval = 'ts_knots[-1]'; print(sEval + ':' , eval(sEval))\r\n        #rs.AddTextDot(\"t:{}\".format(-1), nc0.PointAt(ts_knots[-1]))\r\n        # Add segment index.\r\n        for i in range(len(ts_knots)-1):\r\n            t = (ts_knots[i] + ts_knots[i+1]) / 2.0\r\n            rs.AddTextDot(str(i), nc_FromIn.PointAt(t))\r\n\r\n\r\n    bools_IsLineCrv = []\r\n    bools_Is_seg_linear_nonLine = []\r\n    devs = []\r\n    tols_Needed = []\r\n\r\n    for i, seg in enumerate(segs_All):\r\n        if isinstance(seg, rg.LineCurve):\r\n            bools_IsLineCrv.append(True)\r\n            bools_Is_seg_linear_nonLine.append(False)\r\n            continue\r\n\r\n        rc = getPassingLineCurve(\r\n            seg,\r\n            bProcessArcs=bProcessArcs,\r\n            fDevTol=fDevTol,\r\n            fTolPerLengthUnit=fTolPerLengthUnit,\r\n            fMinLineLength=fMinLineLength,\r\n            )\r\n        if rc and rc[0]:\r\n            bools_IsLineCrv.append(False)\r\n            bools_Is_seg_linear_nonLine.append(True)\r\n            devs.append(rc[1])\r\n        else:\r\n            bools_IsLineCrv.append(False)\r\n            bools_Is_seg_linear_nonLine.append(False)\r\n            if rc[1] is not None:\r\n                tols_Needed.append(rc[1])\r\n\r\n    if not any(bools_Is_seg_linear_nonLine) and not any(bools_IsLineCrv):\r\n        return None, None, \"No linear segments in input (with current settings).\"\r\n\r\n    if not any(bools_Is_seg_linear_nonLine):\r\n        return None, None, \"No segments can be converted to lines (with current settings).\"\r\n\r\n\r\n    i = 0 # Segment index.\r\n    idx_t_notConverted_Start = None\r\n    idxs_ts_combined = [] # tuple(tuple(int(beginning nc segment index), int(ending nc segment index)), bool(True if indices are linear section))\r\n    #bLinearFound = False\r\n    bContiguousLinearFound = False\r\n\r\n    while i < len(segs_All):\r\n        if sc.escape_test(throw_exception=False):\r\n            raise Exception(\"Break at index {}.\".format(i))\r\n\r\n        if bDebug: sEval = \"i\"; print(sEval,'=',eval(sEval))\r\n\r\n        if not bools_Is_seg_linear_nonLine[i]:\r\n            # Start of non-linear, contiguous group.\r\n\r\n            if idx_t_notConverted_Start is None:\r\n                idx_t_notConverted_Start = i\r\n\r\n            i += 1\r\n            continue\r\n\r\n        if idx_t_notConverted_Start is not None:\r\n            # Record non-converted section.\r\n            idxs_ts_combined.append(((idx_t_notConverted_Start, i), False))\r\n            idx_t_notConverted_Start = None\r\n\r\n        # Record segment to convert.\r\n        idxs_ts_combined.append(((i, i+1), True))\r\n\r\n        i += 1\r\n\r\n    # Record the last section.\r\n    if idx_t_notConverted_Start is not None:\r\n        idxs_ts_combined.append(((idx_t_notConverted_Start, i), False))\r\n\r\n\r\n    # Proceed replacing segments with LineCurves.\r\n    pc_Out = rg.PolyCurve()\r\n\r\n    for (idxS, idxE), bLinear in idxs_ts_combined:\r\n        if bLinear:\r\n            line = rg.Line(nc_FromIn.PointAt(ts_knots[idxS]),\r\n                nc_FromIn.PointAt(ts_knots[idxE]))\r\n            if line.Length >= fMinLineLength:\r\n                pc_Out.Append(line)\r\n                #addGeoms(line)\r\n                continue # to next tuples_splits.\r\n\r\n        # Using rgC_In instead of nc_FromIn so as to not increase the degree of any NurbsCurves.\r\n        seg_ForOut = rgC_In.Trim(\r\n            rg.Interval(ts_knots[idxS], ts_knots[idxE]))\r\n        pc_Out.Append(seg_ForOut)\r\n        #addGeoms(seg_ForOut)\r\n\r\n    # Success.\r\n\r\n    bSuccess, plc = pc_Out.TryGetPolyline()\r\n    if bSuccess:\r\n        return (\r\n            plc,\r\n            max(devs) if devs else Rhino.RhinoMath.ZeroTolerance,\r\n            None,\r\n            )\r\n\r\n    return (\r\n        pc_Out,\r\n        max(devs) if devs else Rhino.RhinoMath.ZeroTolerance,\r\n        None,\r\n        )\r\n\r\n\r\ndef processCurve(rgCrv_In, fDevTol=None, fTolPerLengthUnit=None, fMinLineLength=None, bProcessArcs=False, bMerge=True, bMergeThruSeam=True, bDebug=False):\r\n    \"\"\"\r\n    Parameters:\r\n        rgCrv_In\r\n        bAlsoRatioTol\r\n        fDevTol (May be ratio or absoluate based on value of bAlsoRatioTol)\r\n        fMinLineLength\r\n        bProcessArcs\r\n        bDebug\r\n    Returns on success: rg.Curve, float(Deviation), None\r\n    Returns on deviation fail: None, float(Deviation), str(Description of fail)\r\n    Returns on other fails: None, None, str(Description of fail)\r\n    \"\"\"\r\n\r\n\r\n    if isinstance(rgCrv_In, rg.LineCurve):\r\n        return None, None, \"Skipped LineCurve.\"\r\n\r\n    if not bProcessArcs and isinstance(rgCrv_In, rg.ArcCurve):\r\n        return None, None, \"Skipped ArcCurve.\"\r\n\r\n    if rgCrv_In.IsArc(1e-6):\r\n        return None, None, \"Skipped curve passing IsArc.\"\r\n\r\n    if not bMerge and isinstance(rgCrv_In, rg.PolylineCurve):\r\n        return None, None, \"PolylineCurve cannot be processed without allowing segment merging.\"\r\n\r\n\r\n    if not rgCrv_In.IsClosed:\r\n\r\n        rvs = getPassingLineCurve(\r\n            rgCrv_In,\r\n            bProcessArcs=bProcessArcs,\r\n            fDevTol=fDevTol,\r\n            fTolPerLengthUnit=fTolPerLengthUnit,\r\n            fMinLineLength=fMinLineLength)\r\n\r\n        rgC_Res, fDev, sLog = rvs\r\n\r\n        if rgC_Res is not None:\r\n            return rvs\r\n\r\n        # Conversion of entire curve to line failed.\r\n        # Try converting segments between knots.\r\n\r\n\r\n    if isinstance(rgCrv_In, rg.PolylineCurve):\r\n        rvs = convertSpans_of_PolylineCrv(\r\n            rgCrv_In,\r\n            fDevTol=fDevTol,\r\n            fTolPerLengthUnit=fTolPerLengthUnit,\r\n            fMinLineLength=fMinLineLength,\r\n            bProcessArcs=bProcessArcs,\r\n            bMergeThruSeam=bMergeThruSeam,\r\n            bDebug=bDebug,\r\n            )\r\n    else:\r\n        if bMerge:\r\n            rvs = convertSpans_withMerging(\r\n                rgCrv_In,\r\n                fDevTol=fDevTol,\r\n                fTolPerLengthUnit=fTolPerLengthUnit,\r\n                fMinLineLength=fMinLineLength,\r\n                bProcessArcs=bProcessArcs,\r\n                bMergeThruSeam=bMergeThruSeam,\r\n                bDebug=bDebug,\r\n                )\r\n        else:\r\n            rvs = convertSpans_NoMerging(\r\n                rgCrv_In,\r\n                fDevTol=fDevTol,\r\n                fTolPerLengthUnit=fTolPerLengthUnit,\r\n                fMinLineLength=fMinLineLength,\r\n                bProcessArcs=bProcessArcs,\r\n                bDebug=bDebug,\r\n                )\r\n\r\n    rgC_Res, fDev, sLog = rvs\r\n\r\n    if rgC_Res is None:\r\n        if sLog is None:\r\n            return None, None, \"No simplification found.\"\r\n        return None, None, sLog\r\n\r\n    return rvs\r\n\r\n\r\n\r\n    # Optional code to ramp up tolerance.\r\n\r\n    p = -6\r\n    c_Out = None\r\n\r\n    tol_Sum = 0.0\r\n    bTolLimitReached = False\r\n\r\n    while True:\r\n        tol = 10.0**(p)\r\n\r\n        if tol >= (fDevTol - tol_Sum):\r\n            tol = (fDevTol - tol_Sum)\r\n            bTolLimitReached = True\r\n\r\n        print(p, tol)\r\n        \r\n        if p == -2:\r\n            addGeoms(c_Out)\r\n            pass\r\n\r\n        if sc.escape_test(throw_exception=False):\r\n            raise Exception(\"Break at tolerance {}.\".format(tol))\r\n\r\n\r\n        rvs = convertSpans_withMerging(\r\n            rgCrv_In if c_Out is None else c_Out,\r\n            fDevTol=tol,\r\n            fTolPerLengthUnit=fTolPerLengthUnit,\r\n            fMinLineLength=fMinLineLength,\r\n            bProcessArcs=bProcessArcs,\r\n            bDebug=bDebug)\r\n\r\n        if rvs[0] is not None:\r\n            #addGeoms(rc[0])\r\n            c_Out = rvs[0]\r\n\r\n        if bTolLimitReached:\r\n            1/0\r\n            if c_Out is None:\r\n                return None, None, \"No simplification found.\"\r\n            return c_Out, None, None\r\n\r\n        tol_Sum += tol\r\n\r\n        p += 1\r\n\r\n\r\ndef processCurveObject(rhCrv_In, **kwargs):\r\n    \"\"\"\r\n    curvesAndEdges0 = (GUIDs of CurveObjects) and/or BrepEdges\r\n    \"\"\"\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    bAlsoRatioTol = getOpt('bAlsoRatioTol')\r\n    fDevTol = getOpt('fDevTol')\r\n    fTolPerLengthUnit = getOpt('fTolPerLengthUnit')\r\n    fMinLineLength = getOpt('fMinLineLength')\r\n    bProcessArcs = getOpt('bProcessArcs')\r\n    bMerge = getOpt('bMerge')\r\n    bMergeThruSeam = getOpt('bMergeThruSeam')\r\n    bReplace = getOpt('bReplace')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    rgC_In = rs.coercecurve(rhCrv_In)\r\n\r\n    gC_In = rs.coerceguid(rhCrv_In)\r\n\r\n\r\n    rc = processCurve(\r\n        rgC_In,\r\n        fDevTol=fDevTol,\r\n        fTolPerLengthUnit=fTolPerLengthUnit if bAlsoRatioTol else None,\r\n        fMinLineLength=fMinLineLength,\r\n        bProcessArcs=bProcessArcs,\r\n        bMerge=bMerge,\r\n        bMergeThruSeam=bMergeThruSeam,\r\n        bDebug=bDebug,\r\n        )\r\n\r\n    rgC_Res, fDev, sLog = rc\r\n\r\n    if rgC_Res is None:\r\n        if bEcho and sLog is not None: print(sLog)\r\n        return rc\r\n\r\n    if bReplace:\r\n        if sc.doc.Objects.Replace(gC_In, rgC_Res):\r\n            return gC_In, fDev, \"Replaced a curve.\"\r\n        else:\r\n            s = \"Curve could not be replaced with new geometry.\"\r\n            if bEcho: print(s)\r\n            return None, None, s\r\n\r\n    # Add curve.\r\n    gC_Out = sc.doc.Objects.AddCurve(rgCrv_Res)\r\n    if gC_Out != Guid.Empty:\r\n        return gCs_Out, fDev, \"Added a curve.\"\r\n    else:\r\n        s = \"New curve could not be added.\"\r\n        if bEcho: print(s)\r\n        return None, None, s\r\n\r\n\r\ndef main():\r\n\r\n    rgCrvsAndEdges_In = getInput()\r\n    if rgCrvsAndEdges_In is None: return\r\n\r\n\r\n    bAlsoRatioTol = Opts.values['bAlsoRatioTol']\r\n    fDevTol = Opts.values['fDevTol']\r\n    fTolPerLengthUnit = Opts.values['fTolPerLengthUnit']\r\n    fMinLineLength = Opts.values['fMinLineLength']\r\n    bProcessArcs = Opts.values['bProcessArcs']\r\n    bMerge = Opts.values['bMerge']\r\n    bMergeThruSeam = Opts.values['bMergeThruSeam']\r\n    bReplace = Opts.values['bReplace']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n    fDevs = []\r\n    sLogs = []\r\n\r\n    for iC, objref in enumerate(rgCrvsAndEdges_In):\r\n        gCrv_In = rs.coerceguid(objref)\r\n        rgCrv_In = rs.coercecurve(objref)\r\n        #print(rs.coercerhinoobject(objref))\r\n\r\n        Rhino.RhinoApp.SetCommandPrompt(\r\n            \"Processing curve {}...\".format(\r\n                \"\" if len(rgCrvsAndEdges_In) == 1 else \"{} of {} \".format(iC+1, len(rgCrvsAndEdges_In))))\r\n\r\n        if isinstance(rgCrv_In, rg.BrepEdge):\r\n            gCrv_In = sc.doc.Objects.AddCurve(rgCrv_In)\r\n            rc = processCurveObject(\r\n                gCrv_In,\r\n                bAlsoRatioTol=bAlsoRatioTol,\r\n                fDevTol=fDevTol,\r\n                fTolPerLengthUnit=fTolPerLengthUnit,\r\n                fMinLineLength=fMinLineLength,\r\n                bProcessArcs=bProcessArcs,\r\n                bMerge=bMerge,\r\n                bMergeThruSeam=bMergeThruSeam,\r\n                bReplace=bReplace,\r\n                bEcho=False if len(rgCrvsAndEdges_In) > 1 else bEcho,\r\n                bDebug=bDebug,\r\n                )\r\n            gRes, fDev, sLog = rc\r\n            if gRes is None:\r\n                sc.doc.Objects.Delete(objectId=gCrv_In, quiet=False)\r\n            elif fDev is not None:\r\n                fDevs.append(fDev)\r\n            if sLog is not None:\r\n                sLogs.append(sLog)\r\n        elif gCrv_In is not None:\r\n            rc = processCurveObject(\r\n                gCrv_In,\r\n                bEcho=False if len(rgCrvsAndEdges_In) > 1 else bEcho)\r\n            gRes, fDev, sLog = rc\r\n            if gRes is None:\r\n                pass\r\n            elif fDev is not None:\r\n                fDevs.append(fDev)\r\n            if sLog is not None:\r\n                sLogs.append(sLog)\r\n        else:\r\n            s = \"Not CurveObject or BrepEdge.\"\r\n            if bEcho: print(s)\r\n            continue\r\n\r\n    if bEcho and len(rgCrvsAndEdges_In) > 1:\r\n        for sLog in set(sLogs):\r\n            print(\"[{}] {}\".format(sLogs.count(sLog), sLog))\r\n\r\n    if len(fDevs) == 1:\r\n        if bEcho: print(\"Deviation: {}\".format(getFormattedDistance(fDevs[0])))\r\n    elif len(fDevs) > 1:\r\n        if bEcho: print(\"Deviations: [{},{}]\".format(\r\n            getFormattedDistance(min(fDevs)),\r\n            getFormattedDistance(max(fDevs))))\r\n\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}