{
  "source_url": "https://github.com/969flash/UrbanFrame/blob/0f253b7a73233f7217608b7815c1a99f71e14f35/road_network_generator.py",
  "repo": "969flash/UrbanFrame",
  "repo_stars": 0,
  "repo_description": "Generate Urban Frame",
  "license": "unknown",
  "filepath": "road_network_generator.py",
  "instruction": "Road network generator",
  "code": "try:\n    from typing import List, Tuple\nexcept ImportError:\n    pass\nimport networkx as nx\nimport Rhino.Geometry as geo\nimport ghpythonlib.components as ghcomp\nimport utils\nimport importlib\nimport scriptcontext as sc\nimport units\n\nfrom units import Node, Edge, Road, Junction, RoadNetwork\n\nimportlib.reload(units)\nimportlib.reload(utils)\nTOL = 5\n\n\nclass RoadNetworkGenerator:\n    def __init__(self):\n        pass\n\n    def generate(self, road_data: List[Tuple[geo.Curve, float]]) -> RoadNetwork:\n        \"\"\"도로 네트워크를 생성합니다.\"\"\"\n\n        road_data = self.snap_roads(road_data, tol=2)\n        nodes = self._get_nodes(road_data)\n        edges = self._get_edges_from_nodes(nodes)\n        roads, junctions = self._get_road_and_junction(nodes, edges)\n        road_network = RoadNetwork(roads, junctions, nodes, edges)\n        return road_network\n\n    def snap_roads_pt(\n        self, roads: List[Tuple[geo.Curve, float]], tol: float\n    ) -> List[geo.Curve]:\n        \"\"\"도로 네트워크의 모든 교차점을 스냅합니다.\"\"\"\n        if len(roads) < 2:\n            return roads\n\n        # 모든 커브 쌍의 교차점 수집\n        all_crvs = [road[0] for road in roads]\n        pts = utils.get_pts_from_crvs(all_crvs)\n        for crv in all_crvs:\n            pts.extend(utils.get_vertices(crv))\n\n        snaped_road_datas = []\n        for road_crv, width in sorted(roads, key=lambda x: x[1]):\n            for pt in pts:\n                if pt.EpsilonEquals(road_crv.PointAtStart, tol):\n                    road_crv = utils.move_curve_endpoint(road_crv, pt, \"start\")\n\n                if pt.EpsilonEquals(road_crv.PointAtEnd, tol):\n                    road_crv = utils.move_curve_endpoint(road_crv, pt, \"end\")\n            snaped_road_datas.append((road_crv, width))\n\n        return snaped_road_datas\n\n    def snap_roads_crv(\n        self, roads: List[Tuple[geo.Curve, float]], tol: float\n    ) -> List[geo.Curve]:\n        \"\"\"도로 네트워크의 모든 교차점을 스냅합니다.\"\"\"\n        if len(roads) < 2:\n            return roads\n\n        snaped_road_datas = []\n        for road_crv, width in sorted(roads, key=lambda x: x[1]):\n            other_road_crvs = [crv for crv, w in roads if crv != road_crv]\n            for other_road_crv in other_road_crvs:\n                _, param = other_road_crv.ClosestPoint(road_crv.PointAtStart)\n                point_at = other_road_crv.PointAt(param)\n                if point_at.DistanceTo(road_crv.PointAtStart) <= tol:\n                    road_crv = utils.move_curve_endpoint(road_crv, point_at, \"start\")\n\n                _, param = other_road_crv.ClosestPoint(road_crv.PointAtEnd)\n                point_at = other_road_crv.PointAt(param)\n                if point_at.DistanceTo(road_crv.PointAtEnd) <= tol:\n                    road_crv = utils.move_curve_endpoint(road_crv, point_at, \"end\")\n\n            snaped_road_datas.append((road_crv, width))\n\n        return snaped_road_datas\n\n    def snap_roads(\n        self, road_data: List[Tuple[geo.Curve, float]], tol: float\n    ) -> List[geo.Curve]:\n        \"\"\"도로 네트워크의 모든 교차점을 스냅합니다.\"\"\"\n        if len(road_data) < 2:\n            return road_data\n\n        road_data = self.snap_roads_crv(road_data, tol)\n        road_data = self.snap_roads_pt(road_data, tol)\n\n        return road_data\n\n    def merge_edges_in_node(self, nodes: List[Node]) -> List[Node]:\n        \"\"\"같은 폭의 도로 2개만 연결된 노드를 없애고 엣지를 병합합니다.\"\"\"\n        # TODO: 인접노드 병합 기능도\n\n        nearby_node_groups = []\n        for node in nodes:\n            if any(node in group for group in nearby_node_groups):\n                continue\n\n            nearby_nodes = [\n                n\n                for n in nodes\n                if n != node and n.point.DistanceTo(node.point) < TOL * 2\n            ]\n            if nearby_nodes:\n                nearby_node_groups.append([node] + nearby_nodes)\n\n        merged_edges = []  # type: List[Edge]\n        edges_to_remove = []  # type: List[Edge]\n        nodes_to_remove = []  # type: List[Node]\n        result_nodes = []\n\n        for node in nodes:\n            if len(node.edges) != 2:\n                continue\n\n            e1, e2 = node.edges\n            if e1.width != e2.width:\n                continue\n            merged_crv = list(geo.Curve.JoinCurves([e1.curve, e2.curve]))[0]\n            new_edge = Edge(merged_crv, e1.width)\n            merged_edges.append(new_edge)\n            edges_to_remove.extend([e1, e2])\n            nodes_to_remove.append(node)\n\n        for node in nodes:\n            if node in nodes_to_remove:\n                continue\n\n            node.edges = [e for e in node.edges if e not in edges_to_remove]\n\n            for edge in merged_edges:\n                if edge.is_at(node):\n                    node.add_edges([edge])\n            result_nodes.append(node)\n\n        return result_nodes\n\n    def _get_nodes(self, road_data: List[Tuple[geo.Curve, float]]) -> List[Node]:\n        # 입력 정규화: 단일 커브 리스트 또는 (커브, 폭) 리스트 모두 허용\n        # 모든 커브 쌍의 교차점 수집\n        curves = [rd[0] for rd in road_data]\n        node_pts = utils.get_pts_from_crvs(curves)\n        edges = self._get_edges(road_data, node_pts)\n\n        nodes = []\n        for node_pt in node_pts:\n            node = Node(node_pt)\n            connected_edges = [e for e in edges if e.is_at(node)]\n            if not connected_edges:\n                raise ValueError(f\"No connected edges found for node at {node_pt}\")\n            node.add_edges(connected_edges)\n            nodes.append(node)\n\n        nodes = self.merge_edges_in_node(nodes)\n\n        return nodes\n\n    def _get_edges(\n        self, road_data: List[Tuple[geo.Curve, float]], node_pts: List[geo.Point3d]\n    ) -> List[Edge]:\n        edges = []\n        for curve, width in road_data:\n            pts_on_crv = [pt for pt in node_pts if utils.is_pt_on_crv(pt, curve)]\n\n            split_curves = utils.split_curve_at_pts(curve, pts_on_crv)\n            for split_curve in split_curves:\n                edge = Edge(split_curve, width)\n                edges.append(edge)\n        return edges\n\n    def _get_edges_from_nodes(self, nodes: List[Node]) -> List[Edge]:\n        edges = []\n        for node in nodes:\n            edges.extend(node.edges)\n        edges = list(set(edges))\n        return edges\n\n    def _get_road_and_junction(\n        self, nodes: List[Node], edges: List[Edge]\n    ) -> Tuple[List[Road], List[Junction]]:\n        junctions = []  # type: List[Junction]\n        for node in nodes:\n            junction_region = self._get_junction_region(node)\n            junction = Junction(junction_region, node)\n            junctions.append(junction)\n\n        roads = []  # type: List[Road]\n        for edge in edges:\n            road_region = self._get_road_region(edge, junctions)\n            road = Road(road_region, edge)\n            roads.append(road)\n\n        for junction in junctions:\n            connected_roads = [r for r in roads if r.edge.is_at(junction.node)]\n            junction.connected_roads = connected_roads\n\n        return roads, junctions\n\n    def _get_junction_region(self, node: Node) -> geo.Curve:\n        node_circle = geo.Circle(\n            node.point, max(e.width for e in node.edges)\n        ).ToNurbsCurve()\n\n        intersections = []\n        for edge in node.edges:\n            offset_result = utils.offset_crv_outward(edge.curve, edge.width / 2)\n            if not offset_result:\n                raise ValueError(\"Failed to offset road curve.\")\n            for offset_crv in offset_result:\n                inter_pts = utils.get_pts_from_crv_crv(node_circle, offset_crv)\n                intersections.extend(inter_pts)\n\n        if not intersections:\n            raise ValueError(\"No intersection found for junction region.\")\n\n        result = ghcomp.ConvexHull(intersections, geo.Plane.WorldXY).hull\n\n        return result\n\n    def _get_road_region(self, edge: Edge, junctions: List[Junction]) -> geo.Curve:\n        junction_regions = []\n        # edge의 양 끝점에 있는 정션을 수집한다\n        for j in junctions:\n            if j.node == edge.curve.PointAtStart or j.node == edge.curve.PointAtEnd:\n                junction_regions.append(j.region)\n\n        road_region = utils.offset_crv_outward(edge.curve, edge.width / 2)\n        if len(road_region) != 1:\n            raise ValueError(\"offset result wrong.\")\n\n        if not junction_regions:\n            return road_region[0]\n\n        try:\n            diff_region = utils.get_difference_regions(\n                road_region, junction_regions, 0.5\n            )\n        except:\n            raise ValueError(\"도로크기에 비해 교차로가 너무 큽니다.\")\n\n        return max(diff_region, key=lambda r: r.GetLength())\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "scriptcontext"
  ],
  "has_docstring": false
}