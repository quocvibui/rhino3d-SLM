{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_Sun_Shades_Calculator.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_Sun_Shades_Calculator.py",
  "instruction": "Use this component to generate shading devices, either surface or pergola, for any glazed surfmyPlaneace or list of glazed surfaces.  \nThe component first culls all sun vectors obstructed by the...",
  "code": "# Sun Shades Calculator\n# Copyright (c) 2017, Abraham Yezioro <ayez@technion.ac.il> and Antonello Di Nunzio <antonellodinunzio@gmail.com> \n# Sun Shades Calculator is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Sun Shades Calculator is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n# \n# See <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\"\"\"\nUse this component to generate shading devices, either surface or pergola, for any glazed surfmyPlaneace or list of glazed surfaces.  \nThe component first culls all sun vectors obstructed by the context, if provided.\nBy default it calculates the device as a \"new brand\" one but it also can calculate the cut profile for a given surface.\nThe default it will generate an overhang over the window (or multiple overhangs if the _numOfShds is increased).  \nReferences:\nShaviv E., 1975. \"A Method for the Design of Fixed External Sun-Shades\". \"Build International\"  (8), Applied Science Publishers LTD, England, (pp.121-150).\nShaviv E., 1984. \"A Design Tool for Determining the Form of Fixed & Movable Sun-Shades\".  \"ASHRAE Trans.\" Vol. 90, AT-84-18 No. 4, Atlanta (pp.1-14).\n\n-\nProvided by Ladybug 0.0.69\n    \n    Args:\n        _SurfaceOrPergola_: 0= Device optimised for period, will give the horizontal or tilted surface over the top of the window, or the cut profile device on a provided shading surface. 1= Pergola with fins. Default is 0.\n        _window: A Surface or Brep representing a window to be used for shading design.  This can also be a list of Surfaces of Breps.\n        _numOfShds_: The number of shades to generated for each window.\n        _udiv_: Number of row divisions of the window. Used for choosing the lower and higher rows you want to protect. Default is 3.\n        _sunVectors: Sun vectors from the sunPath component.\n        context_: Breps/surfaces that you want to account for as blocking objects. Using it you'll get the shading shape needed for the specific situation.\n        shadeSurface_: An optional shade surface representing a 2D area under consideration for shading. This input can only be used with the sun vector method.\n        ---------------: ...\n        _shdSrfAngle_: In case NO shadeSurface is provided a plane over the window will be used as base for the calculation. In this case you can provide the angle of this plane. Default is 0.0.\n        _shdSrfShift_: In case NO shadeSurface is provided a plane over the window will be used as base for the calculation. n this case you can provide a shift distance from top of the window. Default is 0.01\n        _numPergolaFins_: \"Number of pergola fins. Default is 10.\n        _finsAngle_: \"Angle for pergola fins. Default is 45.\n        ---------------: ...\n        _delaunayHeight_: Distance from base curve and top intersection points. Used by the Delauney Mesh component. Default is 5.\n        _offsetFactor_: VERY important input!! The offset factor for the ConvexHull curve. Will be used for the Delauneay mesh. Default is 40.\n        _cullRes_: Resolution for culling points. 0=Don't cull, 1= Regular cull, 2= Cull a lot. Check the final surface for quality of results, 3= Extreme cull. Be carefull with the results. Default is 1\n    Returns:\n        readMe!: ...\n        pointsOnWindow: Net of points on window\n        uPoints: Net of points on window\n        ptsContext: Show the intersection point of sun vectors with context\n        cullPts: Show the points that define the contour of the shading device. Pay attention to those more/less dense areas covered by these points.\n        finalSrf: Surface representing the shape of the shading device.\n\"\"\"\n##print 'In sunShades'\nghenv.Component.Name = \"Ladybug_Sun_Shades_Calculator\"\nghenv.Component.NickName = 'SunShades_Calc'\nghenv.Component.Message = 'VER 0.0.69\\nDEC_30_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"LB-Legacy\"\nghenv.Component.SubCategory = \"3 | EnvironmentalAnalysis\"\n#compatibleLBVersion = VER 0.0.59\\nFEB_01_2015\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"3\"\nexcept: pass\n\n\n# modules\nimport Rhino as rc\nimport scriptcontext as sc\nimport ghpythonlib.components as ghc\n\nimport math as m\n\n# For accesssing GH classes\n# #########################################\nimport System\nfrom System import Object\nimport clr\nclr.AddReference(\"Grasshopper\")\nimport Grasshopper.Kernel as gh\nfrom Grasshopper.Kernel.Data import GH_Path                     # For creating Path for Data Tree\nfrom Grasshopper import DataTree                                # For creating Data Tree\n# #########################################\n\ninputsDict = {\n     \n0:  [\"_SurfaceOrPergola_\", \"0= Device optimised for period, will give the horizontal or tilted surface over the top of the window,\"\\\n    \" or the cut profile device on a provided shading surface. 1= Pergola with fins. Default is 0.\"],\n1:  [\"_window\", \"A Surface or Brep representing a window to be used for shading design.  This can also be a list of Surfaces of Breps.\"],\n2:  [\"_numOfShds_\", \"The number of shades to generated for each glazed surface.\"],\n3:  [\"_udiv_\", \"Number of row divisions of the window. Used for choosing the lower and higher rows you want to protect. Default is 1.\"],\n4:  [\"_sunVectors\", \"Output of Ladybug sunPath component.\"],\n5:  [\"context_\", \"Breps/surfaces that you want to account for as blocking objects. \"],\n6:  [\"shadeSurface_\", \"An optional shade surface representing a 2D area under consideration for shading. \"],\n7:  [\"---------------\", \"---------------\"],\n8:  [\"_shdSrfAngle_\", \"In case NO shadeSurface is provided a plane over the window will be used as base for the calculation. \" \\\n    \"In this case you can provide the angle of this plane. Default is 0.0.\"],\n9: [\"_shdSrfShift_\", \"In case NO shadeSurface is provided a plane over the window will be used as base for the calculation. \" \\\n    \"In this case you can provide a shift distance from top of the window. Default is 0.01\" ],\n10:  [\"_numPergolaFins_\", \"Number of pergola fins. Default is 10.\"],\n11: [\"_finsAngle_\", \"Angle for pergola fins. Default is 45.\"],\n12: [\"---------------\", \"---------------\"],\n13: [\"_delaunayHeight_\", \"Distance from base curve and top intersection points. Used by the Delauney Mesh component. Default is 5.\"],\n14: [\"_offsetFactor_\", \"VERY important input!! The offset factor for the ConvexHull curve. Will be used for the Delauneay mesh. Default is 40.\"],\n15: [\"_cullRes_\", \"Resolution for culling points. 0=Don't cull, 1= Regular cull, 2= Cull a lot. Check the final surface for quality of results, 3= Extreme cull. Be carefull with the results. Default is 1.\"],\n}\n\n# manage component inputs\n\nif _SurfaceOrPergola_ == None: _SurfaceOrPergola_ = 0\nnumInputs = ghenv.Component.Params.Input.Count\n\n#if _SurfaceOrPergola_ == 0 and shadeSurface_ == None:\nif (_SurfaceOrPergola_ == 0 or _SurfaceOrPergola_ == 2): # and shadeSurface_ == None:\n    for input in range(numInputs):\n        #if input == 9 or input == 10:\n        if input ==  10 or input == 11:\n            ghenv.Component.Params.Input[input].NickName = \".\"\n            ghenv.Component.Params.Input[input].Name = \".\"\n            ghenv.Component.Params.Input[input].Description = \" \"\n            ghenv.Component.Attributes.Owner.OnPingDocument()\n        else:\n            ghenv.Component.Params.Input[input].NickName = inputsDict[input][0]\n            ghenv.Component.Params.Input[input].Name = inputsDict[input][0]\n            ghenv.Component.Params.Input[input].Description = inputsDict[input][1]\nelif _SurfaceOrPergola_ == 1 and shadeSurface_ == None:\n    for input in range(numInputs):\n        ghenv.Component.Params.Input[input].NickName = inputsDict[input][0]\n        ghenv.Component.Params.Input[input].Name = inputsDict[input][0]\n        ghenv.Component.Params.Input[input].Description = inputsDict[input][1]\n#elif (_SurfaceOrPergola_ == 0 or _SurfaceOrPergola_ == 2) and shadeSurface_ != None:\n#elif (_SurfaceOrPergola_ == 2) and shadeSurface_ != None:\n#    for input in range(numInputs):\n#        if input == 7 or input == 8 or input == 9 or input == 10:\n#            ghenv.Component.Params.Input[input].NickName = \".\"\n#            ghenv.Component.Params.Input[input].Name = \".\"\n#            ghenv.Component.Params.Input[input].Description = \" \"\n#        else:\n#            ghenv.Component.Params.Input[input].NickName = inputsDict[input][0]\n#            ghenv.Component.Params.Input[input].Name = inputsDict[input][0]\n#            ghenv.Component.Params.Input[input].Description = inputsDict[input][1]\nelif _SurfaceOrPergola_ == 1 and shadeSurface_ != None:\n    for input in range(numInputs):\n        #if input == 7 or input == 8:\n        #if input == 7:\n        #    ghenv.Component.Params.Input[input].NickName = \".\"\n        #    ghenv.Component.Params.Input[input].Name = \".\"\n        #    ghenv.Component.Params.Input[input].Description = \" \"\n        #else:\n        #    ghenv.Component.Params.Input[input].NickName = inputsDict[input][0]\n        #    ghenv.Component.Params.Input[input].Name = inputsDict[input][0]\n        #    ghenv.Component.Params.Input[input].Description = inputsDict[input][1]\n        ghenv.Component.Params.Input[input].NickName = inputsDict[input][0]\n        ghenv.Component.Params.Input[input].Name = inputsDict[input][0]\n        ghenv.Component.Params.Input[input].Description = inputsDict[input][1]\nelse:\n    for input in range(numInputs):\n        ghenv.Component.Params.Input[input].NickName = inputsDict[input][0]\n        ghenv.Component.Params.Input[input].Name = inputsDict[input][0]\n        ghenv.Component.Params.Input[input].Description = inputsDict[input][1]\n            \nghenv.Component.Attributes.Owner.OnPingDocument()\n\n# functions\ndef giveWarning(warningMsg):\n    w = gh.GH_RuntimeMessageLevel.Warning\n    ghenv.Component.AddRuntimeMessage(w, warningMsg)\n    print warningMsg\n    return -1\n\ndef checkTheData(window, sunVectors, context):\n    contextFlag = True\n    if context:\n        for i in range(len(context)):\n            if context[i] == None:\n                warning = \"Context has Null items. Please clean them and try again\"\n                giveWarning(warning)\n                contextFlag = False\n    if not window or not sunVectors or (context and contextFlag == False):\n        checkData = False\n    elif window and sunVectors:\n        checkData = True\n    else: checkData = True\n    return checkData\n\n\ndef identifyRectangularWindow(window):\n    pts = rc.Geometry.Brep.DuplicateVertices(window)\n    \n    if len(pts) == 4:\n        points = rc.Collections.Point3dList(pts)\n        points_Sort = rc.Geometry.Point3d.SortAndCullPointList(points, sc.doc.ModelAbsoluteTolerance)\n        ## Check for both cases of rectangular window: Taller than wider or Wider than Taller\n        if (points_Sort[0][0] == points_Sort[1][0] and points_Sort[0][1] == points_Sort[1][1] and \\\n           points_Sort[2][0] == points_Sort[3][0] and points_Sort[2][1] == points_Sort[3][1] and \\\n           points_Sort[0][2] == points_Sort[3][2] and points_Sort[1][2] == points_Sort[2][2]) or \\\n           (points_Sort[0][0] == points_Sort[3][0] and points_Sort[0][1] == points_Sort[3][1] and \\\n           points_Sort[1][0] == points_Sort[2][0] and points_Sort[1][1] == points_Sort[2][1] and \\\n           points_Sort[0][2] == points_Sort[1][2] and points_Sort[2][2] == points_Sort[3][2]):\n           rectangularWindow = True\n        else:\n            rectangularWindow = False\n    else:\n        rectangularWindow = False\n\n    return rectangularWindow\n\ndef pointsOfWindow(window, udiv, numOfShds):\n    rectangularWindow = identifyRectangularWindow(window)\n    if rectangularWindow == False:\n        #print 'NO rectangular window'\n        pointsOnWindow = []\n        edges = window.DuplicateEdgeCurves()\n        if len(edges) == 1:\n            t_vals = edges[0].DivideByCount(udiv + 10, True)\n            for t in t_vals:\n                pointsOnWindow.append(edges[0].PointAt(t))\n            \n        else:\n            uPoints = []\n            for edge in edges:\n                t_vals = edge.DivideByCount(udiv, True)\n                for t in t_vals:\n                    uPoints.append(edge.PointAt(t))\n            \n            pointsOnWindow = rc.Geometry.Point3d.CullDuplicates(uPoints, sc.doc.ModelAbsoluteTolerance)\n    else:\n        #print 'YES rectangular window'\n        pts = rc.Geometry.Brep.DuplicateVertices(window)\n        \n        points = rc.Collections.Point3dList(pts)\n        points_Sort1 = rc.Geometry.Point3d.SortAndCullPointList(points, sc.doc.ModelAbsoluteTolerance)\n        \n        points_Sort = []\n        for i in range(len(points_Sort1)):\n            ptSrt1 = rc.Geometry.Point3d(points_Sort1[i][0], points_Sort1[i][1],points_Sort1[i][2]) \n            points_Sort.append( rc.Geometry.Point3d(ptSrt1) )\n        if points_Sort1[0][2] > points_Sort1[2][2]:     # For those cases where the first point is higher than the second point.\n                                                        # Without this the finalSrf is twisted towards the first point of each row\n                                                        # which is wrong (not planar)\n            for i in range(len(points_Sort1)):\n                tmpPtSrt = rc.Geometry.Point3d(points_Sort1[i][0], points_Sort1[i][1],points_Sort1[i][2]) \n                points_Sort.append( rc.Geometry.Point3d(points_Sort1[i][0], points_Sort1[i][1],points_Sort1[i][2] ) )\n                ##points_Sort.append( rc.Geometry.Point3d(tmpPtSrt) )\n                \n            ##print 'Swapping'\n            swapPointA        = points_Sort1[0][2]\n            swapPointB        = points_Sort1[2][2]\n            points_Sort[0][2] = swapPointB\n            points_Sort[3][2] = swapPointB\n            points_Sort[2][2] = swapPointA\n            points_Sort[1][2] = swapPointA\n        #else:\n            \n        frame = []\n        ########################################################################\n        ##print points_Sort[0], '\\n', points_Sort[1], '\\n', points_Sort[2],  '\\n', points_Sort[3]\n\n        ## Case where the window is WIDER than taller\n        if points_Sort[0][0] == points_Sort[1][0] and points_Sort[0][1] == points_Sort[1][1] and \\\n           points_Sort[2][0] == points_Sort[3][0] and points_Sort[2][1] == points_Sort[3][1] and \\\n           points_Sort[0][2] == points_Sort[3][2] and points_Sort[1][2] == points_Sort[2][2]:\n            frame.append(rc.Geometry.LineCurve( points_Sort[1], points_Sort[0]) )    # in RS the order was 0 and 1\n            frame.append(rc.Geometry.LineCurve( points_Sort[0], points_Sort[3]) )\n            #print 'Wider'\n        ## Case where the window is TALLER than wider\n        elif points_Sort[0][0] == points_Sort[3][0] and points_Sort[0][1] == points_Sort[3][1] and \\\n           points_Sort[1][0] == points_Sort[2][0] and points_Sort[1][1] == points_Sort[2][1] and \\\n           points_Sort[0][2] == points_Sort[1][2] and points_Sort[2][2] == points_Sort[3][2]:\n            frame.append(rc.Geometry.LineCurve( points_Sort[3], points_Sort[0]) )    # in RS the order was 0 and 1\n            frame.append(rc.Geometry.LineCurve( points_Sort[0], points_Sort[1]) )\n            #print 'Taller'\n\n        ########################################################################    #CHECK WITH ANTONELLO\n        #frame = []\n        #frame.append(rc.Geometry.LineCurve( points_Sort[1], points_Sort[0]) )    # in RS the order was 0 and 1\n        #frame.append(rc.Geometry.LineCurve( points_Sort[0], points_Sort[3]) )\n        \n        ##vCol = rc.Geometry.Curve.DivideByCount(frame[0], udiv, True)\n        vCol = rc.Geometry.Curve.DivideByCount(frame[0], numOfShds, True)\n        uRow = rc.Geometry.Curve.DivideByCount(frame[1], udiv, True)\n        verP = []\n        horP = []\n        for t in vCol:\n            verP.append(frame[0].PointAt(t))\n        for t in uRow:\n            horP.append(frame[1].PointAt(t))\n        \n        ##vPoints = []\n        uPoints = []\n        for i in range(0, len(verP) + 0, 1): #vdiv or numOfShds\n            for j in range(0, len(horP) + 0, 1):\n                newPt = ( rc.Geometry.Point3d(horP[j][0], horP[j][1], verP[i][2]) )\n                uPoints.append(newPt)   # This is the full grid of point on window\n\n        row1 = 0                        # First row of points. Usually the bottom line\n        row2 = numOfShds #vdiv               # Top row of points. Usually the top line\n        rowsOfWindows = 2               # Number of rows to calculate later on. Should be 2\n        pointsOnWindow = []\n        start = row1 * udiv +row1\n        end = start + udiv\n        #print start, end\n        start1 = row2 * udiv +row2\n        end1 = start1 + udiv\n        #print start1, end1\n        \n        for i in range(start, end +1, 1):\n            pointsOnWindow.append( uPoints[i] )\n            #@print i, uPoints[i][2], pointsOnWindow[i][2]\n        for i in range(start1, end1 +1, 1):\n            pointsOnWindow.append( uPoints[i] )\n    return pointsOnWindow, uPoints\n\ndef loopRowPoints(uPoints, udiv, numOfShds):\n    row1 = 0               # First row of points. Usually the bottom line\n    start = row1 * udiv\n    end   = start + udiv\n    groupPoints = []\n    rowPoints   = []\n    for i in range(1, numOfShds + 1, 1): # Start from row 1. Row 0 is the bottom one.\n        start1 = i * udiv + i\n        end1 = start1 + udiv\n        groupPoints.append((start, end, start1, end1))\n        start = start1# + udiv + 1\n        end   = end1#   + udiv + 1\n    \n    for i in range(len(groupPoints)):\n        tmpPts = []\n        for j in range(groupPoints[i][0], groupPoints[i][1] + 1, 1):\n            tmpPts.append( uPoints[j] )\n        for j in range(groupPoints[i][2], groupPoints[i][3] + 1, 1):\n            tmpPts.append( uPoints[j] )\n        rowPoints.append(tmpPts)\n    return rowPoints, groupPoints\n\ndef isSrfFacingTheVector(sunV, normalVector):\n    sunVRev = rc.Geometry.Vector3d(sunV)\n    sunVRev.Reverse()\n    #print math.degrees(rc.Geometry.Vector3d.VectorAngle(sunVRev, normalVector))\n    if rc.Geometry.Vector3d.VectorAngle(sunVRev, normalVector) < m.pi/2: return True\n    else: return False\n\ndef getSrfPlane(brep):\n    cenPt = rc.Geometry.AreaMassProperties.Compute(brep).Centroid\n    # sometimes the center point is not in the right place\n    cenPt = brep.ClosestPoint(cenPt)\n    bool, centerPtU, centerPtV = brep.Faces[0].ClosestPoint(cenPt)\n    normalVector = brep.Faces[0].NormalAt(centerPtU, centerPtV)\n    return rc.Geometry.Plane(cenPt, normalVector), cenPt\n\ndef raysIntersection(rays, shade, cullRes):\n    if cullRes == 0:\n        culFactor = 1 #0.1\n        pass\n    elif cullRes == 1:\n        culFactor = 5 #1\n    elif cullRes == 2:\n        culFactor = 10 #2\n        pass\n    elif cullRes == 3:\n        culFactor = 20\n        pass\n    ##if   sc.doc.ModelAbsoluteTolerance * 1000 <=   5: tolFactor = 100   #0.001\n    ##elif sc.doc.ModelAbsoluteTolerance * 1000 <=  50: tolFactor = 10    #0.01\n    ##elif sc.doc.ModelAbsoluteTolerance * 1000 <= 500: tolFactor = 1     #0.1\n    \n    ## Reducing even more the points to be used for calculation\n    if   sc.doc.ModelAbsoluteTolerance * 1000 <=   5: tolFactor = 150   * culFactor   #0.001\n    elif sc.doc.ModelAbsoluteTolerance * 1000 <=  50: tolFactor =  15   * culFactor   #0.01\n    elif sc.doc.ModelAbsoluteTolerance * 1000 <= 500: tolFactor =   1.5 * culFactor   #0.1\n    #print sc.doc.ModelAbsoluteTolerance * 1000, tolFactor\n    \n    points_on_ShdSrf = []\n    for i, ray in enumerate(rays):\n        # ShdSrf intersection\n        int = rc.Geometry.Intersect.Intersection.RayShoot(ray, shade, 1)\n        if int != None:\n            points_on_ShdSrf.extend(int)\n    points = rc.Geometry.Point3d.CullDuplicates(points_on_ShdSrf, sc.doc.ModelAbsoluteTolerance * tolFactor) # Rhino Tolerance is too low that no point are culled\n\n    return points\n\ndef fromPlaneToSrf(plane):\n    # This because rays method doesn't work with plane\n    rectangle = rc.Geometry.Rectangle3d(plane, 100, 100)\n    segments = rectangle.ToNurbsCurve().DuplicateSegments()\n    shadeSurface = rc.Geometry.Brep.CreateEdgeSurface(segments)\n    \n    # generate vector\n    cenPt = rc.Geometry.AreaMassProperties.Compute(shadeSurface).Centroid\n    linea_plane = rc.Geometry.Line(cenPt, plane.Origin)\n    vector_plane_scale = linea_plane.Direction\n    \n    # move it in the right place\n    shadeSurface.Translate(vector_plane_scale)\n    \n    return shadeSurface\n\ndef calcIntersections(shadeSurface, pointsOnWindow, grPt, sunVectors, shdSrfShift, shdSrfAngle, window, context, uPoints, cullRes):\n    ##################################################################### WINDOW\n    # from Brep to surface\n    surface_window = window.Surfaces[0]\n    \n    # find the normal of each surface\n    brepPlane, cenPt = getSrfPlane(window)\n    normalVector = brepPlane.Normal\n    ######################################################### PLANE IF NO SHDSRF\n    if shadeSurface: # for very complex pergola shades\n        # tangents vectors\n        vec = rc.Geometry.Surface.Evaluate(surface_window, 0.5, 0.5, 1)[2]\n        \n        # select the normal vector for the plane\n        z_vectors = []\n        for v in vec:\n            z_vectors.append(abs(v[2]))\n        vector_p = vec[z_vectors.index(min(z_vectors))]\n    \n    else:\n    #if not shadeSurface:\n        # find the point with the maximum z\n        z_values = []\n        for pt in pointsOnWindow:\n            z_values.append(pt[2])\n        \n        base_point = pointsOnWindow[z_values.index(max(z_values))]\n        \n        # tangents vectors\n        vec = rc.Geometry.Surface.Evaluate(surface_window, 0.5, 0.5, 1)[2]\n        \n        # select the normal vector for the plane\n        z_vectors = []\n        for v in vec:\n            z_vectors.append(abs(v[2]))\n        vector_p = vec[z_vectors.index(min(z_vectors))]\n        \n        # set the translation and rotation of the plane\n        vector_movePlane = rc.Geometry.Vector3d(0, 0, shdSrfShift)\n        xtrans = rc.Geometry.Transform.Translation(vector_movePlane)\n        base_point.Transform(xtrans)\n        \n        # make the plane\n        plane = rc.Geometry.Plane(base_point, vector_p, normalVector)\n        plane.Rotate(m.radians(shdSrfAngle), vector_p, base_point)\n        \n        # compatible rotation with the sun rays direction\n        bool, linea_test = rc.Geometry.Intersect.Intersection.PlanePlane(plane, rc.Geometry.Plane.WorldXY)\n        point_test = linea_test.PointAt(0.5)\n        line_from_point = rc.Geometry.Line(point_test, cenPt)\n        direction_test = line_from_point.Direction\n        #if isSrfFacingTheVector(direction_test, normalVector) == False:\n        #    plane.Rotate(m.radians(-shdSrfAngle * 2), vector_p, base_point)\n        #    print 'here'\n            \n    ############################################################## INTERSECTIONS\n    # generate rays\n    sun_lines = []\n    sun_rays = []\n    length_vector = 50   ### Check for a better definition!!!\n    for point in pointsOnWindow:\n        for sunV in sunVectors:\n            if isSrfFacingTheVector(sunV, normalVector):\n                sun_lines.append(rc.Geometry.Line(point, -sunV * length_vector))\n                sun_rays.append(rc.Geometry.Ray3d(point, -sunV))\n    lines = sun_lines\n    \n    # effect of the context\n    ptsContext = []\n    contextVectors  = []\n    noContextVectors = []\n    if context:\n        rays = []\n        # intersection\n        for i, ray in enumerate(sun_rays):\n            intersection = rc.Geometry.Intersect.Intersection.RayShoot(ray, context, 1)\n            if intersection == None or len(intersection) == 0:\n                noContextVectors.append(sun_lines[i])\n                rays.append(sun_rays[i])\n            else:\n                contextVectors.append(sun_lines[i])\n                for p in intersection:\n                    ptsContext.append( p )\n        sun_rays = rays\n    \n    # intersections\n    if shadeSurface:\n        tmp_cullPts = raysIntersection(sun_rays, [shadeSurface], cullRes)\n    else:\n        shadeSurface = fromPlaneToSrf(plane)\n        ##@@cullPts = raysIntersection(sun_rays, [shadeSurface], cullRes)\n        tmp_cullPts = raysIntersection(sun_rays, [shadeSurface], cullRes)\n        \n    ### Forcing the Upper left point on window to be part of the cullPoints\n    cullPts = []\n    if shadeSurface_ == None:\n        ##cullPts.append(uPoints[0])\n        cullPts.append(uPoints[ grPt[0] ])  # Include the first point of EACH shading division\n    \n    if tmp_cullPts!= None:\n        for i in range(0, len(tmp_cullPts)): \n            cullPts.append(tmp_cullPts[i])\n    else:\n        warning = \"Seems to be that the shading surface doesn't intersect any sun vector.\\n\" + \\\n        \"    If you are giving a surface for the shadeSurface_ input, be sure that it will affect your window.\"\n        giveWarning(warning)\n\n    return cullPts, ptsContext, normalVector, cenPt, vector_p\n\ndef finalSurfStuff(cullPts, delaunayHeight, offsetFactor, shadeSurface):\n    \n    worldPlane = rc.Geometry.Plane.WorldXY\n    \n    if shadeSurface == None:    # In case no shading surface was provided\n        #$print 'None'\n        planeFromPoints = rc.Geometry.Plane.FitPlaneToPoints(cullPts)\n    else:    # In case shading surface was provided\n        #$print 'WITH'\n        points_surface = ghc.SurfacePoints(shadeSurface).points\n        \n        planeFromPoints = rc.Geometry.Plane.FitPlaneToPoints(points_surface)##\n        #planeFromPoints = rc.Geometry.Plane.FitPlaneToPoints(points_surface)[1]##\n\n    if planeFromPoints:\n        wp  = worldPlane.Normal\n        if shadeSurface == None:    # In case no shading surface was provided\n            myPlane = planeFromPoints [1] # extract plane from FitPlaneToPoints\n        else:    # In case shading surface was provided\n            myPlane = planeFromPoints[1] # extract plane from FitPlaneToPoints###########################################????????????????????????\n            ##myPlane = planeFromPoints # extract plane from FitPlaneToPoints\n        \n        #print type(myPlane), planeFromPoints\n        pfp = rc.Geometry.Plane.Normal.GetValue(myPlane)\n        \n        vectorAngle = rc.Geometry.Vector3d.VectorAngle(pfp, wp)\n        tolAngle = 70       # Tolerance angle. Right now I set it to 70 but this should be followed up\n        if ((vectorAngle >= tolAngle) and (vectorAngle <= 90)) or (vectorAngle >= tolAngle and (vectorAngle < (90 + (90 - tolAngle)))):\n            flag = 0        #0 is for VERTICAL shading surface\n        elif(vectorAngle < tolAngle) or (vectorAngle > (90 + (90 - tolAngle))):\n            flag = 1        #1 is for NON VERTICAL shading surface\n            \n        if flag == 0:\n            worldZXPlane = rc.Geometry.Plane.WorldZX\n            worldYZPlane = rc.Geometry.Plane.WorldYZ\n            \n            wp_ZX = worldZXPlane.Normal * -(1)\n            wp_YZ = worldYZPlane.Normal * -(1)\n            \n            vectorAngle_ZX = rc.Geometry.Vector3d.VectorAngle(pfp, wp_ZX)\n            vectorAngle_YZ = rc.Geometry.Vector3d.VectorAngle(pfp, wp_YZ)\n            \n            if vectorAngle_ZX <=45 or vectorAngle_ZX >=135 and worldYZPlane <= 225:\n                basePlane = worldZXPlane\n                convexHullPlane = cutPlane = rc.Geometry.Plane.WorldZX\n                \n                convexHullPlane = rc.Geometry.Plane.Translate(convexHullPlane, worldZXPlane.Normal * -delaunayHeight)\n\n                convex_Trim_Plane = convexHullPlane\n                cutPlane = rc.Geometry.Plane.Translate(cutPlane, worldZXPlane.Normal * -(delaunayHeight - .01))\n                \n                directionPlane = cutPlane\n            else:\n                basePlane = worldYZPlane\n            \n            G, X = ghc.MoveToPlane(cullPts, convexHullPlane, True, True)\n            delaunayPoints1 = G\n            flatPts = [ rc.Geometry.Point3d( p ) for p in delaunayPoints1 ]\n       \n        elif flag == 1:\n            convex_Trim_Plane = rc.Geometry.Plane.WorldXY        # Connect to ConvexHull and MeshPlaneSec\n            \n            convexHullPlane = convex_Trim_Plane\n            p1 = rc.Geometry.Point3d( 0, 0, delaunayHeight - 0.01)\n            v1 = rc.Geometry.Vector3d(1, 0, 0)\n            v2 = rc.Geometry.Vector3d(0, 1, 0)\n            directionPlane    = rc.Geometry.Plane( p1, v1, v2 )        # Connect to Direction input of Project\n\n            direction  =  rc.Geometry.Vector3d.Add( rc.Geometry.Vector3d(0, 0, 0), rc.Geometry.Vector3d(0, 0, delaunayHeight))        # Connect to Direction input of Project     \n            #Using RS the direction is 0,0,5. Using RC direction is 0,0,-5. Be aware of this, maybe we need to multiply by (-1) \n           \n            flatPts = [ rc.Geometry.Point3d( p ) for p in cullPts ]\n            \n            for i in range(len(cullPts)):               # Flat Z axis point to some height for the DelaunayMesh action\n                flatPts[i][2] = delaunayHeight\n                \n            trimPlanePoint = rc.Geometry.Point3d(0,0, delaunayHeight - 0.01)\n        \n    ###################    \n    spans = 20\n    flexibility = 1\n    points_CULL = [rc.Geometry.Point(pt) for pt in cullPts]\n    patch = ghc.Patch(None, cullPts, spans, flexibility, True) \n    if flag == 0:\n        H, Hz, I = ghc.ConvexHull(cullPts, rc.Geometry.Plane.WorldZX)       # CHECK THIS LATER FOR OTHER CASES or UNIFY WITH FLAG 1\n    elif flag == 1:\n        H, Hz, I = ghc.ConvexHull(cullPts, convexHullPlane)\n\n    points_PV = []\n    count = H.PointCount\n    for i in range(count):\n        points_PV.append(H.Point(i))\n    \n    H_alt     = rc.Geometry.PolylineCurve(points_PV)\n    areaH     = rc.Geometry.AreaMassProperties.Compute(H).Area\n    centH_alt = rc.Geometry.AreaMassProperties.Compute(H).Centroid\n\n    scaleH    = rc.Geometry.Transform.Scale(centH_alt, offsetFactor)\n    dupH_alt  = rc.Geometry.PolylineCurve.Duplicate(H_alt)\n    dupH_alt.Transform(scaleH)\n    offsetCrv = [dupH_alt]\n    \n    areaHalt      = rc.Geometry.AreaMassProperties.Compute(H_alt).Area\n    areaoffsetCrv = rc.Geometry.AreaMassProperties.Compute(offsetCrv[0]).Area\n    \n    if (areaHalt > areaoffsetCrv):\n        print \"Case BAD offset\"\n        scaleH    = rc.Geometry.Transform.Scale(centH_alt, offsetFactor * (-1))\n        dupH_alt  = rc.Geometry.PolylineCurve.Duplicate(H_alt)\n        dupH_alt.Transform(scaleH)\n        offsetCrv = [dupH_alt]\n\n    delaunayPoints = []\n    for i in range(len(cullPts)):               # Flat Z axis point to some height for the DelaunayMesh action\n        delaunayPoints.append(flatPts[i])\n        \n    res = 40\n    divCrv = offsetCrv[0].DivideByCount(res, True)\n    \n    for p in divCrv:\n        delaunayPoints.append(offsetCrv[0].PointAt(p))\n        \n    delaunayMesh = ghc.DelaunayMesh(delaunayPoints, convex_Trim_Plane)\n    M = delaunayMesh \n    trimCurve = ghc.MeshXPlane(delaunayMesh, directionPlane) \n    projectedCrv = ghc.Project(trimCurve, patch, directionPlane)\n    splitSrf = ghc.SurfaceSplit(patch, projectedCrv)\n    \n    \n    \n    H1, Hz1, I1 = ghc.ConvexHull(cullPts, myPlane) #planeFromPoints\n    cen = rc.Geometry.AreaMassProperties.Compute(H1).Centroid\n    centerH = rc.Geometry.Point3d(cen)\n    #print centerH\n    \n    distances = []\n    for srf in splitSrf:\n        cent = rc.Geometry.AreaMassProperties.Compute(srf).Centroid\n        distance = centerH.DistanceTo(cent)\n        distances.append(distance)\n    \n    #print ' Min distance for split surface ', min(distances), distances\n    finalSrf = splitSrf[distances.index(min(distances))]\n    \n    \"\"\"\n    # Below the original way to solve the issue ##\n    if shadeSurface:\n        H1, Hz1, I1 = ghc.ConvexHull(cullPts, planeFromPoints)\n        cen = rc.Geometry.AreaMassProperties.Compute(H1).Centroid\n        centerH = rc.Geometry.Point3d(cen)\n        #print centerH\n\n        uv = rc.Geometry.Surface.ClosestPoint(shadeSurface, centerH)\n        point = rc.Geometry.Surface.Evaluate(shadeSurface, uv[0], uv[1], 10)\n\n    s0 = splitSrf[0]\n    s1 = splitSrf[1]\n    \n    swapFinalSrf = False\n    if swapFinalSrf ==False:\n        finalSrf = splitSrf[1]\n    else:\n        finalSrf = splitSrf[0]\n    \"\"\"\n\n    return finalSrf\n\n\ndef calculatePergola(finalSrf, vectorP, normalVector, cenPt, numPergolaFins, finsAngle, sunVectors):\n    ##################################################################### CURVES\n    # use Untrimmed surface (Domain shape)\n    flat_srf = finalSrf.Surfaces[0].ToBrep()\n    \n    # boudary box & center\n    bbox = finalSrf.GetBoundingBox(True)\n    center = bbox.Center\n    \n    \n    # cutter plane\n    cut_plane = rc.Geometry.Plane(center, vectorP)\n    \n    \n    # make a line where to put all planes\n    curves_for_planes = rc.Geometry.Intersect.Intersection.BrepPlane(flat_srf, cut_plane, sc.doc.ModelAbsoluteTolerance)[1]# attention! sometimes the intersections are multiple\n    if len(curves_for_planes) > 1:\n        curve = rc.Geometry.Curve.JoinCurves(curves_for_planes, 1) # I'm not sure this tolerance can works for all cases, we need a big tolerance value to join difficult curves\n        curve_for_planes = curve[0]\n    else:\n        curve_for_planes = curves_for_planes[0]\n    if cenPt.DistanceTo(curve_for_planes.PointAtStart) < cenPt.DistanceTo(curve_for_planes.PointAtEnd):\n        curve_for_planes.Reverse()\n    \n    \n    # if curve for planes is not horizontal\n    start_point = curve_for_planes.PointAtStart\n    end_point = curve_for_planes.PointAtEnd\n    \n    if  start_point[2] != end_point[2]:\n        end_point_updated = rc.Geometry.Point3d(end_point[0], end_point[1], start_point[2])\n        line_base = rc.Geometry.Line(start_point, end_point_updated)\n        curve_for_planes_straight = line_base.ToNurbsCurve()\n    else: curve_for_planes_straight = curve_for_planes.ToNurbsCurve()\n    \n    \n    # find the brep points\n    finalSrf_crv = rc.Geometry.Brep.DuplicateEdgeCurves(finalSrf)\n    \n    point_finalSrf = []\n    test = []\n    for crv in finalSrf_crv:\n        segments = crv.DuplicateSegments()\n        for segment in segments:\n            point_finalSrf.append(segment.PointAtStart)\n            point_finalSrf.append(segment.PointAtEnd)\n    point_finalSrf = rc.Geometry.Point3d.CullDuplicates(point_finalSrf, sc.doc.ModelAbsoluteTolerance)\n    \n    \n    # find the best size of the curve_for_planes_straight\n    if point_finalSrf == None or point_finalSrf == 1: # when you connect Ladybug_ShadingDesigner or Rhino surface\n        rc.Geometry.Curve.Domain.SetValue(curve_for_planes_straight, rc.Geometry.Interval(0, 1.00))\n        \n    else:\n        parameters_on_strcrv = []\n        \n        for point in point_finalSrf:\n            bool, t = rc.Geometry.NurbsCurve.ClosestPoint(curve_for_planes_straight, point)\n            if bool:\n                parameters_on_strcrv.append(t)\n        start_point_size = curve_for_planes_straight.PointAt(min(parameters_on_strcrv))\n        end_point_size = curve_for_planes_straight.PointAt(max(parameters_on_strcrv))\n        \n        curve_for_planes_straight = rc.Geometry.Line(start_point_size, end_point_size).ToNurbsCurve()\n    \n    # check01- num_division\n    if numPergolaFins <= 1:\n        warning = \"Please set a number of division greater or equals than 2\"\n        giveWarning(warning)\n        return -1\n        \n    # make multiple planes & find the intersection curves\n    curves = []\n    planes = []\n    points = []\n    for i in range(numPergolaFins + 1): # (+1)to generate also the last plane.. I have to check if it works for all cases\n        plane = rc.Geometry.NurbsCurve.PerpendicularFrameAt(curve_for_planes_straight, i / numPergolaFins)[1]\n        point = curve_for_planes_straight.PointAt(i / numPergolaFins)\n        \n        points.append(point)\n        planes.append(plane)\n        \n        bool, curve_points, a = rc.Geometry.Intersect.Intersection.BrepPlane(finalSrf, plane, sc.doc.ModelAbsoluteTolerance * 0.1) # we need some factors, sometimes pergola could disappear\n        if bool:\n            curves.extend(curve_points)\n    \n    ##################################################################### HEIGHT\n    \n     # find the right height\n    distances = []\n    point_on_shd = []\n    for point in points:\n        distances.append(point.DistanceTo(cenPt))\n        point_on_shd.append(flat_srf.ClosestPoint(point))\n    if distances[0] > distances[len(distances)-1]:\n        ###print('all reverse')\n        curves.reverse()\n        planes.reverse()\n    \n    \n    # generate vectors to move the planes\n    pointsOnSurface = rc.Geometry.Intersect.Intersection.ProjectPointsToBreps([flat_srf], points, rc.Geometry.Vector3d.ZAxis, sc.doc.ModelAbsoluteTolerance * 0.1)\n    for i, p in enumerate(points):\n        vec = rc.Geometry.Vector3d.Add(rc.Geometry.Vector3d(pointsOnSurface[i]), -rc.Geometry.Vector3d(p))\n        rc.Geometry.Plane.Translate(planes[i], vec)\n        rc.Geometry.Plane.Rotate(planes[i], m.radians(-finsAngle), vectorP, planes[i].Origin)\n    \n    # point useful to find the right height\n    gen_point = planes[0].Origin\n\n    ############################################################## INTERSECTIONS\n    \n    # it comes from 'Ladybug_ShadingDesigner'\n    def isSrfFacingTheVector_TRSH(sunV, normalVector):\n        sunVRev = rc.Geometry.Vector3d(sunV)\n        sunVRev.Reverse()\n        if rc.Geometry.Vector3d.VectorAngle(sunVRev, normalVector) < m.pi/2: return True\n        else: return False\n    \n    \n    # generate lines\n    sun_lines = []\n    for sunV in sunVectors:\n        if isSrfFacingTheVector(sunV, normalVector):\n            sun_lines.append(rc.Geometry.Line(gen_point, -sunV, 1000))\n    \n    # select a plane and find intersection point\n    pp = planes[1]\n    useful_points = []\n    for line in sun_lines:\n        t = rc.Geometry.Intersect.Intersection.LinePlane(line, pp)[1]\n        point = line.PointAt(t)\n        useful_points.append(point)\n    \n    # make a long line to project points onto it\n    def lineForHeight(plane_dist, bool, factor):\n        distances_point_gen = []\n        points_projected = []\n        asse = plane_dist.YAxis\n        long_line = rc.Geometry.Line(plane_dist.Origin, asse, 1000)\n        for point in useful_points:\n            points_on_line = rc.Geometry.Line.ClosestPoint(long_line, point, bool) #True\n            points_projected.append(points_on_line)\n            distance = points_on_line.DistanceTo(plane_dist.Origin)\n            distances_point_gen.append(distance)\n        # make the vector for the extrusion\n        max_point = points_projected[distances_point_gen.index(max(distances_point_gen))]\n        \n        vec_extrude = factor * rc.Geometry.Vector3d.Add(-rc.Geometry.Vector3d(plane_dist.Origin), rc.Geometry.Vector3d(max_point)) #+\n        \n        return vec_extrude, max_point\n    \n    vec_extrude, max_point = lineForHeight(pp, True, 1)\n    \n    if max_point == pp.Origin:\n        vec_extrude, max_point = lineForHeight(pp, False, -1)\n        \n    pergola = []\n    for crv in curves:\n        pergola.append(rc.Geometry.Extrusion.CreateExtrusion(crv, vec_extrude))\n\n    return pergola\n\n##def main():\ndef main(_numPergolaFins_, _shdSrfShift_):\n    # inputs\n    window     = _window\n    sunVectors = _sunVectors\n\n    if _numOfShds_       == None:                         numOfShds         = 1\n    else:                                                 numOfShds         = _numOfShds_\n    if _numPergolaFins_  == None:                         numPergolaFins    = 10\n    else:                                                 numPergolaFins    = _numPergolaFins_\n    if _finsAngle_       == None:                         finsAngle         = 45\n    else:                                                 finsAngle         = _finsAngle_\n    if _shdSrfShift_     == None or _shdSrfShift_ == 0.0: shdSrfShift       = 0.01\n    else:                                                 shdSrfShift       = _shdSrfShift_\n    if _shdSrfAngle_     == None:                         shdSrfAngle       = 0.0\n    else:                                                 shdSrfAngle       = _shdSrfAngle_\n    if _delaunayHeight_  == None:                         delaunayHeight    = 5.0\n    else:                                                 delaunayHeight    = _delaunayHeight_\n    if _udiv_            == None:                         udiv              = 6\n    else:                                                 udiv              = _udiv_ \n    if _offsetFactor_    == None:                         offsetFactor      = 40\n    else:                                                 offsetFactor      = _offsetFactor_\n    if _cullRes_         == None:                         cullRes           = 1\n    else:                                                 cullRes           = _cullRes_\n    if cullRes < 0 or cullRes> 3: cullRes = 1\n    \n    # points\n    pointsOnWindow, uPoints = pointsOfWindow(window, udiv, numOfShds)\n\n    rowPoints, groupPoints = loopRowPoints(uPoints, udiv, numOfShds)  # rowPoints is a list of lists. The output looks like IronPython.Runtime.List\n\n    finalSrf      = []\n    allCullPts    = []\n    allptsContext = []\n    for i in range(len(rowPoints)):    # List or pair of rows index points (Upoints) to be analysed later on\n        # intersections\n        cullPts, ptsContext, normalVector, cenPt, vector_p = calcIntersections(shadeSurface_, rowPoints[i], groupPoints[i], sunVectors, shdSrfShift, shdSrfAngle, window, context_, uPoints, cullRes)\n        \n        allptsContext.extend(ptsContext)\n        \n        if cullPts == None:   # Some special cases there are point but no surface is created. SO just to be on the safe side\n            warning = \"No enough intersection points to calculate the shading surface\"\n            giveWarning(warning)\n            finalSrf = None\n        elif len(cullPts) < 4:   # Some special cases there are point but no surface is created. SO just to be on the safe side\n            warning = \"No enough intersection points to calculate the shading surface\"\n            giveWarning(warning)\n            finalSrf = None\n        else:\n            allCullPts.extend(cullPts)\n            finalSrf_TMP = finalSurfStuff(cullPts, delaunayHeight, offsetFactor, shadeSurface_)\n            if finalSrf_TMP != -1: \n                print \"Shading Calculation is done!\"\n                if _SurfaceOrPergola_ == 1:\n                    finalSrf.extend( calculatePergola(finalSrf_TMP, vector_p, normalVector, cenPt, numPergolaFins, finsAngle, sunVectors) )\n                else:\n                    finalSrf.append( finalSurfStuff(cullPts, delaunayHeight, offsetFactor, shadeSurface_) )\n    return finalSrf, allCullPts, allptsContext, pointsOnWindow, uPoints\n\n\n#Check the data\n#checkData = False\ncheckData = checkTheData(_window, _sunVectors, context_)\n\ntry:                                              ########   CHECK with ANTONELLO\n    _numPergolaFins_                              ########   with this block the variables are NONE\n    _shdSrfShift_                                 ########   Don't understand WHY  ?????\n    _shdSrfAngle_\n    _finsAngle_\nexcept:\n    _numPergolaFins_ = None\n    _shdSrfShift_    = None\n    _shdSrfAngle_    = None\n    _finsAngle_      = None\n\nif checkData == True:\n    ##result = main()\n    result = main(_numPergolaFins_, _shdSrfShift_)\n    if result != -1:\n        ##finalSrf, cullPts, ptsContext = result\n        finalSrf, cullPts, ptsContext, pointsOnWindow, uPoints = result\nelse:\n    warning = 'Please provide all _inputs'\n    giveWarning(warning)\n    \n    \n\"\"\"    \n#Hide(True)/Show(False) outputs\nghenv.Component.Params.Output[1].Hidden   = True     # pointsOnWindow\nghenv.Component.Params.Output[2].Hidden   = True     # uPoints\nghenv.Component.Params.Output[3].Hidden   = True     # PtsContext\nghenv.Component.Params.Output[4].Hidden   = True     # cullPts\nghenv.Component.Params.Output[5].Hidden   = False    # finalSrf\n\"\"\"\nghenv.Component.Params.Output[1].Hidden   = True     # pointsOnWindow\nghenv.Component.Params.Output[2].Hidden   = True     # uPoints\nghenv.Component.Params.Output[3].Hidden   = True     # PtsContext\nghenv.Component.Params.Output[4].Hidden   = True     # cullPts\nghenv.Component.Params.Output[5].Hidden   = False    # finalSrf\n    ",
  "language": "python",
  "imports": [
    "Rhino",
    "ghpythonlib",
    "scriptcontext"
  ],
  "has_docstring": true
}