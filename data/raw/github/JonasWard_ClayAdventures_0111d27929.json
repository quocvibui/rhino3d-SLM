{
  "source_url": "https://github.com/JonasWard/ClayAdventures/blob/70e453eab058ddb92ad4ee34f3148155e4c1cf31/src/ghPython/PatternBrickLibrary/clusterFromCurves/vertex.py",
  "repo": "JonasWard/ClayAdventures",
  "repo_stars": 3,
  "repo_description": "A width range of different tests and experiments for fdm clay printing",
  "license": "MIT",
  "filepath": "src/ghPython/PatternBrickLibrary/clusterFromCurves/vertex.py",
  "instruction": "Vertex",
  "code": "import Rhino.Geometry as rg\nimport math\n\ndef signed_vector_angle(a, b):\n    return math.atan2( a.X*b.Y - a.Y*b.X, a.X*b.X + a.Y*b.Y )\n\ndef positive_vector_angle(a, b):\n    angle = signed_vector_angle(a, b)\n    if angle > 0:\n        return angle\n    else:\n        return 6.2831853072 + angle\n\nclass Vertex:\n    MAX_A = 1.8\n    DIS = 4.0\n    def __init__(self, location):\n        self.location = rg.Point3d(location)\n        self.neighbours = []\n        self.vectors = []\n        self.n_locations = []\n\n    @property\n    def count(self):\n        return len(self.neighbours)\n\n    def add_neighbour(self, other_vertex):\n        self.neighbours.append(other_vertex)\n\n    def sort_neighbours(self):\n        angles = [n.angle(self) for n in self.neighbours]\n\n        print(angles)\n        print(self.neighbours)\n\n        angles, self.neighbours = list(zip(*sorted(zip(angles, self.neighbours) ) ) )\n        \n        print(angles)\n        print(self.neighbours)\n\n    def angle(self, other):\n        n_vec = rg.Vector3d(self.location - other.location)\n        return positive_vector_angle(rg.Vector3d.XAxis, n_vec)\n\n    def construct_dir_vectors(self):\n\n        if self.count == 0:\n            b_vec = rg.Vector3d(Vertex.DIS, 0, 0)\n            \n            self.interpolate_vectors_end(b_vec)\n\n        elif self.count == 1:\n            b_vec = rg.Vector3d(self.neighbours[0].location - self.location)\n            self.vectors.append(b_vec * .5)\n\n            self.interpolate_vectors_end(b_vec)\n\n        else:\n            for i in range(self.count):\n                v_0 = rg.Vector3d(.5 * (self.neighbours[i].location - self.location) )\n                v_1 = rg.Vector3d(.5 * (self.neighbours[(i + 1) % self.count].location - self.location) )\n\n                self.interpolate_vectors(v_0, v_1)\n\n        print(\"vector count : {}\".format(len(self.vectors)))\n\n    def interpolate_vectors(self, v_0, v_1):\n        # initialize the first vectors of the two as a normal vector\n        self.vectors.append(rg.Vector3d(v_0) )\n        \n        # getting the positive angle\n        angle = positive_vector_angle(v_0, v_1)\n\n        print(angle)\n\n        if angle > Vertex.MAX_A:\n\n            angle_count = math.ceil( angle / Vertex.MAX_A )\n            angle_delta = angle / angle_count\n\n            print(\"angle count : {}\".format(angle_count) )\n\n            b_vec = rg.Vector3d(v_0)\n            b_vec.Unitize()\n            b_vec = b_vec * Vertex.DIS\n\n            for i in range(1, int(angle_count), 1):\n                r_matrix = rg.Transform.Rotation(i * angle_delta, self.location)\n                n_vec = rg.Vector3d(b_vec)\n                n_vec.Transform(r_matrix)\n                self.vectors.append(n_vec)\n                print(\"added a vector\")\n\n    def interpolate_vectors_end(self, b_vec):\n        angle_count = math.ceil( math.pi * 2.0 / Vertex.MAX_A )\n        angle_delta = math.pi * 2.0 / angle_count\n\n        loc_v = rg.Vector3d(b_vec)\n        loc_v.Unitize()\n        loc_v = loc_v * Vertex.DIS\n\n        for i in range(1, int(angle_count), 1):\n            r_matrix = rg.Transform.Rotation(i * angle_delta, self.location)\n            n_vec = rg.Vector3d(loc_v)\n            n_vec.Transform(r_matrix)\n            self.vectors.append(n_vec)\n\n    def new_location(self):\n        for i in range(len(self.vectors) ):\n            self.n_locations.append(rg.Point3d(self.location + self.vectors[i] + self.vectors[(i + 1) % len(self.vectors) ]) )\n\n    def curve_representation(self):\n        return rg.Polyline(self.n_locations + [self.n_locations[0]] ).ToNurbsCurve()\n\n    def line_representation(self):\n        return [rg.Line(self.location, n_l) for n_l in self.n_locations]",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}