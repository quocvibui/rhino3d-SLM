{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/xSurface.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "xSurface.py",
  "instruction": "160618: Created.\r\n...\r\n190617: Using NurbsSurface in place of other surfaces due to bugs in RhinoCommon stated below.\r\n190720: A Cone-related function now check whether test point is at the Apex and...",
  "code": "\"\"\"\r\n160618: Created.\r\n...\r\n190617: Using NurbsSurface in place of other surfaces due to bugs in RhinoCommon stated below.\r\n190720: A Cone-related function now check whether test point is at the Apex and returns accordingly.\r\n190722: Split some functions.  Added a function.\r\n190727: Corrected some output and notes.\r\n190803: Modifications for when a value < 1e-12 is passed in as a deviation tolerance to some functions.\r\n190810: getDescription now reports the construction curves for Rev and Sum surfaces. \r\n191118: Moved some functions to other modules.\r\n191124: Import-related bug fix.\r\n191126: Modified some printed output.\r\n201212: Added knot information to description of NurbsSurface.\r\n210325: getDescription now tests for primitives using more tolerances and reports the primitive's radius, etc.\r\n210327: Bug fix.\r\n210330: Modified some tolerances to test for 'perfect' primitive match.\r\n210604: Bug fix in knot multiplicity routine.\r\n220317: Added splitSurfaceIntoBrep.\r\n220623: Bug fix.\r\n250324: Added functions concerning surfaces that create bad breps. Bug fix in a debug routine.\r\n\r\nKnown Issues with RhinoCommon:\r\n    \r\n    RevSurface.IsPlanar and\r\n    SumSurface.IsPlanar (5 - 6.11+?):\r\n        Some results are erroneously False.  Use NurbsSurface instead (ToNurbsSurface).\r\n    \r\n    RevSurface.TryGetPlane:\r\n        Some erroneous Plane results.  Use NurbsSurface instead (ToNurbsSurface).\r\n    \r\n    RevSurface.TryGetSphere (5 - 6.11+?):\r\n        Resultant sphere IsValid == False.  Use BrepFace or NurbsSurface conversion instead.\r\n    \r\n    RevSurface.TryGetCylinder (5 - 6.14+?):\r\n        Cylinder not found when it should.  Convert to NurbsSurface and analyze that instead.\r\n    \r\n    NurbsSurface.IsSphere(tolerance) and\r\n    NurbsSurface.TryGetSphere(tolerance) (5.? - 6.11+?):\r\n        Sphere not found for some sizes at tolerance < 1e-9.\r\n    \r\n    NurbsSurface.IsTorus(tolerance) and\r\n    NurbsSurface.TryGetTorus(tolerance) (5.? - 6.11+?):\r\n        Torus not found for some sizes at tolerance < 1e-9.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.Geometry as rg\r\nimport scriptcontext as sc\r\n\r\nimport System\r\n\r\n\r\nmaxExponentFor2 = 4\r\n\r\n\r\ndef getDescription(rgSrf0):\r\n    \"\"\"\r\n    Returns: String\r\n    \"\"\"\r\n\r\n    typeSrf = rgSrf0.GetType()\r\n\r\n    # Check whether face's UnderlyingSurface is already a primitive shape.\r\n    if typeSrf == rg.PlaneSurface:\r\n        return \"PlaneSurface\"\r\n\r\n    fTols_ToTry = Rhino.RhinoMath.ZeroTolerance, 1e-9, 1e-8\r\n    # 1e-8 can compensate for ZeroTolerance scaling from inches to millimeters\r\n    # because 2.32830643654e-10 * 25.4 ~ 5.91389834881e-09.\r\n\r\n    for fTol in fTols_ToTry:\r\n        if rgSrf0.IsPlanar(fTol):\r\n            return \"Planar ({}) {}\".format(fTol, typeSrf.Name)\r\n        #    elif (\r\n        #            (typeSrf==rg.RevSurface or typeSrf==rg.SumSurface)\r\n        #            and rgSrf0.IsPlanar(fTol)\r\n        #    ):\r\n        #        return \"Planar ({}) {}\".format(fTol, typeSrf.Name)\r\n\r\n    if rgSrf0.IsSolid: s = \"Solid\"\r\n    elif (rgSrf0.IsClosed(0) or rgSrf0.IsClosed(1)): s = \"Closed\"\r\n    else: s = \"Open\"\r\n\r\n    for fTol in fTols_ToTry:\r\n        rc = rgSrf0.TryGetCylinder(fTol)\r\n        if rc[0]:\r\n            cyl = rc[1]\r\n            s += \", R{:.4f} cylindrical ({:.3e})\".format(cyl.Radius, fTol)\r\n            break\r\n        rc = rgSrf0.TryGetCone(fTol)\r\n        if rc[0]:\r\n            cone = rc[1]\r\n            s += \", {:.2f} degree conical ({:.3e})\".format(cone.AngleInDegrees(), fTol)\r\n            break\r\n        rc = rgSrf0.TryGetSphere(fTol)\r\n        if rc[0]:\r\n            sphere = rc[1]\r\n            s += \", R{:.4f} spherical ({:.3e})\".format(sphere.Radius, fTol)\r\n            break\r\n        rc = rgSrf0.TryGetTorus(fTol)\r\n        if rc[0]:\r\n            torus = rc[1]\r\n            s += \", R{:.4f},r{:.4f} toric ({:.3e})\".format(torus.MajorRadius, torus.MinorRadius, fTol)\r\n            break\r\n    \r\n    s += \" {}\".format(typeSrf.Name)\r\n    \r\n    if typeSrf==rg.RevSurface:\r\n        s += \" with {} revolute\".format(rgSrf0.Curve.GetType().Name)\r\n    elif typeSrf==rg.SumSurface:\r\n        s += \" composed of {} and {}\".format(\r\n                rgSrf0.IsoCurve(0, rgSrf0.Domain(1).T0).GetType().Name,\r\n                rgSrf0.IsoCurve(1, rgSrf0.Domain(0).T0).GetType().Name,\r\n                )\r\n    elif typeSrf == rg.NurbsSurface:\r\n        s += \"  Rational,\" if rgSrf0.IsRational else \"  Non-rational,\"\r\n        s += \"  Degrees {} x {}\".format(rgSrf0.Degree(0), rgSrf0.Degree(1))\r\n        s += \"  CpCts {} x {}\".format(rgSrf0.Points.CountU, rgSrf0.Points.CountV)\r\n        s += \"  SpanCts {} x {}\".format(rgSrf0.SpanCount(0), rgSrf0.SpanCount(1))\r\n        if Rhino.RhinoApp.ExeVersion >= 7:\r\n            s += \"  KnotStyles {} x {}\".format(\r\n                rgSrf0.KnotsU.KnotStyle, rgSrf0.KnotsU.KnotStyle)\r\n\r\n\r\n        iCt_KnotMulties_U = []\r\n        iK = 0\r\n        while iK < rgSrf0.KnotsU.Count:\r\n            m = rgSrf0.KnotsU.KnotMultiplicity(iK)\r\n            iCt_KnotMulties_U.append(m)\r\n            iK += m\r\n\r\n        iCt_KnotMulties_V = []\r\n        iK = 0\r\n        while iK < rgSrf0.KnotsV.Count:\r\n            m = rgSrf0.KnotsV.KnotMultiplicity(iK)\r\n            iCt_KnotMulties_V.append(m)\r\n            iK += m\r\n        s += \"  KnotMultiplicities {} x {}\".format(\r\n            iCt_KnotMulties_U, iCt_KnotMulties_V)\r\n\r\n\r\n    return s\r\n\r\n\r\ndef isIsoStatusAtSeam(rgSrf, isoStatus):\r\n    if isoStatus == Rhino.Geometry.IsoStatus.South:\r\n        return rgSrf.IsAtSeam(rgSrf.Domain(0).Mid, rgSrf.Domain(1).Min)\r\n    elif isoStatus == Rhino.Geometry.IsoStatus.East:\r\n        return rgSrf.IsAtSeam(rgSrf.Domain(0).Max, rgSrf.Domain(1).Mid)\r\n    elif isoStatus == Rhino.Geometry.IsoStatus.North:\r\n        return rgSrf.IsAtSeam(rgSrf.Domain(0).Mid, rgSrf.Domain(1).Max)\r\n    elif isoStatus == Rhino.Geometry.IsoStatus.West:\r\n        return rgSrf.IsAtSeam(rgSrf.Domain(0).Min, rgSrf.Domain(1).Mid)\r\n\r\n\r\ndef isSrfSideSingularPerIsoStatus(rgSrf, isoStatus):\r\n    if isoStatus == Rhino.Geometry.IsoStatus.South: return rgSrf.IsSingular(0)\r\n    if isoStatus == Rhino.Geometry.IsoStatus.East: return rgSrf.IsSingular(1)\r\n    if isoStatus == Rhino.Geometry.IsoStatus.North: return rgSrf.IsSingular(2)\r\n    if isoStatus == Rhino.Geometry.IsoStatus.West: return rgSrf.IsSingular(3)\r\n\r\n\r\ndef pointsOfSenw(rgSrf, side):\r\n    \"\"\"\r\n    side can be an Rhino.Geometry.IsoStatus or\r\n    integers 0 (South), 1 (East), 2 (North), & 3 (West).\r\n    \"\"\"\r\n    if side == 0 or side == Rhino.Geometry.IsoStatus.South:\r\n        ptList = rgSrf.Points\r\n        numU = ptList.CountU\r\n        pts = [ptList.GetControlPoint(u, 0).Location for u in range(numU)]\r\n    elif side == 1 or side == Rhino.Geometry.IsoStatus.East:\r\n        ptList = rgSrf.Points\r\n        numU = ptList.CountU\r\n        numV = ptList.CountV\r\n        pts = [ptList.GetControlPoint(numU-1, v).Location for v in range(numV)]\r\n    elif side == 2 or side == Rhino.Geometry.IsoStatus.North:\r\n        ptList = rgSrf.Points\r\n        numU = ptList.CountU\r\n        numV = ptList.CountV\r\n        pts = [ptList.GetControlPoint(u, numV-1).Location for u in range(numU)]\r\n    elif side == 3 or side == Rhino.Geometry.IsoStatus.West:\r\n        ptList = rgSrf.Points\r\n        numV = ptList.CountV\r\n        pts = [ptList.GetControlPoint(0, v).Location for v in range(numV)]\r\n    else: return\r\n    \r\n    return pts\r\n\r\n\r\ndef senwCurvePerSide(rgSrf, side):\r\n    \"\"\"\r\n    side can be an Rhino.Geometry.IsoStatus or\r\n    integers 0 (South), 1 (East), 2 (North), & 3 (West).\r\n    Curve direction matches that of surface, which means that\r\n    North and West curves are in opposition to the trim loop.\r\n    \"\"\"\r\n    if side == 0 or side == Rhino.Geometry.IsoStatus.South:\r\n        return rgSrf.IsoCurve(0, rgSrf.Domain(1).Min)\r\n    elif side == 1 or side == Rhino.Geometry.IsoStatus.East:\r\n        return rgSrf.IsoCurve(1, rgSrf.Domain(0).Max)\r\n    elif side == 2 or side == Rhino.Geometry.IsoStatus.North:\r\n        return rgSrf.IsoCurve(0, rgSrf.Domain(1).Max)\r\n    elif side == 3 or side == Rhino.Geometry.IsoStatus.West:\r\n        return rgSrf.IsoCurve(1, rgSrf.Domain(0).Min)\r\n\r\n\r\ndef shortSenws(rgSrf, fSenwLen_MinAllowed, bEcho=False):\r\n    def maximumPointSpread(pts):\r\n        distMax = 0.\r\n        for i in range(len(pts)):\r\n            ptA = pts[i]\r\n            for j in range(i+1, len(pts)):\r\n                ptB = pts[j]\r\n                dist = ptA.DistanceTo(ptB)\r\n                if dist > distMax: distMax = dist\r\n        return distMax\r\n    \r\n    \r\n    iSenwsWithinPtSpread = []\r\n    for side in (0,1,2,3):\r\n        if not rgSrf.IsSingular(side):\r\n            crv = senwCurvePerSide(rgSrf, side)\r\n            length = crv.GetLength()\r\n            if length < fSenwLen_MinAllowed:\r\n                iSenwsWithinPtSpread.append(side)\r\n            else:\r\n                pts_CP = pointsOfSenw(rgSrf, side)\r\n                if maximumPointSpread(pts_CP) < fSenwLen_MinAllowed:\r\n                    if bEcho: print \"SENW found using maximumPointSpread instead of GetLength().\"\r\n                    iSenwsWithinPtSpread.append(side)\r\n    return iSenwsWithinPtSpread\r\n\r\n\r\ndef is_srf_valid_for_brep(rgSrf):\r\n    \"\"\"\r\n    Returns:\r\n        rg.NurbsSurfaceNew surface if input was invalid and/or created an invalid brep.\r\n    \"\"\"\r\n\r\n    if not rgSrf.IsValid:\r\n        sEval = \"rgSrf\"; print(sEval,'=',eval(sEval))\r\n        sEval = \"rgSrf.IsValid\"; print(sEval,'=',eval(sEval))\r\n        return False\r\n\r\n    _rgB = rgSrf.ToBrep()\r\n    if not _rgB.IsValid:\r\n        sEval = \"_rgB.IsValid\"; print(sEval,'=',eval(sEval))\r\n        _rgB.Dispose()\r\n        return False\r\n\r\n    _rgB.Dispose()\r\n    return True\r\n\r\n\r\ndef repair_srf_invalid_for_brep(rgSrf_In):\r\n    if isinstance(rgSrf_In, rg.NurbsSurface):\r\n        return\r\n\r\n    print(\"ToNurbsSurface() ...\")\r\n    rgSrf_Out = rgSrf_In.ToNurbsSurface()\r\n    if not rgSrf_Out.IsValid:\r\n        rgSrf_Out.Dispose()\r\n        return\r\n    _rgB = rgSrf_Out.ToBrep()\r\n    sEval = \"_rgB.IsValid\"; print(sEval,'=',eval(sEval))\r\n    if not _rgB.IsValid:\r\n        _rgB.Dispose()\r\n        return\r\n    _rgB.Dispose()\r\n    \r\n    return rgSrf_Out\r\n\r\n\r\ndef splitSurfaceIntoBrep(rgSrf_toSplit, rgCrvs_Splitters, **kwargs):\r\n    \"\"\"\r\n    Parameters:\r\n        rgSrf_toSplit: Can be rg.BrepFace or other rg.Surface.\r\n        rgCrvs_Splitters\r\n        fTolerance\r\n        bTryOtherTolsOnFail\r\n        bDebug\r\n    Returns on success:\r\n        rg.Brep\r\n    Returns on fail:\r\n        None\r\n    \"\"\"\r\n\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    fTolerance = getOpt('fTolerance')\r\n    bTryOtherTolsOnFail = getOpt('bTryOtherTolsOnFail')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n    if isinstance(rgSrf_toSplit, rg.BrepFace):\r\n        rgFace_toSplit = rgSrf_toSplit\r\n        rgBrep_TempForUnderlyingSrf = None\r\n        rgSrf_Underlying = rgFace_toSplit.UnderlyingSurface()\r\n    elif isinstance(rgSrf_toSplit, rg.Surface):\r\n        rgSrf_Underlying = rgSrf_toSplit\r\n        rgBrep_TempForUnderlyingSrf = rgSrf_toSplit.ToBrep()\r\n        rgFace_toSplit = rgBrep_TempForUnderlyingSrf.Faces[0]\r\n    else:\r\n        return\r\n\r\n\r\n    #if not is_srf_valid_for_brep(rgSrf_Underlying):\r\n    #    if isinstance(rgSrf_Underlying, rg.NurbsSurface):\r\n    #        return\r\n    #    rv = repair_srf_invalid_for_brep(rgSrf_Underlying)\r\n    #    if rv is None: return\r\n    #    rgSrf_Underlying = rv\r\n\r\n\r\n    def getFormattedDistance(fDistance):\r\n        if fDistance is None: return \"(No deviation provided)\"\r\n        if fDistance < 0.001:\r\n            return \"{:.2e}\".format(fDistance)\r\n        else:\r\n            return \"{:.{}f}\".format(fDistance, sc.doc.ModelDistanceDisplayPrecision)\r\n\r\n\r\n    # Create tolerance loop.\r\n    if bTryOtherTolsOnFail:\r\n        fTols_toTry = []\r\n        #for tolMultiplier in 1.0, 0.5, 2.0, 0.25, 4.0, 0.125, 8.0, 0.0625, 16.0:\r\n        for tolMultiplier in 1.0, 0.5, 0.1:\r\n            tol = tolMultiplier * fTolerance\r\n            fTols_toTry.append(tol)\r\n    else:\r\n        fTols_toTry = fTolerance,\r\n\r\n\r\n    # Split in a tolerance loop.\r\n    for fTol_toTry in fTols_toTry:\r\n\r\n        #\r\n        #\r\n        rgB_Split = rgFace_toSplit.Split(\r\n            curves=rgCrvs_Splitters,\r\n            tolerance=fTol_toTry)\r\n        #\r\n        #\r\n\r\n\r\n        if bDebug: sEval='rgB_Split'; print sEval+':',eval(sEval)\r\n        \r\n        if rgB_Split is None:\r\n            if bDebug and fTol_toTry == fTolerance:\r\n                print \"  Failed at fTol_toTry=={}.\".format(\r\n                    getFormattedDistance(fTol_toTry))\r\n                #_rgB = rgFace_toSplit.DuplicateFace(duplicateMeshes=False)\r\n                sc.doc.Objects.AddSurface(rgFace_toSplit)\r\n                for c in rgCrvs_Splitters:\r\n                    sc.doc.Objects.AddCurve(c)\r\n                sc.doc.Views.Redraw()\r\n                1/0\r\n        elif rgB_Split.Faces.Count == rgFace_toSplit.Brep.Faces.Count:\r\n            if bDebug:\r\n                    if rgB_Split.Faces.Count == 1:\r\n                        print \"BrepFace.Split resulted in a 1-face Brep.\"\r\n                    else:\r\n                        print \"BrepFace.Split resulted in a Brep with no additional faces.\"\r\n\r\n            rgB_Split = None\r\n\r\n            if not isinstance(rgFace_toSplit.UnderlyingSurface(), rg.NurbsSurface):\r\n                s = \"{} face was not split.\".format(\r\n                    rgFace_toSplit.UnderlyingSurface().GetType().Name)\r\n                s += \"  Trying NurbsSurface equivalent ...\"\r\n                print s\r\n\r\n\r\n                def convertToNS():\r\n                    ns = rgFace_toSplit.UnderlyingSurface().ToNurbsSurface()\r\n                    rgB_1F_NS = ns.ToBrep()\r\n                    if not rgB_1F_NS.IsValid:\r\n                        return\r\n                    if rgB_1F_NS.Faces.Count != 1:\r\n                        return\r\n                    return rgB_1F_NS.Faces[0]\r\n\r\n                rgF_NS_toSplit = convertToNS()\r\n\r\n                if rgF_NS_toSplit is not None:\r\n                    rgB_Split = rgF_NS_toSplit.Split(\r\n                        curves=rgCrvs_Splitters,\r\n                        tolerance=fTol_toTry)\r\n                    if rgB_Split.Faces.Count == rgFace_toSplit.Brep.Faces.Count:\r\n                        rgB_Split = None\r\n                        print \"  NurbsSurface face also didn't split.\"\r\n                    else:\r\n                        print \"  NurbsSurface passed.  This means that the modified\" \\\r\n                            \" model has an underlying surface which was converted\" \\\r\n                            \" from {} to a NurbsSurface.\".format(\r\n                                rgFace_toSplit.UnderlyingSurface().GetType().Name)\r\n        else:\r\n            if bDebug:\r\n                sEval='rgB_Split.IsValid'; print sEval+':',eval(sEval)\r\n                sEval='rgB_Split.Faces.Count'; print sEval+':',eval(sEval)\r\n                #sc.doc.Objects.AddBrep(rgB_Split); sc.doc.Views.Redraw()\r\n            if not rgB_Split.IsValid:\r\n                rgB_Split = None\r\n\r\n            if bDebug or abs(fTol_toTry - fTolerance) > 1e-9:\r\n                print \"  Split successful at a tolerance of {}.\".format(\r\n                    getFormattedDistance(fTol_toTry))\r\n            break # out of tolerance loop.\r\n\r\n\r\n    if rgBrep_TempForUnderlyingSrf: rgBrep_TempForUnderlyingSrf.Dispose()\r\n\r\n    return rgB_Split\r\n\r\n\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "scriptcontext"
  ],
  "has_docstring": true
}