{
  "source_url": "https://github.com/chinsohyun/RhinoPython/blob/20488c293c36fb1b113471a48bf79190097ad447/Game_of_life/cellular%20automata_a6_jsohyun.py",
  "repo": "chinsohyun/RhinoPython",
  "repo_stars": 0,
  "repo_description": "Individual Projects in Scripting and Parametric Design Fall 2024",
  "license": "unknown",
  "filepath": "Game_of_life/cellular automata_a6_jsohyun.py",
  "instruction": "Cellular automata a6 jsohyun",
  "code": "import random\nimport rhinoscriptsyntax as rs\nimport time\nimport copy\n\ncols = 7\nrows = 7\ncell_size = 10  # Define the cell size\n# Create a 2D Array and points grid\ndef make2DArrayGrid(cols, rows):\n    grid = []\n    for i in range(rows):\n        row = []\n        for j in range(cols):\n            state = random.randint(0, 1)  # Randomly initialize alive (1) or dead (0), which will not appear\n            row.append(state)\n        grid.append(row)\n    return grid\n\n# Count 1st-layer neighbors\ndef count_neighbors(grid, x, y):\n    sum_neighbors = 0\n    for i in range(-1, 2):\n        for j in range(-1, 2):\n            col = (x + i)\n            row = (y + j)\n            if col in range(0, cols) and row in range(0, rows):\n                sum_neighbors += grid[row][col]\n    sum_neighbors -= grid[y][x]  # Subtract the cell itself from count\n    return sum_neighbors\n\n# Count 1st-layer neighbors\ndef count_far_neighbors(grid, x, y):\n    sum_neighbors = 0\n    for i in range(-2, 3):\n        for j in range(-2, 3):\n            if i in [-2, 2] or j in [-2, 2]: #check only edge cases\n                col = (x + i)\n                row = (y + j)\n                if col in range(0, cols) and row in range(0, rows): #fix the bug, mod sometimes doesn't work\n                    sum_neighbors += grid[row][col]\n#    print(x, y, list, sum_neighbors)\n    return sum_neighbors\n\ndef pos_far_neighbor(next_grid, grid, x, y):\n    pos = []\n    for i in range(-2, 3):\n        for j in range(-2, 3):\n            if i in [-2, 2] or j in [-2, 2]: #check only edge cases\n                col = (x + i)\n                row = (y + j)\n                if col in range(0, cols) and row in range(0, rows):\n                    if next_grid[row][col] == 1:\n                        pos.append((i, j)) #save the direction\n    if grid[y][x] == 0: \n        if (-2, 0) in pos:\n            return 90\n        elif (2, 0) in pos:\n            return -90\n        elif (0, -2) in pos:\n            return 180\n        elif (0, 2) in pos:\n            return 0\n    return None\n        \ndef check_neighbor(dict, x, y, generation):\n    count = 0\n    for i in range(-1, 2):\n        for j in range(-1, 2):\n            if dict.get((x + i, y + j, generation)) == 0:\n                count += 1\n    return count\n\ndef plant_balcony(live_cells, tree_cells, col, row, buffer, z_offset):\n    for a in range(-1, 2):\n        for b in range(-1, 2):\n                i = a + col\n                j = b + row\n                pt = (i * cell_size, j * cell_size, z_offset) \n                ##################################\n                if i in [-1, cols] or j in [-1, rows] and not tree_cells.get((i, j, generation)):\n                    if (i + j) % 2 == 0 or generation %2 == 0 : #sparse the density\n                        tree_cells[(i, j, generation)] = rs.InsertBlock(\"big_tree\", rs.CreatePoint(pt[0], pt[1], pt[2]), [1, 1, 1])\n\n# Update the grid for the next generation and place blocks at the correct Z-offset\ndef update_grid(cols, rows, grid, generation):\n    next_grid = []\n    next_grid = copy.deepcopy(grid)\n    # Calculate the Z-offset for the current generation\n    z_offset = generation * cell_size *1.3\n    \n    #To test initial state\n    if generation == 0: \n        for row in range(rows):\n            for col in range(cols):\n                pt = (col * cell_size - 200, row * cell_size, 0)\n                if grid[row][col] == 0:\n                    dead_cells[(col, row, generation)] = 0\n                    rs.InsertBlock(\"dead\", rs.CreatePoint(pt[0], pt[1], pt[2]), [1, 1, 1])\n                else:\n                    live_cells[(col, row, generation)] = 0\n                    rs.InsertBlock(\"live\", rs.CreatePoint(pt[0], pt[1], pt[2]), [1, 1, 1])\n# selective, sparse.\n    for i in range(cols):\n        for j in range(rows):\n            neighbors = count_neighbors(grid, i, j)\n            far_neighbors = count_far_neighbors(grid, i, j)\n            state = grid[j][i]\n            buffer = (generation + 1) * 200\n            pt = (i * cell_size, j * cell_size, z_offset)  # Adjust Z position based on generation\n            pt_plan = (i * cell_size + buffer, j * cell_size, z_offset)\n            # Game of Life rules and rendering\n            if state == 0 and neighbors == 0 and far_neighbors < 5 :  # A dead cell becomes alive\n                next_grid[j][i] = 1\n                house = rs.InsertBlock(\"live\", rs.CreatePoint(pt[0], pt[1], pt[2]), [1, 1, 1]) \n                if neighbors < 2: #rotate house.\n                    rs.RotateObject(house, (pt[0], pt[1], pt[2]), 90)\n                live_cells[(i, j, generation)] = 0\n                \n            elif state == 1 and neighbors > 3 or neighbors < 2:  # A live cell dies\n                next_grid[j][i] = 0\n                dead_cells[(i, j, generation)] = 0\n                rs.InsertBlock(\"dead\", rs.CreatePoint(pt[0], pt[1], pt[2]), [1, 1, 1])\n                \n            elif state == 1: # A live cell: 2 or 3 \n                live_cells[(i, j, generation)] = 0\n                rs.InsertBlock(\"live\", rs.CreatePoint(pt[0], pt[1], pt[2]), [1, 1, 1])\n                \n            elif state == 0: # A dead cell: other than 3\n                dead_cells[(i, j, generation)] = 0\n                rs.InsertBlock(\"dead\", rs.CreatePoint(pt[0], pt[1], pt[2]), [1, 1, 1])\n    #plant trees, fontains, ladders, big trees.\n    for i in range(cols):\n        for j in range(rows):\n            neighbors = count_neighbors(next_grid, i, j)\n            far_neighbors = count_far_neighbors(next_grid, i, j)\n            state = next_grid[j][i]\n            buffer = generation * 200\n            pt = (i * cell_size, j * cell_size, z_offset) \n            ##\n#            rs.AddTextDot(neighbors, (pt[0], pt[1], pt[2]))\n\n            #add ladder.\n            if state == 0 and neighbors == 0:\n                if check_neighbor(ladder_cells, i, j, generation) < 3 and not ladder_cells.get((i, j, generation)):\n                    if far_neighbors < 5 and generation != 0:\n                        angle = pos_far_neighbor(next_grid, grid, i, j)\n                        if angle:\n                            ladder = rs.InsertBlock(\"ladder\", rs.CreatePoint(pt[0], pt[1], pt[2]), [1, 1, 1]) \n                            rs.RotateObject(ladder, (pt[0], pt[1], pt[2]), angle)\n                            ladder_cells[(i, j, generation)] = 0\n                            \n            if state == 0 and neighbors != 0: # plant tree in the slab\n                #add small trees\n                if neighbors > 3: #only if high density of house\n                    tree_cells[(i, j, generation)] = 0\n                    rs.InsertBlock(\"tree\", rs.CreatePoint(pt[0], pt[1], pt[2]), [1, 1, 1])\n                #add fontains\n                previous = generation -1\n                if not tree_cells.get((i, j, generation)) and not water_cells.get((i, j, generation)) and ladder_cells.get((i, j, previous))!= 0: \n                    if neighbors == 1 and check_neighbor(water_cells, i, j, generation) < 1:\n                        water = rs.InsertBlock(\"water\", rs.CreatePoint(pt[0], pt[1], pt[2]), [1, 1, 1])\n                        angle = random.choice([0, 90, 180, 360])\n                        rs.RotateObject(water, (pt[0], pt[1], pt[2]), angle)\n                        water_cells[(i, j, generation)] = 0\n                        \n      \n            #plant big tree!\n            if state == 1: \n                if i in [0, cols -1] or j in [0, rows -1]: #go to the balcony\n                    if far_neighbors > 5 or neighbors < 3:\n                        plant_balcony(live_cells, tree_cells, i, j, buffer, z_offset)\n                        \n    return next_grid\n\n \n# Initialize grid and dictionaries for live and dead cells\ngrid = make2DArrayGrid(cols, rows)\nlive_cells = {}  # Dictionary to track live cells and their objects\ndead_cells = {}  # Dictionary to track dead cells and their objects\ntree_cells = {}\nwater_cells = {}\nladder_cells = {}\n\n# Run the simulation for multiple generations\nnum_generations = 10  # Set the number of generations\n\nfor generation in range(num_generations):\n    rs.EnableRedraw(False)  # Disable screen redraw for the update phase\n    grid = update_grid(cols, rows, grid, generation)  # Update grid to the next generation",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}