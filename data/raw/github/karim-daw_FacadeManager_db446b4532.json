{
  "source_url": "https://github.com/karim-daw/FacadeManager/blob/d9d53528ed0387646dae683dd5e145bd5e477793/FM-Python/src/FM-FacadeManager.py",
  "repo": "karim-daw/FacadeManager",
  "repo_stars": 1,
  "repo_description": null,
  "license": "unknown",
  "filepath": "FM-Python/src/FM-FacadeManager.py",
  "instruction": "Template for the creation of user objects for the Big Ideas tab. This text shows up as the component's description. In order to create an icon, drag+drop 24x24 pixel png onto component. Save them...",
  "code": "\"\"\"\nTemplate for the creation of user objects for the Big Ideas tab. This text shows up as the component's description. In order to create an icon, drag+drop 24x24 pixel png onto component. Save them under L:\\TOOLS\\SOURCECODE\\Icons\n-\n    Args:\n        A: This is how to create a tool tip.\n    Returns:\n        B: This is how to create a tool tip.\n        \n        \n        Version: 280621\n\"\"\"\n\n# Give your component a unique name and nickname (portrayed on the canvas).\nghenv.Component.Name = \"FM-FacadeManager\"\nghenv.Component.NickName = \"FM-FM\"\n\n# Keep it in the \"Performing\" tab\nghenv.Component.Category = \"FM-Python\"\n\n# Define the subcategory\nghenv.Component.SubCategory = \"Facade-Manager\"\n\n# If you want to give the component a version number etc.\nimport time\nimport Rhino\nimport Rhino.Geometry as rg\nimport scriptcontext as rs\nimport System\nimport math\nimport System.Collections.Generic.IEnumerable as IEnumerable\n\nghenv.Component.Message = time.strftime(\"%d/%m/%Y\") + \"\\n\" + time.strftime(\"%H:%M:%S\")\n\n\n\n\n# Your code here\n#THIS IS A TEST\n\nclass Panel:\n\n    def __init__(self):\n\n        self.message = \"didnt work\"\n\n    def MakeMessage(self):\n\n        self.message = \"hello, i am a panel! Hooray!\"\n\n\n\n\n################################### Utilities functions ########################################\n\n\nclass Utilities:\n\n    def __init__(self):\n\n        self.message = \"using utitlity class\"\n    \n\n    def GetMinHeight(self,brep):\n\n        \"\"\"get min height of brep\"\"\"\n\n        # create bbox for brep\n        bbox = brep.GetBoundingBox(True)\n        \n        # Get max z component\n        minHeight = round( (bbox.Min.Z) ,2)\n\n        return minHeight\n    \n\n    def GetMaxHeight(self,brep):\n\n        \"\"\"get max height of brep\"\"\"\n\n        # create bbox for brep\n        bbox = brep.GetBoundingBox(True)\n        \n        # Get max z component\n        maxHeight = round( (bbox.Max.Z) ,2)\n\n        return maxHeight\n    \n    def ComputeSurfaceLength(self,surface):\n\n        if type(surface) == rg.Brep:\n            brepSurfaceList = surface.Surfaces\n            surface = brepSurfaceList[0]\n            firstPoint = surface.PointAt(0.0,0.0)\n            secondPoint = surface.PointAt(1.0,0.0)\n            distance = firstPoint.DistanceTo(secondPoint)\n            print(\"Surface span is {0}\".format(distance))\n        else:\n            firstPoint = surface.PointAt(0.0,0.0)\n            secondPoint = surface.PointAt(1.0,0.0)\n            distance = firstPoint.DistanceTo(secondPoint)\n            print(\"Surface span is {0}\".format(distance))          \n\n        return distance\n\n\n    def ComputeSurfaceNormal(self,surface):\n\n        \"\"\" computes surface normal and returns unit vector\"\"\"\n\n        if type(surface) == rg.Brep:\n            brepSurfaceList = surface.Surfaces\n            surface = brepSurfaceList[0]\n            normal = surface.NormalAt(0.5,0.5)\n            normal.Unitize\n        else:\n            normal = surface.NormalAt(0.5,0.5)\n            normal.Unitize\n        \n        return normal\n    \n    def ComputeSurfaceTangent(self,normalVector):\n\n        \"\"\" computes vector perpendicular to input vector \"\"\"\n\n        # if vector is pointing up, use x or y axis as corss vector\n        if normalVector.Z == 1:\n            crossVector = rg.Vector3d(0, 1, 0)\n        elif normalVector.Z == -1:\n            crossVector = rg.Vector3d(0, 1, 0)\n        else:\n            crossVector = rg.Vector3d(0, 0, 1)\n\n        # compute cross product\n        tangent = rg.Vector3d.CrossProduct(normalVector, crossVector)\n        tangent.Unitize\n\n        return tangent\n    \n\n    def ContourBrep(self,brep,stepSizes):\n\n        \"\"\" contour brep along upwards with a given set of step sizes and return list of curves\"\"\"\n        \n        print(\"ContourBrep will contour an object of type {0}\".format(type(brep)))  \n\n        cCurves = []\n        for step in stepSizes:\n\n            # contruct point from stepSizes\n            pnt = rg.Point3d(0,0,step)\n\n            # create plane\n            pln = rg.Plane(pnt, rg.Vector3d(0,0,1))\n\n            # get curves and join them\n            crvs = rg.Intersect.Intersection.BrepPlane(brep,pln,0.01)[1]\n\n            # NEED TO FIX THIS, have to write function that takes in varying sizes of inputs\n            if crvs.Count == 1:\n                cCurves.append(rg.Curve.JoinCurves(crvs)[0])\n            else:\n                for crv in crvs:\n                    cCurves.append(crv)\n        print(cCurves)\n        return cCurves\n\n    \n    def ContourSurface(self,surface,stepSize):\n\n        \"\"\" contour a single surfac by given step sizes and direction and returns a list of curves\"\"\"\n\n        print(\"ContourSurface will contour an object of type {0}\".format(type(surface)))   \n\n\n        # compute Normal\n        nrml = self.ComputeSurfaceNormal(surface)\n\n        # compute Tangent\n        tngt = self.ComputeSurfaceTangent(nrml)\n        print(\"my surface tangent is {0}\".format(tngt))\n\n        # set domain of surface\n        interval_0 = rg.Interval(0.0,1.0)\n        surface.SetDomain(0,interval_0)\n        surface.SetDomain(1,interval_0)\n\n        #print(\"I set the domain of the surface\")\n        #print(surface.SetDomain(0,interval_0))\n\n        # compute first point on surface\n        #print(\"first surface point\")\n        fSurfacePnt = surface.PointAt(0.0,0.0)\n        lSurfacePnt = surface.PointAt(0.0,1.0)\n        eSurfacePnt = surface.PointAt(1.0,0.0)\n        dSurfacePnt = surface.PointAt(1.0,1.0)\n        print(fSurfacePnt)\n        print(lSurfacePnt)\n        print(eSurfacePnt)\n        print(dSurfacePnt)\n\n        print(\"testing if point is sitting on surface\")\n        print(surface.IsPointOnFace(0.0,0.0))\n\n        # compute list of numbers for range\n        surfaceLength = self.ComputeSurfaceLength(surface)\n        count = int(math.ceil(surfaceLength/stepSize))\n        print(\"number of counts\")\n        print(count)\n\n\n        # loop through steps\n        vCurves = []\n        for i in range(count):\n\n            # create tangent move vector\n            mVec = tngt * i\n            print(fSurfacePnt)\n\n            # contruct point from stepSizes and plane\n            pnt = fSurfacePnt + mVec\n            print(\"points\")\n            print(pnt)\n            pln = rg.Plane(pnt,tngt)\n            print(pln)\n\n            dupFace = rg.BrepFace.DuplicateFace(surface,False)\n            print(dupFace)\n\n            # get curves and join them\n            crvs = rg.Intersect.Intersection.BrepPlane(dupFace,pln,0.1)\n            #crvs = rg.Intersect.Intersection.BrepPlane(dupFace,pln,0.01)\n            print(crvs)\n            if len(crvs) == 1:\n                vCurves.append(rg.Curve.JoinCurves(crvs)[0])\n            else:\n                for crv in crvs:\n                    vCurves.append(crv)\n\n        \n        return vCurves\n\n\n    def SplitBrep(self,brep,curves):\n\n        \n        print(\"Splitting Breps...\")\n        print(type(brep))\n        print(len(curves))\n        print(type(curves))\n\n        if type(brep) != rg.Brep:\n            castBrep = rg.BrepFace.DuplicateFace(brep,False)\n            print(\"converted to brep\")\n            print(type(castBrep))\n            #print(curves[1])\n            print(curves)\n            if curves[1] == None:\n                splitBreps = castBrep.Split.Overloads[IEnumerable[rg.Curve], System.Double](curves,0.01)\n            else:\n                splitBreps = castBrep.Split.Overloads[IEnumerable[rg.Curve], System.Double](curves[1],0.01)\n        else:\n            print(\"hi\")\n            print(type(brep))\n            splitBreps = brep.Split.Overloads[IEnumerable[rg.Curve], System.Double](curves,0.01)\n\n        explodeBreps = []\n        for i, splitBrep in enumerate(splitBreps):\n            # Get faces from breps\n            for j, face in enumerate(splitBrep.Faces):          \n                # turn it into brep \n                dupFace = rg.BrepFace.DuplicateFace(face,False)\n                explodeBreps.append(face)\n                #print(type(dupFace))\n\n        return explodeBreps\n\n\n\n\nrs.sticky[\"Fm-Panel\"] = Panel\nrs.sticky[\"Fm-Utilities\"] = Utilities \n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}