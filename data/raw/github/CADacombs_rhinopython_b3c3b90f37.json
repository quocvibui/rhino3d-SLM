{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Arc_convertToNonRationalCubicBezier.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Arc_convertToNonRationalCubicBezier.py",
  "instruction": "This script converts an arc up through 180 degrees into a non-rational, cubic, Bezier NurbsCurve.\r\n\r\nOne of the two approximation options uses my solution for converting an arc into a\r\nnon-rational,...",
  "code": "\"\"\"\r\nThis script converts an arc up through 180 degrees into a non-rational, cubic, Bezier NurbsCurve.\r\n\r\nOne of the two approximation options uses my solution for converting an arc into a\r\nnon-rational, cubic Bezier while maintaining the same tangent vectors and\r\nradius at both ends:\r\nhttps://discourse.mcneel.com/t/approximating-arc-with-non-rational-cubic-bezier/133784\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n220128: Created.\r\n220314: Bug fix in curve selection.\r\n220501: Now can input multiple curves.  Refactored.\r\n220824: Improved printed output included reporting curve deviations.\r\n220909: Added support for 180 degree arcs.\r\n220917: By default, will create a cubic Bezier that is coincident with the arc\r\nat its midpoint and matches the arc's tangent vectors at its ends.\r\n220918: Added Opts and getInput.\r\n221005: Bug fix.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nimport math\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bMatchRadiusAtEnds'; keys.append(key)\r\n    values[key] = False\r\n    names[key] = 'Match'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'MidPt', 'RadiusAtEnds')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fInputArcTol'; keys.append(key)\r\n    values[key] = 1e-9\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bReplace'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'Action'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Add', 'Replace')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fInputArcTol':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n                return\r\n            if cls.riOpts[key].CurrentValue < Rhino.RhinoMath.ZeroTolerance:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue = Rhino.RhinoMath.ZeroTolerance\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n                return\r\n\r\n        if key == 'fOutputDevTol':\r\n            if cls.riOpts[key].CurrentValue < 0.0:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n                return\r\n            if cls.riOpts[key].CurrentValue < 1e-6:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue = 1e-6\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n                return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getPreselectedCurves():\r\n    gObjs_Preselected = [rdObj.Id for rdObj in sc.doc.Objects.GetSelectedObjects(includeLights=False, includeGrips=False)]\r\n    if gObjs_Preselected:\r\n        gCrvs_Preselected = []\r\n        oes = rd.ObjectEnumeratorSettings()\r\n        oes.NormalObjects = True\r\n        oes.LockedObjects = False\r\n        oes.IncludeLights = False\r\n        oes.IncludeGrips = False\r\n        for rdRhinoObject in sc.doc.Objects.GetObjectList(oes):\r\n            if rdRhinoObject.Id in gObjs_Preselected:\r\n                if rdRhinoObject.ObjectType == rd.ObjectType.Curve:\r\n                    gCrvs_Preselected.append(rdRhinoObject.Id)\r\n        if gCrvs_Preselected:\r\n            if Opts.values['bEcho']:\r\n                s  = \"({} curves\".format(len(gCrvs_Preselected))\r\n                s += \" were preselected.)\"\r\n                print(s)\r\n            return tuple(gCrvs_Preselected)\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get curves with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select arcs with angle <= 180 deg\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Curve\r\n\r\n\r\n    #def customGeometryFilter(rdObj, rgObj, compIdx):\r\n    #    if not isinstance(rgObj, rg.Curve):\r\n    #        return False\r\n    #    if (\r\n    #        isinstance(rgObj, rg.NurbsCurve) and\r\n    #        rgObj.Degree == 3 and\r\n    #        rgObj.Points.Count == 4 and\r\n    #        not rgObj.IsRational\r\n    #    ):\r\n    #        return False\r\n    #    if rgObj.IsArc(fInputArcTol):\r\n    #        return True\r\n    #    return False\r\n\r\n    #go.SetCustomGeometryFilter(customGeometryFilter)\r\n\r\n\r\n    go.SubObjectSelect = False\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    go.AlreadySelectedObjectSelect = True\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Keep objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False)\r\n\r\n    bPreselectedObjsChecked = False\r\n\r\n    idxs_Opt = {}\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        addOption('bMatchRadiusAtEnds')\r\n        addOption('fInputArcTol')\r\n        addOption('bReplace')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        # Use bPreselectedObjsChecked so that only objects before the\r\n        # first call to go.GetMultiple is considered.\r\n        if not bPreselectedObjsChecked and go.ObjectsWerePreselected:\r\n            bPreselectedObjsChecked = True\r\n            go.EnablePreSelect(False, True)\r\n            continue\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fDevTol'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef createPoints_matchArcRadiusAtEnds(arc):\r\n\r\n    if (arc.Angle - Rhino.RhinoMath.ZeroTolerance) > math.pi:\r\n        return\r\n\r\n\r\n    if abs(arc.Angle - math.pi) <= Rhino.RhinoMath.ZeroTolerance:\r\n        print(\"180 degrees\")\r\n        return Rhino.Collections.Point3dList(\r\n            arc.StartPoint,\r\n            arc.StartPoint + arc.Radius * 0.75**(-0.5) * arc.TangentAt(arc.AngleDomain.T0),\r\n            arc.EndPoint   - arc.Radius * 0.75**(-0.5) * arc.TangentAt(arc.AngleDomain.T1),\r\n            arc.EndPoint)\r\n\r\n\r\n    cos_ = math.cos((math.pi/2.0)-arc.Angle)\r\n    tan_ = math.tan(arc.Angle/2.0)\r\n    sqrt_ = (1.0 + 6.0*tan_/cos_)**0.5\r\n    t = arc.Radius * cos_ * (sqrt_ - 1.0) / 3.0\r\n\r\n    return Rhino.Collections.Point3dList(\r\n        arc.StartPoint,\r\n        arc.StartPoint + t * arc.TangentAt(arc.AngleDomain.T0),\r\n        arc.EndPoint   - t * arc.TangentAt(arc.AngleDomain.T1),\r\n        arc.EndPoint)\r\n\r\n\r\ndef createPoints_matchArcAtMidPoint(arc):\r\n\r\n    if (arc.Angle - Rhino.RhinoMath.ZeroTolerance) > math.pi:\r\n        return\r\n\r\n\r\n    # Per https://pomax.github.io/bezierinfo/#circles_cubic\r\n    k = 4.0 * math.tan(arc.Angle/4.0) / 3.0\r\n\r\n    return Rhino.Collections.Point3dList(\r\n        arc.StartPoint,\r\n        arc.StartPoint + k * arc.TangentAt(arc.AngleDomain.T0) * arc.Radius,\r\n        arc.EndPoint   - k * arc.TangentAt(arc.AngleDomain.T1) * arc.Radius,\r\n        arc.EndPoint)\r\n\r\n\r\ndef processCurve(crv_In, bMatchRadiusAtEnds=False, fInputArcTol=None):\r\n\r\n    if fInputArcTol is None: fInputArcTol = 1e-9\r\n\r\n    bSuccess, arc = crv_In.TryGetArc(fInputArcTol)\r\n    if not bSuccess:\r\n        #raise ValueError(\r\n        #    \"Arc should have been obtained from Curve.TryGetArc \"\r\n        #    \"since Curve.IsArc returned true.\")\r\n        return\r\n\r\n\r\n    if arc.Angle > (math.pi + Rhino.RhinoMath.ZeroTolerance):\r\n        print(\"Angle of arc is {:.2f}.\".format(math.degrees(arc.Angle)),\r\n            \"Script only converts up to 180 degs.\",\r\n            \"Curve skipped.\",\r\n            sep=\"  \"\r\n            )\r\n        return\r\n\r\n    if bMatchRadiusAtEnds:\r\n        point3dList = createPoints_matchArcRadiusAtEnds(arc)\r\n    else:\r\n        point3dList = createPoints_matchArcAtMidPoint(arc)\r\n\r\n    return rg.Curve.CreateControlPointCurve(point3dList, degree=3)\r\n\r\n\r\ndef formatDistance(fDistance):\r\n    if fDistance is None:\r\n        return \"(None)\"\r\n    if fDistance == Rhino.RhinoMath.UnsetValue:\r\n        return \"(Infinite)\"\r\n    if fDistance < 10.0**(-(sc.doc.DistanceDisplayPrecision-1)):\r\n        return \"{:.2e}\".format(fDistance)\r\n    return \"{:.{}f}\".format(fDistance, sc.doc.ModelDistanceDisplayPrecision)\r\n\r\n\r\ndef main():\r\n\r\n    objrefs = getInput()\r\n    if objrefs is None: return\r\n\r\n    bMatchRadiusAtEnds = Opts.values['bMatchRadiusAtEnds']\r\n    fInputArcTol = Opts.values['fInputArcTol']\r\n    bReplace = Opts.values['bReplace']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n\r\n    if bDebug:\r\n        sEval = \"bMatchRadiusAtEnds\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval = \"fInputArcTol\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval = \"bReplace\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval = \"bEcho\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        sEval = \"bDebug\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n    else:\r\n        sc.doc.Views.RedrawEnabled = False\r\n\r\n\r\n    gCrvs_Out = []\r\n    sLogs = []\r\n    devs = []\r\n\r\n    for objref in objrefs:\r\n\r\n        crv_In = objref.Curve()\r\n\r\n        if not crv_In: return\r\n\r\n\r\n        nc_Res = processCurve(\r\n            crv_In,\r\n            bMatchRadiusAtEnds=bMatchRadiusAtEnds,\r\n            fInputArcTol=fInputArcTol,\r\n            )\r\n\r\n        if nc_Res is None: continue\r\n\r\n\r\n        rc = rg.Curve.GetDistancesBetweenCurves(nc_Res, crv_In, 0.1*sc.doc.ModelAbsoluteTolerance)\r\n        if not rc[0]:\r\n            sLogs.append(\"GetDistancesBetweenCurves failed.\")\r\n        else:\r\n            devs.append(rc[1])\r\n\r\n        rdObj_In = objref.Object()\r\n\r\n        if bReplace and isinstance(rdObj_In, rd.CurveObject):\r\n            bReplaced = sc.doc.Objects.Replace(rdObj_In.Id, nc_Res)\r\n            if bReplaced:\r\n                sLogs.append(\"Replaced curve with non-rational, cubic Bezier.\")\r\n                gCrv_Out = rdObj_In.Id\r\n                gCrvs_Out.append(gCrv_Out)\r\n            else:\r\n                sLogs.append(\"Could not replace curve.\")\r\n                continue\r\n        else:\r\n            gCrv_Out = sc.doc.Objects.AddCurve(nc_Res)\r\n            if gCrv_Out != gCrv_Out.Empty:\r\n                sLogs.append(\"Added non-rational, cubic Bezier curve.\")\r\n                gCrvs_Out.append(gCrv_Out)\r\n            else:\r\n                sLogs.append(\"Could not add curve.\")\r\n                continue\r\n\r\n    for s in set(sLogs):\r\n        print(\"{} of {}\".format(sLogs.count(s), s))\r\n\r\n    if not gCrvs_Out:\r\n        print(\"No curves were modified/added.\")\r\n        return\r\n\r\n    if len(devs) == 1:\r\n        print(\"Deviation: {}\".format(formatDistance(devs[0])))\r\n    elif len(devs) > 1:\r\n        if max(devs) - min(devs) < 10**(-(sc.doc.ModelDistanceDisplayPrecision+1)):\r\n            print(\"Deviations: {}\".format(formatDistance(devs[0])))\r\n        else:\r\n            print(\"Deviations: [{},{}]\".format(\r\n                formatDistance(min(devs)),\r\n                formatDistance(max(devs)),\r\n                ))\r\n\r\n\r\n    sc.doc.Views.Redraw()\r\n\r\n    return gCrvs_Out\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}