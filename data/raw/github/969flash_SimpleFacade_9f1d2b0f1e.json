{
  "source_url": "https://github.com/969flash/SimpleFacade/blob/6c7fecac5a2905e174905fc57fab87d40de0cc3e/facade_plan.py",
  "repo": "969flash/SimpleFacade",
  "repo_stars": 1,
  "repo_description": "Make Facade From Building Mass",
  "license": "unknown",
  "filepath": "facade_plan.py",
  "instruction": "Facade plan",
  "code": "# -*- coding:utf-8 -*-\ntry:\n    from typing import List, Tuple, Dict, Any, Optional\nexcept ImportError:\n    pass\n\nimport Rhino.Geometry as geo  # type: ignore\nimport utils\nfrom abc import ABC, abstractmethod\nimport math\n\n\nclass Facade:\n    \"\"\"파사드 클래스 - facade_plan에서 정의하여 순환 참조 방지\"\"\"\n\n    def __init__(\n        self,\n        glasses: list[geo.Brep],\n        walls: list[geo.Brep],\n        frames: list[geo.Brep] = None,\n        slabs: list[geo.Brep] = None,\n    ) -> None:\n        self.glasses = glasses\n        self.walls = walls\n        self.frames = frames if frames is not None else []\n        self.slabs = slabs if slabs is not None else []\n\n\nclass BaseFacadeType(ABC):\n    \"\"\"파사드 타입의 베이스 클래스\"\"\"\n\n    def __init__(\n        self,\n        pattern_length: float,\n        pattern_depth: float,\n        pattern_ratio: float,\n        building_curve: geo.Curve,\n    ):\n        self.pattern_length = pattern_length\n        self.pattern_depth = pattern_depth\n        self.pattern_ratio = pattern_ratio\n        self.building_curve = building_curve\n\n    @abstractmethod\n    def generate(self, seg: geo.Curve, extrude_height: float) -> Optional[Facade]:\n        \"\"\"파사드를 생성하는 추상 메서드\"\"\"\n        pass\n\n    def _extrude_to_facade(\n        self,\n        glass_segs: list[geo.Curve],\n        wall_segs: list[geo.Curve],\n        frame_segs: list[geo.Curve],\n        extrude_height: float,\n    ) -> Optional[Facade]:\n        \"\"\"커브 세트를 층 높이만큼 압출하여 Facade로 변환\"\"\"\n\n        def _ext_to_brep(line: geo.Curve) -> Optional[geo.Brep]:\n            ext = geo.Extrusion.Create(line, extrude_height, False)\n            return ext.ToBrep() if ext else None\n\n        glass_breps = [b for b in (_ext_to_brep(c) for c in glass_segs) if b]\n        wall_breps = [b for b in (_ext_to_brep(c) for c in wall_segs) if b]\n        frame_breps = [b for b in (_ext_to_brep(c) for c in frame_segs) if b]\n\n        if not glass_breps and not wall_breps and not frame_breps:\n            return None\n\n        return Facade(glass_breps, wall_breps, frame_breps, [])\n\n\nclass FacadeType1(BaseFacadeType):\n    \"\"\"기본 파사드 - 패턴 파라미터 기반\"\"\"\n\n    def generate(self, seg: geo.Curve, extrude_height: float) -> Optional[Facade]:\n        pts_from_seg = utils.get_pts_by_length(\n            seg, self.pattern_length, include_start=True\n        )\n        if not pts_from_seg or len(pts_from_seg) < 2:\n            return None\n\n        glass_segs: list[geo.Curve] = []\n        wall_segs: list[geo.Curve] = []\n        frame_segs: list[geo.Curve] = []\n\n        for pt, next_pt in zip(pts_from_seg, pts_from_seg[1:]):\n            vector = utils.get_vector_from_pts(pt, next_pt)\n            if hasattr(vector, \"IsZero\") and vector.IsZero:\n                continue\n            vector.Unitize()\n\n            div_pt = pt + vector * (self.pattern_length * self.pattern_ratio)\n            out_vec = utils.get_outside_perp_vec_from_pt(div_pt, self.building_curve)\n\n            if out_vec is not None:\n                partition_pt = div_pt + out_vec * self.pattern_depth\n                glass_segs.append(geo.LineCurve(pt, partition_pt))\n                wall_segs.append(geo.LineCurve(partition_pt, next_pt))\n            else:\n                glass_segs.append(geo.LineCurve(pt, div_pt))\n                wall_segs.append(geo.LineCurve(div_pt, next_pt))\n\n        if len(pts_from_seg) >= 2:\n            wall_segs.append(geo.LineCurve(pts_from_seg[-1], seg.PointAtEnd))\n\n        return self._extrude_to_facade(\n            glass_segs, wall_segs, frame_segs, extrude_height\n        )\n\n\nclass FacadeType2(BaseFacadeType):\n    \"\"\"직선형 파사드\"\"\"\n\n    def generate(self, seg: geo.Curve, extrude_height: float) -> Optional[Facade]:\n        pts_from_seg = utils.get_pts_by_length(\n            seg, self.pattern_length, include_start=True\n        )\n        if not pts_from_seg or len(pts_from_seg) < 2:\n            return None\n\n        glass_segs: list[geo.Curve] = []\n        wall_segs: list[geo.Curve] = []\n        frame_segs: list[geo.Curve] = []\n\n        for pt, next_pt in zip(pts_from_seg, pts_from_seg[1:]):\n            vector = utils.get_vector_from_pts(pt, next_pt)\n            if hasattr(vector, \"IsZero\") and vector.IsZero:\n                continue\n            vector.Unitize()\n\n            div_pt = pt + vector * (self.pattern_length * self.pattern_ratio)\n            glass_segs.append(geo.LineCurve(pt, div_pt))\n            wall_segs.append(geo.LineCurve(div_pt, next_pt))\n\n        if len(pts_from_seg) >= 2:\n            wall_segs.append(geo.LineCurve(pts_from_seg[-1], seg.PointAtEnd))\n\n        return self._extrude_to_facade(\n            glass_segs, wall_segs, frame_segs, extrude_height\n        )\n\n\nclass FacadeType3(BaseFacadeType):\n    \"\"\"프레임이 있는 파사드\"\"\"\n\n    def generate(self, seg: geo.Curve, extrude_height: float) -> Optional[Facade]:\n        pts_from_seg = utils.get_pts_by_length(\n            seg, self.pattern_length, include_start=True\n        )\n        if not pts_from_seg or len(pts_from_seg) < 2:\n            return None\n\n        glass_segs: list[geo.Curve] = []\n        wall_segs: list[geo.Curve] = []\n        frame_segs: list[geo.Curve] = []\n\n        for pt, next_pt in zip(pts_from_seg, pts_from_seg[1:]):\n            vector = utils.get_vector_from_pts(pt, next_pt)\n            if hasattr(vector, \"IsZero\") and vector.IsZero:\n                continue\n            vector.Unitize()\n\n            div_pt = pt + vector * (self.pattern_length * self.pattern_ratio)\n            out_vec = utils.get_outside_perp_vec_from_pt(div_pt, self.building_curve)\n\n            if out_vec is not None:\n                out_mid = div_pt + out_vec * self.pattern_depth\n                frame_segs.append(geo.LineCurve(div_pt, out_mid))\n\n            glass_segs.append(geo.LineCurve(pt, div_pt))\n            wall_segs.append(geo.LineCurve(div_pt, next_pt))\n\n        if len(pts_from_seg) >= 2:\n            wall_segs.append(geo.LineCurve(pts_from_seg[-1], seg.PointAtEnd))\n\n        return self._extrude_to_facade(\n            glass_segs, wall_segs, frame_segs, extrude_height\n        )\n\n\nclass FacadeType4(BaseFacadeType):\n    \"\"\"지그재그 패턴 파사드\"\"\"\n\n    def generate(self, seg: geo.Curve, extrude_height: float) -> Optional[Facade]:\n        pts_from_seg = utils.get_pts_by_length(\n            seg, self.pattern_length, include_start=True\n        )\n        if not pts_from_seg or len(pts_from_seg) < 2:\n            return None\n\n        glass_segs: list[geo.Curve] = []\n        wall_segs: list[geo.Curve] = []\n        frame_segs: list[geo.Curve] = []\n\n        for i, (pt, next_pt) in enumerate(zip(pts_from_seg, pts_from_seg[1:])):\n            vector = utils.get_vector_from_pts(pt, next_pt)\n            if hasattr(vector, \"IsZero\") and vector.IsZero:\n                continue\n            vector.Unitize()\n\n            div_pt = pt + vector * (self.pattern_length * self.pattern_ratio)\n            out_vec = utils.get_outside_perp_vec_from_pt(div_pt, self.building_curve)\n\n            if out_vec is not None:\n                direction = 1 if i % 2 == 0 else -1\n                zigzag_pt = div_pt + out_vec * (self.pattern_depth * direction)\n\n                if direction > 0:\n                    frame_end = div_pt + out_vec * (\n                        self.pattern_depth * direction * 0.6\n                    )\n                    frame_segs.append(geo.LineCurve(div_pt, frame_end))\n\n                glass_segs.append(geo.LineCurve(pt, zigzag_pt))\n                wall_segs.append(geo.LineCurve(zigzag_pt, next_pt))\n            else:\n                glass_segs.append(geo.LineCurve(pt, div_pt))\n                wall_segs.append(geo.LineCurve(div_pt, next_pt))\n\n        if len(pts_from_seg) >= 2:\n            wall_segs.append(geo.LineCurve(pts_from_seg[-1], seg.PointAtEnd))\n\n        return self._extrude_to_facade(\n            glass_segs, wall_segs, frame_segs, extrude_height\n        )\n\n\nclass FacadeType5(BaseFacadeType):\n    \"\"\"웨이브 패턴 파사드\"\"\"\n\n    def generate(self, seg: geo.Curve, extrude_height: float) -> Optional[Facade]:\n        pts_from_seg = utils.get_pts_by_length(\n            seg, self.pattern_length, include_start=True\n        )\n        if not pts_from_seg or len(pts_from_seg) < 2:\n            return None\n\n        glass_segs: list[geo.Curve] = []\n        wall_segs: list[geo.Curve] = []\n        frame_segs: list[geo.Curve] = []\n\n        for i, (pt, next_pt) in enumerate(zip(pts_from_seg, pts_from_seg[1:])):\n            vector = utils.get_vector_from_pts(pt, next_pt)\n            if hasattr(vector, \"IsZero\") and vector.IsZero:\n                continue\n            vector.Unitize()\n\n            div_pt = pt + vector * (self.pattern_length * self.pattern_ratio)\n            out_vec = utils.get_outside_perp_vec_from_pt(div_pt, self.building_curve)\n\n            if out_vec is not None:\n                wave_factor = math.sin(i * math.pi / 2)\n                wave_pt = div_pt + out_vec * (self.pattern_depth * wave_factor)\n\n                if abs(wave_factor) > 0.7:\n                    frame_depth = self.pattern_depth * abs(wave_factor) * 0.5\n                    frame_end = div_pt + out_vec * frame_depth\n                    frame_segs.append(geo.LineCurve(div_pt, frame_end))\n\n                glass_segs.append(geo.LineCurve(pt, wave_pt))\n                wall_segs.append(geo.LineCurve(wave_pt, next_pt))\n            else:\n                glass_segs.append(geo.LineCurve(pt, div_pt))\n                wall_segs.append(geo.LineCurve(div_pt, next_pt))\n\n        if len(pts_from_seg) >= 2:\n            wall_segs.append(geo.LineCurve(pts_from_seg[-1], seg.PointAtEnd))\n\n        return self._extrude_to_facade(\n            glass_segs, wall_segs, frame_segs, extrude_height\n        )\n\n\nclass FacadeType6(BaseFacadeType):\n    \"\"\"피라미드 패턴 파사드\"\"\"\n\n    def generate(self, seg: geo.Curve, extrude_height: float) -> Optional[Facade]:\n        pts_from_seg = utils.get_pts_by_length(\n            seg, self.pattern_length, include_start=True\n        )\n        if not pts_from_seg or len(pts_from_seg) < 2:\n            return None\n\n        glass_segs: list[geo.Curve] = []\n        wall_segs: list[geo.Curve] = []\n        frame_segs: list[geo.Curve] = []\n\n        total_segments = len(pts_from_seg) - 1\n\n        for i, (pt, next_pt) in enumerate(zip(pts_from_seg, pts_from_seg[1:])):\n            vector = utils.get_vector_from_pts(pt, next_pt)\n            if hasattr(vector, \"IsZero\") and vector.IsZero:\n                continue\n            vector.Unitize()\n\n            div_pt = pt + vector * (self.pattern_length * self.pattern_ratio)\n            out_vec = utils.get_outside_perp_vec_from_pt(div_pt, self.building_curve)\n\n            if out_vec is not None:\n                center_distance = abs(i - total_segments / 2) / (total_segments / 2)\n                pyramid_factor = 1.0 - center_distance\n                pyramid_pt = div_pt + out_vec * (self.pattern_depth * pyramid_factor)\n\n                if pyramid_factor > 0.3:\n                    frame_end = div_pt + out_vec * (\n                        self.pattern_depth * pyramid_factor * 0.5\n                    )\n                    frame_segs.append(geo.LineCurve(div_pt, frame_end))\n\n                glass_segs.append(geo.LineCurve(pt, pyramid_pt))\n                wall_segs.append(geo.LineCurve(pyramid_pt, next_pt))\n            else:\n                glass_segs.append(geo.LineCurve(pt, div_pt))\n                wall_segs.append(geo.LineCurve(div_pt, next_pt))\n\n        if len(pts_from_seg) >= 2:\n            wall_segs.append(geo.LineCurve(pts_from_seg[-1], seg.PointAtEnd))\n\n        return self._extrude_to_facade(\n            glass_segs, wall_segs, frame_segs, extrude_height\n        )\n\n\nclass FacadeType7(BaseFacadeType):\n    \"\"\"헥사곤 패턴 파사드\"\"\"\n\n    def generate(self, seg: geo.Curve, extrude_height: float) -> Optional[Facade]:\n        pts_from_seg = utils.get_pts_by_length(\n            seg, self.pattern_length * 0.5, include_start=True\n        )\n        if not pts_from_seg or len(pts_from_seg) < 2:\n            return None\n\n        glass_segs: list[geo.Curve] = []\n        wall_segs: list[geo.Curve] = []\n        frame_segs: list[geo.Curve] = []\n\n        for i, (pt, next_pt) in enumerate(zip(pts_from_seg, pts_from_seg[1:])):\n            vector = utils.get_vector_from_pts(pt, next_pt)\n            if hasattr(vector, \"IsZero\") and vector.IsZero:\n                continue\n            vector.Unitize()\n\n            div_pt = pt + vector * ((self.pattern_length * 0.5) * self.pattern_ratio)\n            out_vec = utils.get_outside_perp_vec_from_pt(div_pt, self.building_curve)\n\n            if out_vec is not None:\n                hex_angle = (i % 6) * math.pi / 3\n                hex_factor = math.cos(hex_angle) * 0.8 + 0.2\n                hex_pt = div_pt + out_vec * (self.pattern_depth * hex_factor)\n\n                if abs(hex_factor) > 0.5:\n                    frame_end = div_pt + out_vec * (\n                        self.pattern_depth * hex_factor * 0.3\n                    )\n                    frame_segs.append(geo.LineCurve(div_pt, frame_end))\n\n                glass_segs.append(geo.LineCurve(pt, hex_pt))\n                wall_segs.append(geo.LineCurve(hex_pt, next_pt))\n            else:\n                glass_segs.append(geo.LineCurve(pt, div_pt))\n                wall_segs.append(geo.LineCurve(div_pt, next_pt))\n\n        if len(pts_from_seg) >= 2:\n            wall_segs.append(geo.LineCurve(pts_from_seg[-1], seg.PointAtEnd))\n\n        return self._extrude_to_facade(\n            glass_segs, wall_segs, frame_segs, extrude_height\n        )\n\n\nclass FacadeType8(BaseFacadeType):\n    \"\"\"스파이럴 패턴 파사드\"\"\"\n\n    def generate(self, seg: geo.Curve, extrude_height: float) -> Optional[Facade]:\n        pts_from_seg = utils.get_pts_by_length(\n            seg, self.pattern_length * 0.8, include_start=True\n        )\n        if not pts_from_seg or len(pts_from_seg) < 2:\n            return None\n\n        glass_segs: list[geo.Curve] = []\n        wall_segs: list[geo.Curve] = []\n        frame_segs: list[geo.Curve] = []\n\n        for i, (pt, next_pt) in enumerate(zip(pts_from_seg, pts_from_seg[1:])):\n            vector = utils.get_vector_from_pts(pt, next_pt)\n            if hasattr(vector, \"IsZero\") and vector.IsZero:\n                continue\n            vector.Unitize()\n\n            div_pt = pt + vector * ((self.pattern_length * 0.8) * self.pattern_ratio)\n            out_vec = utils.get_outside_perp_vec_from_pt(div_pt, self.building_curve)\n\n            if out_vec is not None:\n                spiral_angle = i * math.pi / 4\n                spiral_radius = (i % 8 + 1) / 8.0\n                spiral_factor = math.sin(spiral_angle) * spiral_radius\n                spiral_pt = div_pt + out_vec * (self.pattern_depth * spiral_factor)\n\n                if abs(spiral_factor) > 0.4:\n                    frame_depth = self.pattern_depth * abs(spiral_factor) * 0.6\n                    frame_end = div_pt + out_vec * frame_depth\n                    frame_segs.append(geo.LineCurve(div_pt, frame_end))\n\n                glass_segs.append(geo.LineCurve(pt, spiral_pt))\n                wall_segs.append(geo.LineCurve(spiral_pt, next_pt))\n            else:\n                glass_segs.append(geo.LineCurve(pt, div_pt))\n                wall_segs.append(geo.LineCurve(div_pt, next_pt))\n\n        if len(pts_from_seg) >= 2:\n            wall_segs.append(geo.LineCurve(pts_from_seg[-1], seg.PointAtEnd))\n\n        return self._extrude_to_facade(\n            glass_segs, wall_segs, frame_segs, extrude_height\n        )\n\n\nclass FacadeType9(BaseFacadeType):\n    \"\"\"랜덤 노이즈 패턴 파사드\"\"\"\n\n    def generate(self, seg: geo.Curve, extrude_height: float) -> Optional[Facade]:\n        pts_from_seg = utils.get_pts_by_length(\n            seg, self.pattern_length * 0.6, include_start=True\n        )\n        if not pts_from_seg or len(pts_from_seg) < 2:\n            return None\n\n        glass_segs: list[geo.Curve] = []\n        wall_segs: list[geo.Curve] = []\n        frame_segs: list[geo.Curve] = []\n\n        for i, (pt, next_pt) in enumerate(zip(pts_from_seg, pts_from_seg[1:])):\n            vector = utils.get_vector_from_pts(pt, next_pt)\n            if hasattr(vector, \"IsZero\") and vector.IsZero:\n                continue\n            vector.Unitize()\n\n            div_pt = pt + vector * ((self.pattern_length * 0.6) * self.pattern_ratio)\n            out_vec = utils.get_outside_perp_vec_from_pt(div_pt, self.building_curve)\n\n            if out_vec is not None:\n                noise1 = math.sin(i * 0.7) * 0.5\n                noise2 = math.cos(i * 1.3) * 0.3\n                noise3 = math.sin(i * 2.1) * 0.2\n                noise_factor = noise1 + noise2 + noise3\n\n                noise_pt = div_pt + out_vec * (self.pattern_depth * noise_factor)\n\n                if abs(noise_factor) > 0.6:\n                    frame_end = div_pt + out_vec * (\n                        self.pattern_depth * noise_factor * 0.4\n                    )\n                    frame_segs.append(geo.LineCurve(div_pt, frame_end))\n\n                glass_segs.append(geo.LineCurve(pt, noise_pt))\n                wall_segs.append(geo.LineCurve(noise_pt, next_pt))\n            else:\n                glass_segs.append(geo.LineCurve(pt, div_pt))\n                wall_segs.append(geo.LineCurve(div_pt, next_pt))\n\n        if len(pts_from_seg) >= 2:\n            wall_segs.append(geo.LineCurve(pts_from_seg[-1], seg.PointAtEnd))\n\n        return self._extrude_to_facade(\n            glass_segs, wall_segs, frame_segs, extrude_height\n        )\n\n\nclass FacadeType10(BaseFacadeType):\n    \"\"\"복합 패턴 파사드\"\"\"\n\n    def generate(self, seg: geo.Curve, extrude_height: float) -> Optional[Facade]:\n        pts_from_seg = utils.get_pts_by_length(\n            seg, self.pattern_length * 0.4, include_start=True\n        )\n        if not pts_from_seg or len(pts_from_seg) < 2:\n            return None\n\n        glass_segs: list[geo.Curve] = []\n        wall_segs: list[geo.Curve] = []\n        frame_segs: list[geo.Curve] = []\n\n        total_segments = len(pts_from_seg) - 1\n\n        for i, (pt, next_pt) in enumerate(zip(pts_from_seg, pts_from_seg[1:])):\n            vector = utils.get_vector_from_pts(pt, next_pt)\n            if hasattr(vector, \"IsZero\") and vector.IsZero:\n                continue\n            vector.Unitize()\n\n            div_pt = pt + vector * ((self.pattern_length * 0.4) * self.pattern_ratio)\n            out_vec = utils.get_outside_perp_vec_from_pt(div_pt, self.building_curve)\n\n            if out_vec is not None:\n                # 1. 지그재그 성분\n                zigzag_factor = 1 if i % 2 == 0 else -1\n                # 2. 웨이브 성분\n                wave_factor = math.sin(i * math.pi / 3) * 0.7\n                # 3. 피라미드 성분\n                center_distance = (\n                    abs(i - total_segments / 2) / (total_segments / 2)\n                    if total_segments > 0\n                    else 0\n                )\n                pyramid_factor = (1.0 - center_distance) * 0.6\n                # 4. 노이즈 성분\n                noise_factor = math.sin(i * 0.9) * math.cos(i * 1.7) * 0.4\n\n                # 모든 성분 결합\n                combined_factor = (\n                    zigzag_factor * 0.3\n                    + wave_factor * 0.3\n                    + pyramid_factor * 0.2\n                    + noise_factor * 0.2\n                )\n\n                complex_pt = div_pt + out_vec * (self.pattern_depth * combined_factor)\n\n                # 복잡한 프레임 시스템\n                if abs(combined_factor) > 0.5:\n                    frame_end = div_pt + out_vec * (\n                        self.pattern_depth * combined_factor * 0.5\n                    )\n                    frame_segs.append(geo.LineCurve(div_pt, frame_end))\n\n                    if abs(combined_factor) > 0.8:\n                        side_frame_end = div_pt + out_vec * (\n                            self.pattern_depth * combined_factor * 0.3\n                        )\n                        frame_segs.append(geo.LineCurve(div_pt, side_frame_end))\n\n                glass_segs.append(geo.LineCurve(pt, complex_pt))\n                wall_segs.append(geo.LineCurve(complex_pt, next_pt))\n            else:\n                glass_segs.append(geo.LineCurve(pt, div_pt))\n                wall_segs.append(geo.LineCurve(div_pt, next_pt))\n\n        if len(pts_from_seg) >= 2:\n            wall_segs.append(geo.LineCurve(pts_from_seg[-1], seg.PointAtEnd))\n\n        return self._extrude_to_facade(\n            glass_segs, wall_segs, frame_segs, extrude_height\n        )\n\n\nclass BottomFacadeType1(BaseFacadeType):\n    \"\"\"저층부 파사드 타입 1 - 두꺼운 프레임과 긴 벽체\"\"\"\n\n    def generate(self, seg: geo.Curve, extrude_height: float) -> Optional[Facade]:\n        pts_from_seg = utils.get_pts_by_length(\n            seg, self.pattern_length * 0.9, include_start=True\n        )\n        if not pts_from_seg or len(pts_from_seg) < 2:\n            return None\n\n        glass_segs: list[geo.Curve] = []\n        wall_segs: list[geo.Curve] = []\n        frame_segs: list[geo.Curve] = []\n\n        for pt, next_pt in zip(pts_from_seg, pts_from_seg[1:]):\n            vector = utils.get_vector_from_pts(pt, next_pt)\n            if hasattr(vector, \"IsZero\") and vector.IsZero:\n                continue\n            vector.Unitize()\n\n            glass_len = self.pattern_length * 0.3\n            glass_pt = pt + vector * glass_len\n            glass_segs.append(geo.LineCurve(pt, glass_pt))\n\n            wall_segs.append(geo.LineCurve(glass_pt, next_pt))\n\n            out_vec = utils.get_outside_perp_vec_from_pt(glass_pt, self.building_curve)\n            if out_vec is not None:\n                frame_depth = self.pattern_depth * 1.3\n                frame_end = glass_pt + out_vec * frame_depth\n                frame_segs.append(geo.LineCurve(glass_pt, frame_end))\n\n        if len(pts_from_seg) >= 2:\n            wall_segs.append(geo.LineCurve(pts_from_seg[-1], seg.PointAtEnd))\n\n        return self._extrude_to_facade(\n            glass_segs, wall_segs, frame_segs, extrude_height\n        )\n\n\nclass BottomFacadeType2(BaseFacadeType):\n    \"\"\"저층부 파사드 타입 2 - 벽체 비중이 높은 필라 구조\"\"\"\n\n    def generate(self, seg: geo.Curve, extrude_height: float) -> Optional[Facade]:\n        pts_from_seg = utils.get_pts_by_length(\n            seg, self.pattern_length, include_start=True\n        )\n        if not pts_from_seg or len(pts_from_seg) < 2:\n            return None\n\n        glass_segs: list[geo.Curve] = []\n        wall_segs: list[geo.Curve] = []\n        frame_segs: list[geo.Curve] = []\n\n        for pt, next_pt in zip(pts_from_seg, pts_from_seg[1:]):\n            vector = utils.get_vector_from_pts(pt, next_pt)\n            if hasattr(vector, \"IsZero\") and vector.IsZero:\n                continue\n            vector.Unitize()\n\n            first_div = pt + vector * (self.pattern_length * 0.2)\n            second_div = pt + vector * (self.pattern_length * 0.8)\n\n            glass_segs.append(geo.LineCurve(pt, first_div))\n            wall_segs.append(geo.LineCurve(first_div, second_div))\n            wall_segs.append(geo.LineCurve(second_div, next_pt))\n\n            out_vec = utils.get_outside_perp_vec_from_pt(\n                second_div, self.building_curve\n            )\n            if out_vec is not None:\n                frame_depth = self.pattern_depth * 1.1\n                frame_start = first_div - out_vec * (self.pattern_depth * 0.3)\n                frame_end = second_div + out_vec * frame_depth\n                frame_segs.append(geo.LineCurve(frame_start, frame_end))\n\n        if len(pts_from_seg) >= 2:\n            wall_segs.append(geo.LineCurve(pts_from_seg[-1], seg.PointAtEnd))\n\n        return self._extrude_to_facade(\n            glass_segs, wall_segs, frame_segs, extrude_height\n        )\n\n\nclass BottomFacadeType3(BaseFacadeType):\n    \"\"\"저층부 파사드 타입 3 - 대칭 프레임과 짧은 창호\"\"\"\n\n    def generate(self, seg: geo.Curve, extrude_height: float) -> Optional[Facade]:\n        pts_from_seg = utils.get_pts_by_length(\n            seg, self.pattern_length * 0.75, include_start=True\n        )\n        if not pts_from_seg or len(pts_from_seg) < 2:\n            return None\n\n        glass_segs: list[geo.Curve] = []\n        wall_segs: list[geo.Curve] = []\n        frame_segs: list[geo.Curve] = []\n\n        for pt, next_pt in zip(pts_from_seg, pts_from_seg[1:]):\n            vector = utils.get_vector_from_pts(pt, next_pt)\n            if hasattr(vector, \"IsZero\") and vector.IsZero:\n                continue\n            vector.Unitize()\n\n            center = pt + vector * (self.pattern_length * 0.5)\n            glass_start = center - vector * (self.pattern_length * 0.15)\n            glass_end = center + vector * (self.pattern_length * 0.15)\n\n            wall_segs.append(geo.LineCurve(pt, glass_start))\n            glass_segs.append(geo.LineCurve(glass_start, glass_end))\n            wall_segs.append(geo.LineCurve(glass_end, next_pt))\n\n            out_vec = utils.get_outside_perp_vec_from_pt(center, self.building_curve)\n            if out_vec is not None:\n                frame_depth = self.pattern_depth * 1.4\n                left_frame_start = glass_start\n                left_frame_end = glass_start + out_vec * frame_depth\n                right_frame_start = glass_end\n                right_frame_end = glass_end + out_vec * frame_depth\n                frame_segs.append(geo.LineCurve(left_frame_start, left_frame_end))\n                frame_segs.append(geo.LineCurve(right_frame_start, right_frame_end))\n\n        if len(pts_from_seg) >= 2:\n            wall_segs.append(geo.LineCurve(pts_from_seg[-1], seg.PointAtEnd))\n\n        return self._extrude_to_facade(\n            glass_segs, wall_segs, frame_segs, extrude_height\n        )\n\n\nclass FacadeTypeRegistry:\n    \"\"\"파사드 타입 레지스트리 - 팩토리 패턴\"\"\"\n\n    _facade_types = {\n        1: FacadeType1,\n        2: FacadeType2,\n        3: FacadeType3,\n        4: FacadeType4,\n        5: FacadeType5,\n        6: FacadeType6,\n        7: FacadeType7,\n        8: FacadeType8,\n        9: FacadeType9,\n        10: FacadeType10,\n    }\n\n    @classmethod\n    def create_facade_type(\n        cls,\n        type_num: int,\n        pattern_length: float,\n        pattern_depth: float,\n        pattern_ratio: float,\n        building_curve: geo.Curve,\n    ) -> Optional[BaseFacadeType]:\n        \"\"\"지정된 타입의 파사드 객체를 생성\"\"\"\n        facade_class = cls._facade_types.get(type_num)\n        if facade_class:\n            return facade_class(\n                pattern_length, pattern_depth, pattern_ratio, building_curve\n            )\n        return None\n\n    @classmethod\n    def get_available_types(cls) -> list[int]:\n        \"\"\"사용 가능한 파사드 타입 번호 목록을 반환\"\"\"\n        return list(cls._facade_types.keys())\n\n\nclass BottomFacadeTypeRegistry:\n    \"\"\"저층부 전용 파사드 타입 레지스트리\"\"\"\n\n    _facade_types = {\n        1: BottomFacadeType1,\n        2: BottomFacadeType2,\n        3: BottomFacadeType3,\n    }\n\n    @classmethod\n    def create_facade_type(\n        cls,\n        type_num: int,\n        pattern_length: float,\n        pattern_depth: float,\n        pattern_ratio: float,\n        building_curve: geo.Curve,\n    ) -> Optional[BaseFacadeType]:\n        facade_class = cls._facade_types.get(type_num)\n        if facade_class:\n            return facade_class(\n                pattern_length, pattern_depth, pattern_ratio, building_curve\n            )\n        return None\n\n    @classmethod\n    def get_available_types(cls) -> list[int]:\n        return list(cls._facade_types.keys())\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": false
}