{
  "source_url": "https://github.com/ksteinfe/decodes/blob/b876d6d01ea23ccbf4558182582a822b008cf2b8/src/decodes/io/rhino_in.py",
  "repo": "ksteinfe/decodes",
  "repo_stars": 43,
  "repo_description": "a platform agnostic generative design library for 3d designers",
  "license": "GPL-3.0",
  "filepath": "src/decodes/io/rhino_in.py",
  "instruction": "Rhino in",
  "code": "from .. import *\nfrom ..core import *\nfrom ..core import dc_base, dc_vec, dc_point, dc_cs, dc_line, dc_mesh, dc_pgon, dc_xform\nimport rhinoscriptsyntax as rs\nif VERBOSE_FS: print(\"rhino_in loaded\")\n\n\nclass RhinoIn():\n    \"\"\"innie for pulling stuff from rhino\"\"\"\n    \"\"\"based on Rhinoscript package\"\"\"\n    \n    def __init__(self):\n        pass\n        \n    def get_point(self, prompt=\"select a point\"):\n        rh_point = rs.GetPoint(prompt)\n        return Point(rh_point[0],rh_point[1],rh_point[2])\n        \n    def get_mesh(self, prompt=\"select a mesh\", triangulate=False):\n        mesh_id = rs.GetObject(prompt, 32, True)\n        rh_mesh = rs.coercemesh(mesh_id)\n        \n        verts = [Point(rh_pt.X,rh_pt.Y,rh_pt.Z) for rh_pt in rh_mesh.Vertices]\n        faces = []\n        for rh_fc in rh_mesh.Faces :\n            if triangulate:\n                faces.append([rh_fc[0],rh_fc[1],rh_fc[2]]) #add the first three points of each face\n                if rh_fc[2] != rh_fc[3] : \n                    faces.append([rh_fc[0],rh_fc[2],rh_fc[3]]) #if face is a quad, add the missing triangle\n            else :\n                if rh_fc[2] == rh_fc[3] : faces.append([rh_fc[0],rh_fc[1],rh_fc[2]])\n                else : faces.append([rh_fc[0],rh_fc[1],rh_fc[2],rh_fc[3]])\n            \n        return Mesh(verts,faces)\n\n\ndef from_rgvec(rg_vec):\n    return Vec(rg_vec.X,rg_vec.Y,rg_vec.Z)\n\ndef from_rgpt(rg_pt):\n    return Point(rg_pt.X,rg_pt.Y,rg_pt.Z)\n\ndef from_rgplane(rh_plane):\n        cpt = from_rgpt(rh_plane.Origin)\n        x_axis = from_rgvec(rh_plane.XAxis)\n        y_axis = from_rgvec(rh_plane.YAxis)\n        return CS(cpt,x_axis,y_axis)\n\ndef from_rgpolyline(gh_polyline):\n    if gh_polyline.IsClosed : \n        gh_curve = gh_polyline.ToNurbsCurve()\n        isplanar, plane = gh_curve.TryGetPlane()\n        if isplanar : \n            cs = from_rgplane(plane)\n            w_verts = [from_rgpt(gh_polyline[i]) for i in range(len(gh_polyline))]\n            verts = [ Vec(pt*cs.ixform) for pt in w_verts ]\n            if (verts[0]==verts[-1]) : del verts[-1] #remove last vert if a duplicate\n            return PGon(verts,cs)\n        else:\n            warnings.warn(\"Cannot import non-planar closed polyline as PGon, attempting to import as a PLine\")\n        \n    # if we've gotten this far, then the pline isn't closed, or is closed and non-planar\n    gh_curve = gh_polyline.ToNurbsCurve()\n    w_verts = [from_rgpt(gh_polyline[i]) for i in range(len(gh_polyline))]\n    return PLine(w_verts)\n    \n\ndef from_rgtransform(rh_xf):\n    xf = Xform()\n    xf.m00, xf.m01, xf.m02, xf.m03 = rh_xf.M00, rh_xf.M01, rh_xf.M02, rh_xf.M03\n    xf.m10, xf.m11, xf.m12, xf.m13 = rh_xf.M10, rh_xf.M11, rh_xf.M12, rh_xf.M13\n    xf.m20, xf.m21, xf.m22, xf.m23 = rh_xf.M20, rh_xf.M21, rh_xf.M22, rh_xf.M23\n    xf.m30, xf.m31, xf.m32, xf.m33 = rh_xf.M30, rh_xf.M31, rh_xf.M32, rh_xf.M33\n    return xf\n\n",
  "language": "python",
  "imports": [
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}