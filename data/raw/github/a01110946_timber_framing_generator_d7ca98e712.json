{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/scripts/gh_panel_decomposer.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "scripts/gh_panel_decomposer.py",
  "instruction": "Panel Decomposer for Grasshopper.",
  "code": "# File: scripts/gh_panel_decomposer.py\n\"\"\"Panel Decomposer for Grasshopper.\n\nDecomposes framed walls into manufacturable panels with optimized joint placement.\nHandles wall corner geometry adjustments for accurate panel dimensions suitable\nfor offsite construction and prefabrication workflows.\n\nReads ``framing_segments`` from enriched walls_json (output by Junction\nAnalyzer) so that panels are created within junction-adjusted framing bounds\nrather than the raw ``[0, wall_length]`` range. Walls with adjusted segments\nare panelized per-segment; multi-segment walls (e.g., X-crossing splits)\nproduce independent panel runs that are merged into a single result.\n\nKey Features:\n1. Panel Decomposition\n   - Splits walls into panels respecting max length constraints\n   - Optimizes joint locations using dynamic programming\n   - Aligns joints with stud locations for structural support\n\n2. Framing-Segment-Aware Panelization\n   - Reads ``framing_segments`` per wall (list of [u_start, u_end] pairs)\n   - Panels created within segment bounds (extended, trimmed, split)\n   - Multi-segment walls produce one panel run per segment\n   - Openings filtered and shifted to segment-local coords for optimizer\n   - Panel U coords shifted back to wall-absolute space after optimization\n   - Backward compatible: absent framing_segments defaults to full wall\n\n3. Corner Adjustment Calculation\n   - Detects wall corners from endpoint proximity\n   - Calculates extend/recede adjustments for face-to-face dimensions\n   - Applies adjustments to panel geometry output (not Revit walls)\n   - Segment-aware walls skip this step (junctions already handled)\n\n4. Exclusion Zone Handling\n   - Avoids joints near openings (12\" per GA-216)\n   - Avoids joints near wall corners (24\" default)\n   - Respects shear panel boundaries\n\nEnvironment:\n    Rhino 8\n    Grasshopper\n    Python component (CPython 3)\n\nDependencies:\n    - Rhino.Geometry: Curve and point creation for visualization\n    - Grasshopper: DataTree for multi-wall output organization\n    - timber_framing_generator.panels: Core panelization logic\n\nPerformance Considerations:\n    - DP algorithm is O(n^2) where n = number of stud positions\n    - Typical walls process in < 100ms\n    - Corner detection is O(w^2) where w = number of walls\n    - Multi-segment walls add one panelization pass per segment\n\nUsage:\n    1. Connect 'walls_json' from Junction Analyzer (enriched with framing_segments)\n       or from Wall Analyzer (backward compatible without segments)\n    2. Optionally connect 'framing_json' from Framing Generator (for stud-aligned joints)\n    3. Configure panel constraints (max_length, joint offsets, etc.)\n    4. Set 'run' to True to execute\n    5. Use 'panels_json' for downstream processing or shop drawings\n\n    Note: In the new pipeline (panelization-before-framing), this component\n    typically receives walls_json directly without framing_json. The stud\n    alignment is calculated from stud_spacing parameter instead.\n\nInput Requirements:\n    walls_json (walls_json) - str:\n        JSON string from Junction Analyzer (enriched with framing_segments)\n        or from Wall Analyzer (backward compatible without segments).\n        Required: Yes\n        Access: Item\n\n    framing_json (framing_json) - str:\n        JSON string from Framing Generator with framing elements\n        Required: No (enhances joint stud detection when available)\n        Access: Item\n\n    max_panel_length (max_length) - float:\n        Maximum panel length in feet\n        Required: No (defaults to 24.0)\n        Access: Item\n\n    min_joint_to_opening (joint_opening) - float:\n        Minimum distance from joint to opening edge in feet\n        Required: No (defaults to 1.0 per GA-216)\n        Access: Item\n\n    min_joint_to_corner (joint_corner) - float:\n        Minimum distance from joint to wall corner in feet\n        Required: No (defaults to 2.0)\n        Access: Item\n\n    stud_spacing (stud_space) - float:\n        Stud spacing in feet for joint alignment\n        Required: No (defaults to 1.333 = 16\" OC)\n        Access: Item\n\n    run (run) - bool:\n        Boolean to trigger execution\n        Required: Yes\n        Access: Item\n\nOutputs:\n    panels_json (panels_json) - str:\n        JSON string containing panel data for all walls\n\n    panel_curves (panel_curves) - DataTree[Curve]:\n        Panel boundary curves for visualization (closed polylines)\n\n    joint_points (joint_points) - DataTree[Point3d]:\n        Joint location points at mid-wall height\n\n    debug_info (debug_info) - str:\n        Debug information and status messages\n\nTechnical Details:\n    - Panel geometry uses adjusted dimensions (not Revit centerlines)\n    - Corner adjustments stored in results but don't modify Revit\n    - Segment-aware walls use junction bounds directly (no extra corner detection)\n    - Multi-segment panel U coords are in wall-absolute space after shift-back\n    - Use gh_wall_corner_adjuster.py to apply changes to Revit walls\n\nError Handling:\n    - Invalid JSON returns empty outputs with error in debug_info\n    - Missing optional inputs use sensible defaults\n    - Missing framing_segments falls back to full wall range\n    - Processing errors logged but don't halt execution\n\nAuthor: Timber Framing Generator\nVersion: 1.1.0\n\"\"\"\n\n# =============================================================================\n# Imports\n# =============================================================================\n\n# Standard library\nimport sys\nimport json\nimport traceback\n\n# .NET / CLR\nimport clr\nclr.AddReference(\"Grasshopper\")\nclr.AddReference(\"RhinoCommon\")\n\n# Rhino / Grasshopper\nimport Rhino.Geometry as rg\nimport Grasshopper\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\n\n# =============================================================================\n# Force Module Reload (CPython 3 in Rhino 8)\n# =============================================================================\n\n_modules_to_clear = [k for k in sys.modules.keys()\n                     if 'timber_framing_generator' in k\n                     or k == 'src']\nfor mod in _modules_to_clear:\n    del sys.modules[mod]\n\n# =============================================================================\n# Project Setup\n# =============================================================================\n\n# Primary: worktree / feature-branch path\n# Fallback: main repo path (for modules not yet in the worktree)\n_WORKTREE_PATH = r\"C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\tfg-sheathing-junctions\"\n_MAIN_REPO_PATH = r\"C:\\Users\\Fernando Maytorena\\OneDrive\\Documentos\\GitHub\\timber_framing_generator\"\n\nfor _p in (_WORKTREE_PATH, _MAIN_REPO_PATH):\n    while _p in sys.path:\n        sys.path.remove(_p)\nsys.path.insert(0, _MAIN_REPO_PATH)\nsys.path.insert(0, _WORKTREE_PATH)\n\nfrom src.timber_framing_generator.panels import (\n    PanelConfig,\n    decompose_all_walls,\n    decompose_wall_to_panels,\n)\nfrom src.timber_framing_generator.utils.geometry_factory import get_factory\n\n# =============================================================================\n# Constants\n# =============================================================================\n\nCOMPONENT_NAME = \"Panel Decomposer\"\nCOMPONENT_NICKNAME = \"PanelDecomp\"\nCOMPONENT_MESSAGE = \"v1.1\"\nCOMPONENT_CATEGORY = \"Timber Framing\"\nCOMPONENT_SUBCATEGORY = \"Panels\"\n\n# =============================================================================\n# Logging Utilities\n# =============================================================================\n\ndef log_message(message, level=\"info\"):\n    \"\"\"Log to console and optionally add GH runtime message.\n\n    Args:\n        message: The message to log\n        level: One of \"info\", \"debug\", \"warning\", \"error\", \"remark\"\n    \"\"\"\n    print(f\"[{level.upper()}] {message}\")\n\n    if level == \"warning\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Warning, message)\n    elif level == \"error\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Error, message)\n    elif level == \"remark\":\n        ghenv.Component.AddRuntimeMessage(\n            Grasshopper.Kernel.GH_RuntimeMessageLevel.Remark, message)\n\n\ndef log_debug(message):\n    \"\"\"Log debug message (console only).\"\"\"\n    print(f\"[DEBUG] {message}\")\n\n\ndef log_info(message):\n    \"\"\"Log info message (console only).\"\"\"\n    print(f\"[INFO] {message}\")\n\n\ndef log_warning(message):\n    \"\"\"Log warning message (console + GH UI).\"\"\"\n    log_message(message, \"warning\")\n\n\ndef log_error(message):\n    \"\"\"Log error message (console + GH UI).\"\"\"\n    log_message(message, \"error\")\n\n# =============================================================================\n# Component Setup\n# =============================================================================\n\ndef setup_component():\n    \"\"\"Initialize and configure the Grasshopper component.\n\n    This function handles:\n    1. Setting component metadata (name, category, etc.)\n    2. Configuring input parameter names, descriptions, and access\n    3. Configuring output parameter names and descriptions\n\n    Note: Output[0] is reserved for GH's internal 'out' - start from Output[1]\n\n    IMPORTANT: Type Hints cannot be set programmatically in Rhino 8.\n    They must be configured via UI: Right-click input → Type hint → Select type\n    \"\"\"\n    ghenv.Component.Name = COMPONENT_NAME\n    ghenv.Component.NickName = COMPONENT_NICKNAME\n    ghenv.Component.Message = COMPONENT_MESSAGE\n    ghenv.Component.Category = COMPONENT_CATEGORY\n    ghenv.Component.SubCategory = COMPONENT_SUBCATEGORY\n\n    # Configure inputs\n    # NOTE: Type Hints must be set via GH UI (right-click → Type hint)\n    inputs = ghenv.Component.Params.Input\n    input_config = [\n        (\"Walls JSON\", \"walls_json\", \"JSON string from Wall Analyzer\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Framing JSON\", \"framing_json\", \"JSON string from Framing Generator (optional, for stud alignment)\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Max Panel Length\", \"max_length\", \"Maximum panel length in feet (default 24.0)\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Joint to Opening\", \"joint_opening\", \"Min distance from joint to opening in feet (default 1.0)\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Joint to Corner\", \"joint_corner\", \"Min distance from joint to corner in feet (default 2.0)\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Stud Spacing\", \"stud_space\", \"Stud spacing in feet (default 1.333 = 16\\\" OC)\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n        (\"Run\", \"run\", \"Boolean to trigger execution\",\n         Grasshopper.Kernel.GH_ParamAccess.item),\n    ]\n\n    for i, (name, nick, desc, access) in enumerate(input_config):\n        if i < inputs.Count:\n            inputs[i].Name = name\n            inputs[i].NickName = nick\n            inputs[i].Description = desc\n            inputs[i].Access = access\n\n    # Configure outputs (start from index 1, as 0 is reserved for 'out')\n    outputs = ghenv.Component.Params.Output\n    output_config = [\n        (\"Panels JSON\", \"panels_json\", \"JSON string containing panel data\"),\n        (\"Panel Curves\", \"panel_curves\", \"Panel boundary curves for visualization\"),\n        (\"Joint Points\", \"joint_points\", \"Joint location points\"),\n        (\"Debug Info\", \"debug_info\", \"Debug information and status\"),\n    ]\n\n    for i, (name, nick, desc) in enumerate(output_config):\n        idx = i + 1\n        if idx < outputs.Count:\n            outputs[idx].Name = name\n            outputs[idx].NickName = nick\n            outputs[idx].Description = desc\n\n# =============================================================================\n# Helper Functions\n# =============================================================================\n\ndef validate_inputs(walls_json, run):\n    \"\"\"Validate component inputs.\n\n    Args:\n        walls_json: JSON string with wall data\n        run: Boolean trigger\n\n    Returns:\n        tuple: (is_valid, error_message)\n    \"\"\"\n    if not run:\n        return False, \"Component not running. Set 'run' to True.\"\n\n    if not walls_json:\n        return False, \"No walls_json input provided\"\n\n    try:\n        json.loads(walls_json)\n    except json.JSONDecodeError as e:\n        return False, f\"Invalid JSON in walls_json: {e}\"\n\n    return True, None\n\n\ndef parse_walls_json(walls_json):\n    \"\"\"Parse walls JSON to list of wall dictionaries.\n\n    Args:\n        walls_json: JSON string\n\n    Returns:\n        List of wall dictionaries\n    \"\"\"\n    data = json.loads(walls_json)\n    return data if isinstance(data, list) else [data]\n\n\ndef parse_framing_json(framing_json):\n    \"\"\"Parse framing JSON to list of framing element dictionaries.\n\n    Args:\n        framing_json: JSON string or None\n\n    Returns:\n        List of framing dictionaries or None\n    \"\"\"\n    if not framing_json:\n        return None\n    data = json.loads(framing_json)\n    return data if isinstance(data, list) else [data]\n\n\ndef create_panel_boundary_curve(corners):\n    \"\"\"Create boundary curve from panel corners.\n\n    Args:\n        corners: Dictionary with bottom_left, bottom_right, top_right, top_left\n\n    Returns:\n        Closed polyline curve or None on failure\n    \"\"\"\n    try:\n        factory = get_factory()\n        bl, br, tr, tl = corners[\"bottom_left\"], corners[\"bottom_right\"], corners[\"top_right\"], corners[\"top_left\"]\n\n        points = [\n            factory.create_point3d(bl[\"x\"], bl[\"y\"], bl[\"z\"]),\n            factory.create_point3d(br[\"x\"], br[\"y\"], br[\"z\"]),\n            factory.create_point3d(tr[\"x\"], tr[\"y\"], tr[\"z\"]),\n            factory.create_point3d(tl[\"x\"], tl[\"y\"], tl[\"z\"]),\n            factory.create_point3d(bl[\"x\"], bl[\"y\"], bl[\"z\"]),  # Close loop\n        ]\n        return factory.create_polyline_curve(points)\n    except Exception as e:\n        log_debug(f\"Error creating panel curve: {e}\")\n        return None\n\n\ndef create_joint_point(u_coord, wall_data):\n    \"\"\"Create point at joint location.\n\n    Args:\n        u_coord: U coordinate of joint\n        wall_data: Wall data dictionary\n\n    Returns:\n        Point3d at joint location or None on failure\n    \"\"\"\n    try:\n        factory = get_factory()\n        base_plane = wall_data.get(\"base_plane\", {})\n        origin = base_plane.get(\"origin\", {})\n        x_axis = base_plane.get(\"x_axis\", {})\n        height = wall_data.get(\"wall_height\", wall_data.get(\"height\", 8.0))\n        base_elev = wall_data.get(\"base_elevation\", 0.0)\n\n        ox, oy = origin.get(\"x\", 0), origin.get(\"y\", 0)\n        xx, xy = x_axis.get(\"x\", 1), x_axis.get(\"y\", 0)\n\n        return factory.create_point3d(\n            ox + u_coord * xx,\n            oy + u_coord * xy,\n            base_elev + height / 2\n        )\n    except Exception as e:\n        log_debug(f\"Error creating joint point: {e}\")\n        return None\n\n\ndef _has_adjusted_segments(wall_data):\n    \"\"\"Check if a wall has non-default framing segments.\n\n    Returns True when ``framing_segments`` is present and differs from\n    the default ``[[0, wall_length]]``.\n    \"\"\"\n    segments = wall_data.get(\"framing_segments\")\n    if not segments:\n        return False\n    wall_length = wall_data.get(\"wall_length\", 0)\n    if len(segments) == 1:\n        seg = segments[0]\n        if abs(seg[0]) < 1e-6 and abs(seg[1] - wall_length) < 1e-6:\n            return False\n    return True\n\n\ndef _panelize_segment(wall_data, seg_start, seg_end, seg_idx, config):\n    \"\"\"Panelize a single framing segment of a wall.\n\n    Creates a working copy of *wall_data* with ``wall_length`` set to\n    the segment length and openings shifted into segment-local coords.\n    Calls ``decompose_wall_to_panels()`` in ``[0, seg_length]`` space,\n    then shifts resulting panel U coords back to wall-absolute coords.\n\n    Corner adjustments are skipped because the junction system has\n    already computed the correct segment bounds.\n\n    Args:\n        wall_data: Original wall dict (not mutated).\n        seg_start: Segment start U in wall-absolute feet.\n        seg_end: Segment end U in wall-absolute feet.\n        seg_idx: Segment index (for panel IDs).\n        config: PanelConfig instance.\n\n    Returns:\n        PanelResults dict with U coords in wall-absolute space.\n    \"\"\"\n    seg_length = seg_end - seg_start\n    wall_id = wall_data.get(\"wall_id\", \"unknown\")\n\n    # Build segment-local wall data\n    working = dict(wall_data)\n    working[\"wall_length\"] = seg_length\n\n    # Prefix wall_id for multi-segment to get unique panel IDs\n    if seg_idx is not None:\n        working[\"wall_id\"] = f\"{wall_id}_seg{seg_idx}\"\n\n    # Filter and shift openings into segment-local coords\n    local_openings = []\n    for o in wall_data.get(\"openings\", []):\n        o_start = o.get(\"u_start\", 0)\n        o_end = o.get(\"u_end\", 0)\n        # Opening must overlap segment\n        if o_end > seg_start and o_start < seg_end:\n            shifted = dict(o)\n            shifted[\"u_start\"] = max(o_start - seg_start, 0)\n            shifted[\"u_end\"] = min(o_end - seg_start, seg_length)\n            local_openings.append(shifted)\n    working[\"openings\"] = local_openings\n\n    # Panelize in [0, seg_length] space (no extra corner_adjustments)\n    result = decompose_wall_to_panels(working, None, config)\n\n    # Shift U coords back to wall-absolute space\n    for panel in result.get(\"panels\", []):\n        panel[\"u_start\"] += seg_start\n        panel[\"u_end\"] += seg_start\n        # Shift corner geometry\n        corners = panel.get(\"corners\", {})\n        _shift_corners_u(corners, seg_start, wall_data)\n\n    for joint in result.get(\"joints\", []):\n        joint[\"u_coord\"] += seg_start\n\n    # Restore original wall_id in result\n    result[\"wall_id\"] = wall_id\n\n    return result\n\n\ndef _shift_corners_u(corners, u_offset, wall_data):\n    \"\"\"Shift panel corner positions by a U offset along the wall X axis.\n\n    Recalculates corner XY from the wall's base_plane to ensure correct\n    world coordinates after the segment-local → absolute shift.\n\n    Args:\n        corners: Panel corners dict (bottom_left, bottom_right, etc.).\n            **Modified in place.**\n        u_offset: U offset to add (feet).\n        wall_data: Original wall data with base_plane for direction.\n    \"\"\"\n    base_plane = wall_data.get(\"base_plane\", {})\n    x_axis = base_plane.get(\"x_axis\", {\"x\": 1, \"y\": 0, \"z\": 0})\n    dx = x_axis.get(\"x\", 1) * u_offset\n    dy = x_axis.get(\"y\", 0) * u_offset\n\n    for key in (\"bottom_left\", \"bottom_right\", \"top_right\", \"top_left\"):\n        pt = corners.get(key, {})\n        if isinstance(pt, dict):\n            pt[\"x\"] = pt.get(\"x\", 0) + dx\n            pt[\"y\"] = pt.get(\"y\", 0) + dy\n\n\ndef process_panelization(walls_data, framing_data, config):\n    \"\"\"Process walls through panelization pipeline.\n\n    Reads ``framing_segments`` per wall (injected by Junction Analyzer).\n    Walls with adjusted segments are panelized per-segment; walls without\n    segments (or with default ``[[0, wall_length]]``) go through the\n    standard ``decompose_all_walls()`` path.\n\n    Args:\n        walls_data: List of wall dictionaries\n        framing_data: List of framing dictionaries or None (from Framing Generator)\n        config: PanelConfig instance\n\n    Returns:\n        tuple: (all_results, panel_curves_tree, joint_points_tree, info_lines)\n    \"\"\"\n    log_info(f\"Processing {len(walls_data)} walls\")\n\n    # Separate walls into segment-aware and default groups\n    default_walls = []\n    default_indices = []\n    segment_walls = []\n    segment_indices = []\n\n    for idx, wd in enumerate(walls_data):\n        if _has_adjusted_segments(wd):\n            segment_walls.append(wd)\n            segment_indices.append(idx)\n        else:\n            default_walls.append(wd)\n            default_indices.append(idx)\n\n    # Process default walls through standard pipeline (with corner detection)\n    default_framing = None\n    if framing_data and default_walls:\n        default_framing = [\n            framing_data[i] if i < len(framing_data) else None\n            for i in default_indices\n        ]\n    default_results = (\n        decompose_all_walls(default_walls, default_framing, config)\n        if default_walls else []\n    )\n\n    # Process segment-aware walls per-segment\n    segment_results = []\n    for wd in segment_walls:\n        segments = wd.get(\"framing_segments\", [])\n        wall_id = wd.get(\"wall_id\", \"unknown\")\n        wall_seg_results = []\n\n        for si, (seg_s, seg_e) in enumerate(segments):\n            seg_idx = si if len(segments) > 1 else None\n            result = _panelize_segment(wd, seg_s, seg_e, seg_idx, config)\n            wall_seg_results.append(result)\n\n        if len(wall_seg_results) == 1:\n            segment_results.append(wall_seg_results[0])\n        else:\n            # Merge multi-segment results into one entry per wall\n            merged_panels = []\n            merged_joints = []\n            for r in wall_seg_results:\n                merged_panels.extend(r.get(\"panels\", []))\n                merged_joints.extend(r.get(\"joints\", []))\n            segment_results.append({\n                \"wall_id\": wall_id,\n                \"panels\": merged_panels,\n                \"joints\": merged_joints,\n                \"corner_adjustments\": [],\n                \"total_panel_count\": len(merged_panels),\n                \"original_wall_length\": wd.get(\"wall_length\", 0),\n                \"adjusted_wall_length\": sum(s[1] - s[0] for s in segments),\n                \"metadata\": {\"framing_segments\": segments},\n            })\n\n    # Rebuild results in original wall order\n    all_results = [None] * len(walls_data)\n    for i, idx in enumerate(default_indices):\n        all_results[idx] = default_results[i]\n    for i, idx in enumerate(segment_indices):\n        all_results[idx] = segment_results[i]\n\n    # Build visualization trees\n    panel_curves = DataTree[object]()\n    joint_points = DataTree[object]()\n    info_lines = []\n    total_panels = 0\n    total_joints = 0\n\n    for wall_idx, result in enumerate(all_results):\n        wall_id = result[\"wall_id\"]\n        panels = result[\"panels\"]\n        joints = result[\"joints\"]\n        wall_data = walls_data[wall_idx] if wall_idx < len(walls_data) else {}\n\n        seg_tag = \"\"\n        if wall_idx in segment_indices:\n            n_segs = len(walls_data[wall_idx].get(\"framing_segments\", []))\n            seg_tag = f\" ({n_segs} segment{'s' if n_segs > 1 else ''})\"\n\n        info_lines.append(\n            f\"Wall {wall_id}{seg_tag}: {len(panels)} panels, {len(joints)} joints\"\n        )\n\n        for panel_idx, panel in enumerate(panels):\n            curve = create_panel_boundary_curve(panel[\"corners\"])\n            if curve:\n                panel_curves.Add(curve, GH_Path(wall_idx, panel_idx))\n\n        for joint_idx, joint in enumerate(joints):\n            point = create_joint_point(joint[\"u_coord\"], wall_data)\n            if point:\n                joint_points.Add(point, GH_Path(wall_idx, joint_idx))\n\n        total_panels += len(panels)\n        total_joints += len(joints)\n\n    info_lines.append(f\"Total: {total_panels} panels, {total_joints} joints\")\n    log_info(f\"Completed: {total_panels} panels, {total_joints} joints\")\n\n    return all_results, panel_curves, joint_points, info_lines\n\n# =============================================================================\n# Main Function\n# =============================================================================\n\ndef main(walls_json_in, framing_json_in, max_length_in, joint_opening_in,\n         joint_corner_in, stud_space_in, run_in):\n    \"\"\"Main entry point for the component.\n\n    Args:\n        walls_json_in: JSON string with wall data.\n        framing_json_in: JSON string with framing data (optional).\n        max_length_in: Max panel length in feet (optional).\n        joint_opening_in: Min joint-to-opening distance (optional).\n        joint_corner_in: Min joint-to-corner distance (optional).\n        stud_space_in: Stud spacing in feet (optional).\n        run_in: Boolean trigger.\n\n    Returns:\n        tuple: (panels_json, panel_curves, joint_points, debug_info)\n            - panels_json: JSON string with panel data for all walls.\n            - panel_curves: DataTree of panel boundary curves.\n            - joint_points: DataTree of joint location points.\n            - debug_info: Debug information string.\n    \"\"\"\n    setup_component()\n\n    # Initialize outputs\n    panels_json = \"\"\n    panel_curves = DataTree[object]()\n    joint_points = DataTree[object]()\n    debug_lines = []\n\n    try:\n        # Validate inputs\n        is_valid, error_msg = validate_inputs(walls_json_in, run_in)\n        if not is_valid:\n            if error_msg and \"not running\" not in error_msg.lower():\n                log_warning(error_msg)\n            debug_lines.append(error_msg)\n            return panels_json, panel_curves, joint_points, \"\\n\".join(debug_lines)\n\n        # Parse inputs\n        walls_data = parse_walls_json(walls_json_in)\n        framing_data = parse_framing_json(framing_json_in) if framing_json_in else None\n        debug_lines.append(f\"Parsed {len(walls_data)} walls\")\n\n        # Build configuration\n        config = PanelConfig(\n            max_panel_length=max_length_in if max_length_in else 24.0,\n            min_joint_to_opening=joint_opening_in if joint_opening_in else 1.0,\n            min_joint_to_corner=joint_corner_in if joint_corner_in else 2.0,\n            stud_spacing=stud_space_in if stud_space_in else 1.333,\n        )\n        debug_lines.append(f\"Config: max={config.max_panel_length}ft, stud={config.stud_spacing}ft\")\n\n        # Process panelization\n        all_results, panel_curves, joint_points, info_lines = process_panelization(\n            walls_data, framing_data, config\n        )\n        debug_lines.extend(info_lines)\n\n        # Serialize results\n        panels_json = json.dumps(all_results, indent=2)\n\n    except Exception as e:\n        log_error(f\"Unexpected error: {str(e)}\")\n        debug_lines.append(f\"ERROR: {str(e)}\")\n        debug_lines.append(traceback.format_exc())\n\n    return panels_json, panel_curves, joint_points, \"\\n\".join(debug_lines)\n\n# =============================================================================\n# Execution\n# =============================================================================\n\n# Set default values for optional inputs\ntry:\n    walls_json\nexcept NameError:\n    walls_json = None\n\ntry:\n    framing_json\nexcept NameError:\n    framing_json = None\n\ntry:\n    max_length\nexcept NameError:\n    max_length = None\n\ntry:\n    joint_opening\nexcept NameError:\n    joint_opening = None\n\ntry:\n    joint_corner\nexcept NameError:\n    joint_corner = None\n\ntry:\n    stud_space\nexcept NameError:\n    stud_space = None\n\ntry:\n    run\nexcept NameError:\n    run = False\n\n# Execute main — pass inputs explicitly to avoid CPython 3 exec() scope issues\nif __name__ == \"__main__\":\n    panels_json, panel_curves, joint_points, debug_info = main(\n        walls_json, framing_json, max_length, joint_opening,\n        joint_corner, stud_space, run\n    )\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon"
  ],
  "has_docstring": true
}