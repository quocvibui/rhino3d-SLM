{
  "source_url": "https://github.com/969flash/EDDM_slope_analysis/blob/fca2d00ca0837fcd3005a465fb4aae506194b373/main.py",
  "repo": "969flash/EDDM_slope_analysis",
  "repo_stars": 0,
  "repo_description": "analysis road slope percentege based on Korea SHP file",
  "license": "unknown",
  "filepath": "main.py",
  "instruction": null,
  "code": "# -*- coding:utf-8 -*-\ntry:\n    from typing import List, Tuple, Dict, Any, Optional\nexcept ImportError:\n    pass\n\nimport math\n\nimport scriptcontext as sc\nimport Rhino  # type: ignore\nimport Rhino.Geometry as geo  # type: ignore\nimport ghpythonlib.components as ghcomp\n\nimport time\n\nBIGNUM = 1000000\nOP_TOL = 0.0001\n\n\ndef is_pt_inside(region, pt, plane=geo.Plane.WorldXY, tol=OP_TOL):\n    # type: (geo.Curve, geo.Point3d, geo.Plane, float) -> int\n    # clipper 보다 10배 빠름\n    containment = region.Contains(pt, plane, tol)\n\n    return containment == geo.PointContainment.Inside\n\n\nclass Road:\n\n    def __init__(self, centerline):\n        # type: (geo.Curve) -> None\n        self.center_crv = centerline\n        self.mid_pt = centerline.PointAtNormalizedLength(0.5)\n        self.st_pt = centerline.PointAtStart\n        self.en_pt = centerline.PointAtEnd\n\n        self.length = round(centerline.GetLength(), 2)\n\n        self.st_pt_on_topo = None  # type: geo.Point3d\n        self.st_pt_on_topo = None  # type: geo.Point3d\n        self.height = None  # type: float\n        self.road_region = None  # type: geo.Curve\n\n    def set_height(self, topo):\n        # type: (geo.Mesh) -> bool\n\n        def get_projected_pt_on_mesh(pt, mesh):\n            # type: (geo.Point3d, geo.Mesh) -> geo.Point3d | None\n            # Z축 방향 레이 생성\n            ray = geo.Ray3d(pt, geo.Vector3d(0, 0, -1))  # Z축 아래 방향\n            t = geo.Intersect.Intersection.MeshRay(mesh, ray)\n\n            if t >= 0:\n                # 레이의 t 값으로 교차점 계산\n                return ray.PointAt(t)\n\n            ray = geo.Ray3d(pt, geo.Vector3d(0, 0, 1))  # Z축 윗 방향\n            t = geo.Intersect.Intersection.MeshRay(mesh, ray)\n\n            if t >= 0:\n                # 레이의 t 값으로 교차점 계산\n                return ray.PointAt(t)\n\n            return None  # 교차가 없을 경우 None 반환\n\n        self.st_pt_on_topo = get_projected_pt_on_mesh(self.st_pt, topo)\n        self.en_pt_on_topo = get_projected_pt_on_mesh(self.en_pt, topo)\n\n        # 도로의 끝점이 토포그래피를 벗어나는등의 이유로 높이 설정이 실패하는 경우\n        if not (self.st_pt_on_topo and self.en_pt_on_topo):\n            return False\n\n        self.height = abs(self.st_pt_on_topo.Z - self.en_pt_on_topo.Z)\n        return True\n\n    @property\n    def slope_percentage(self):\n        # type: () -> float\n        if self.height is None:\n            raise Exception(\"NO HEIGHT\")\n\n        return self.height / self.length\n\n    def is_steep(self, steep_percentage):\n        # type: (float) -> bool\n\n        return self.slope_percentage > steep_percentage\n\n\nstime = time.time()\n\n# input :  topo(geo.Mesh), road_centerlines(List[geo.Curve]), road_regions(List[geo.Curve]), steep_percentage(float)\n\nroads = [Road(centerline) for centerline in road_centerlines]\n\nsteep_roads = []\nfor road in roads:\n\n    # road의 height 설정\n    is_height_available = road.set_height(topo)\n    if not is_height_available:\n        continue\n\n    # 가파른 도로 처리\n    if not road.is_steep(steep_percentage):\n        continue\n\n    # road와 매칭될 region 설정\n    matched_region = None\n    for region in road_regions:\n        if is_pt_inside(region, road.mid_pt):\n            matched_region = region\n            road.road_region = matched_region\n            road_regions = [\n                region for region in road_regions if region is not matched_region\n            ]\n            break\n\n    steep_roads.append(road.road_region)\n\noutput = (\n    \"Total Roads = \"\n    + str(len(roads))\n    + \"\\n\"\n    + \"Steep Roads = \"\n    + str(len(steep_roads))\n    + \"\\n\"\n    + str(round(len(steep_roads) / len(roads) * 100, 2))\n    + \"% of road is steep\"\n    + \"\\n\"\n)\n\netime = time.time()\n\nprint(\"TIME\", etime - stime)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib",
    "scriptcontext"
  ],
  "has_docstring": false
}