{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Brep_createDivsBetween2CrvsForSurfacing.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Brep_createDivsBetween2CrvsForSurfacing.py",
  "instruction": "Spb brep create divs between2crvs for surfacing",
  "code": "\"\"\"\r\n\"\"\"\r\n\r\n\"\"\"\r\n200402-04: Created, starting with other scripts.\r\n200517: Further development.\r\n220328: Import-related update.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nfrom clr import StrongBox\r\nfrom System import Array\r\nfrom System import Enum\r\nfrom System import Guid\r\n\r\n\r\nclass Opts():\r\n    \r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    riAddOpts = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    def addOptionDouble(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionDouble(\r\n            getObj, englishName=names[key], numberValue=riOpts[key])\r\n\r\n\r\n    def addOptionInteger(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionInteger(\r\n            getObj, englishName=names[key], intValue=riOpts[key])\r\n\r\n\r\n    def addOptionList(key, names, listValues, values):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionList(\r\n            getObj,\r\n            englishOptionName=names[key],\r\n            listValues=listValues,\r\n            listCurrentIndex=values[key])\r\n\r\n\r\n    def addOptionToggle(key, names, riOpts):\r\n        return lambda getObj: ri.Custom.GetBaseClass.AddOptionToggle(\r\n            getObj, englishName=names[key], toggleValue=riOpts[key])\r\n\r\n\r\n    key = 'fDivisionLength'; keys.append(key)\r\n    values[key] = 1000.0 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n    \r\n    key = 'bAtGrevilles'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bAtEqualDivisions'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'iDivisionCt'; keys.append(key)\r\n    values[key] = 2\r\n    riOpts[key] = ri.Custom.OptionInteger(\r\n            initialValue=values[key],\r\n            setLowerLimit=True,\r\n            limit=2)\r\n    riAddOpts[key] = addOptionInteger(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bSplitPolyCrvToSegs'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bSplitPathsAtKnots'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bAddCrvs'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    riAddOpts[key] = addOptionToggle(key, names, riOpts)\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def setValues(cls):\r\n        for key in cls.keys:\r\n            if key in cls.riOpts:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n\r\n\r\n    @classmethod\r\n    def saveSticky(cls):\r\n        for key in cls.stickyKeys:\r\n            if key in cls.riOpts:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.riOpts[key].CurrentValue\r\n            else:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef prepareCurves(rgCs_In, bSplitPolyCrvToSegs=True, bSplitPathsAtKnots=False):\r\n    \"\"\"\r\n    Prepare curves, including splitting per options.\r\n\r\n    Returns: list of new curves\r\n    \"\"\"\r\n    \r\n    rc = rg.Curve.JoinCurves(\r\n            rgCs_In,\r\n            joinTolerance=sc.doc.ModelAbsoluteTolerance)\r\n    if not rc: return\r\n    rgCrvs_Joined = rc\r\n\r\n    rgCrvs_Final = []\r\n    for rgCrv_Joined in rgCrvs_Joined:\r\n        if isinstance(rgCrv_Joined, rg.PolyCurve):\r\n            rgCrv_Joined.RemoveNesting()\r\n\r\n        if not bSplitPolyCrvToSegs:\r\n            rgCrvs_SplitPoly = [rgCrv_Joined.Duplicate()]\r\n        else:\r\n            # bSplitPolyCrvToSegs == True.\r\n            if isinstance(rgCrv_Joined, rg.PolyCurve):\r\n                rc = rgCrv_Joined.Explode()\r\n                if rc:\r\n                    rgCrvs_Exploded = rc\r\n                    rgCrvs_SplitPoly = rc\r\n            else:\r\n                # not PolyCurve.\r\n                rgCrvs_SplitPoly = [rgCrv_Joined.Duplicate()]\r\n\r\n        if not bSplitPathsAtKnots:\r\n            rgCrvs_Final.extend(rgCrvs_SplitPoly)\r\n        else:\r\n            for rgCrv_SplitPoly in rgCrvs_SplitPoly:\r\n                ts_SpanBoundaries = [rgCrv_SplitPoly.Domain.T0]\r\n                for iSpan in xrange(rgCrv_SplitPoly.SpanCount):\r\n                    ts_SpanBoundaries.append(rgCrv_SplitPoly.SpanDomain(iSpan).T1)\r\n                rc = rgCrv_SplitPoly.Split(ts_SpanBoundaries)\r\n                if rc:\r\n                    rgCrvs_SplitAtKnots = rc\r\n                    rgCrvs_Final.extend(rgCrvs_SplitAtKnots)\r\n\r\n                rgCrv_SplitPoly.Dispose()\r\n    \r\n    return rgCrvs_Final\r\n\r\n\r\ndef getParameters(nc, fDivisionLength=None):\r\n\r\n\r\n    ts = []\r\n\r\n    if fDivisionLength is None:\r\n        fDivisionLength = 1000.0*sc.doc.ModelAbsoluteTolerance\r\n\r\n    rc = nc.DivideByLength(\r\n        segmentLength=fDivisionLength,\r\n        includeEnds=True)\r\n    if rc: ts.extend(rc)\r\n    if not nc.IsClosed:\r\n        # DivideByLength doesn't add the T1 segment\r\n        # even though includeEnds == True.\r\n        # https://developer.rhino3d.com/api/RhinoCommon/html/M_Rhino_Geometry_Curve_DivideByLength.htm\r\n        # shows the parameter labeled as 'includeStart'.\r\n        ts.append(nc.Domain.T1)\r\n\r\n        lastDivLength = nc.GetLength(subdomain=rg.Interval(ts[-2], ts[-1]))\r\n        if lastDivLength < 0.5 * fDivisionLength:\r\n            del ts[-2]\r\n\r\n    if ts is None:\r\n        print \"No parameters were obtained.\"\r\n        return\r\n\r\n    ts = sorted(set(ts)) # Remove duplicates and sort.\r\n\r\n    # Remove overlaps for closed (including periodic) curves.\r\n    if nc.IsClosed:\r\n        ts_WIP = []\r\n        for t in ts:\r\n            if t >= nc.Domain.T0 and t < nc.Domain.T1:\r\n                ts_WIP.append(t)\r\n        ts = ts_WIP\r\n\r\n    return ts\r\n\r\n\r\ndef getPointPairsBetweenCrvs_ClosestPts(rgCrvA, rgCrvB, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    def getPoints(nc_From, nc_To):\r\n\r\n        pts_From = []\r\n        ts_From = []\r\n        pts_To = []\r\n        ts_To = []\r\n\r\n        ts_Grevilles = nc_From.GrevilleParameters()\r\n        pts_Grevilles = nc_From.GrevillePoints()\r\n\r\n        ts_Knots = set([nc_From.Knots[i] for i in range(nc_From.Knots.Count)])\r\n        pts_Knots = [nc_From.PointAt(t) for t in ts_Knots]\r\n\r\n        ts_From_IntvEnds = list(set(list(ts_Grevilles) + list(ts_Knots)))\r\n\r\n        ts_From_IntvEnds.sort()\r\n\r\n        for i in range(1, len(ts_From_IntvEnds)):\r\n            interval = rg.Interval(ts_From_IntvEnds[i-1], ts_From_IntvEnds[i])\r\n\r\n            subC_From = nc_From.Trim(interval)\r\n\r\n            rc = subC_From.ClosestPoints(nc_To)\r\n            if not rc[0]: continue\r\n\r\n            pt_From = rc[1]\r\n            b, t_From = nc_From.ClosestPoint(pt_From)\r\n            if not b: continue\r\n\r\n            # Do not accept points at each interval's T0 and T1.\r\n            # TODO: Is this always correct to do?\r\n            for pt_From_IntvEnd in list(pts_Grevilles) + pts_Knots:\r\n                dist = pt_From_IntvEnd.DistanceTo(pt_From)\r\n                if dist <= sc.doc.ModelAbsoluteTolerance:\r\n                    break # to next interval.\r\n\r\n            #for t_From_IntvEnd in ts_From_IntvEnds:\r\n            #    param_dist = abs(t_From_IntvEnd-t_From)\r\n            #    if param_dist <= 1.0/(2.0**32):\r\n            #        break # to next interval.\r\n            else:\r\n                pt_To = rc[2]\r\n                if (\r\n                    pt_To.EpsilonEquals(nc_To.PointAtStart, sc.doc.ModelAbsoluteTolerance) or\r\n                    pt_To.EpsilonEquals(nc_To.PointAtEnd, sc.doc.ModelAbsoluteTolerance)\r\n                ):\r\n                    continue # to next interval.\r\n\r\n                b, t_To = nc_To.ClosestPoint(pt_To)\r\n                if not b: continue\r\n\r\n                pts_From.append(pt_From)\r\n                ts_From.append(t_From)\r\n                pts_To.append(pt_To)\r\n                ts_To.append(t_To)\r\n                #sc.doc.Objects.AddPoint(pt_From)\r\n                #sc.doc.Objects.AddPoint(pt_To)\r\n\r\n        return pts_From, ts_From, pts_To, ts_To\r\n\r\n\r\n    def areEpsilonEqual(a, b, epsilon):\r\n        # This is a relative comparison.\r\n        delta = abs(a - b)\r\n        fRelComp = delta / max(abs(a), abs(b))\r\n        bRhEpsEquals = Rhino.RhinoMath.EpsilonEquals(a, b, epsilon)\r\n        return fRelComp < epsilon\r\n\r\n\r\n    ts_Out_A = []\r\n    ts_Out_B = []\r\n\r\n    nc_A = rgCrvA.ToNurbsCurve()\r\n    nc_B = rgCrvB.ToNurbsCurve()\r\n\r\n\r\n    pts_Out_A, ts_Out_A, pts_Out_B, ts_Out_B = getPoints(nc_A, nc_B)\r\n\r\n    pts_B_2ndRound, ts_B_2ndRound, pts_A_2ndRound, ts_A_2ndRound = getPoints(nc_B, nc_A)\r\n\r\n\r\n    # Add parameters from 2nd round to return data if not redundant.\r\n    pts_A_toAdd = []\r\n    ts_A_toAdd = []\r\n    for i in range(len(pts_A_2ndRound)):\r\n        pt_toCheck = pts_A_2ndRound[i]\r\n        for pt in pts_Out_A:\r\n            if pt.EpsilonEquals(pt_toCheck, sc.doc.ModelAbsoluteTolerance):\r\n                break\r\n        else:\r\n            pts_A_toAdd.append(pt_toCheck)\r\n            ts_A_toAdd.append(ts_A_2ndRound[i])\r\n\r\n    pts_Out_A.extend(pts_A_toAdd) \r\n    ts_Out_A.extend(ts_A_toAdd) \r\n\r\n    pts_B_toAdd = []\r\n    ts_B_toAdd = []\r\n    for i in range(len(pts_B_2ndRound)):\r\n        pt_toCheck = pts_B_2ndRound[i]\r\n        for pt in pts_Out_B:\r\n            if pt.EpsilonEquals(pt_toCheck, sc.doc.ModelAbsoluteTolerance):\r\n                break\r\n        else:\r\n            pts_B_toAdd.append(pt_toCheck)\r\n            ts_B_toAdd.append(ts_B_2ndRound[i])\r\n\r\n    pts_Out_B.extend(pts_B_toAdd) \r\n    ts_Out_B.extend(ts_B_toAdd) \r\n\r\n    return pts_Out_A, ts_Out_A, pts_Out_B, ts_Out_B\r\n\r\n\r\ndef createCrossSectionLines_PerpTo(ncs_A, ncs_B, ts_perA, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    lines_Out_perA = []\r\n    ncs_B_Out_perA = []\r\n\r\n    for iA in range(len(ncs_A)):\r\n        ncA = ncs_A[iA]\r\n        tsA = ts_perA[iA]\r\n        \r\n        lines_Out_perA.append([])\r\n        ncs_B_Out_perA.append([None])\r\n\r\n        t_B_StartForA = None\r\n        nc_B_StartForA = None\r\n        t_B_EndForA = None\r\n        nc_B_EndForA = None\r\n            \r\n        for iT, tA in enumerate(tsA):\r\n\r\n            if tA > 26.1:\r\n                pass\r\n                #bDebug = True\r\n\r\n            pt_A = ncA.PointAt(tA)\r\n\r\n            for iB in range(len(ncs_B)):\r\n                \r\n                nc_B = ncs_B[iB]\r\n\r\n                res, tB_forSeed = nc_B.ClosestPoint(pt_A)\r\n                if not res:\r\n                    raise ValueError(\"ClosestPoint returned {}.\".format(res))\r\n\r\n                bSuccess, tB = nc_B.GetLocalPerpPoint(\r\n                    testPoint=pt_A,\r\n                    seedParmameter=tB_forSeed)\r\n\r\n                if not bSuccess:\r\n                    continue\r\n\r\n                line = rg.Line(ncA.PointAt(tA), to=nc_B.PointAt(tB))\r\n                if bDebug: sc.doc.Objects.AddLine(line)\r\n\r\n                lines_Out_perA[-1].append(line)\r\n\r\n    return lines_Out_perA\r\n\r\n\r\ndef createCrossSectionLines_EqualDivs(rgCrv_DivByLength, rgCrv_DivByCount, fDivisionLength=None, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    lines_Out = []\r\n\r\n    if fDivisionLength is None:\r\n        fDivisionLength = 1000.0*sc.doc.ModelAbsoluteTolerance\r\n\r\n    tAs = getParameters(rgCrv_DivByLength, fDivisionLength=fDivisionLength)\r\n\r\n    strongBox_points = StrongBox[Array[rg.Point3d]]()\r\n\r\n    tBs = rgCrv_DivByCount.DivideByCount(\r\n        segmentCount=len(tAs)-1,\r\n        includeEnds=True,\r\n        points=strongBox_points)\r\n\r\n    pts_B = list(strongBox_points.Value)\r\n\r\n    for iT in range(len(tAs)):\r\n        tA = tAs[iT]\r\n\r\n        pt_A = rgCrv_DivByLength.PointAt(tA)\r\n        pt_B = pts_B[iT]\r\n\r\n        line = rg.Line(pt_A, to=pt_B)\r\n        if bDebug: sc.doc.Objects.AddLine(line)\r\n\r\n        lines_Out.append(line)\r\n\r\n    return lines_Out\r\n\r\n\r\ndef createConnectingCurves(rgCs_A_In, rgCs_B_In, **kwargs):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    def getOpt(key): return kwargs[key] if key in kwargs else Opts.values[key]\r\n\r\n    bSplitPolyCrvToSegs = getOpt('bSplitPolyCrvToSegs')\r\n    bSplitPathsAtKnots = getOpt('bSplitPathsAtKnots')\r\n    fDivisionLength = getOpt('fDivisionLength')\r\n    bAtGrevilles = getOpt('bAtGrevilles')\r\n    iDivisionCt = getOpt('iDivisionCt')\r\n    bEcho = getOpt('bEcho')\r\n    bDebug = getOpt('bDebug')\r\n\r\n\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(\"Preparing path curves ...\")\r\n\r\n    rgCs_A_Prepped = prepareCurves(\r\n        rgCs_A_In,\r\n        bSplitPolyCrvToSegs=bSplitPolyCrvToSegs,\r\n        bSplitPathsAtKnots=bSplitPathsAtKnots)\r\n\r\n    rgCs_B_Prepped = prepareCurves(\r\n        rgCs_B_In,\r\n        bSplitPolyCrvToSegs=bSplitPolyCrvToSegs,\r\n        bSplitPathsAtKnots=bSplitPathsAtKnots)\r\n\r\n\r\n    joinedCrvs_A = rg.Curve.JoinCurves(rgCs_A_Prepped)\r\n    if len(joinedCrvs_A) != 1:\r\n        return\r\n\r\n    joinedCrvs_B = rg.Curve.JoinCurves(rgCs_B_Prepped)\r\n    if len(joinedCrvs_B) != 1:\r\n        return\r\n\r\n    joined_A = joinedCrvs_A[0]\r\n    joined_B = joinedCrvs_B[0]\r\n\r\n    if not rg.Curve.DoDirectionsMatch(joined_A, joined_B):\r\n        joined_B.Reverse()\r\n\r\n    rc = getPointPairsBetweenCrvs_ClosestPts(\r\n        joined_A,\r\n        joined_B,\r\n        bDebug=bDebug)\r\n\r\n    pts_A, ts_A, pts_B, ts_B = rc\r\n\r\n    for pt in pts_A:\r\n        sc.doc.Objects.AddPoint(pt)\r\n\r\n    for pt in pts_B:\r\n        sc.doc.Objects.AddPoint(pt)\r\n\r\n\r\n    if len(ts_A) != len(ts_B):\r\n        raise ValueError(\"Parameter count mismatch: {} and {}\".format(\r\n            len(ts_A), len(ts_B)))\r\n\r\n\r\n    # Split curves at parameters.\r\n    splitCrvs_A = joined_A.Split(ts_A)\r\n    #for c in splitCrvs_A: sc.doc.Objects.AddCurve(c)\r\n\r\n    splitCrvs_B = joined_B.Split(ts_B)\r\n\r\n    lines_Out = []\r\n\r\n    for i in range(len(splitCrvs_A)):\r\n        splitA = splitCrvs_A[i]\r\n        splitB = splitCrvs_B[i]\r\n        \r\n        lengthA = splitA.GetLength()\r\n        lengthB = splitB.GetLength()\r\n\r\n        if lengthA > lengthB:\r\n            # Divide A.  Divisions of B will be less than fDivisionLength.\r\n            crv_DivByLength = splitA\r\n            ts_DivByLength = ts_A\r\n            crv_DivByCount = splitB\r\n            bReverseCrvs = False\r\n        else:\r\n            crv_DivByLength = splitB\r\n            ts_DivByLength = ts_B\r\n            crv_DivByCount = splitA\r\n            bReverseCrvs = True\r\n\r\n        lines = createCrossSectionLines_EqualDivs(\r\n            crv_DivByLength,\r\n            crv_DivByCount,\r\n            fDivisionLength,\r\n            bDebug=bDebug)\r\n\r\n        if bReverseCrvs:\r\n            for line in lines:\r\n               line.Flip()\r\n\r\n        if i == 0:\r\n            lines_Out.append(lines)\r\n        else:\r\n            lines_Out.append(lines[1:])\r\n\r\n    return lines_Out\r\n\r\n\r\nclass DrawLinesConduit(Rhino.Display.DisplayConduit):\r\n\r\n    def __init__(self):\r\n        self.color = sc.doc.Layers.CurrentLayer.Color\r\n        self.lines = None\r\n\r\n    def CalculateBoundingBox(self, calculateBoundingBoxEventArgs):\r\n        if self.lines:\r\n            self.bbox = rg.BoundingBox(points=[line.From for line in self.lines])\r\n            calculateBoundingBoxEventArgs.IncludeBoundingBox(self.bbox)\r\n\r\n    def PreDrawObjects(self, drawEventArgs):\r\n        if self.lines:\r\n            drawEventArgs.Display.DrawLines(\r\n                lines=self.lines,\r\n                color=self.color,\r\n                thickness=1)\r\n\r\n\r\ndef getInput_Options(rgCs_A_In, rgCs_B_In):\r\n    \"\"\"\r\n    Get options.\r\n    \r\n    Returns\r\n        None to cancel.\r\n        False to indicate to create objects with current options.\r\n        True to indicate to regenerate geometry and return to this function.\r\n    \"\"\"\r\n    \r\n    valuesBefore = {}\r\n\r\n    go = ri.Custom.GetOption()\r\n    go.SetCommandPrompt(\"Set options\")\r\n\r\n    go.AcceptNothing(True)\r\n\r\n    rgCrvs_Connecting = createConnectingCurves(\r\n        rgCs_A_In,\r\n        rgCs_B_In,\r\n        fDivisionLength=Opts.values['fDivisionLength'],\r\n        )\r\n\r\n    conduit = DrawLinesConduit()\r\n\r\n    if rgCrvs_Connecting:\r\n        conduit.lines = [line for lines in rgCrvs_Connecting for line in lines]\r\n        conduit.Enabled = True\r\n        sc.doc.Views.Redraw()\r\n\r\n\r\n    idxs_Opts = {}\r\n\r\n    while True:\r\n        sc.escape_test()\r\n\r\n        for key in Opts.keys:\r\n            valuesBefore[key] = Opts.values[key]\r\n\r\n        go.AddOptionDouble(Opts.names['fDivisionLength'], Opts.riOpts['fDivisionLength'])\r\n        go.AddOptionToggle(Opts.names['bAtGrevilles'], Opts.riOpts['bAtGrevilles'])\r\n        #go.AddOptionToggle(Opts.names['bAtEqualDivisions'],\r\n        #                    Opts.riOpts['bAtEqualDivisions'])\r\n        #if Opts.values['bAtEqualDivisions']:\r\n        #    go.AddOptionInteger(Opts.names['iDivisionCt'],\r\n        #                        Opts.riOpts['iDivisionCt'])\r\n        go.AddOptionToggle(Opts.names['bSplitPolyCrvToSegs'], Opts.riOpts['bSplitPolyCrvToSegs'])\r\n        go.AddOptionToggle(Opts.names['bSplitPathsAtKnots'], Opts.riOpts['bSplitPathsAtKnots'])\r\n        go.AddOptionToggle(Opts.names['bAddCrvs'], Opts.riOpts['bAddCrvs'])\r\n        key = 'bEcho'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        key = 'bDebug'; idxs_Opts[key] = Opts.riAddOpts[key](go)\r\n        \r\n        res = go.Get()\r\n\r\n        conduit.Enabled = False\r\n        sc.doc.Views.Redraw()\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n        elif res == ri.GetResult.Nothing:\r\n            # Accept current result.\r\n            return rgCrvs_Connecting\r\n\r\n        Opts.setValues()\r\n        Opts.saveSticky()\r\n\r\n        for key in Opts.keys:\r\n            if valuesBefore[key] != Opts.values[key]:\r\n                rgCrvs_Connecting = createConnectingCurves(\r\n                    rgCs_A_In,\r\n                    rgCs_B_In,\r\n                    fDivisionLength=Opts.values['fDivisionLength'],\r\n                    )\r\n                if rgCrvs_Connecting:\r\n                    conduit.lines = [line for lines in rgCrvs_Connecting for line in lines]\r\n                    conduit.Enabled = True\r\n                    sc.doc.Views.Redraw()\r\n                break\r\n        else:\r\n            for key in Opts.keys:\r\n                print valuesBefore[key], Opts.values[key]\r\n            print \"No options were changed.\"\r\n\r\n\r\ndef main():\r\n\r\n    res, objrefs = ri.RhinoGet.GetMultipleObjects(\r\n        \"Select first set of rail curves\",\r\n        acceptNothing=False,\r\n        filter=rd.ObjectType.Curve)\r\n    if res == Rhino.Commands.Result.Cancel: return\r\n    \r\n    rgCs_A_In = [o.Curve() for o in objrefs]\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    res, objrefs = ri.RhinoGet.GetMultipleObjects(\r\n        \"Select second set of rail curves\",\r\n        acceptNothing=False,\r\n        filter=rd.ObjectType.Curve)\r\n    if res == Rhino.Commands.Result.Cancel: return\r\n\r\n    rgCs_B_In = [o.Curve() for o in objrefs]\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    bAtGrevilles = Opts.values['bAtGrevilles']\r\n    bAtEqualDivisions = Opts.values['bAtEqualDivisions']\r\n    iDivisionCt = Opts.values['iDivisionCt']\r\n    bSplitPolyCrvToSegs = Opts.values['bSplitPolyCrvToSegs']\r\n    bSplitPathsAtKnots = Opts.values['bSplitPathsAtKnots']\r\n    bAddCrvs = Opts.values['bAddCrvs']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n\r\n    rc = getInput_Options(rgCs_A_In, rgCs_B_In)\r\n\r\n    if rc is None:\r\n        # Cancel.\r\n        return\r\n    if not rc:\r\n        # Create objects.\r\n        return\r\n\r\n    for lines in rc:\r\n        for line in lines:\r\n            sc.doc.Objects.AddCurve(rg.LineCurve(line))\r\n\r\n    sc.doc.Views.Redraw()\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "scriptcontext"
  ],
  "has_docstring": false
}