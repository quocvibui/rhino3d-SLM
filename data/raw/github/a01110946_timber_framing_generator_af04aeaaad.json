{
  "source_url": "https://github.com/a01110946/timber_framing_generator/blob/0b689e23c0ee24a9cfbdf280b219f659a54afd43/src/timber_framing_generator/framing_elements/headers.py",
  "repo": "a01110946/timber_framing_generator",
  "repo_stars": 3,
  "repo_description": "A Python tool bridging Revit and Rhino through Rhino.Inside.Revit to automate timber frame design. Processes Revit walls to generate complete framing solutions including studs, plates, headers, and cripples. Features intelligent wall decomposition, opening analysis, and automated documentation generation.",
  "license": "unknown",
  "filepath": "src/timber_framing_generator/framing_elements/headers.py",
  "instruction": "File: timber_framing_generator/framing_elements/headers.py",
  "code": "# File: timber_framing_generator/framing_elements/headers.py\n\nfrom typing import Dict, Any, Tuple, Optional\nimport Rhino.Geometry as rg\nfrom src.timber_framing_generator.utils.safe_rhino import safe_get_length, safe_create_extrusion\nfrom src.timber_framing_generator.config.framing import FRAMING_PARAMS, get_framing_param\nfrom ..utils.logging_config import get_logger\n\n# Initialize logger for this module\nlogger = get_logger(__name__)\n\n\nclass HeaderGenerator:\n    \"\"\"\n    Generates header framing elements above openings.\n\n    Headers span between king studs above an opening, providing structural\n    support and load transfer around the opening. This class handles the\n    positioning, sizing, and geometric creation of header elements.\n    \"\"\"\n\n    def __init__(self, wall_data: Dict[str, Any]):\n        \"\"\"\n        Initialize the header generator with wall data and coordinate system.\n\n        Args:\n            wall_data: Dictionary containing wall information\n            coordinate_system: Optional coordinate system for transformations\n        \"\"\"\n        logger.debug(\"Initializing HeaderGenerator\")\n        logger.debug(f\"Wall data: {wall_data}\")\n        \n        # Store the wall data for use throughout the generation process\n        self.wall_data = wall_data\n\n        # Initialize storage for debug geometry\n        self.debug_geometry = {\"points\": [], \"curves\": [], \"planes\": [], \"profiles\": []}\n        \n        logger.debug(\"HeaderGenerator initialized successfully\")\n\n    def generate_header(\n        self,\n        opening_data: Dict[str, Any],\n        king_stud_positions: Optional[Tuple[float, float]] = None,\n        profile_height: Optional[float] = None,\n        profile_depth: Optional[float] = None,\n    ) -> Optional[rg.Brep]:\n        \"\"\"\n        Generate a header above an opening.\n\n        This method creates a header based on:\n        1. The opening data for positioning and dimensions\n        2. Optional king stud positions for span length\n        3. Profile dimensions for sizing\n\n        Args:\n            opening_data: Dictionary with opening information\n            king_stud_positions: Optional tuple of (left, right) u-coordinates\n                                 If not provided, calculated from opening width\n                                 plus configured offsets\n            profile_height: Optional height (vertical dimension) of header profile.\n                           If not provided, uses FRAMING_PARAMS[\"header_height\"].\n            profile_depth: Optional depth (into wall) of header profile.\n                          If not provided, uses FRAMING_PARAMS[\"header_depth\"].\n\n        Returns:\n            Header geometry as a Rhino Brep\n        \"\"\"\n        try:\n            # Log input parameters\n            logger.info(\"===== HEADER GENERATION DETAILS =====\")\n            logger.debug(f\"Opening data: {opening_data}\")\n            logger.debug(f\"King stud positions: {king_stud_positions}\")\n\n            # Extract opening information\n            opening_u_start = opening_data.get(\"start_u_coordinate\")\n            opening_width = opening_data.get(\"rough_width\")\n            opening_height = opening_data.get(\"rough_height\")\n            opening_v_start = opening_data.get(\"base_elevation_relative_to_wall_base\")\n\n            logger.debug(\"Extracted opening data:\")\n            logger.debug(f\"  opening_u_start: {opening_u_start}\")\n            logger.debug(f\"  opening_width: {opening_width}\")\n            logger.debug(f\"  opening_height: {opening_height}\")\n            logger.debug(f\"  opening_v_start: {opening_v_start}\")\n\n            if None in (\n                opening_u_start,\n                opening_width,\n                opening_height,\n                opening_v_start,\n            ):\n                logger.warning(\"Missing required opening data for header generation\")\n                return None\n\n            # Get essential parameters\n            base_plane = self.wall_data.get(\"base_plane\")\n            if base_plane is None:\n                logger.warning(\"No base plane available for header generation\")\n                return None\n\n            # Calculate header dimensions\n            # Use provided profile dimensions if available, otherwise fall back to FRAMING_PARAMS\n            king_stud_offset = get_framing_param(\"king_stud_offset\", self.wall_data, 1.5 / 12 / 2)\n\n            if profile_depth is not None:\n                header_width = profile_depth  # Through wall thickness\n                logger.debug(f\"Using provided profile_depth: {profile_depth}\")\n            else:\n                header_width = get_framing_param(\"header_depth\", self.wall_data, 5.5 / 12)\n\n            if profile_height is not None:\n                header_height = profile_height  # Vertical dimension\n                logger.debug(f\"Using provided profile_height: {profile_height}\")\n            else:\n                header_height = get_framing_param(\"header_height\", self.wall_data, 7.0 / 12)\n\n            header_height_above_opening = get_framing_param(\n                \"header_height_above_opening\", self.wall_data, 0.0\n            )  # Distance above opening\n\n            logger.info(\"Header dimensions:\")\n            logger.info(f\"  header_width (depth into wall): {header_width} ft = {header_width * 12} in\")\n            logger.info(f\"  header_height (vertical): {header_height} ft = {header_height * 12} in\")\n            logger.info(f\"  height_above_opening: {header_height_above_opening}\")\n            logger.info(f\"  king_stud_offset: {king_stud_offset}\")\n\n            # Calculate header position (top of opening + half header height)\n            opening_v_end = opening_v_start + opening_height\n            header_v = opening_v_end + (header_height / 2) + header_height_above_opening\n\n            logger.debug(\"Vertical position:\")\n            logger.debug(f\"  opening_v_end: {opening_v_end}\")\n            logger.debug(f\"  header_v: {header_v}\")\n\n            # Calculate header span\n            if king_stud_positions:\n                logger.debug(\"Using provided king stud positions for header\")\n                u_left, u_right = king_stud_positions\n\n                # Check if these are centerlines or inner faces\n                logger.debug(f\"Raw king stud positions: u_left={u_left}, u_right={u_right}\")\n\n                # Adjust positions to use inner faces instead of centerlines\n                inner_left = u_left + king_stud_offset\n                inner_right = u_right - king_stud_offset\n                logger.debug(f\"  inner_left: {u_left} + {king_stud_offset} = {inner_left}\")\n                logger.debug(f\"  inner_right: {u_right} - {king_stud_offset} = {inner_right}\")\n                logger.debug(\n                    f\"Adjusted for inner faces: u_left={inner_left}, u_right={inner_right}\"\n                )\n\n                # Use the adjusted positions\n                u_left = inner_left\n                u_right = inner_right\n            else:\n                # Calculate positions based on opening with offsets\n                logger.debug(\"No king stud positions provided, calculating based on opening\")\n                trimmer_width = get_framing_param(\"trimmer_width\", self.wall_data, 1.5 / 12)\n                u_left = opening_u_start - trimmer_width\n                u_right = opening_u_start + opening_width + trimmer_width\n                logger.debug(f\"Calculated positions: u_left={u_left}, u_right={u_right}\")\n\n            logger.debug(\n                f\"Final header span: u_left={u_left}, u_right={u_right}, width={u_right-u_left}\"\n            )\n\n            # 1. Create the centerline endpoints in wall-local coordinates\n            # The wall's base_plane coordinate system is:\n            #   - XAxis = along wall (U direction)\n            #   - YAxis = vertical (V direction) - derived from World Z\n            #   - ZAxis = wall normal (W direction)\n            # Position using wall-local U,V coordinates via base_plane axes\n\n            start_point = rg.Point3d.Add(\n                base_plane.Origin,\n                rg.Vector3d.Add(\n                    rg.Vector3d.Multiply(base_plane.XAxis, u_left),\n                    rg.Vector3d.Multiply(base_plane.YAxis, header_v),\n                ),\n            )\n\n            end_point = rg.Point3d.Add(\n                base_plane.Origin,\n                rg.Vector3d.Add(\n                    rg.Vector3d.Multiply(base_plane.XAxis, u_right),\n                    rg.Vector3d.Multiply(base_plane.YAxis, header_v),\n                ),\n            )\n\n            logger.debug(\"Header endpoints in world coordinates:\")\n            logger.debug(f\"  start_point: {start_point}\")\n            logger.debug(f\"  end_point: {end_point}\")\n\n            # Create the centerline as a curve\n            centerline = rg.LineCurve(start_point, end_point)\n            self.debug_geometry[\"curves\"].append(centerline)\n            logger.debug(f\"Created centerline with length: {safe_get_length(centerline)}\")\n\n            # 2. Create a profile plane at the start point\n            # Create vectors for the profile plane\n            # X axis goes into the wall (for width)\n            profile_x_axis = base_plane.ZAxis\n            # Y axis goes up/down (for height)\n            profile_y_axis = base_plane.YAxis\n\n            profile_plane = rg.Plane(start_point, profile_x_axis, profile_y_axis)\n            self.debug_geometry[\"planes\"].append(profile_plane)\n            logger.debug(\"Created profile plane for header\")\n\n            # 3. Create a rectangular profile centered on the plane\n            profile_rect = rg.Rectangle3d(\n                profile_plane,\n                rg.Interval(-header_width / 2, header_width / 2),\n                rg.Interval(-header_height / 2, header_height / 2),\n            )\n\n            profile_curve = profile_rect.ToNurbsCurve()\n            self.debug_geometry[\"profiles\"].append(profile_rect)\n            logger.debug(f\"Created profile rectangle - width: {header_width}, height: {header_height}\")\n\n            # 4. Extrude the profile along the centerline\n            # Calculate the vector from start to end\n            extrusion_vector = rg.Vector3d(end_point - start_point)\n            logger.debug(f\"Extrusion vector length: {safe_get_length(extrusion_vector)}\")\n            \n            try:\n                logger.debug(\"Creating header extrusion\")\n                extrusion = safe_create_extrusion(profile_curve, extrusion_vector)\n                if extrusion and hasattr(extrusion, 'IsValid') and extrusion.IsValid:\n                    logger.info(\"Successfully created header\")\n                    # Check if already a Brep\n                    if hasattr(extrusion, 'ToBrep'):\n                        return extrusion.ToBrep()\n                    else:\n                        return extrusion\n                else:\n                    logger.warning(\"Primary extrusion method created invalid extrusion\")\n            except Exception as e:\n                logger.warning(f\"Failed to create valid header extrusion: {str(e)}\")\n                \n            # Try alternative approach - direct box creation using wall-aligned plane\n            try:\n                logger.debug(\"Attempting box creation for header\")\n                # Use header_width (depth into wall) and header_height already calculated above\n                # Don't redefine them here - use the values from lines 98-102\n\n                # Safely get header length and handle null/invalid values\n                header_length = safe_get_length(extrusion_vector)\n                if header_length is None or header_length <= 0:\n                    logger.warning(\"Invalid header length, using fallback value\")\n                    # Estimate length based on start and end points\n                    if start_point is not None and end_point is not None:\n                        header_length = start_point.DistanceTo(end_point)\n                    else:\n                        # Last resort - use a default value\n                        header_length = 6.0  # Default header length of 6 feet\n\n                logger.info(f\"Creating header box with dimensions:\")\n                logger.info(f\"  length (along wall): {header_length} ft = {header_length * 12} in\")\n                logger.info(f\"  height (vertical): {header_height} ft = {header_height * 12} in\")\n                logger.info(f\"  depth (into wall): {header_width} ft = {header_width * 12} in\")\n\n                # Ensure we have valid dimensions before creating the box\n                if header_width <= 0 or header_height <= 0 or header_length <= 0:\n                    raise ValueError(f\"Invalid box dimensions: {header_width}x{header_height}x{header_length}\")\n\n                # Ensure start_point is valid\n                if start_point is None:\n                    logger.warning(\"Invalid start point for box creation, using origin\")\n                    start_point = rg.Point3d.Origin\n\n                # FIX: Create a wall-aligned plane for the box\n                # The box will extend along its X-axis, so we set:\n                # - X-axis = wall direction (for length along wall)\n                # - Y-axis = vertical (for height)\n                # - Z-axis (implicit) = wall normal (for depth)\n                box_plane = rg.Plane(\n                    start_point,\n                    base_plane.XAxis,  # X-axis = wall direction (for length)\n                    base_plane.YAxis   # Y-axis = vertical (for height)\n                )\n\n                # Create a box for the header with wall-aligned orientation\n                # Interval order: X (length along wall), Y (height), Z (depth into wall)\n                # Use header_width (depth into wall) and header_height from main calculation\n                logger.info(f\"Box intervals being created:\")\n                logger.info(f\"  X (length): 0 to {header_length}\")\n                logger.info(f\"  Y (height): {-header_height/2} to {header_height/2}\")\n                logger.info(f\"  Z (depth): {-header_width/2} to {header_width/2}\")\n                box = rg.Box(\n                    box_plane,\n                    rg.Interval(0, header_length),                   # X = length along wall\n                    rg.Interval(-header_height/2, header_height/2), # Y = vertical height\n                    rg.Interval(-header_width/2, header_width/2)    # Z = depth into wall (header_width)\n                )\n\n                if box and box.IsValid:\n                    header_brep = box.ToBrep()\n                    if header_brep and hasattr(header_brep, 'IsValid') and header_brep.IsValid:\n                        # Verify actual dimensions of created Brep\n                        bbox = header_brep.GetBoundingBox(True)\n                        actual_x = bbox.Max.X - bbox.Min.X\n                        actual_y = bbox.Max.Y - bbox.Min.Y\n                        actual_z = bbox.Max.Z - bbox.Min.Z\n                        logger.info(f\"Created header Brep bounding box dimensions:\")\n                        logger.info(f\"  World X extent: {actual_x} ft = {actual_x * 12} in\")\n                        logger.info(f\"  World Y extent: {actual_y} ft = {actual_y * 12} in (depth into wall)\")\n                        logger.info(f\"  World Z extent: {actual_z} ft = {actual_z * 12} in (VERTICAL HEIGHT)\")\n                        logger.info(\"Successfully created header using box creation method\")\n                        return header_brep\n            except Exception as box_error:\n                logger.warning(f\"Box creation failed: {str(box_error)}\")\n            \n            # Try another fallback - simple rectangle extrusion with wall-aligned plane\n            try:\n                logger.debug(\"Attempting direct rectangle extrusion for header\")\n                # Use header_width (depth into wall) and header_height from main calculation\n\n                # FIX: Create wall-aligned profile plane\n                # Profile should be in the wall-normal/vertical plane\n                rect_plane = rg.Plane(\n                    start_point,\n                    base_plane.ZAxis,  # X = wall normal (for depth)\n                    base_plane.YAxis   # Y = vertical (for height)\n                )\n\n                # Create rectangle with centered intervals\n                # Use header_width for depth into wall, header_height for vertical\n                rect = rg.Rectangle3d(\n                    rect_plane,\n                    rg.Interval(-header_width/2, header_width/2),\n                    rg.Interval(-header_height/2, header_height/2)\n                )\n\n                # Convert to curve and extrude along wall direction\n                rect_curve = rect.ToNurbsCurve()\n                fallback_extrusion = safe_create_extrusion(rect_curve, extrusion_vector)\n\n                if fallback_extrusion and hasattr(fallback_extrusion, 'IsValid') and fallback_extrusion.IsValid:\n                    logger.info(\"Successfully created header using rectangle extrusion fallback\")\n                    # Check if already a Brep\n                    if hasattr(fallback_extrusion, 'ToBrep'):\n                        return fallback_extrusion.ToBrep()\n                    else:\n                        return fallback_extrusion\n            except Exception as rect_error:\n                logger.warning(f\"Rectangle extrusion failed: {str(rect_error)}\")\n\n            # Final fallback - create wall-aligned box at start point\n            try:\n                logger.debug(\"Attempting emergency header creation\")\n                # FIX: Create wall-aligned box with correct orientation\n                # X = wall direction (length), Y = vertical (height), Z = wall normal (depth)\n                emergency_plane = rg.Plane(\n                    start_point,\n                    base_plane.XAxis,  # X = wall direction\n                    base_plane.YAxis   # Y = vertical\n                )\n\n                emergency_box = rg.Box(\n                    emergency_plane,\n                    rg.Interval(0, header_length),                   # X = length along wall\n                    rg.Interval(-header_height/2, header_height/2), # Y = height\n                    rg.Interval(-header_width/2, header_width/2)    # Z = depth into wall (header_width)\n                )\n\n                brep = emergency_box.ToBrep()\n                if brep and hasattr(brep, 'IsValid') and brep.IsValid:\n                    logger.warning(\"Created emergency header as fallback\")\n                    return brep\n            except Exception as final_error:\n                logger.error(f\"All header creation methods failed: {str(final_error)}\")\n                \n            logger.warning(\"Failed to create valid header geometry\")\n            return None\n\n        except Exception as e:\n            logger.error(f\"Error generating header: {str(e)}\")\n            import traceback\n            logger.error(traceback.format_exc())\n            return None\n\n    def _generate_header_fallback(\n        self, opening_data, king_stud_positions=None\n    ) -> Optional[rg.Brep]:\n        \"\"\"Fallback method for header generation when coordinate transformations fail.\"\"\"\n        try:\n            logger.debug(\"Using fallback method for header generation\")\n\n            # Extract opening information\n            opening_u_start = opening_data.get(\"start_u_coordinate\")\n            opening_width = opening_data.get(\"rough_width\")\n            opening_height = opening_data.get(\"rough_height\")\n            opening_v_start = opening_data.get(\"base_elevation_relative_to_wall_base\")\n\n            # Calculate header v-coordinate (top of opening)\n            opening_v_end = opening_v_start + opening_height\n            header_height = get_framing_param(\"header_height\", self.wall_data, 7.0 / 12)  # 7 inches default\n            header_depth = get_framing_param(\"header_depth\", self.wall_data, 3.5 / 12)   # 3.5 inches default\n            header_v = opening_v_end + header_height / 2\n            header_height_above_opening = get_framing_param(\n                \"header_height_above_opening\", self.wall_data, 0.0\n            )\n            header_v = header_v + header_height_above_opening\n\n            # Calculate positions based on opening with offsets\n            trimmer_width = get_framing_param(\"trimmer_width\", self.wall_data, 1.5 / 12)\n            king_stud_offset = get_framing_param(\"king_stud_offset\", self.wall_data, 1.5 / 12 / 2)\n\n            # Get the base plane from wall data\n            base_plane = self.wall_data.get(\"base_plane\")\n            if base_plane is None:\n                logger.warning(\"No base plane available for fallback header generation\")\n                return None\n\n            # Calculate header center point (centered horizontally above the opening)\n            header_center_u = opening_u_start + opening_width / 2\n            header_center_v = header_v  # Center vertically above opening\n            header_center = base_plane.PointAt(header_center_u, header_center_v, 0)\n\n            # Create header length based on opening width plus some extension\n            header_length = opening_width + trimmer_width + trimmer_width\n\n            try:\n                # Create box with proper orientation\n                x_axis = base_plane.XAxis\n                y_axis = base_plane.YAxis\n\n                # Create a box plane centered on the header\n                box_plane = rg.Plane(header_center, x_axis, y_axis)\n\n                # Create the box with proper dimensions\n                box = rg.Box(\n                    box_plane,\n                    rg.Interval(\n                        -header_length / 2, header_length / 2\n                    ),  # Length along x-axis\n                    rg.Interval(\n                        -header_height / 2, header_height / 2\n                    ),  # Width into the wall\n                    rg.Interval(\n                        -header_depth / 2, header_depth / 2\n                    ),  # Height centered on header_center\n                )\n\n                # Convert to Brep\n                if box and box.IsValid:\n                    logger.info(\"Successfully created header using fallback method\")\n                    return box.ToBrep()\n                else:\n                    logger.warning(\"Fallback method created invalid box\")\n                    return None\n\n            except Exception as e:\n                logger.error(f\"Error in header fallback box creation: {str(e)}\")\n                return None\n\n        except Exception as e:\n            logger.error(f\"Error in header fallback: {str(e)}\")\n            return None\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}