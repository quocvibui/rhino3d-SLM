{
  "source_url": "https://github.com/jesterKing/import_3dm/blob/b3c680c3fe049bae8e421fac9da7f13c6c9cd927/import_3dm/converters/views.py",
  "repo": "jesterKing/import_3dm",
  "repo_stars": 372,
  "repo_description": "Blender importer script for Rhinoceros 3D files",
  "license": "MIT",
  "filepath": "import_3dm/converters/views.py",
  "instruction": "MIT License",
  "code": "# MIT License\n\n# Copyright (c) 2018-2024 Nathan Letwory, Joel Putnam, Tom Svilans, Lukas Fertig\n\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\nimport rhino3dm as r3d\nfrom . import utils\nfrom mathutils import Matrix\n\n\ndef handle_view(context, view, name, scale):\n        vp = view.Viewport\n\n        # Construct transformation matrix\n        mat = Matrix([\n            [vp.CameraX.X, vp.CameraX.Y, vp.CameraX.Z, 0],\n            [vp.CameraY.X, vp.CameraY.Y, vp.CameraY.Z, 0],\n            [vp.CameraZ.X, vp.CameraZ.Y, vp.CameraZ.Z, 0],\n            [0,0,0,1]])\n\n        mat.invert()\n\n        mat[0][3] = vp.CameraLocation.X * scale\n        mat[1][3] = vp.CameraLocation.Y * scale\n        mat[2][3] = vp.CameraLocation.Z * scale\n\n        lens = vp.Camera35mmLensLength\n\n        tags = utils.create_tag_dict(None, name)\n        blcam = utils.get_or_create_iddata(context.blend_data.cameras, tags, None)\n\n        # Set camera to perspective or parallel\n        if vp.IsPerspectiveProjection:\n            blcam.type = \"PERSP\"\n            blcam.lens = lens\n            blcam.sensor_width = 36.0\n        elif vp.IsParallelProjection:\n            blcam.type = \"ORTHO\"\n            frustum = vp.GetFrustum()\n            blcam.ortho_scale = (frustum['right'] - frustum['left']) * scale\n\n        # Link camera data to new object\n        blobj = utils.get_or_create_iddata(context.blend_data.objects, tags, blcam)\n        blobj.matrix_world = mat\n\n        # Return new camera\n        return blobj\n\ndef handle_views(context, model, layer, views, layer_name, scale):\n\n    collection_is_new = False\n    if layer_name in context.blend_data.collections:\n        viewLayer = context.blend_data.collections[layer_name]\n    else:\n        viewLayer = context.blend_data.collections.new(name=layer_name)\n        collection_is_new = True\n\n    for v in views:\n        camera = handle_view(context, v, \"RhinoView_\" + v.Name, scale)\n        try:\n            viewLayer.objects.link(camera)\n        except Exception:\n            pass\n\n    if collection_is_new:\n        layer.children.link(viewLayer)\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": true
}