{
  "source_url": "https://github.com/ladybug-tools/honeybee-legacy/blob/bd62af4862fe022801fb87dbc8794fdf1dff73a9/src/Honeybee_Skylight%20Based%20on%20Ratio.py",
  "repo": "ladybug-tools/honeybee-legacy",
  "repo_stars": 129,
  "repo_description": ":bee: Honeybee is a free and open source plugin to connect Grasshopper3D to EnergyPlus, Radiance, Daysim and OpenStudio for building energy and daylighting simulation",
  "license": "NOASSERTION",
  "filepath": "src/Honeybee_Skylight Based on Ratio.py",
  "instruction": "Use this component to generate windows for a HBSurface or HBZone based on a desired window-to-wall ratio. In addition to generating window geometry that corresponds with the input ratio, this...",
  "code": "# glazingCreator\n# The main geometry-generating parts of this component are developed by Chris Mackey\n#\n# Honeybee: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Honeybee.\n# \n# Copyright (c) 2013-2020, Chris Mackey and Mostapha Sadeghipour Roudsari <Chris@MackeyArchitecture.com - mostapha@ladybug.tools> \n# Honeybee is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Honeybee is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Honeybee; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to generate windows for a HBSurface or HBZone based on a desired window-to-wall ratio. In addition to generating window geometry that corresponds with the input ratio, this component also allows you a fairly high level of control over the window geometry.\n_\nThe first way in which you gain additional control over geometry is the option of whether you want to generate a single window for each surface, which is good for making energy simulations run fast, or you want to use the glazig ratio to create several windows distributed across the surfaces, which is often necessary to have accurate daylight simulations or high-resolution thermal maps.\nIf you break up the window into several ones, you also have the ability to set the distance between each of the windows along the surface.\n_\nIf you input wall surfaces that have perfectly horizontal tops and/or bottoms, you also have access to a number of other other inputs such as window height, the sill height, and whether you want to split the glazing vertically into two windows.\n-\nProvided by Honeybee 0.0.66\n    \n    Args:\n        _HBObjects: Honeybee thermal zones or surfaces for which glazing should be generated.\n        _skyLightRatio: If you have input a full zone or roof surface as your HBObjects, use this input to generate skylights on the roof surfaces. A single window for each surface is good for making energy simulations run fast while several distributed windows is often necessary to have accurate daylight simulations or high-resolution thermal maps. The default is set to \"True\" to generate multiple distributed windows.\n        breakUpSkylight_: Set to \"True\" to generate a distributed set of multiple windows for skylights and set to \"False\" to generate just a single window per roof surface.\n        skyLightBreakUpDist_: An optional number in Rhino model units that sets the distance between individual skylights when the breakUpSkylight_ input above is set to 'True'.  The default is set to 3 meters.\n        EPConstruction_: A optional text string of an EnergyPlus construction name that sets the material construction of the window. The default will assign a generic double pane window without low-e coatings.\n        RADMaterial_: A optional text string of an Radiance glass material name that sets the material of the window.\n        _runIt: set runIt to True to generate the glazing\n    Returns:\n        readMe!: ...\n        HBObjWGLZ: Newhoneybee zones that contain glazing surfaces based on the parameters above. \n\"\"\"\n\nghenv.Component.Name = \"Honeybee_Skylight Based on Ratio\"\nghenv.Component.NickName = 'skylightCreator'\nghenv.Component.Message = 'VER 0.0.66\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"HB-Legacy\"\nghenv.Component.SubCategory = \"00 | Honeybee\"\n#compatibleHBVersion = VER 0.0.56\\nJAN_01_2017\n#compatibleLBVersion = VER 0.0.59\\nFEB_01_2015\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"0\"\nexcept: pass\n\n\nimport Rhino as rc\nimport scriptcontext as sc\nimport rhinoscriptsyntax as rs\nimport math\nimport uuid\n\n# all this only to graft the data at the end! booooooo\nimport Grasshopper.Kernel as gh\nimport System\nfrom Grasshopper import DataTree\nfrom Grasshopper.Kernel.Data import GH_Path\n\ntol = sc.doc.ModelAbsoluteTolerance\n\ndef checkEPConstr(EPConstruction, hb_EPObjectsAux):\n    # if it is just the name of the material make sure it is already defined\n    if len(EPConstruction.split(\"\\n\")) == 1:\n        # if the material is not in the library add it to the library\n        if not hb_EPObjectsAux.isEPConstruction(EPConstruction):\n            warningMsg = \"Can't find \" + EPConstruction + \" in EP Construction Library.\\n\" + \\\n                        \"Add the construction to the library and try again.\"\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warningMsg)\n            return None\n    else:\n        # it is a full string.\n        if EPConstruction.startswith('WindowMaterial:'):\n            warningMsg = \"Your window construction, \" + EPConstruction.split('\\n')[1].split(',')[0] + \", is a window material and not a full window construction.\\n\" + \\\n                        \"Pass this window material through a 'Honeybee_EnergyPlus Construction' component cand connect the construction to this one.\"\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warningMsg)\n            return None\n        added, EPConstruction = hb_EPObjectsAux.addEPObjectToLib(EPConstruction, overwrite = True)\n        \n        if not added:\n            msg = EPConstruction + \" is not added to the project library!\"\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, msg)\n            print msg\n            return None\n    return EPConstruction\n\ndef checkRADMat(RADMaterial, hb_RADMaterialAUX):\n    if len(RADMaterial.strip().split(\" \")) == 1:\n        if not hb_RADMaterialAUX.isMatrialExistInLibrary(RADMaterial):\n            warningMsg = \"Can't find \" + RADMaterial + \" in RAD Material Library.\\n\" + \\\n                \"Add the material to the library and try again.\"\n            ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warningMsg)\n            return None\n    return RADMaterial\n\ndef findGlzBasedOnRatio(baseSrf, glzRatio, breakUpWindow, breakUpDist, conversionFactor, hb_GlzGeoGeneration):\n    lastSuccessfulRestOfSrf = []\n    \n    #Check if the surface is a planar surface\n    planarBool = rc.Geometry.BrepFace.IsPlanar(baseSrf.Faces[0], sc.doc.ModelAbsoluteTolerance)\n    \n    #Rebuild and simplify the surface to ensure best results when generating the glazing.\n    edgeLinear = True\n    createdNew = False\n    edges = baseSrf.Edges\n    joinedEdges = rc.Geometry.Curve.JoinCurves(edges)\n    simplificationOpt = rc.Geometry.CurveSimplifyOptions.All\n    \n    joinedEdgesSimplified = []\n    for crv in joinedEdges:\n        joinedEdgesSimplified.append(crv.Simplify(simplificationOpt, sc.doc.ModelAbsoluteTolerance, sc.doc.ModelAngleToleranceRadians))\n    \n    originalSrfDir = baseSrf.Faces[0].NormalAt(0,0)\n    if planarBool == True:\n        try:\n            baseSrf = rc.Geometry.Brep.CreatePlanarBreps(joinedEdgesSimplified)[0]\n            createdNew = True\n        except:\n            createdNew = False\n    newSrfDir = baseSrf.Faces[0].NormalAt(0,0)\n    \n    #If the direction of the rebuilt surface is not the same as that of the original surface, flip it around.\n    if createdNew == True:\n        if newSrfDir.X < originalSrfDir.X + tol and newSrfDir.X > originalSrfDir.X - tol and newSrfDir.Y < originalSrfDir.Y + tol and newSrfDir.Y > originalSrfDir.Y - tol and newSrfDir.Z < originalSrfDir.Z + tol and newSrfDir.Z > originalSrfDir.Z - tol:\n            pass\n        else:\n            baseSrf.Flip()\n    else: pass\n    \n    #Check if the surface has any curved edges to it\n    for crv in joinedEdgesSimplified:\n        if crv != None:\n            for edge in crv.DuplicateSegments():\n                if rc.Geometry.BrepEdge.IsLinear(edge, sc.doc.ModelAbsoluteTolerance):\n                    pass\n                else:\n                    edgeLinear = False\n        else: pass\n    \n    #Check if the surface is a planar skylight that can be broken up into quads and, if so, send it through the skylight generator\n    glazing, lastSuccessfulRestOfSrf = hb_GlzGeoGeneration.createSkylightGlazing(baseSrf, glzRatio, planarBool, edgeLinear, breakUpWindow, breakUpDist, conversionFactor)\n    \n    #Check to make sure that a window has been generated and, if so, check to make sure that the window that has been generated is facing the right direction.  If not, flip it.\n    if glazing == None:\n        print \"Failed to calculate the glazing\"\n        pass\n    else:\n        try:\n            len(glazing)\n        except:\n            glazing = [glazing]\n        \n        for window in glazing:\n            windowDir = window.Faces[0].NormalAt(0,0)\n            if windowDir.X < originalSrfDir.X + tol and windowDir.X > originalSrfDir.X - tol and windowDir.Y < originalSrfDir.Y + tol and windowDir.Y > originalSrfDir.Y - tol and windowDir.Z < originalSrfDir.Z + tol and windowDir.Z > originalSrfDir.Z - tol:\n                pass\n            else:\n                window.Flip()\n    \n    if lastSuccessfulRestOfSrf==[]:\n        lastSuccessfulRestOfSrf = hb_GlzGeoGeneration.getRestOfSurfacePlanar(baseSrf, glazing)\n    \n    return glazing, lastSuccessfulRestOfSrf\n\ndef giveWarning(message):\n    print message\n    w = gh.GH_RuntimeMessageLevel.Warning\n    ghenv.Component.AddRuntimeMessage(w, message)\n\ndef main(skyLightRatio, breakUpSkylight, skyLightBreakUpDist, EPConstruct, RADMat):\n    # check if honeybee is flying\n    # import the classes\n    if sc.sticky.has_key('ladybug_release')and sc.sticky.has_key('honeybee_release'):\n        try:\n            if not sc.sticky['honeybee_release'].isCompatible(ghenv.Component): return -1\n            if sc.sticky['honeybee_release'].isInputMissing(ghenv.Component): return -1\n        except:\n            warning = \"You need a newer version of Honeybee to use this compoent.\" + \\\n            \" Use updateHoneybee component to update userObjects.\\n\" + \\\n            \"If you have already updated userObjects drag Honeybee_Honeybee component \" + \\\n            \"into canvas and try again.\"\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, warning)\n            return -1\n    \n        try:\n            if not sc.sticky['ladybug_release'].isCompatible(ghenv.Component): return -1\n        except:\n            warning = \"You need a newer version of Ladybug to use this compoent.\" + \\\n            \" Use updateLadybug component to update userObjects.\\n\" + \\\n            \"If you have already updated userObjects drag Ladybug_Ladybug component \" + \\\n            \"into canvas and try again.\"\n            w = gh.GH_RuntimeMessageLevel.Warning\n            ghenv.Component.AddRuntimeMessage(w, warning)\n            return -1\n        \n        hb_RADMaterialAUX = sc.sticky[\"honeybee_RADMaterialAUX\"]\n        hb_EPObjectsAux = sc.sticky[\"honeybee_EPObjectsAUX\"]()\n        hb_EPZone = sc.sticky[\"honeybee_EPZone\"]\n        hb_EPSrf = sc.sticky[\"honeybee_EPSurface\"]\n        hb_EPFenSurface = sc.sticky[\"honeybee_EPFenSurface\"]\n        hb_GlzGeoGeneration = sc.sticky[\"honeybee_GlzGeoGeneration\"]()\n        lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n    else:\n        print \"You should first let both Ladybug and Honeybee to fly...\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, \"You should first let both Ladybug and Honeybee to fly...\")\n        return [], []\n    \n    # call the objects from the lib\n    hb_hive = sc.sticky[\"honeybee_Hive\"]()\n    HBZoneObjects = hb_hive.callFromHoneybeeHive(_HBObjects)\n    \n    #Check constructions and RADMAterials.\n    if EPConstruct != None:\n        constrCheck = checkEPConstr(EPConstruct, hb_EPObjectsAux)\n        if constrCheck != None:\n            EPConstruct = constrCheck\n        else:\n            return -1\n    if RADMat != None:\n        matCheck = checkRADMat(RADMat, hb_RADMaterialAUX)\n        if matCheck != None:\n            RADMat = matCheck\n        else:\n            return -1\n    \n    #Get the conversion factor (for the future when HB is availble in other model units).\n    conversionFactor = lb_preparation.checkUnits()\n    \n    #Set the final lists to be filled.\n    joinedSrf = []\n    zonesWithOpeningsGeometry =[]\n    ModifiedHBZones = []\n    \n    if HBZoneObjects and HBZoneObjects[0] != None:\n        # collect the surfaces\n        HBSurfaces = []\n        for HBObj in HBZoneObjects:\n            if HBObj.objectType == \"HBZone\":\n                for surface in HBObj.surfaces: HBSurfaces.append(surface)\n            elif HBObj.objectType == \"HBSurface\":\n                if not hasattr(HBObj, 'type'):\n                    # find the type based on \n                    HBObj.type = HBObj.getTypeByNormalAngle()\n                \n                if not hasattr(HBObj, \"BC\"):\n                    HBObj.BC = 'OUTDOORS'\n                HBSurfaces.append(HBObj)\n        \n        for surface in HBSurfaces:\n            if skyLightRatio!=0 and surface.BC.upper() == 'OUTDOORS' and surface.type == 1:\n                if surface.hasChild:\n                    surface.removeAllChildSrfs()\n                \n                face = surface.geometry # call surface geometry\n                \n                # This part of the code sends the parameters and surfaces to their respective methods of of galzing generation.  It is developed by Chris Mackey.\n                lastSuccessfulGlzSrf, lastSuccessfulRestOfSrf = findGlzBasedOnRatio(face, skyLightRatio, breakUpSkylight, skyLightBreakUpDist, conversionFactor, hb_GlzGeoGeneration)\n                \n                if lastSuccessfulGlzSrf!= None:\n                    if isinstance(lastSuccessfulGlzSrf, list):\n                        for glzSrfCount, glzSrf in enumerate(lastSuccessfulGlzSrf):\n                            fenSrf = hb_EPFenSurface(glzSrf, surface.num, surface.name + '_glz_' + `glzSrfCount`, surface, 5, lastSuccessfulRestOfSrf)\n                            if EPConstruct != None:\n                                fenSrf.setEPConstruction(EPConstruct)\n                            if RADMat != None:\n                                addedToLib, fenSrf.RadMaterial = hb_RADMaterialAUX.analyseRadMaterials(RADMat, True)\n                            zonesWithOpeningsGeometry.append(glzSrf)\n                            surface.addChildSrf(fenSrf)\n                        if lastSuccessfulRestOfSrf==[]:\n                            surface.calculatePunchedSurface()\n                    else:\n                        fenSrf = hb_EPFenSurface(lastSuccessfulGlzSrf, surface.num, surface.name + '_glz_0', surface, 5, lastSuccessfulRestOfSrf)\n                        if EPConstruct != None:\n                            fenSrf.setEPConstruction(EPConstruct)\n                        if RADMat != None:\n                            addedToLib, fenSrf.RadMaterial = hb_RADMaterialAUX.analyseRadMaterials(RADMat, True)\n                        zonesWithOpeningsGeometry.append(lastSuccessfulGlzSrf)\n                        surface.addChildSrf(fenSrf)\n                        if lastSuccessfulRestOfSrf==[]: surface.calculatePunchedSurface()\n        \n        #add zones to dictionary\n        ModifiedHBZones  = hb_hive.addToHoneybeeHive(HBZoneObjects, ghenv.Component)\n        \n    return zonesWithOpeningsGeometry, ModifiedHBZones\n\nif _runIt and _HBObjects and _HBObjects[0]:\n    results = main(_skyLightRatio, breakUpSkylight_, skyLightBreakUpDist_, EPConstruction_, RADMaterial_)\n    if results!= -1:\n        glazingSrf, HBObjWGLZ = results",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}