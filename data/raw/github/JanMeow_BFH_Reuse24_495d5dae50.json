{
  "source_url": "https://github.com/JanMeow/BFH_Reuse24/blob/8ee5b5647d3500e8ac32686766bd46658e59ac11/Kevin/otherThing/tempWallGenerate.py",
  "repo": "JanMeow/BFH_Reuse24",
  "repo_stars": 0,
  "repo_description": "BFH 24 Spring Studio Scripts Development",
  "license": "MIT",
  "filepath": "Kevin/otherThing/tempWallGenerate.py",
  "instruction": "Temp wall generate",
  "code": "import Rhino.Geometry as rg\nfrom ghpythonlib.components import Area, SurfaceClosestPoint, EvaluateSurface, Contour, SurfaceSplit, Extrude, OffsetCurve, BoundarySurfaces\nimport ghpythonlib.treehelpers as th\nimport math\nfrom copy import copy\nfrom Grasshopper.Kernel.Data import GH_Path\nfrom Grasshopper import DataTree\nimport System.Array as array\n\n\ndef create_contours(surface, base_plane, interval):\n    base_plane = copy(base_plane)\n    base_plane.Rotate(math.pi/2, base_plane.XAxis, base_plane.Origin)\n    base_plane.Rotate(math.pi/10, base_plane.ZAxis, base_plane.Origin)\n    contours = []\n    trimmed_contours = []\n\n    # Get the bounding box of the surface in the plane's coordinate system\n    bbox = surface.GetBoundingBox(base_plane)\n\n    # Start and end values for contouring in the direction of the plane's normal\n    start = bbox.Min.Z\n    end = bbox.Max.Z\n\n    # Generate contours\n    z = start\n    while z <= end:\n        # Create a plane parallel to the base plane at height z\n        contour_plane = rg.Plane(base_plane)\n        contour_plane.Translate(base_plane.Normal * z)\n\n        # Generate the contour\n        contour_curves = rg.Brep.CreateContourCurves(surface, contour_plane)\n        contours.extend(contour_curves)\n\n        z += interval\n\n    # Get the edge curves of the surface\n    edge_curves = surface.DuplicateEdgeCurves()\n    boundary = rg.Curve.JoinCurves(edge_curves)[0]  # Join edge curves to form a single boundary curve\n    \n    # Trim contours\n    for contour in contours:\n        intersection_events = rg.Intersect.Intersection.CurveCurve(contour, boundary, 0.01, 0.01)\n        if intersection_events:\n            intersection_params = [event.ParameterA for event in intersection_events]\n            segments = contour.Split(intersection_params)\n            for segment in segments:\n                trimmed_contours.append(segment)\n\n    return trimmed_contours\n\n\ndef create_beam(curve, base_plane, width, height):\n    start_point = curve.PointAtStart\n\n    # Create a plane at the start point with the same orientation as the provided plane\n    section_plane = rg.Plane(start_point, base_plane.YAxis, base_plane.ZAxis)\n    matrix = rg.Transform.Translation(-base_plane.YAxis*width/2)\n    section_plane.Transform(matrix)\n\n    # Create a rectangle in this plane\n    rectangle = rg.Rectangle3d(section_plane, width, height)\n\n    # Create a sweep\n    sweep = rg.SweepOneRail()\n    sweep.AngleToleranceRadians = 0.01\n    sweep.ClosedSweep = True\n    sweep.SweepTolerance = 0.01\n\n    # Perform the sweep\n    swept_breps = sweep.PerformSweep(curve, rectangle.ToNurbsCurve())\n\n    # Assuming we want the first Brep if there are multiple\n    return swept_breps[0]\n    \n\n\ndef create_board(surface, base_plane, length, width, thickness, direction):\n    if direction:\n        firDirPlane = copy(base_plane)\n        secDirPlane = copy(base_plane)\n        secDirPlane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n    else:\n        base_plane = copy(base_plane)\n        base_plane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n        firDirPlane = copy(base_plane)\n        secDirPlane = copy(base_plane)\n        secDirPlane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n\n    crvLength = create_contours(surface, firDirPlane, length)\n    crvWidth = create_contours(surface, secDirPlane, width)\n\n    crvCombine = []\n    crvCombine.extend(crvLength)\n    crvCombine.extend(crvWidth)\n\n    panelGeoList = SurfaceSplit(surface, crvCombine)\n\n        # create panel geometry\n    panelOffsetList = []\n    boardSeam = 2\n    for panel in panelGeoList:\n        # neg = OffsetCurve(panel, -boardSeam, base_plane, 1)\n        # pos = OffsetCurve(panel, boardSeam, base_plane, 1)\n        # if pos.GetLength() > neg.GetLength():\n        #     offsetResult = neg\n        # else:\n        #     offsetResult = pos\n        \n        # panelOffsetSrf = BoundarySurfaces(offsetResult)\n        panelOffsetList.append(Extrude(panel, base_plane.ZAxis*thickness))\n    \n    return panelOffsetList\n\n\n\ndef create_substructInfill(surface, base_plane, width, thickness, distance, direction):\n    if direction:\n        workPlane = copy(base_plane)\n\n    else:\n        base_plane = copy(base_plane)\n        base_plane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n        workPlane = copy(base_plane)\n    \n    substructCrv = create_contours(surface, workPlane, distance)\n\n    panelGeoList = SurfaceSplit(surface, substructCrv)\n\n\n    # create panel geometry\n    panelOffsetList = []\n    for panel in panelGeoList:\n        neg = OffsetCurve(panel, -width/2, base_plane, 1)\n        pos = OffsetCurve(panel, width/2, base_plane, 1)\n        if pos.GetLength() > neg.GetLength():\n            offsetResult = neg\n        else:\n            offsetResult = pos\n        \n        panelOffsetSrf = BoundarySurfaces(offsetResult)\n        panelOffsetList.append(Extrude(panelOffsetSrf, base_plane.ZAxis*thickness*0.8))\n\n    # create beam\n    beamGeo = []\n    for crv in substructCrv:\n        beamGeo.append(create_beam(crv, base_plane, width, thickness))\n\n    return (panelOffsetList, beamGeo)\n\n\n\ndef create_paint(surface, base_plane, thickness):\n    return Extrude(surface, base_plane.ZAxis*thickness)\n\n\n\ndef create_substruct(surface, base_plane, width, thickness, distance, direction):\n    if direction:\n        workPlane = copy(base_plane)\n\n    else:\n        base_plane = copy(base_plane)\n        base_plane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n        workPlane = copy(base_plane)\n    \n    substructCrv = create_contours(surface, workPlane, distance)\n\n    # create beam\n    beamGeo = []\n    for crv in substructCrv:\n        beamGeo.append(create_beam(crv, base_plane, width, thickness))\n\n    return beamGeo\n\n\n\ndef create_cladding(surface, base_plane, length, width, thickness, direction):\n    if direction:\n        firDirPlane = copy(base_plane)\n        secDirPlane = copy(base_plane)\n        secDirPlane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n    else:\n        base_plane = copy(base_plane)\n        base_plane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n        firDirPlane = copy(base_plane)\n        secDirPlane = copy(base_plane)\n        secDirPlane.Rotate(math.pi/2, base_plane.ZAxis, base_plane.Origin)\n\n    crvLength = create_contours(surface, firDirPlane, length)\n    crvWidth = create_contours(surface, secDirPlane, width)\n\n    crvCombine = []\n    crvCombine.extend(crvLength)\n    crvCombine.extend(crvWidth)\n\n    panelGeoList = SurfaceSplit(surface, crvCombine)\n\n        # create panel geometry\n    panelOffsetList = []\n    boardSeam = 2\n    for panel in panelGeoList:\n        # neg = OffsetCurve(panel, -boardSeam, base_plane, 1)\n        # pos = OffsetCurve(panel, boardSeam, base_plane, 1)\n        # if pos.GetLength() > neg.GetLength():\n        #     offsetResult = neg\n        # else:\n        #     offsetResult = pos\n        \n        # panelOffsetSrf = BoundarySurfaces(offsetResult)\n        panelOffsetList.append(Extrude(panel, base_plane.ZAxis*thickness))\n    \n    return panelOffsetList\n\n\n\n\nbasePlane = []\nboardGeoList = []\nsubstructInfillGeoList = []\npaintGeoList = []\nsubstructGeoList = []\ncladdingGeoList = []\nlayerTree = DataTree[object]()\n\nfor id, (srfList, matList) in enumerate(zip(surfaceList.Branches, materialList.Branches)):\n    print(matList)\n    mat = matList[0]\n    if id == 0:\n        for srf in srfList:\n            uvP = SurfaceClosestPoint(Area(srf)[1], srf)[1]\n            frame = EvaluateSurface(srf, uvP)[4]\n            basePlane.append(frame)\n    \n    allTypeGeo = []\n    for srf_id, srf in enumerate(srfList):\n        workPlane = basePlane[srf_id]\n        matType = mat.materialType\n        print(matType)\n        if matType == \"board\":\n            boardGeo = create_board(srf, workPlane, mat.length, mat.width, mat.thickness, mat.direction)\n            boardGeoList.append(boardGeo)\n            allTypeGeo.append(boardGeo)\n            \n        elif matType == \"substructInfill\":\n            panelGeo, beamGeo = create_substructInfill(srf, workPlane, mat.width, mat.thickness, mat.distance, mat.direction)\n            substructInfillGeoList.append(beamGeo)\n            substructInfillGeoList.append(panelGeo)\n            allTypeGeo.append(beamGeo)\n            allTypeGeo.append(panelGeo)\n\n        elif matType == \"paint\":\n            paintGeo = create_paint(srf, workPlane, mat.thickness)\n            paintGeoList.append([paintGeo])\n            allTypeGeo.append([paintGeo])\n            \n        elif matType == \"substruct\":\n            substructGeo = create_substruct(srf, workPlane, mat.width, mat.thickness, mat.distance, mat.direction)\n            substructGeoList.append(substructGeo)\n            allTypeGeo.append(substructGeo)\n\n        elif matType == \"cladding\":\n            claddingGeo = create_cladding(srf, workPlane, mat.length, mat.width, mat.thickness, mat.direction)\n            claddingGeoList.append(claddingGeo)\n            allTypeGeo.append(claddingGeo)\n        \n    path = GH_Path(array[int]([0,0,id]))\n    layerTree.AddRange(allTypeGeo, path)\n        \n\n\nallTypeMaterial = layerTree\n\n\n# class wallGenerate:\n#     def __init__(self, surfaceList, materialList, thicknessList):\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "ghpythonlib"
  ],
  "has_docstring": false
}