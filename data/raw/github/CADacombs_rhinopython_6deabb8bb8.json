{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Crv_convertToPiecewiseURBS.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Crv_convertToPiecewiseURBS.py",
  "instruction": "This script will convert a curve to a\r\nPiecewise Uniform Rational Basis Spline (URBS) curve.\r\n\r\nPeriodic curves' domains will (most likely?) be modified due to moving their seams\r\nto a parameter to...",
  "code": "\"\"\"\r\nThis script will convert a curve to a\r\nPiecewise Uniform Rational Basis Spline (URBS) curve.\r\n\r\nPeriodic curves' domains will (most likely?) be modified due to moving their seams\r\nto a parameter to be split.\r\n\r\nSend any questions, comments, or script development service needs to\r\n@spb on the McNeel Forums, https://discourse.mcneel.com/\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n#! python 2\r\n\r\n\"\"\"\r\n240819: Created starting with the 'Bezier' script.\r\n240828: Bug fix to correctly handle closed and periodic curves.\r\n        Fixed crash when no output.\r\n        Added support for BrepEdge input. New curves are added, the edge curves are not replaced within the Brep.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\n\r\nsc.escape_test(throw_exception=False, reset=True) # Added due to a bug in RhinoCode (at least up through 8.10).\r\n\r\n\r\nclass Opts():\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'bExplode'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bNurbs_NotPoly'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'Curve'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Poly', 'Nurbs')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDeleteInput'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        else:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            return\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    Get curve with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select curves\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Curve\r\n    # go.GeometryAttributeFilter = ri.Custom.GeometryAttributeFilter.WireCurve\r\n\r\n    idxs_Opt = {}\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        addOption('bExplode')\r\n        if not Opts.values['bExplode']:\r\n            addOption('bNurbs_NotPoly')\r\n        addOption('bDeleteInput')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n\r\n        res = go.GetMultiple(minimumNumber=1, maximumNumber=0)\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objrefs = go.Objects()\r\n            go.Dispose()\r\n            return objrefs\r\n\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef formatDistance(fDistance, iPrecision=15):\r\n    if fDistance is None: return \"(No deviation provided)\"\r\n    \r\n    if fDistance < 0.01:\r\n        return \"{:.{}e}\".format(fDistance, iPrecision)\r\n    \r\n    if fDistance < 0.1:\r\n        return \"{:.{}g}\".format(fDistance, iPrecision+1)\r\n    \r\n    return \"{:.{}g}\".format(fDistance, iPrecision)\r\n\r\n\r\ndef createCrvs(rgCrv_In, bExplode, bNurbs_NotPoly, bDebug=False):\r\n    \"\"\"\r\n    Returns on success: rg.NurbsCurve, None\r\n    Returns on fail: None, str(Log)\r\n    \"\"\"\r\n\r\n    if isinstance(rgCrv_In, rg.PolyCurve):\r\n        rgC_WIP = rgCrv_In.CleanUp()\r\n        if rgC_WIP is None:\r\n            rgC_WIP = rgCrv_In.DuplicateCurve()\r\n    else:\r\n        rgC_WIP = rgCrv_In.DuplicateCurve()\r\n\r\n    if isinstance(rgC_WIP, (rg.ArcCurve, rg.LineCurve, rg.PolylineCurve)):\r\n        rgC_WIP.Dispose()\r\n        return [], \"{} was skipped.\".format(rgC_WIP.GetType().Name)\r\n\r\n    if rgC_WIP.SpanCount == 1:\r\n        rgC_WIP.Dispose()\r\n        return [], \"{} with single span skipped.\".format(rgC_WIP.GetType().Name)\r\n\r\n\r\n    # Only PolyCurves and multi-span NurbsCurves should remain.\r\n\r\n    # Check whether PolyCurve has consecutive NurbsCurves.\r\n    if isinstance(rgC_WIP, rg.NurbsCurve):\r\n        nc_WIP = rgC_WIP\r\n    elif isinstance(rgC_WIP, rg.PolyCurve):\r\n        idx_LastNurbs = None\r\n        for i in range(rgC_WIP.SegmentCount):\r\n            seg = rgC_WIP.SegmentCurve(i)\r\n            if isinstance(seg, rg.NurbsCurve):\r\n                if seg.Knots.KnotStyle not in (\r\n                    rg.KnotStyle.QuasiUniform,\r\n                    rg.KnotStyle.Uniform\r\n                    ):\r\n                    break # out of for loop.\r\n        else:\r\n            rgC_WIP.Dispose()\r\n            return [], \"No segments in PolyCurve are non-uniform NURBS.\"\r\n        nc_WIP = rgC_WIP.ToNurbsCurve()\r\n        rgC_WIP.Dispose()\r\n    else:\r\n        raise Exception(\"{}!\".format(rgC_WIP.GetType().Name))\r\n\r\n    # nc_WIP is now a non-uniform NurbsCurve.\r\n\r\n    def parametersBetweenUniformSpans(nc):\r\n        if nc.IsClosed and not nc.IsPeriodic:\r\n            ts = [nc.Knots[0]]\r\n        else:\r\n            ts = []\r\n        \r\n        if nc.IsPeriodic:\r\n            iK = nc.Degree - 1\r\n            k = nc.Knots[iK]\r\n            m = nc.Knots.KnotMultiplicity(iK)\r\n            if m > 1:\r\n                ts.append(nc.Knots[iK])\r\n\r\n            iK = nc.Degree # nc.Knots.KnotMultiplicity(0) # First interior knot, not starting end.\r\n            k = nc.Knots[iK]\r\n            fSpanLength_Ref = nc.Knots[iK] - nc.Knots[iK-1]\r\n        else:\r\n            iK = nc.Degree # nc.Knots.KnotMultiplicity(0) # First interior knot, not starting end.\r\n            fSpanLength_Ref = None\r\n        while iK < nc.Knots.Count:\r\n            sc.escape_test(throw_exception=True, reset=True)\r\n\r\n            k = nc.Knots[iK]\r\n            m = nc.Knots.KnotMultiplicity(iK)\r\n            fSpanLength_Now = nc.Knots[iK] - nc.Knots[iK-1]\r\n\r\n            if fSpanLength_Ref is None:\r\n                fSpanLength_Ref = fSpanLength_Now\r\n            elif abs(fSpanLength_Now - fSpanLength_Ref) > Rhino.RhinoMath.ZeroTolerance:\r\n                ts.append(nc.Knots[iK-1])\r\n\r\n            if nc.Knots[iK] == nc.Domain.T1:\r\n                break\r\n\r\n            if m > 1:\r\n                ts.append(nc.Knots[iK])\r\n                fSpanLength_Ref = None\r\n            else:\r\n                fSpanLength_Ref = fSpanLength_Now\r\n\r\n            iK += m\r\n\r\n        if len(ts) == 0:\r\n            return []\r\n\r\n        # if nc.IsPeriodic:\r\n        #     if nc.Domain.T0 not in ts:\r\n        #         nc.ChangeClosedCurveSeam(ts[0])\r\n\r\n        return ts\r\n\r\n\r\n    ts = parametersBetweenUniformSpans(nc_WIP)\r\n    # sEval = \"ts\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n    if len(ts) == 0:\r\n        return [], \"No non-uniform spans found.\"\r\n\r\n    # TODO: Implement moving the seam to a split parameter.\r\n    #       Through V8.10, using the following code generates a knot vector - curve domain mismatch.\r\n    if nc_WIP.IsPeriodic:\r\n        if nc_WIP.Domain.T0 not in ts:\r\n            print(nc_WIP.ChangeClosedCurveSeam(ts[0]))\r\n            # Generate the list of parameters again since the domain has been changed.\r\n            ts = parametersBetweenUniformSpans(nc_WIP)\r\n            ts.append(nc_WIP.Domain.T1) # Since T1 (T0) was confirmed to be a parameter for splitting.\r\n\r\n    # if nc_WIP.IsPeriodic:\r\n    #     if nc_WIP.Domain.T0 not in ts:\r\n    #         print(nc_WIP.ChangeClosedCurveSeam(ts[0]))\r\n    #         sc.doc.Objects.AddCurve(nc_WIP); sc.doc.Views.Redraw(); 1/0\r\n\r\n\r\n    ncs_URBS = nc_WIP.Split(ts)\r\n\r\n    if bExplode:\r\n        return ncs_URBS, None\r\n\r\n    pcs = rg.Curve.JoinCurves(ncs_URBS, joinTolerance=1e-6, preserveDirection=True)\r\n\r\n    if len(pcs) != 1:\r\n        raise Exception(\"{} curves returned from Curve.JoinCurves.\".format(len(pcs)))\r\n\r\n    pc_Res = pcs[0]\r\n\r\n    if not bNurbs_NotPoly:\r\n        return [pc_Res], None\r\n\r\n    nc_Out = pc_Res.ToNurbsCurve()\r\n    pc_Res.Dispose()\r\n\r\n    return [nc_Out], None\r\n\r\n\r\ndef processCurveObject(rhCrv_In, bExplode, bNurbs_NotPoly, bDeleteInput, bEcho=True, bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    if isinstance(rhCrv_In, rd.ObjRef):\r\n        rgCrv_In = rhCrv_In.Curve()\r\n        if rgCrv_In is None:\r\n            return [], \"Curve could not be obtained from ObjRef.\"\r\n        bDeleteInput = False\r\n    elif isinstance(rhCrv_In, rd.CurveObject):\r\n        rgCrv_In = rhCrv_In.CurveGeometry\r\n        if rgCrv_In is None:\r\n            return [], \"Curve could not be obtained from CurveObject.\"\r\n    else:\r\n        raise Exception(\"{} was passed to processCurveObject\".format(rgCrv_In.GetType().Name))\r\n    # rdCrv_In = rs.coercerhinoobject(rhCrv_In) # IsDocumentControlled.\r\n    # rgCrv_In = rdCrv_In.Geometry # IsDocumentControlled.\r\n\r\n    cs_Res, sLog = createCrvs(\r\n        rgCrv_In,\r\n        bExplode=bExplode,\r\n        bNurbs_NotPoly=bNurbs_NotPoly,\r\n        bDebug=bDebug,\r\n        )\r\n    if len(cs_Res) == 0:\r\n        return [], [] if sLog is None else [sLog]\r\n\r\n    gOuts = []\r\n    sOuts = []\r\n\r\n    bAllAddSuccess = True\r\n\r\n    if bDeleteInput:\r\n        if len(cs_Res) == 1:\r\n            if not sc.doc.Objects.Replace(objectId=rdCrv_In.Id, curve=cs_Res[0]):\r\n                sOut = \"Replace failed.\"\r\n                if bEcho: print(sOut)\r\n                return None, sOut\r\n            sOuts.append(\"Curve was replaced\")\r\n        else:\r\n            for c in cs_Res:\r\n                gOut = sc.doc.Objects.AddCurve(c)\r\n                if gOut != gOut.Empty:\r\n                    gOuts.append(gOut)\r\n                    sOuts.append(\"Curve was added.\")\r\n                else:\r\n                    bAllAddSuccess = False\r\n                    sOuts.append(\"AddCurve failed.\")\r\n            if bAllAddSuccess:\r\n                sc.doc.Objects.Delete(rdCrv_In)\r\n                # sOut = \"Curve was replaced.\"\r\n    else:\r\n        # bDeleteInput == False\r\n        for c in cs_Res:\r\n            gOut = sc.doc.Objects.AddCurve(c)\r\n            if gOut != gOut.Empty:\r\n                gOuts.append(gOut)\r\n                sOuts.append(\"Curve was added.\")\r\n            else:\r\n                bAllAddSuccess = False\r\n                sOuts.append(\"AddCurve failed.\")\r\n\r\n    if not bAllAddSuccess:\r\n        return gOuts, sOuts\r\n\r\n    # if sc.doc.Objects.Select(gOut):\r\n    #     sOut += \" and is selected.\"\r\n    # else:\r\n    #     sOut += \" but could not be selected.\"\r\n\r\n    # if bEcho: print(sOut)\r\n\r\n    return gOuts, sOuts\r\n\r\n\r\ndef main():\r\n\r\n    objrefs = getInput()\r\n    if objrefs is None: return\r\n\r\n    bExplode = Opts.values['bExplode']\r\n    bNurbs_NotPoly = Opts.values['bNurbs_NotPoly']\r\n    bDeleteInput = Opts.values['bDeleteInput']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n    gCrvs_Res = []\r\n    sLogs = []\r\n\r\n    for objref in objrefs:\r\n        gCrvs_Ret, sLogs_Ret = processCurveObject(\r\n            objref,\r\n            bExplode=bExplode,\r\n            bNurbs_NotPoly=bNurbs_NotPoly,\r\n            bDeleteInput=bDeleteInput,\r\n            bEcho=bEcho if len(objrefs) == 1 else False,\r\n            bDebug=bDebug,\r\n            )\r\n        gCrvs_Res.extend(gCrvs_Ret)\r\n        sLogs.extend(sLogs_Ret)\r\n\r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n    if bEcho and sLogs:\r\n        if len(sLogs) == 1:\r\n            print(sLogs[0])\r\n        else:\r\n            for sLog in set(sLogs):\r\n                print(\"[{}] {}\".format(sLogs.count(sLog), sLog))\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}