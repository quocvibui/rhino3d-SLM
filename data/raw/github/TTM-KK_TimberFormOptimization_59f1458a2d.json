{
  "source_url": "https://github.com/TTM-KK/TimberFormOptimization/blob/a728057ff3bfbfb7995b309e835a6278a6e86fcc/Main_test1.py",
  "repo": "TTM-KK/TimberFormOptimization",
  "repo_stars": 0,
  "repo_description": "This is a Form Generate Project, using non preform timber.",
  "license": "unknown",
  "filepath": "Main_test1.py",
  "instruction": "Main test1",
  "code": "# -*- coding:utf-8 -*-\n\nfrom Generate import Generate\nimport rhinoscriptsyntax as rs\nimport time\nfrom operator import itemgetter\n# import copy\n# import random as rnd\nimport sys\nfrom forMain import Sort\nfrom forMain import timberMethod\nfrom forMain import Instance\nfrom forMain import MoveObject\nimport Rhino.Geometry\nimport scriptcontext\nfrom forMain import drawInformatinon\n# from matplotlib import pyplot\nimport GA.Selection\nimport GA.Evaluation\nimport GA.Crossover\nimport GA.Method\nimport ReGenerate\nfrom gc import collect\n\n\nnum_timber = 10  # timberの総本数\nnum_base_timber = 3\ncantilever_num = 4  # 初期生成時の全体の中でのcantileverの数\nbridge_num = 3\n\ndivide_range = 3  # 次世代に継承する材の最低本数を指定\npop_num = 3  # 初期個体数。世代ごとの個体数　ttm add 181003\nelite_num = 1  # エリート選択における選択数。\ngeneration_num = 2  # 世代数\n\ntournament_size = 2  # トーナメントサイズ\ntournament_num = 1  # トーナメント選択の回数\nmutation_ratio = 20  # 突然変異の確率\ninitial_population_draw = False\nflag_high = True  # ソート昇順の場合True　降順の場合False\n\nconnect_count = 10  # 接合制約数\nid_list = []  # timberのid\npop_size = pop_num  # 交叉時に生成する個体数\ngenerate_range = 3000  # 生成可能範囲を指定。（現在は立方体） TODO 立方体以外にも対応したいところ。\nbetween_draw_rhino = generation_num  # generation_numを割り切れる数で指定すること。\n\nevaluate_list = []  # 各世代の評価値を保存しておくためのリスト\n# temp_center_line = []   # 複製した中心線のリスト\n# temp_surface = []       # 複製したサーフェスのリスト\n# temp_mark = []\ntimber_num = []  # Timberクラスの各インスタンスの通し番号を格納するリスト\nnew_gene_num_list = []\n\n# 制約条件\nlimit_degree = [45, 135]  # 接合角度制約\n\n# boolean\ninput_flag = False  # 再生成アルゴリズム用　デバック時に使用すると便利\nredraw_flag = False  # 描画を逐一見るためのフラグ。重くなると思うから普段はFalseで\ninformation_flag = False\nlayer_flag = False\n\nrs.AddLayer('all_pop_layer')\nrs.CurrentLayer('all_pop_layer')\n\n# Step0: rhino上のオブジェクトを取得。また通し番号を作成する。\nget_center_line = rs.GetObjects(\"select %s lines\" % num_timber, rs.filter.curve)\nget_surface = rs.GetObjects(\"Select %s Surfaces\" % num_timber, rs.filter.surface)\nget_obj = Sort.scanObjectSort(num_timber, get_center_line, get_surface)\n\nprogram_start = time.time()\n\n# メンバ変数に格納する\ncenter_line = get_obj[0]\nall_surface = get_obj[1]\n# all_mark = get_obj[2]\n\nfor i in range(0, num_timber):\n    id_list.append(i)\n\n# Step1: サーフィスと中心線を（個体数*Timberの種類）だけ複製。後でインスタンス変数に取り込むため、リストに格納する\ntemp_center_line = Instance.axis_instance(pop_num, center_line)\ntemp_surface = Instance.surface_instance(pop_num, all_surface)\n# temp_mark = inst.mark_instance(pop_num, all_mark)\n\n# print(\"temp_surface\", temp_surface)\n# print(\"temp_center_line\", temp_center_line)\n\n\n# Step2: Generateクラスのインスタンスを個体数だけ作成\ndic = {}\nfor foo in range(pop_num):\n    dic['generate' + str(foo)] = foo\n\nfor i in range(pop_num):\n    timber_num.append(i)\n\n# スキャンデータを生成クラスに渡し、インスタンス化\nfor i in range(pop_num):\n    dic['generate' + str(i)] = Generate(temp_center_line[i], temp_surface[i], id_list, num_timber, timber_num[i],\n                                        generate_range)\n\n# 使用し終わったObjectのリスト削除。\ndel get_center_line, get_surface, get_obj, id_list, timber_num\ndel temp_center_line, temp_surface, center_line, all_surface\ncollect()\n\n# Step3: 各Generateクラスのインスタンス毎にTimberクラスのインスタンスを作成\nfor j in range(pop_num):\n    dic['generate' + str(j)].instantiate_timber()  # Timberクラスのインスタンスを作成するGenerateクラスのメソッド\n    dic['generate' + str(j)].population_id = j  # 個体番号を振る\n    # print(\"pop_index\", dic['generate' + str(j)].pop_index)\n\nclosed_curve = rs.GetObjects(\"select closed curves, base timber generated\")\nobjects_curve = []\nif closed_curve:\n    for i in range(len(closed_curve)):\n        curve = rs.coercecurve(closed_curve[i])\n        objects_curve.append(curve)\n        del closed_curve[i]\nelse:\n    raise Exception('select closed curve is Error')\n\n# Step4 初期生成\nt1 = time.time()\nrs.EnableRedraw(False)\nfor i in range(pop_num):\n\n    for j in range(num_base_timber):\n        flag_gl = dic['generate' + str(i)].generate_ground_init(generate_range, objects_curve=objects_curve)\n        if flag_gl:\n            pass\n        else:\n            raise Exception('init_base_generation is fail')\n\n    for j in range(num_base_timber):\n        tim = dic['generate' + str(i)].used_list[j]\n\n        copy_from = Rhino.Geometry.Point3d(0, 0, 0)\n        copy_to = Rhino.Geometry.Point3d((generate_range * 2) * i, - generate_range * 2, 0)\n        vec_move = copy_to - copy_from\n\n        MoveObject.MoveTimberObjects(vec_move, tim)\n\n    for j in range(cantilever_num):\n        flag_canti = dic['generate' + str(i)].cantilever(limit_degree)\n        if flag_canti:\n            pass\n        else:\n            raise Exception('cantilever is fail')\n\n    for j in range(bridge_num):\n        flag_bridge = dic['generate' + str(i)].bridge(limit_degree)\n        if flag_bridge:\n            pass\n        else:\n            raise Exception('bridge is fail')\n\n    print('success : %s' % i)\n\n# 初期個体が分裂していないか確認。\n# for i in range(pop_num):\n#     pop = dic['generate' + str(i)]\n#     flag_divide = GA.Method.confirm_pop_divide(num_timber, pop)\n#     print(\"flag_divide : %s  Time: '{0}'\".format(flag_divide))\n\n\n# Rhinoに描画されるオブジェクとに置き換える。\nif initial_population_draw:\n    drawInformatinon.draw_rhino_object(pop_num, num_timber, dic)\n\nt2 = time.time()\ninit_generation_time = t2 - t1  # time of Initial Generate\nprint(\"\\n\")\nprint(\"init generation time: %s\" % init_generation_time)\n\n\nrs.Redraw()\n\n\n# 指定した世代数GAのループを繰り返す。\n# ----------------------------------------------------------------------------------------------------------------------\nfor main_loop in range(generation_num):\n\n    # Step6:  # EVALUATION　評価\n    evaluation_value = []  # 一世代分の評価値を格納するリスト\n    t3 = time.time()\n    for i in range(pop_num):\n        instance_pop = dic['generate' + str(i)]\n\n        # 評価関数　一個体ずつ評価値が帰ってくるように設計すること。\n        # evaluate_value = GA.Evaluation.overlap_num2(num_timber, instance_pop)\n        # evaluate_value = GA.Evaluation.partner_num_evaluate(num_timber, instance_pop, 2, 10)\n        # evaluate_value = GA.Evaluation.pop_height_evaluate(num_timber, instance_pop)\n        evaluate_value = GA.Evaluation.pop_evaluation(num_timber, instance_pop, main_loop, generate_range,\n                                                      generation_num)\n\n        dic['generate' + str(i)].evaluation = evaluate_value\n        evaluation_value.append(dic['generate' + str(i)].evaluation)\n\n    evaluate_list.append(evaluation_value)  # 全世代の評価値を格納するリスト\n\n    t4 = time.time()\n    print(\"\\n\")\n    print(\"Result of EVALUATION --- Generation : %s  Result : %s\" % (main_loop, evaluation_value))\n    print(\"Evaluation Time: %s\" % (t4 - t3))\n\n    # Step7:  # SELECTION  選択\n    selected_id_list = []\n    sort_generate_instance_list = []  # Genarateクラスインスタンスのリストを作成する。\n    for i in range(pop_num):\n        sort_generate_instance_list.append(dic['generate' + str(i)])\n\n    # リスト内のクラスインスタンスの保持する評価値に従いソートを行う\n    if flag_high:\n        GA.Selection.sort_high(sort_generate_instance_list)\n    else:\n        GA.Selection.sort_low(sort_generate_instance_list)\n\n    # elite selection\n    GA.Selection.eliteSelection(elite_num, sort_generate_instance_list, selected_id_list)\n\n    # print('elite', selected_id_list)\n\n    # tournament selection\n    GA.Selection.tournamentSelection_min(tournament_size, tournament_num, sort_generate_instance_list, selected_id_list)\n\n    # print('tornament', selected_id_list)\n    # 一旦削除\n    del sort_generate_instance_list\n\n    # メモリ負担減のため、surfaceとcenter_lineを開放。\n    for i in range(pop_num):\n        if i not in selected_id_list:\n            for j in range(num_timber):\n                dic['generate' + str(i)].used_list[j].surface = None\n                dic['generate' + str(i)].used_list[j].center_line = None\n    collect()\n\n    # Step8: 交叉　再生成　\n    # 更新用リスト各位\n\n    temp_list_center_for_next_generation = [[[] for i in range(num_timber)] for j in range(pop_num)]\n    temp_list_srf_for_next_generation = [[[] for i in range(num_timber)] for j in range(pop_num)]\n    temp_list_select_domain_list_for_next_generation = [[[] for i in range(num_timber)] for j in range(pop_num)]\n    list_temp_partner_tim = [[[] for i in range(num_timber)] for j in range(pop_num)]  # partner_tim更新用のリストを作成\n    # list_temp_gene_tim = []  # 次世代の遺伝子更新用リスト\n\n    # 前世代のpartner_timを保存する。\n    list_partner_tim_prior_generation = [[[] for i in range(num_timber)] for j in range(pop_num)]  # 前世代のpartner_timを保存。\n    for i in range(pop_num):\n        for j in range(num_timber):\n            for k in range(num_timber):\n                if dic['generate' + str(i)].used_list[k].id == j:\n                    list_partner_tim_prior_generation[i][j].extend(dic['generate' + str(i)].used_list[k].partner_tim)\n                    break\n    # print(\"list_partner_tim_prior_generation\", list_partner_tim_prior_generation)\n\n    # 現世代の再生成開始。\n    # ------------------------------------------------------------------------------------------------------------------\n    for loop in range(pop_size):\n\n        pop_generate_start_time = time.time()\n\n        pop_regenerate = dic['generate' + str(loop)]\n\n        print(\"\\n\")\n        print(\"start regeneration No.%s\" % loop)\n        print(\"------------------------------------------------------------\")\n\n        # decide the 2 crossover point\n        # divide_point1, divide_point2 = GA.Crossover.selectDividePoints(num_timber, divide_range)\n\n        # Get the index in the 'selected_list' of the individual used for crossover\n        pop_1_id, pop_2_id = GA.Crossover.select2Poplation(selected_id_list)\n\n        # print(pop_1_id)\n        # print(pop_2_id)\n        pop_1 = dic['generate' + str(pop_1_id)]\n        pop_2 = dic['generate' + str(pop_2_id)]\n\n        # 2点交叉　Generateクラス変数の更新とlist_temp_gene_timに新しく生成した遺伝子情報をappendする。 継承する材の番号が格納されたリストをreturnする\n        # already_regenerate = GA.Crossover.two_point_crossover(num_timber, divide_range, pop_1, pop_2)\n        pop_regenerate.already_regenerate_tim_id = GA.Crossover.random_chunk_crossover(num_timber, divide_range, pop_1)\n\n        # pop_2に関して継承する材を決定するアルゴリズム add\n        decide_inheritance_num_list, connect_list = GA.Method.decide_inheritance_tim_connected(pop_1, pop_2, pop_regenerate.already_regenerate_tim_id,\n                                                                                      generate_range)\n        # print('\\n')\n        # print('connect_list', connect_list)\n\n        # print(\"decide_inheritance_num_list %s\"%(decide_inheritance_num_list))\n\n        # 個体の保持する要素の保存。　　一旦pop_1をコピーしてオブジェクトを保存する。一つの個体生成がおわったら元に戻す。\n        list_srf_temp = []\n        list_center_line_temp = []\n        list_select_domain_temp = []\n        GA.Method.saveInstanceInformation(num_timber, pop_1, list_srf_temp, list_center_line_temp,\n                                          list_select_domain_temp)\n\n        # pop_2のTimber、select_domain_listのDomainを更新する  add 190218\n        GA.Method.RenewalPop2(pop_1, pop_2, decide_inheritance_num_list)\n\n        # select_domain_listの更新。　形態を引き継いでいる材の接合ドメインの更新を行う。前世代では使用していたが、空席になるドメインが生じるはずなので\n        GA.Method.selectDomainRenewal(pop_regenerate.already_regenerate_tim_id, num_timber, pop_1)\n\n        # select_domain_listの更新2.\n        GA.Method.selectDomainRenewal2(decide_inheritance_num_list, num_timber, pop_1)\n\n        # partnerの更新ミスがないかチェック\n        for i in range(num_timber):\n            for j in range(len(list_temp_partner_tim[loop][i])):\n                if list_temp_partner_tim[loop][i][j] == i:\n                    raise Exception('miss renewal partner_tim')\n\n        for i in range(num_timber):\n            for j in range(len(list_temp_partner_tim[loop][i])):\n                if list_temp_partner_tim[loop][i][j] == i:\n                    raise Exception('miss renewal partner_tim')\n\n        # そのまま継承する材をMoveObjectでコピー、partnerを更新する\n        GA.Method.move_and_pop_update_for_already(pop_regenerate.already_regenerate_tim_id, pop_1, generate_range, generation_num, between_draw_rhino,\n                                       main_loop, loop, list_temp_partner_tim)\n\n        for i in range(num_timber):\n            for j in range(len(list_temp_partner_tim[loop][i])):\n                if list_temp_partner_tim[loop][i][j] == i:\n                    raise Exception('miss renewal partner_tim')\n\n        # そのまま継承する材をMoveObjectでコピーし、partnerを更新する。　add 190220\n        GA.Method.move_and_pop_update_for_inheritance(decide_inheritance_num_list, pop_1, pop_2, generate_range, generation_num,\n                                        between_draw_rhino, main_loop, loop, list_temp_partner_tim)\n\n        for i in range(num_timber):\n            for j in range(len(list_temp_partner_tim[loop][i])):\n                if list_temp_partner_tim[loop][i][j] == i:\n                    raise Exception('miss renewal partner_tim')\n\n        # pop_2の材の位相関係を継承しながら再生成を行う。\n        # for i in range(len(connect_list)):\n        #     index = decide_inheritance_num_list.index(connect_list[i][0])\n        #     del decide_inheritance_num_list[index]\n        #     already_regenerate.append(connect_list[i][0])\n        # print('check del inheritance form', decide_inheritance_num_list)\n\n        pop_regenerate.already_regenerate_tim_id.extend(decide_inheritance_num_list)  # add 190220\n        # print('check already_regenerate', already_regenerate)\n        # print(\"already_regenerate_list : %s\"%(already_regenerate))\n        # for i in range(len(connect_list)):\n        #     decide_inheritance_num_list.append(connect_list[i][0])\n        pop_regenerate.yet_regenerate_tim_id = []\n        for i in range(num_timber):\n            if i in pop_regenerate.already_regenerate_tim_id:\n                pass\n            else:\n                pop_regenerate.yet_regenerate_tim_id.append(i)\n\n        # yet_regenerate.extend(pop_1.temp_yet_regenerate)\n\n        # print(\"before yet_regenerate_list : %s\"%(yet_regenerate))  # add 190220\n        # for ex in range(len(decide_inheritance_num_list)):\n        #     index_ex = yet_regenerate.index(decide_inheritance_num_list[ex])\n        #     yet_regenerate.pop(index_ex)\n        # print(\"after yet_regenerate_list : %s\" % (yet_regenerate))\n\n        # partner_timの確認　check_timber_partner3と一致している必要がある。\n        # check_timber_partner1 = []\n        # for i in range(num_timber):\n        #     for j in range(num_timber):\n        #         if pop_1.used_list[j].name == i:\n        #             check_timber_partner1.append(pop_1.used_list[j].partner_tim)\n        #             break\n\n        # print(\"check_timber_partner1\", check_timber_partner1)\n\n        # connect_listの接合関係をlist_temp_partner_timに組み込む。\n        for i in range(len(connect_list)):\n            tim_id = connect_list[i][1]\n            list_temp_partner_tim[loop][tim_id].append(connect_list[i][0])\n            list_temp_partner_tim[loop][connect_list[i][0]].append(connect_list[i][1])\n\n        for i in range(num_timber):\n            for j in range(len(list_temp_partner_tim[loop][i])):\n                if list_temp_partner_tim[loop][i][j] == i:\n                    raise Exception('miss renewal partner_tim')\n\n        # pop1のpartner_listを更新する。\n        for i in range(num_timber):\n            for j in range(num_timber):\n                if pop_1.used_list[i].id == j:\n                    pop_1.used_list[i].partner_tim = []\n                    pop_1.used_list[i].partner_tim.extend(list_temp_partner_tim[loop][j])\n                    break\n\n        # 再生成されていないことになった部材のpartner_timを空リストにする。\n        for i in range(len(pop_regenerate.yet_regenerate_tim_id)):\n            tim_id = pop_regenerate.yet_regenerate_tim_id[i]\n            for j in range(num_timber):\n                if pop_1.used_list[j].id == tim_id:\n                    pop_1.used_list[j].partner_tim = []\n\n\n        regenerate_start = time.time()\n        # 再生成のプロセス\n        ReGenerate.regenerate(pop_regenerate.already_regenerate_tim_id, pop_regenerate.yet_regenerate_tim_id, pop_1, pop_2, num_timber, limit_degree,\n                              generation_num, main_loop, loop, between_draw_rhino, list_temp_partner_tim,\n                              mutation_ratio)\n        regenerate_end = time.time()\n        regenerate_time = regenerate_end - regenerate_start\n\n        print(\"Regenerate Time: {0}  Pop No.{1} Generation {2}\".format(regenerate_time, loop, main_loop))\n\n        # TODO 再生成した個体がバラバラに成っていないか確認するアルゴリズムを記述する。\n        # t1_flag_divede = time.time()\n        # flag_divide = GA.Method.confirm_pop_divide(num_timber, pop_1)\n        # t2_flag_divide = time.time()\n\n        # Generateクラスインスタンス変数の更新\n        # 戻す。　　次世代の個体生成前に保持していたGenerateクラスの変数に戻す。\n        GA.Method.RenewalInstanceInformationSameGeneration(pop_1, temp_list_srf_for_next_generation,\n                                                           temp_list_center_for_next_generation,\n                                                           temp_list_select_domain_list_for_next_generation,\n                                                           list_srf_temp, list_center_line_temp,\n                                                           list_select_domain_temp, loop)\n\n        del list_srf_temp, list_center_line_temp\n        collect()\n\n        # pop_1のpartner_timを再生成前の状態に戻す。\n        for i in range(num_timber):\n            for j in range(num_timber):\n                if pop_1.used_list[i].id == j:\n                    pop_1.used_list[i].partner_tim = []\n                    pop_1.used_list[i].partner_tim.extend(list_partner_tim_prior_generation[pop_1.population_id][j])\n                    break\n\n        pop_generate_end_time = time.time()\n        cul_time = pop_generate_end_time - pop_generate_start_time\n\n        print('GENERATION: {}  POP: {}  TIME: {}'.format(main_loop, pop_regenerate.population_id, cul_time))\n\n        # print(\"list_temp_partner_tim\", list_temp_partner_tim)\n        # input(\"stop\")\n\n    # 全個体のGenerateインスタンス変数を更新する。\n    # srf, center_lineの更新\n    for i in range(pop_num):\n        for j in range(num_timber):\n            name_tim = dic['generate' + str(i)].used_list[j].id\n            # print(\"name_tim\", name_tim)\n            dic['generate' + str(i)].used_list[j].center_line = None  # listで問題ないっぽい\n            dic['generate' + str(i)].used_list[j].center_line = temp_list_center_for_next_generation[i][name_tim]\n\n            dic['generate' + str(i)].used_list[j].surface = None\n            dic['generate' + str(i)].used_list[j].surface = temp_list_srf_for_next_generation[i][name_tim]\n\n    #  partner_tim　の更新\n    for i in range(pop_num):\n        for j in range(num_timber):\n            for k in range(num_timber):  # TODO\n                if dic['generate' + str(i)].used_list[j].id == k:\n                    dic['generate' + str(i)].used_list[j].partner_tim = []\n                    dic['generate' + str(i)].used_list[j].partner_tim.extend(list_temp_partner_tim[i][k])\n\n            # print(\"update partner_tim\", dic['generate' + str(i)].used_list[j].partner_tim)\n\n            # 中心線を更新しているので、リスト内の値を更新するb\n            # print(\"check error\", dic['generate' + str(i)].used_list[j].center_line)\n            dic['generate' + str(i)].used_list[j].measure_length()\n\n    # tim_distance の更新\n    for i in range(pop_num):\n        for j in range(num_timber):\n            for k in range(num_timber):\n                if k != j:\n                    timberMethod.distanceBetweenTimber_RhinoCommon(dic['generate' + str(i)].used_list[j],\n                                                                   dic['generate' + str(i)].used_list[k])\n                else:\n                    dic['generate' + str(i)].used_list[j].tim_distance[dic['generate' + str(i)].used_list[j].id] = []\n                    continue\n\n    # # gene_information の更新\n    # for i in range(pop_num):\n    #     dic['generate' + str(i)].gene_info = []\n    #     dic['generate' + str(i)].gene_info.extend(list_temp_gene_tim[i])\n\n    # select_domain_listの更新\n    for i in range(pop_num):\n        for j in range(num_timber):\n            dic['generate' + str(i)].used_list[j].select_domain_list = []\n            dic['generate' + str(i)].used_list[j].select_domain_list.extend(\n                temp_list_select_domain_list_for_next_generation[i][dic['generate' + str(i)].used_list[j].id])\n\n    del temp_list_center_for_next_generation, temp_list_srf_for_next_generation\n    collect()\n\n# Step10:  EVALUATION\nevaluation_value = []\nt3_1 = time.time()\nfor i in range(pop_num):\n    instance_pop = dic['generate' + str(i)]\n\n    # evaluate_value = GA.Evaluation.overlap_num2(num_timber, instance_pop)\n    # evaluate_value = GA.Evaluation.partner_num_evaluate(num_timber, instance_pop, 2, 3)\n    evaluate_value = GA.Evaluation.pop_evaluation(num_timber, instance_pop, generation_num, generate_range,\n                                                  generation_num)\n\n    dic['generate' + str(i)].evaluation = evaluate_value\n\n    evaluation_value.append(dic['generate' + str(i)].evaluation)\n    # print('evaluation value Pop: %s : value is %s'%(i, dic['generate' + str(i)].evaluation))\nevaluate_list.append(evaluation_value)\n\n\n# 一番適応度が高い個体だけを描画する。ほかはレイヤーに隠す。\neva_high_index = evaluation_value.index(max(evaluation_value))\nfor i in range(pop_num):\n    rs.AddLayer('pop' + str(i))\n\nsort = sorted(evaluation_value, reverse=True)\ndraw_value = sort[:5]\ndraw_index = []\nfor i in range(len(draw_value)):\n    index = evaluation_value.index(draw_value[i])\n    draw_index.append(index)\n\nfor i in range(pop_num):\n    if i in draw_index:\n        for j in range(num_timber):\n            center_line = scriptcontext.doc.Objects.AddCurve(dic['generate' + str(i)].used_list[j].center_line)\n            surface = scriptcontext.doc.Objects.AddBrep(dic['generate' + str(i)].used_list[j].surface)\n            rs.ObjectLayer(center_line, 'pop' + str(i))\n            rs.ObjectLayer(surface, 'pop' + str(i))\n\nfor i in range(pop_num):\n    if i in draw_index:\n        pass\n    else:\n        rs.LayerVisible('pop' + str(i), False)\n\n# rs.CurrentLayer('pop' + str(eva_high_index))\n# rs.LayerVisible('all_pop_layer', False)\n\n\nt4_1 = time.time()\nprint(\"\\n\")\nprint(\"Result of EVALUATION --- Generation : %s  Result : %s\" % (generation_num, evaluation_value))\nprint(\"Evaluation Time: %s\" % (t4_1 - t3_1))\n\n\nprogram_finish = time.time()\nprint(\"\\n\")\nprint(\"EVALUATE : result --- %s\" % evaluate_list)\nprint(\"Processing Time : %s\" % (program_finish - program_start))\n\nfor i in range(pop_num):\n    list = []\n    for j in range(num_timber):\n        temp = []\n        temp.append(dic['generate' + str(i)].used_list[j].id)\n        temp.append(dic['generate' + str(i)].used_list[j].partner_tim)\n\n        list.append(temp)\n\n    list.sort(key=itemgetter(0))\n    print('Pop ID {} : {}'.format(i, list))\n\n# グラフに評価値の推移を描画\ndrawInformatinon.drawEvaluateValue(evaluate_list)\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}