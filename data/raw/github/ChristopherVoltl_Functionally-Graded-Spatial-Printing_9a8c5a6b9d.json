{
  "source_url": "https://github.com/ChristopherVoltl/Functionally-Graded-Spatial-Printing/blob/6b41d41d74c4e17e284adb2d04fbdaa7bf061c01/voxel/voxel.py",
  "repo": "ChristopherVoltl/Functionally-Graded-Spatial-Printing",
  "repo_stars": 2,
  "repo_description": "a computational method for 3D printing functionally graded lattice structures using an industrial robotic arm and finite element analysis, optimizing toolpaths to create lightweight, high-performance parts with varying densities.",
  "license": "MIT",
  "filepath": "voxel/voxel.py",
  "instruction": null,
  "code": "import rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\nimport Rhino.Geometry as rg\r\nimport Rhino.DocObjects as rd\r\nimport math\r\nimport os\r\nimport System\r\nimport System.Collections.Generic\r\nimport Rhino\r\n\r\ndef SampleViewCaptureToFile(name):\r\n    view = sc.doc.Views.ActiveView;\r\n    if view:\r\n        view_capture = Rhino.Display.ViewCapture()\r\n        view_capture.Width = view.ActiveViewport.Size.Width\r\n        view_capture.Height = view.ActiveViewport.Size.Height\r\n        view_capture.ScaleScreenItems = False\r\n        view_capture.DrawAxes = False\r\n        view_capture.DrawGrid = False\r\n        view_capture.DrawGridAxes = False\r\n        view_capture.TransparentBackground = True\r\n        bitmap = view_capture.CaptureToBitmap(view)\r\n        if bitmap:\r\n            bitmap.Save(name, System.Drawing.Imaging.ImageFormat.Png);\r\n\r\n\r\n\r\ndef voxelize_brep(brep, voxel_size, points_guid):\r\n    bbox = rs.BoundingBox(brep)\r\n    if bbox is None:  # Check if bounding box exists\r\n        return None\r\n\r\n    min_pt, max_pt = bbox[0], bbox[6]\r\n    x_span = max_pt.X - min_pt.X\r\n    y_span = max_pt.Y - min_pt.Y\r\n    z_span = max_pt.Z - min_pt.Z\r\n\r\n    x_voxels = int(x_span / voxel_size) + 1\r\n    y_voxels = int(y_span / voxel_size) + 1\r\n    z_voxels = int(z_span / voxel_size) + 1\r\n\r\n    voxels = []\r\n    color = []\r\n    voxel_guids = []\r\n    renderCount = 1\r\n\r\n    for i in range(x_voxels):\r\n        for j in range(y_voxels):\r\n            for k in range(z_voxels):\r\n                x = min_pt.X + i * voxel_size\r\n                y = min_pt.Y + j * voxel_size\r\n                z = min_pt.Z + k * voxel_size\r\n                voxel = rg.Box(rg.Plane.WorldXY, rg.Interval(x, x + voxel_size), rg.Interval(y, y + voxel_size), rg.Interval(z, z + voxel_size))\r\n                voxel_guid = sc.doc.Objects.AddBrep(voxel.ToBrep())\r\n                voxel_guids.append(voxel_guid)\r\n                intersect = rg.Intersect.Intersection.BrepBrep(brep, voxel.ToBrep(), sc.doc.ModelAbsoluteTolerance)\r\n                voxel_brep = voxel.ToBrep()\r\n                \r\n                #calculate the closest point in the to the voxel\r\n                voxel_centroid = rg.AreaMassProperties.Compute(voxel_brep).Centroid\r\n                #closest_point = brep.ClosestPoint(rs.coercebrep(brep_guid))\r\n                coordinates = []\r\n                \r\n                for point in points_guid:\r\n                    coordinates.append(rs.PointCoordinates(point))\r\n                #use that info to extract the info of the point to get the color\r\n                closest_point, point_index = find_closest_point(voxel_centroid, coordinates)\r\n                point_property = get_point_property(points_guid[point_index])\r\n\r\n                voxelCorners = voxel.GetCorners()\r\n                \r\n                #TEST INSIDE BREP ONLY IF THE 8 CORNER POINTS ARE INSIDE THE BREP ******new****\r\n                cornerCount = 0\r\n                for corner in voxelCorners:\r\n                    isPointonSrf = is_point_on_brep(corner, brep)\r\n                    if rg.Brep.IsPointInside(brep, corner, sc.doc.ModelAbsoluteTolerance, True) or isPointonSrf is True:\r\n                        cornerCount+=1\r\n                if cornerCount == 8:\r\n                    rs.ObjectColor(voxel_guid, point_property)\r\n                    voxels.append(voxel)\r\n                    color.append([point_property.R, point_property.G, point_property.B])\r\n                else:\r\n                    print(\"The point is not inside the Brep.\")\r\n                    rs.DeleteObject(voxel_guid)\r\n                \r\n                cornerCount = 0\r\n                '''\r\n                if len(intersect[1]) > 0:\r\n                    rs.ObjectColor(voxel_guid, point_property)\r\n                    voxels.append(voxel)\r\n                    color.append([point_property.R, point_property.G, point_property.B])\r\n\r\n                    location = \"C:/Users/Chris/Desktop/Temp/Voxel/\"\r\n                    name = location + \"Voxel\" + \"000\" + str(renderCount) + \".png\"\r\n                    SampleViewCaptureToFile(name)\r\n                    renderCount = renderCount + 1\r\n                else: \r\n                    #test inside or outside ****old*****\r\n                    if rg.Brep.IsPointInside(brep, voxel_centroid, sc.doc.ModelAbsoluteTolerance, True):\r\n                        print(\"The point is inside the Brep.\")\r\n                        rs.ObjectColor(voxel_guid, point_property)\r\n                        voxels.append(voxel)\r\n                        color.append([point_property.R, point_property.G, point_property.B])\r\n                    else:\r\n                        print(\"The point is not inside the Brep.\")\r\n                        rs.DeleteObject(voxel_guid)\r\n                        '''\r\n\r\n\r\n    return voxels, color, voxel_guids\r\n\r\ndef get_point_property(point):\r\n    \r\n    #If ColorSource is ON::color_from_object, then value of m_color is used.\r\n    color = rs.ObjectColor(point)\r\n    return color\r\n    \r\ndef find_closest_point(target_point, point_set):\r\n    closest_point = None\r\n    closest_point_index = None\r\n    min_distance = float('inf')\r\n\r\n    for i in range(len(point_set)):\r\n        distance = target_point.DistanceTo(point_set[i])\r\n        if distance < min_distance:\r\n            min_distance = distance\r\n            closest_point = point_set[i]\r\n            closest_point_index = i\r\n    \r\n    return closest_point, closest_point_index\r\n    \r\n\r\n\r\ndef toolpath_to_voxel(voxels, color, highdensity, hd_centroid, meddensity, md_centroid, lowdensity, ld_centroid):\r\n    \r\n    for voxel in range(len(voxels)):\r\n      #voxel_guid = sc.doc.Objects.AddBrep(voxels[voxel].ToBrep())\r\n      color[voxel]\r\n      voxel_brep = voxels[voxel].ToBrep()\r\n      print(color[voxel])\r\n      if color[voxel][0] == 255 and color[voxel][1] == 0:\r\n          print(\"meow\")\r\n          voxel_centroid = rg.AreaMassProperties.Compute(voxel_brep).Centroid\r\n          start_point = rs.coerce3dpoint(hd_centroid)\r\n          end_point = rs.coerce3dpoint(voxel_centroid)\r\n          \r\n          vector = rg.Vector3d(end_point - start_point)\r\n          rs.CopyObject(highdensity, vector)\r\n      elif color[voxel][0] == 255 and color[voxel][1] == 255:\r\n          print(\"moo\")\r\n          voxel_centroid = rg.AreaMassProperties.Compute(voxel_brep).Centroid\r\n          start_point = rs.coerce3dpoint(md_centroid)\r\n          end_point = rs.coerce3dpoint(voxel_centroid)\r\n          \r\n          vector = rg.Vector3d(end_point - start_point)\r\n          \r\n          rs.CopyObject(meddensity, vector)\r\n      elif color[voxel][0] == 0 and color[voxel][1] == 255:\r\n          print(\"woof\")\r\n          voxel_centroid = rg.AreaMassProperties.Compute(voxel_brep).Centroid\r\n          start_point = rs.coerce3dpoint(ld_centroid)\r\n          end_point = rs.coerce3dpoint(voxel_centroid)\r\n          \r\n          vector = rg.Vector3d(end_point - start_point)\r\n          \r\n          rs.CopyObject(lowdensity, vector)\r\n\r\n\r\n\r\ndef split_breps_with_breps(breps_to_split, splitting_breps, brep):\r\n    split_breps = []\r\n    splitting_breps = splitting_breps.Surfaces\r\n    for brep_to_split in breps_to_split:\r\n        for splitting_brep in splitting_breps:\r\n            splitting_brep = Rhino.Geometry.Brep.CreateFromSurface(splitting_brep)\r\n            print(brep_to_split)\r\n            if str(brep_to_split) == \"Rhino.Geometry.Box\":\r\n                brep_to_split = rg.Brep.CreateFromBox(brep_to_split)\r\n            intersection_curves = rg.Intersect.Intersection.BrepBrep(brep_to_split, splitting_brep, 0.001)\r\n            if intersection_curves:\r\n                #brep_pieces = (rs.SplitBrep(brep_to_split, splitting_brep))\r\n                brep_pieces = (brep_to_split.CreateBooleanSplit(brep_to_split, splitting_brep, .001))\r\n                    # Check if any pieces were created\r\n                if brep_pieces:\r\n                    #rs.DeleteObject(brep_to_split)\r\n                    for piece in brep_pieces:\r\n                        #test inside or outside\r\n                        piece_centroid = rs.SurfaceVolumeCentroid(rs.coercebrep(piece))\r\n                        if brep.IsPointInside(piece_centroid[0], .001, True):\r\n                            print(\"The point is inside the Brep.\")\r\n                            split_breps.append(rs.coercebrep(piece))\r\n                        else:\r\n                            print(\"The point is not inside the Brep.\")\r\n                            \r\n                        print(\"Brep split successful.\")\r\n                else:\r\n                    print(\"No pieces were created.\")\r\n\r\n    return split_breps, brep_to_split\r\n\r\ndef is_point_on_brep(point, brep):\r\n    \"\"\"\r\n    Check if a point is on any of the surfaces of a Brep.\r\n    \"\"\"\r\n    # Get all the surfaces of the BrepSurfacesfaces\r\n    surfaces = brep.Surfaces\r\n    closesetPoint = brep.ClosestPoint(point)\r\n    distance = point.DistanceTo(closesetPoint)\r\n    if distance < 2:\r\n        return True\r\n    # If the point is not on any surface of the Brep\r\n    return False\r\n\r\n\r\n\r\n\r\n#points_guid = [rs.coerce3dpoint(points_guid) for point_guid in point_guids]\r\nbrep_guid = rs.GetObject(\"Select a Brep\", rs.filter.surface | rs.filter.polysurface)\r\npoints_guid = rs.GetObjects(\"Select points\", rs.filter.point)\r\nvoxel_size = rs.GetReal(\"Enter voxel size\", 2.0)\r\n\r\nrs.HideObject(brep_guid)\r\nrs.HideObject(points_guid)\r\n\r\nvoxels, colors, voxel_guid = voxelize_brep(rs.coercebrep(brep_guid), voxel_size, points_guid)\r\n#toolpath geometry \r\n\r\n\r\n\r\n#rs.HideObjects(voxel_guid)\r\n\r\n#split_voxels, voxels = split_breps_with_breps(voxels, rs.coercebrep(brep_guid), rs.coercebrep(brep_guid))\r\n\r\nhighdensity = rs.GetObjects(\"Pick High Density Toolpath\")\r\nhd_centroid = rs.GetObject(\"Pick High Density centroid\")\r\n\r\nmeddensity = rs.GetObjects(\"Pick Medium Density Toolpath\")\r\nmd_centroid = rs.GetObject(\"Pick Medium Density centroid\")\r\n\r\nlowdensity = rs.GetObjects(\"Pick Low Density Toolpath\")\r\nld_centroid = rs.GetObject(\"Pick Low Density centroid\")\r\n\r\ntoolpath = toolpath_to_voxel(voxels, colors, highdensity, hd_centroid, meddensity, md_centroid, lowdensity, ld_centroid)\r\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": false
}