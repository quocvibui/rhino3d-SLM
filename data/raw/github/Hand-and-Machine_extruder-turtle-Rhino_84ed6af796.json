{
  "source_url": "https://github.com/Hand-and-Machine/extruder-turtle-Rhino/blob/68b9f4a35b6e2ff867de22a4eb8817569858def9/extruder_turtle/turtle_utilities.py",
  "repo": "Hand-and-Machine/extruder-turtle-Rhino",
  "repo_stars": 3,
  "repo_description": null,
  "license": "MIT",
  "filepath": "extruder_turtle/turtle_utilities.py",
  "instruction": "Turtle utilities",
  "code": "import copy\nimport Rhino.Geometry as geom\nimport rhinoscriptsyntax as rs\nimport ExtruderTurtle as e\nimport operator as op\nimport math\nimport random\nimport extruder_turtle\nfrom extruder_turtle import *\n\ndef translate(g,x,y,z):\n\ttranslation = geom.Transform.Translation(x,y,z)\n\tg.Transform(translation)\n\t\ndef rotate(g,angle):\n\tpoint = rs.CurveAreaCentroid(g)[0]\n\trotation = geom.Transform.Rotation(math.radians(angle),point)\n\tg.Transform(rotation)\n\t\ndef scale(g,scale_factor):\n\tpoint = rs.CurveAreaCentroid(g)[0]\n\tscale= geom.Transform.Scale(point,scale_factor)\n\tg.Transform(scale)\n\n# versions of transformations that do not alter input shape\ndef translate_copy(g,x,y,z):\n\tshape = copy.deepcopy(g)\n\ttranslation = geom.Transform.Translation(x,y,z)\n\tshape.Transform(translation)\n\treturn shape\n\t\ndef rotate_copy(g,angle):\n\tshape = copy.deepcopy(g)\n\trotation = geom.Transform.Rotation(math.radians(angle),rs.CreatePoint(0,0,0))\n\tshape.Transform(rotation)\n\treturn shape\n\t\ndef scale_copy(g,scale_factor):\n\tshape = copy.deepcopy(g)\n\tscale= geom.Transform.Scale(rs.CreatePoint(0,0,0),scale_factor)\n\tshape.Transform(scale)\n\treturn shape\n\n# generates a surface of size*2 squared\n# around the origin at height z\ndef surface_for_slice(z,size):\n\tpoints = []\n\tpoints.append(rs.CreatePoint(-size,-size,z))\n\tpoints.append(rs.CreatePoint(-size,size,z))\n\tpoints.append(rs.CreatePoint(size,size,z))\n\tpoints.append(rs.CreatePoint(size,-size,z))\n\tplane = rs.AddSrfPt(points)\n\treturn plane\n\ndef convex_hull(points):\n\tstart = a\n\thull_points = []\n\tlines = []\n\twhile a:\n\t\to = a\n\t\ta = points[0]\n\t\tfor b in points:\n\t\t\tif (a[0]-o[0])*(b[1]-o[1])-(a[1]-o[1])*(b[0]-o[0]) < 0: a = b\n\t\tlines.append(rs.AddLine(o,a))\n\t\thull_points.append(o)\n\t\tif (a == start): \n\t\t\tbreak\n\treturn lines, hull_points\n\ndef mix_factor_metal(t):\n\tt.do(\"M163 S0 P0.96; Set Mix Factor small auger extruder \\nM163 S1 P0.04; Set Mix Factor large plunger extruder\\nM164 S0 ; Finalize mix\")\n\t\n\n# slices a solid (shape)\ndef slice_solid (shape, layer_height):\n\tbb = rs.BoundingBox(shape)\n\theight = rs.Distance(bb[0], bb[4])\n\tlayers = int(height/layer_height)\n\tsize = rs.Distance(bb[0], bb[2])*2\n\tslices = []\n\tz = layer_height\n\tfor i in range (1,layers+1):\n\t\tslice = one_slice(shape,z,size)\n\t\tif (slice):\n\t\t\tslices.append(slice)\n\t\tz = z+layer_height\n\treturn slices\n\n# creates one slice of a shape at height z\ndef one_slice(shape,z,size,plane = False):\n\tif (plane==False):\n\t\tplane = surface_for_slice(z,size)\n\tintersection = rs.BooleanIntersection(plane, shape, delete_input=False)\n\tif (intersection):\n\t\tsurfaces = rs.ExplodePolysurfaces(intersection, delete_input=False)\n\telse:\n\t\treturn\n\tif (len(surfaces)>1):\n\t\tcurves = rs.DuplicateEdgeCurves(surfaces[2])\n\t\tif (len(curves)>1):\n\t\t\tcurves = rs.JoinCurves(curves)\n\t\treturn curves[0]\n\n# slices a shape using layer_height\ndef slice_with_turtle (t, shape, walls = 1, layer_height=False, spiral_up=False, bottom = False, start_layer=0, layers=10000):\n\tif (layer_height==False or layer_height == 0):\n\t\tlayer_height = t.get_layer_height()\n\tbb = rs.BoundingBox(shape)\n\theight = rs.Distance(bb[0], bb[4])\n\tprint(\"height: \" +str(height))\n\tlayers = int(round(height/layer_height)) # number of slices\n\tprint(\"layers: \" +str(layers))\n\tsize = rs.Distance(bb[0], bb[6])*2 # size of slicing plane\n\tpoint_bottom = (rs.CreatePoint(0,0,bb[0].Z))\n\tpoint_top = (rs.CreatePoint(0,0,bb[4].Z))\n\t\n\t#slices\n\tslices = rs.AddSrfContourCrvs(shape,(point_bottom,point_top),layer_height)\n\n\t#follow slice curves with turtle\n\t#follow_slice_curves_with_turtle(t,slices,walls=walls,spiral_up=spiral_up, bottom=bottom, start_layer=start_layer, layers=10000)\n\n\treturn slices\n\n# generates a turtle path and g-code that slices a solid (shape)\n# optional number of walls, walls are offset into interior of shape\ndef slice_with_turtle_2 (t, shape, walls = 1, layer_height=False, spiral_up=False):\n\tif (layer_height==False or layer_height == 0):\n\t\tlayer_height = t.get_layer_height()\n\n\tbb = rs.BoundingBox(shape)\n\theight = rs.Distance(bb[0], bb[4])\n\tlayers = int(round(height/layer_height)) # number of slices\n\tsize = rs.Distance(bb[0], bb[6])*2 # size of slicing plane\n\tslices = []\n\tz = bb[0].Z\n\n\tslice = one_slice(shape,z,size)\n\tif (slice==False):\n\t\tprint(\"Slicing error. Move your shape closer to the origin for slicing.\")\n\t\treturn\n\n\t#generate slice curves\n\tfor i in range (0,layers+1):\n\t\tslice = one_slice(shape,z,size)\n\t\tif (slice):\n\t\t\tslices.append(slice)\n\t\tz = z+layer_height\n\n\t#slice the top layer\n\tz = height\n\tslice = one_slice(shape,z,size)\n\tif (slice):\n\t\tslices.append(slice)\n\n\tif (bottom and len(slices)>0):\n\t\tspiral_bottom(t,slices[0])\n\t\tt.lift(layer_height)\n\n\tlayers = len(slices)\n\t#follow slice curves with turtle\n\tfollow_slice_curves_with_turtle(t,slices,walls=walls,spiral_up=spiral_up)\n\n\tprint(\"number of slices of layer_height tall is: \" +str(len(slices)))\n\treturn slices\n\ndef max_distance_between_slices(points0,points1):\n\tmaxd = 0\n\tfor i in range (0, len(points0)):\n\t\tdistance = rs.Distance(points0[i],points1[i])\n\t\tif (distance > maxd):\n\t\t\tmaxd = distance\n\treturn maxd\n\n# slices a shape with an equal distance between layers\n# calculates distance based on maximum total distance \n# (vertical and horizontal) between layers\ndef slice_with_turtle_even_layers (t, shape, walls = 1, layer_height=False, bottom=False, spiral_up=False):\n\tif (layer_height==False or layer_height == 0):\n\t\tlayer_height = t.get_layer_height()\n\n\tnum_comparison_points = 2\n\tbb = rs.BoundingBox(shape)\n\theight = rs.Distance(bb[0], bb[4])\n\tbottom_z = bb[0].Z\n\ttop_z = bb[4].Z\n\tsize = rs.Distance(bb[0], bb[6])*2 # size of slicing plane = diagonal*2\n\tslices = []\n\tz = bottom_z\n\tprint(\"z: \" +str(z))\n\tp0 = bb[0]\n\tp1 = rs.CreatePoint(bb[0].X,bb[0].Y,z+.1)\n\tslice = rs.AddSrfContourCrvs(shape,(p0,p1),layer_height)\n\n\t#slice = one_slice(shape,z,size)\n\tif (slice):\n\t\tpoints = rs.DivideCurve (slice[len(slice)-1], num_comparison_points)\n\telse: \n\t\tprint(\"Slicing error. Move your shape closer to the origin for slicing.\")\n\t\treturn\n\n\t#generate slice curves\n\tcount_main = 0\n\twhile (z < top_z and count_main <100):\n\t\tprint(\"z: \" +str(z))\n\t\t# measure max distance between point this slice & previous slice\n\t\t# calculate z based on that distance\n\t\tnew_layer_height = 0\n\t\tprevious_points = copy.deepcopy(points)\n\t\tp0 = rs.CreatePoint(bb[0].X,bb[0].Y,z)\n\t\tp1 = rs.CreatePoint(bb[0].X,bb[0].Y,z+layer_height)\n\t\tslice = rs.AddSrfContourCrvs(shape,(p0,p1),layer_height)\n\t\tif (slice):\n\t\t\tpoints = rs.DivideCurve (slice[len(slice)-1], num_comparison_points)\n\n\t\tmaxd = max_distance_between_slices(previous_points,points)\n\t\tdesired_distance = layer_height*1.0\n\t\tprint(\"maxd: \" +str(maxd))\n\t\tif (maxd>desired_distance): # generate a new slice\n\t\t\tprint(\"generating new slice at layer: \" +str(count_main))\n\t\t\ttheta = math.asin(layer_height/maxd)\n\t\t\tnew_layer_height = math.sin(theta)*desired_distance\n\t\t\tprint(\"new layer height: \" +str(new_layer_height))\n\t\t\tp0 = rs.CreatePoint(bb[0].X,bb[0].Y,z)\n\t\t\tp1 = rs.CreatePoint(bb[0].X,bb[0].Y,z+new_layer_height)\n\t\t\tslice = rs.AddSrfContourCrvs(shape,(p0,p1),new_layer_height*2)\n\t\t\tpoints = rs.DivideCurve (slice[len(slice)-1], num_comparison_points)\n\n\t\t# if you're close to the top of the shape\n\t\t# make sure you account for thinner layers\n\t\tif (z+layer_height >= top_z-layer_height):\n\t\t\tprint(\"top slice\")\n\t\t\tif (new_layer_height):\n\t\t\t\tif (z+new_layer_height < top_z):\n\t\t\t\t\tz = z+new_layer_height\n\t\t\t\telse:\n\t\t\t\t\tprint(\"very top\")\n\t\t\t\t\tslices = slices + slice\n\t\t\t\t\tz0 = bb[4].Z -.05\n\t\t\t\t\tz = bb[4].Z+.05\n\t\t\t\t\tp0 = rs.CreatePoint(bb[0].X,bb[0].Y,z0)\n\t\t\t\t\tp1 = rs.CreatePoint(bb[0].X,bb[0].Y,z)\n\t\t\t\t\tslice = rs.AddSrfContourCrvs(shape,(p0,p1),new_layer_height)\n\t\t\t\t\tslices.append(slice[len(slice)-1])\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tz = z+layer_height/2\n\n\t\telse:\n\t\t\tif (new_layer_height>0):\n\t\t\t\tprint(\"adding new layer height\")\n\t\t\t\tz = z+new_layer_height\n\t\t\telse:\n\t\t\t\tprint(\"adding normal layer height\")\n\t\t\t\tz = z+layer_height\n\n\t\t#print(\"new distance: \" +str(maxd))\n\t\tif (slice):\n\t\t\tprint(\"number new slices: \" + str(len(slice)))\n\t\t\tslices.append(slice[len(slice)-1])\n\n\t\tcount_main = count_main + 1\n\t'''\n\t#slice the top layer\n\tz = bb[7].Z-.01\n\tp0 = rs.CreatePoint(bb[0].X,bb[0].Y,z)\n\tp1 = rs.CreatePoint(bb[0].X,bb[0].Y,z+layer_height)\n\tslice = rs.AddSrfContourCrvs(shape,(p0,p1),layer_height)\n\t#slice = one_slice(shape,z,size)\n\tif (slice):\n\t\tslices = slices + slice\n\telse:\n\t\tprint(\"final slice failed\")\n\t'''\n\treturn slices\n\n\tfollow_slice_curves_with_turtle(t,slices,walls=walls,spiral_up=spiral_up)\n\n\tprint(\"number of equal distanced slices is: \" +str(len(slices)))\n\treturn slices\n\n# given a list of curves that slice a shape (slices)\n# follow the curves with the turtle\ndef follow_slice_curves_with_turtle(t,slices,walls=1, bottom = False, spiral_up=False, matrix = False, start_layer=0, layers=10000):\n\tresolution = t.get_resolution()\n\n\tif (bottom!=False):\n\t\tbottom_layers = bottom\n\telse:\n\t\tbottom_layers = 0\n\n\t#z0 = t.getZ()\n\tpoints = rs.DivideCurve (slices[0], 100)\n\tt.set_position(points[0].X, points[0].Y, points[0].Z)\n\tz0 = points[0].Z\n\n\tif (layers==10000 or layers==False):\n\t\tlayers = len(slices)\n\telse:\n\t\tlayers = layers+start_layer\n\n\tprint(\"layers: \" +str(layers))\n\n\t# generate paths for all layers\n\tfor i in range (start_layer,layers):\n\t\tif (matrix):\n\t\t\tnum_points = len(matrix)\n\t\telse:\n\t\t\tpoints = rs.DivideCurve (slices[i], 100)\n\t\t\tll = line_length(points)\n\t\t\tnum_points = int(ll/resolution)\n\t\tpoints = rs.DivideCurve (slices[i], num_points)\n\n\t\t# account for current z position\n\t\t# move slices up if necessary\n\t\tif (z0 != 0):\n\t\t\tfor j in range (num_points):\n\t\t\t\tpoints[j].Z = points[j].Z+z0\n\t\t\n\t\t# spiral up if possible and relevant\n\t\t# don't spiral up on the last layer\n\t\t# don't spiral up on the bottom layers\n\t\tif (walls == 1 and spiral_up and i<layers-1 and i>bottom_layers):\n\t\t\tpoints_next = rs.DivideCurve (slices[i+1], num_points)\n\t\t\tz_inc = (points_next[0].Z+z0-points[0].Z)/num_points\n\t\t\tfollow_closed_line (t,points,z_inc=z_inc, matrix = matrix)\n\t\telse:\n\t\t\tfollow_closed_line(t,points,walls=walls, matrix = matrix)\n\n\t\tif (i < bottom_layers):\n\t\t\tspiral_bottom(t,slices[i],walls)   \n\n# given a list of curves that slice a shape (slices)\n# follow the curves with the turtle\ndef follow_slice_curves_woven(t,slices, bottom=False, spiral_up=False, matrix = False, num_oscillations=False, amplitude = False, start_layer=0, layers=10000):\n\tresolution = t.get_resolution()\n\tinitial_n_points = 25\n\t# set parameters if not passed in\n\tif (num_oscillations==False):\n\t\tpoints = rs.DivideCurve (slices[20], initial_n_points)\n\t\tll = line_length(points)\n\t\tnum_oscillations = int(ll/resolution)/10\n\t\tprint(\"num_oscillations: \" +str(num_oscillations))\n\tif (amplitude==False):\n\t\tamplitude=1.0\n\tif (bottom==False):\n\t\tbottom_layers = 0\n\telse:\n\t\tbottom_layers = bottom*2\n\t\t#print(\"printing a bottom\")\n\t\n\t# find starting point\n\tpoints = rs.DivideCurve (slices[start_layer], initial_n_points)\n\tt.penup()\n\tt.set_position(points[start_layer].X, points[start_layer].Y, points[start_layer].Z)\n\tt.pendown()\n\tz0 = points[start_layer].Z\n\n\tif (layers==10000 or layers==False):\n\t\tlayers = len(slices)-1\n\telse:\n\t\tif (layers<10000):\n\t\t\tlayers = layers+start_layer\n\t\telse:\n\t\t\tlayers = len(slices)-1\n\n\t#print(\"layers in woven: \" +str(layers) )\n\n\t# create shape\n\t# generate paths for all layers\n\tvolume = 0\n\textruder_distance = 0\n\tmass = 0\n\t#t.set_tube_color(159, 102, 119)\n\t#t.set_tube_color(180, 43, 97)\n\tfor i in range (start_layer,layers):\n\t\tif (matrix):\n\t\t\tnum_points = len(matrix)\n\t\telse:\n\t\t\tpoints = rs.DivideCurve (slices[i], initial_n_points)\n\t\t\tll = line_length(points)\n\t\t\tnum_points = int(ll/resolution)\n\n\t\tpoints = rs.DivideCurve (slices[i], num_points)\n\n\t\t# change number of oscillations to fit layer\n\t\t# comment out for constant number of oscillations\n\t\t#num_oscillations = len(points)/8\n\t\tif (num_oscillations%2==0):\n\t\t\tnum_oscillations = num_oscillations+1\n\n\n\t\tif (i%2==0):\n\t\t\ttheta_offset = 0\n\t\telse:\n\t\t\ttheta_offset = 180\n\n\t\tif (i==bottom_layers):\n\t\t\tif (t.get_printer()==\"micro\"):\n\t\t\t\tprint(\"cm on tube for bottom: \" + str(t.get_volume(print_out=False)))\n\t\t\telse:\n\t\t\t\tprint (t.get_volume())\n\t\t\t\tprint(\"mm on tube for bottom: \" + str(t.get_volume(print_out=False)))\n\n\t\t#main wall layers\n\t\tif (spiral_up and i<layers-1 and i>bottom_layers):\n\t\t\tpoints_next = rs.DivideCurve (slices[i+1], num_points)\n\t\t\tz_inc = (points_next[0].Z-points[0].Z)/num_points\n\t\t\tif (z_inc<0 and abs(z_inc)>.5):\n\t\t\t\tprint(\"PROBLEM!!! z_inc < 0: \" +str(z_inc))\n\t\t\t\tprint(\"at layer: \" +str(i))\n\t\t\tfollow_closed_line_weave(t,points=points, num_oscillations=num_oscillations, amplitude = amplitude, z_inc = z_inc, theta_offset=theta_offset)\n\t\t# bottom layers\n\t\telse:\n\t\t\tfollow_closed_line_weave(t,points=points, num_oscillations=num_oscillations, amplitude = amplitude, theta_offset=theta_offset)\n\n\t\tif (i < bottom_layers and i%2==0):\n\t\t\tspiral_bottom(t,slices[i],walls=1) \n\t\t\tt.lift(t.get_layer_height())\n\t\tif (spiral_up==False or (i<bottom_layers and i%2==1)):\n\t\t\tt.lift(t.get_layer_height())\n\t\tif (i==bottom_layers or i==layers-2):\n\t\t\tt.lift(t.get_layer_height()/2)\n\n# given a list of curves that slice a shape (slices)\n# follow the curves with the turtle\ndef follow_slice_curves_woven_data(t,slices, bottom = False, spiral_up=False, matrix = False, num_oscillations=False, amplitude = False):\n\tresolution = t.get_resolution()\n\tinitial_n_points = 25\n\tif (num_oscillations==False):\n\t\tnum_oscillations = 21\n\tif (amplitude==False):\n\t\tamplitude=1\n\tif (bottom!=False):\n\t\tbottom_layers = bottom\n\telse:\n\t\tbottom_layers = 0\n\t\n\t# color variables\n\t#colors\n\tblue = 60,170,250\n\torange = 255,150,57\n\tpurple = 100,60,210\n\tred = 240,130,120\n\tlight_green = 200,250,200\n\tgreen = 50,150,50\n\tyellow = 250,250,50\n\tblue = 0,0,255\n\twhite = 255,255,255\n\t\n\tlayers_per_week = len(slices)/50.0\n\t#print(\"layers per week: \" +str(layers_per_week))\n\n\tmonths =        ['october', 'september','august','july','june','may',           'april','march','february','january','december','november' ]\n\tmonths_layer =  []\n\tmonths_color =  [yellow,    yellow,     orange,  red, orange, yellow,   green, green, blue,blue, green, green  ]\n\tweeks_per_month = [31/7.0, 30/7.0, 31/7.0, 31/7.0, 30/7.0, 31/7.0, 30/7.0, 31/7.0, 28/7.0, 31/7.0, 31/7.0, 30/7.0]\n\n\tcurrent_color = white\n\tt.set_tube_color((white))\n\n\tfor i in range (len(months)):\n\t\tx = i*weeks_per_month[i]*layers_per_week\n\t\tmonths_layer.append(int(x))\n\t\t#print (str(months[i]) + \": \" +str(int(x)))\n\t\n\t# find starting point\n\tpoints = rs.DivideCurve (slices[0], initial_n_points)\n\tt.penup()\n\tt.set_position(points[0].X, points[0].Y, points[0].Z)\n\tt.pendown()\n\tz0 = points[0].Z\n\tlayers = len(slices)\n\n\tfor i in range (0,layers):\n\n\t\tfor j in range (0, len(months)):\n\t\t\tif (i==months_layer[j] and current_color!=months_color[j]):\n\t\t\t\tt.set_tube_color((months_color[j]))\n\t\t\t\tcurrent_color = months_color[j]\n\n\t\tpoints = rs.DivideCurve (slices[i], initial_n_points)\n\t\tll = line_length(points)\n\t\tnum_points = int(ll/(resolution*2))\n\t\tpoints = rs.DivideCurve (slices[i], num_points)\n\t\t#print(\"number_points: \" +str(len(points)))\n\n\t\t# change number of oscillations to fit layer\n\t\t# comment out for constant number of oscillations\n\t\t#num_oscillations = len(points)/8\n\t\tif (num_oscillations%2==0):\n\t\t\tnum_oscillations = num_oscillations+1\n\n\t\tif (i%2==0):\n\t\t\ttheta_offset = 0\n\t\telse:\n\t\t\ttheta_offset = 180\n\n\t\t#bottom layers\n\t\tt.pendown()\n\t\tif (i < bottom_layers):\n\t\t\tspiral_bottom(t,slices[i],walls=1)\n\n\t\t#main wall layers\n\t\tif (spiral_up and i<layers-1 and i>bottom_layers):\n\t\t\tpoints_next = rs.DivideCurve (slices[i+1], num_points)\n\t\t\tz_inc = float(points_next[0].Z-points[0].Z)/num_points\n\t\t\tfollow_closed_line_weave(t,points=points, num_oscillations=num_oscillations, amplitude = amplitude, z_inc = z_inc, theta_offset=theta_offset)\n\t\t# bottom layers\n\t\telse:\n\t\t\tfollow_closed_line_weave(t,points=points, num_oscillations=num_oscillations, amplitude = amplitude, z_inc = 0, theta_offset=theta_offset)\n \n\t\tif (spiral_up==False or i<bottom_layers):\n\t\t\tt.lift(t.get_layer_height())\n\n\t\tif (i==bottom_layers or i==layers-2):\n\t\t\tt.lift(t.get_layer_height()/2.0)\n\n\ndef follow_closed_line_interior(t,curve,number=1,ignore_Z=False):\n\tcurve_center = rs.CurveAreaCentroid(curve)\n\tif (curve_center):\n\t\tcurve_center = curve_center[0]\n\telse:\n\t\tprint(\"Couldn't get a center point.\")\n\t\treturn\n\n\t# get a curve offset to the interior of the shape\n\tfor i in range(number):\n\t\tif (i==0):\n\t\t\toffset_curve = rs.OffsetCurve(curve,curve_center,t.get_extrude_width()/2.0)\n\t\telse:\n\t\t\toffset_curve = rs.OffsetCurve(curve,curve_center,t.get_extrude_width()*(i+.5))\n\n\t\tfollow_closed_line(t,curve=offset_curve, ignore_Z=ignore_Z)\n\ndef follow_closed_line_exterior(t,curve,number=1,ignore_Z=False):\n\tcurve_center = rs.CurveAreaCentroid(curve)\n\tif (curve_center):\n\t\tcurve_center = curve_center[0]\n\telse:\n\t\t#print(\"Couldn't get a center point.\")\n\t\tcurve_center = rs.CreatePoint(0,5.0,0)\n\t\treturn\n\n\t\t# get a curve offset to the interior of the shape\n\tfor i in range(number):\n\t\tif (i==0):\n\t\t\toffset_curve = rs.OffsetCurve(curve,curve_center,-t.get_extrude_width()/2.0)\n\t\telse:\n\t\t\toffset_curve = rs.OffsetCurve(curve,curve_center,-t.get_extrude_width()*(i+.5))\n\n\tfollow_closed_line(t,curve=offset_curve)\n\n\n#generates a turtle path from a curve or a list of rhinoscript points\ndef follow_closed_line(t,points=False,curve=False,z_inc=0,walls = 1,matrix=False, ignore_Z=True):\n\tif (not(curve) and not(points)):\n\t\tprint(\"You need to provide this function with either a curve or a list of points\")\n\t\treturn\n\telif (curve):\n\t\t#print(\"got a curve\")\n\t\tresolution = t.get_resolution()\n\t\tpoints = rs.DivideCurve (curve, 48)\n\t\t# ll = line_length(points)\n\t\t# num_points = int(ll/resolution)+1\n\t\t# points = rs.DivideCurve (curve, num_points)\n\n\n\t#start with pen up\n\t#t.penup()\n\n\t# t2 keeps track of points for next wall\n\tt2 = e.ExtruderTurtle()\n\tt2.penup()\n\n\tif (matrix):\n\t\tmatrix=[]\n\t\tfor i in range(48):\n\t\t\tif (i%12==1 or i%12==2 or i%12==3):\n\t\t\t\tmatrix.append(1)\n\t\t\telse:\n\t\t\t\tmatrix.append(0)\n\n\t# follow the curve\n\t# generate points for next wall if applicable (poinst2)\n\tpoints2 = []\n\ti=0\n\tfor point in points:\n\t\t# matrix marks pen up spots in path\n\t\tif (matrix and matrix[i]==0):\n\t\t\tt.penup()\n\t\telif (matrix and matrix[i]==1):\n\t\t\tt.pendown()\n\t\ti+=1\n\n\t\t# move to next point\n\t\tif (z_inc==0 or walls > 1):\n\t\t\tif (ignore_Z==False):\n\t\t\t\tt.set_position(point.X,point.Y,point.Z)\n\t\t\telse:\n\t\t\t\tt.set_position(point.X,point.Y)\n\t\t\t# t.pendown()\n\t\t\t#print(\"pendown\")\n\t\telse:\n\t\t\tt.set_position(point.X,point.Y)\n\t\t\t# t.pendown()\n\t\t\tif (ignore_Z==False):\n\t\t\t\tt.lift(z_inc)\n\n\t\t# if (i==1):\n\t\t# \tt.pendown()\n\t\t# \t#t.extrude(2)\n\n\t\t# # get points for next wall\n\t\t# if (walls>1):\n\t\t# \tprint(\"second wall\")\n\t\t# \tif (ignore_Z==False):\n\t\t# \t\tt.set_position(points[i].X,points[i].Y,points[i].Z)\n\t\t# \telse:\n\t\t# \t\tt.set_position(points[i].X,points[i].Y)\n\t\t# \tt2.left(90)\n\t\t# \tt2.forward(t.get_extrude_width())\n\t\t# \tx1 = t2.getX()\n\t\t# \ty1 = t2.getY()\n\t\t# \tif (ignore_Z==False):\n\t\t# \t\tz1 = t2.getZ()\n\t\t# \tt2.backward(t.get_extrude_width())\n\t\t# \tt2.right(90)\n\t\t# \tif (ignore_Z==False):\n\t\t# \t\tpoints2.append(rs.CreatePoint(x1,y1,z1))\n\t\t# \telse:\n\t\t# \t\tpoints2.append(rs.CreatePoint(x1,y1,t.getZ()))\n\t\t# \tprint(points2[0])\n\n\n\t#close the layer curve\n\tt.set_position(points[0].X,points[0].Y)\n\tif (z_inc==0 or walls > 1):\n\t\tif (ignore_Z==False):\n\t\t\tt.set_position(point.X,point.Y,point.Z)\n\n\tt.pendown()\n\n\t# # draw second wall\n\t# while (walls>1):\n\t# \tt.penup()\n\t# \tfor i in range (0, len(points2)):\n\t# \t\tif (matrix and matrix[i]==1):\n\t# \t\t\tt.penup()\n\t# \t\telse:\n\t# \t\t\tt.pendown()\n\t# \t\tt.set_position(points2[i].X,points2[i].Y,points[i].Z)\n\t# \twalls = walls-1\n\t# \t# you've drawn 2 walls, subtract these and draw the next wall\n\t# \t'''\n\t# \twalls = walls-2\n\t# \tif (walls > 1):\n\t# \t\tfollow_closed_line(t, points2, walls = walls)\n\t# \t'''\n\ndef spiral_bottom(t,curve,walls=1):\n\textrude_rate = t.get_extrude_rate()\n\n\tarea = 0\n\tprevious_area = 10\n\ti = 0\n\tcount = 100\n\tprevious_area = rs.CurveArea(curve)\n\tarea = previous_area\n\tcurve_center_previous =0\n\n\twhile (area <=previous_area and i<count):\n\t\t# important!! \n\t\t# make sure curve center is in XY plane\n\t\t# set current view to top view\n\t\tstrView = rs.CurrentView(\"Top\") \n\t\t\n\t\tcurve_center = rs.CurveAreaCentroid(curve)\n\t\tif (curve_center):\n\t\t\tcurve_center = curve_center[0]\n\t\t\tcurve_center_previous = curve_center\n\t\telse:\n\t\t\tprint(\"Couldn't get a center point, using previous.\")\n\t\t\tcurve_center = curve_center_previous\n\n\t\to = rs.OffsetCurve(curve,curve_center,t.get_extrude_width())\n\t\tif (area):  \n\t\t\tprevious_area = area\n\t\telse:\n\t\t\tprint(\"Couldn't get an area, using previous.\")\n\t\t\n\t\t# if there is a viable offset curve, compute the new area\n\t\t# otherwise, get out ot the loop\n\t\tif (o):\n\t\t\ttry:\n\t\t\t\tarea = rs.CurveArea(o)\n\t\t\texcept:\n\t\t\t\tprint(\"Challenging bottom 1. Re-computing.\")\n\t\t\t\ttry:\n\t\t\t\t\to = rs.OffsetCurve(curve,curve_center,t.get_extrude_width()-.5)\n\t\t\t\texcept:\n\t\t\t\t\tprint(\"Challenging bottom 2. Re-computing.\")\n\t\t\t\t\to = rs.OffsetCurve(curve,curve_center,t.get_extrude_width()+.5)\n\t\t\t\ttry:\n\t\t\t\t\tarea = rs.CurveArea(o)\n\t\t\t\texcept:\n\t\t\t\t\tprint(\"Couldn't get an area.\")\n\t\t\t\t\tbreak\n\t\telse:\n\t\t\t#print(\"Challenging bottom 3. No viable offset curve. Exiting.\")\n\t\t\tbreak\n\n\t\t# if you have reached the inner-most ring of bottom, get out of loop\n\t\tif (area>=previous_area):\n\t\t\t#print(\"Next area larger. \")\n\t\t\t#print(\"previous_area = \" +str(previous_area) + \", area: \" +str(area))\n\t\t\t#print(i)\n\t\t\tbreak\n\t\telse:\n\t\t\tfollow_closed_line(t,curve=o)\n\t\t\tcurve = o\n\t\ti = i+1\n\n\tif (curve_center):\n\t\treturn curve_center\n\telse:\n\t\treturn curve_center_previous\n\n\n# important: assumes turtle is either \n# somewhere on the circle curve, on_circle=True\n# or at the center of the circle, on_circle=False\ndef zig_zag_circular_bottom(t,diameter,center_point,t_on_circle=True):\n\tif (t_on_circle==False):\n\t\tt.forward(diameter/2)\n\t\tt.left(90)\n\n\tz = t.getZ()\n\tr = diameter/2.0\n\tpoints = []\n\tpoints.append(rs.CreatePoint(-r,-r,z))\n\tpoints.append(rs.CreatePoint(-r,r,z))\n\tpoints.append(rs.CreatePoint(r,r,z))\n\tpoints.append(rs.CreatePoint(r,-r,z))\n\tplane = rs.AddSrfPt(points)\n\tcircle = rs.AddCircle(plane,r)\n\tt.set_heading_point(center_point)\n\t\n\textrude_width = t.get_extrude_width()\n\tt.forward(extrude_width)\n\tt.left(90)\n\tintersections = rs.CurveCurveIntersection(circle,line)\n\n#assumes curve is flat, doesn't work for non-planar curves\ndef zig_zag_bottom(t,curve):\n\tresolution = t.get_resolution()\n\tpoints = curve_to_points(curve,resolution)\n\t#find bounding box points, will define slicing line boundaries\n\tminPx = min(points, key=op.itemgetter(0))\n\tmaxPx = max(points, key=op.itemgetter(0))\n\tminPy = min(points, key=op.itemgetter(1))\n\tmaxPy = max(points, key=op.itemgetter(1))\n\tindex = go_to_point_on_curve(t,curve,minPx)\n\t# print(\"index: \" +str(index))\n\tx = minPx.X\n\tz = minPx.Z\n\tx = x + t.get_extrude_width()\n\tintersections_list = []\n\twhile (x < maxPx.X):\n\t\tindex = go_to_point_on_curve(t,curve,t.get_position())\n\t\t# generate slicing line\n\t\t# slice in x\n\t\t# x increment = one spacing width\n\t\t# line = current x from miny to maxy\n\t\tline = rs.AddLine(rs.CreatePoint(x,minPy.Y,z),rs.CreatePoint(x,maxPy.Y,z))\n\t\t# check for intersections between line and curve\n\t\tintersections = rs.CurveCurveIntersection(curve,line)\n\t\tintersections_list.append(intersections)\n\t\t# find intersection at curve turtle is on\n\t\t# travel along curve to the intersection\n\t\t# jump to intersection across curve, stay inside shape\n\t\tfor i in range (len(intersections)):\n\t\t\td = distance_on_curve(t,curve,intersections[i][1],index)\n\t\t\tif (d < t.get_extrude_width()*2):\n\t\t\t\t# print(\"found the point at intersections: \" +str(i))\n\t\t\t\t# print(\"distance is: \" +str(d))\n\t\t\t\tt.set_position_point(intersections[i][1])\n\t\t\t\tbreak\n\n\t\tx = x + t.get_extrude_width()\n\t\t# print(\"x slice: \" +str(x))\n\treturn intersections_list\n\n# generates points from a curve\n# number of points determined by resolution\ndef curve_to_points(curve,resolution):\n\tpoints = rs.DivideCurve (curve, 100)\n\tll = line_length(points)\n\tnum_points = int(ll/resolution)\n\tpoints = rs.DivideCurve (curve, num_points)\n\treturn points\n\n# go to point on curve, start at beginning of curve\ndef go_to_point_on_curve(t,curve,point):\n\tresolution = t.get_resolution()\n\tt.penup()\n\tpoints = curve_to_points(curve,resolution)\n\tfor i in range (len(points)):\n\t\td = rs.Distance(points[i],point)\n\t\tt.set_position_point(points[i])\n\t\tif (d <resolution*2):\n\t\t\tt.pendown()\n\t\t\treturn i\n\tprint(\"Point was not on curve. At end of curve.\")\n\treturn 0\n\n# distance between t and point on curve\n# index is index of t's position on curve/points array\n# assumes t is on the curve\ndef distance_on_curve(t,curve,point,index):\n\tresolution = t.get_resolution()\n\tpoints = curve_to_points(curve,resolution)\n\t\n\tdistance = 0\n\t# goes forward along curve\n\tfor i in range (index,len(points)-1):\n\t\td = rs.Distance(points[i],point)\n\t\tdistance = distance + abs(rs.Distance(points[i],points[i+1]))\n\t\tif (abs(d) <= resolution):\n\t\t\t#print(\"Found the point on curve in distance function at:\")\n\t\t\t#print(distance)\n\t\t\treturn distance\n\n\tdistance = 0\n\t# goes backward along curve\n\ti = index\n\twhile (i>0):\n\t\td=rs.Distance(points[i],point)\n\t\tdistance = distance + abs(rs.Distance(points[i],points[i+1]))\n\t\tif (abs(d) <= resolution):\n\t\t\t# print(\"Found the point on curve in distance function at:\")\n\t\t\t# print(distance)\n\t\t\treturn distance\n\t\ti = i-1\n\n\tprint(\"Point was not on curve. At end of curve.\")\n\treturn resolution*1000\n\ndef line_length(points):\n\tlength = 0\n\tfor i in range (1, len(points)):\n\t\tlength = length + rs.Distance(points[i-1],points[i])\n\tlength = length + rs.Distance(points[len(points)-1],points[0])\n\treturn length\n\n\n#bump_width in number of steps NOT mm\ndef bump_square(t,bump_length,c_bump,dtheta,z_inc=0,bump_width=0):\n\tt.left(90)\n\tt.forward(bump_length)\n\tt.right(90)\n\tif (bump_width!=0):\n\t\tfor j in range(int(bump_width)):\n\t\t\tt.forward_lift(c_bump,z_inc)\n\t\t\tt.right(dtheta)\n\tt.right(90)\n\tt.forward(bump_length)\n\tt.left(90)\n\ndef bump_triangle(t,bump_length, bump_width, c_inc, d_theta,z_inc=0):\n\t# convert width into steps\n\tnumber_steps = int(bump_width/c_inc)\n\t\n\tx0 = t.getX()\n\ty0 = t.getY()\n\tz0 = t.getZ()\n\tyaw0 = t.get_yaw()\n\tt2 = e.ExtruderTurtle()\n\tt2.set_position(x0,y0,z0)\n\tt2.set_heading(yaw0)\n\tif (bump_width==0):\n\t\tbump_square(t,bump_length,0,d_theta)\n\t\treturn\n\n\tfor i in range (0,number_steps/2):\n\t\tt2.forward_lift(c_inc,z_inc)\n\t\tt2.right(d_theta)\n\tt2.left(90)\n\tt2.forward(bump_length)\n\tx1 = t2.getX()\n\ty1 = t2.getY()\n\tz1 = t2.getZ()\n\tt2.backward(bump_length)\n\tt2.right(90)\n\tfor i in range (0,number_steps/2):\n\t\tt2.forward_lift(c_inc,z_inc)\n\t\tt2.right(d_theta)\n\n\t# NOTE should do for all angles, right now yaw only\n\tyaw = t2.get_yaw()\n\n\tx2 = t2.getX()\n\ty2 = t2.getY()\n\tz2 = t2.getZ()\n\n\tt.set_position(x1,y1,z1)\n\tt.set_position(x2,y2,z2)\n\t# NOTE should do for all angles, right now yaw only\n\tt.set_heading(yaw)\n\n\ndef follow_closed_line_simple_bumps(t,points,curve=False, num_bumps=0,bump_length=0, bump_start = 0, z_inc=0):\n\tif (not(curve) and not(points)):\n\t\tprint(\"You need to provide this function with either a curve or a list of points\")\n\t\treturn\n\tif (curve):\n\t\t#print(\"got a curve\")\n\t\tresolution = t.get_resolution()\n\t\tpoints = rs.DivideCurve (curve, 100)\n\t\tll = line_length(points)\n\t\tnum_points = int(ll/resolution)+1\n\t\tpoints = rs.DivideCurve (curve, num_points)\n\n\tl = len(points)\n\tif (num_bumps !=0):\n\t\tbump_distance = int(l/num_bumps)\n\telse:\n\t\tbump_distance = 0\n\n\tfor i in range (len(points)):\n\t\tt.set_position(points[i].X,points[i].Y)\n\t\tt.lift(z_inc)\n\t\tif (num_bumps!=0 and (i+bump_start)%bump_distance==0 and i>0):\n\t\t\tt.right(90)\n\t\t\tt.forward(bump_length)\n\t\t\tt.backward(bump_length)\n\t\t\tt.left(90)\n\n\tt.set_position(points[0].X,points[0].Y)\n\tt.lift(z_inc)\n\ndef distance_squaredXY (p0, p1):\n\tds = (p1.X-p0.X)*(p1.X-p0.X)+(p1.Y-p0.Y)*(p1.Y-p0.Y)\n\treturn ds\n\n#generates a turtle path from a curve or a list of rhinoscript points\ndef follow_closed_line_chase (t,points=False,curve=False,z_inc=0,angle=50,movement=1, z_movement=False):\n\tresolution = t.get_resolution()*10\n\tif (not(curve) and not(points)):\n\t\tprint(\"You need to provide this function with either a curve or a list of points\")\n\t\treturn\n\tif (curve):\n\t\t#print(\"got a curve\")\n\t\tpoints = rs.DivideCurve (curve, 100)\n\t\tll = line_length(points)\n\t\tnum_points = int(ll/resolution)\n\t\tpoints = rs.DivideCurve (curve, num_points)\n\n\tif (points):\n\t\t# print(\"got points\")\n\t\tll = line_length(points)\n\t\tnum_points = int(ll/resolution)\n\t\t# points = rs.DivideCurve (curve, num_points)\n\t\tt_extra_steps = 15\n\n\n\t# print(\"number of points in slice: \" +str(num_points))\n\n\t# t2 follows the basic curve, t will chase t2\n\tt2 = e.ExtruderTurtle()\n\t\n\n\tr = 0\n\n\t#flat XY movement only\n\tif (z_movement==False):\n\t\tif (z_inc==0 or walls > 1):\n\t\t\tt2.set_position(points[r].X,points[r].Y,points[r].Z)\n\t\t\tt2.set_position(points[r+1].X,points[r+1].Y,points[r+1].Z)\n\t\t\tt.penup()\n\t\t\tt.set_position(points[r].X,points[r].Y)\n\t\t\tt.pendown()\n\t\telse:\n\t\t\tt2.set_position(points[r].X,points[r].Y)\n\t\t\tt2.set_position(points[r+1].X,points[r+1].Y)\n\t\t\tt.penup()\n\t\t\tt.set_position(points[r].X,points[r].Y)\n\t\t\tt.pendown()\n\t\n\t#adding z movement to path\n\telse:\n\t\tnew_z_inc = t.get_layer_height()/num_points\n\t\tif (z_inc==0 or walls > 1):\n\t\t\tt2.set_position(points[r].X,points[r].Y,points[r].Z)\n\t\t\tt2.set_position(points[r+1].X,points[r].Y,points[r+1].Z)\n\t\t\tt.penup()\n\t\t\tt.set_position(points[r].X,points[r].Y)\n\t\t\tt.pendown()\n\t\telse:\n\t\t\tt2.set_position(points[r].X,points[r].Y,points[r].Z)\n\t\t\tt2.set_position(points[r+1].X,points[r+1].Y,points[r+1].Z)\n\t\t\tt.penup()\n\t\t\tt.set_position(points[r].X,points[r].Y)\n\t\t\tt.pendown()\n\n\n\n\tprevious_distance_sq = 10000000\n\n\tt.right(random.randint(0,360))\n\tfor j in range (r, len(points)+r):\n\t\tif (j>=len(points)):\n\t\t\ti = j%r\n\t\telse:\n\t\t\ti=j\n\t\tif (z_movement==False):\n\t\t\t# move to next point with lead turtle\n\t\t\tif (z_inc==0 or walls > 1):\n\t\t\t\tt2.set_position(points[i].X,points[i].Y,points[i].Z)\n\t\t\t\t#t.set_position(z=points[i].Z)\n\t\t\telse:\n\t\t\t\tt2.set_position(points[i].X,points[i].Y)\n\t\t\t\tt2.lift(z_inc)\n\n\t\t\t# move real turtle in chase pattern\n\t\t\tfor s in range (0,t_extra_steps):\n\t\t\t\tdistance_sq = distance_squaredXY(t2.get_position(), t.get_position())\n\t\t\t\tif (distance_sq > previous_distance_sq):\n\t\t\t\t\tt.right(angle)\n\t\t\t\t\tt.forward (movement)\n\t\t\t\telse:\n\t\t\t\t\tt.right(random.randint(-(angle-15),angle-15))\n\t\t\t\t\tt.forward(movement)\n\t\t\t\tif (z_inc>0):\n\t\t\t\t\tt.lift(z_inc)\n\t\t\t\tprevious_distance_sq = distance_sq\n\t\t# adding z movement to path\n\t\telse:\n\t\t\tt2.set_position(points[i].X,points[i].Y)\n\n\t\t\t# move real turtle in chase pattern\n\t\t\tfor s in range (0,random.randint(t_extra_steps-5, t_extra_steps+5)):\n\t\t\t\tif (i==0):\n\t\t\t\t\tn = random.randint(0,len(points)/5)\n\t\t\t\t\tt.set_position(points[n].X, points[n].Y)\n\t\t\t\t\tbreak\n\t\t\t\tdistance_sq = distance_squaredXY(rs.CreatePoint(t2.getX(),t2.getY(),0), rs.CreatePoint(t.getX(), t.getY(),0))\n\t\t\t\tif (distance_sq > previous_distance_sq):\n\t\t\t\t\tt.right(angle)\n\t\t\t\t\tt.forward (movement)\n\t\t\t\t\tt.lift(random.uniform(-new_z_inc, new_z_inc))\n\t\t\t\telse:\n\t\t\t\t\tt.right(random.randint(-(angle-15),angle-15))\n\t\t\t\t\tt.forward(movement)\n\t\t\t\t\tt.lift(random.uniform(-new_z_inc, new_z_inc))\n\t\t\t\tif (z_inc>0):\n\t\t\t\t\tt.lift(z_inc)\n\t\t\t\telse:\n\t\t\t\t\tt.lift(random.uniform(new_z_inc,new_z_inc*.05))\n\t\t\t\tprevious_distance_sq = distance_sq\n\n\n\ndef follow_closed_line_weave(t,points=False, curve=False, num_oscillations=25.0, amplitude = 2, theta_offset=0, z_inc=0, extra_support=False):\n\tif (not(curve) and not(points)):\n\t\tprint(\"You need to provide this function with either a curve or a list of points\")\n\t\treturn\n\tif (curve):\n\t\tresolution = t.get_resolution()/2\n\t\tpoints = rs.DivideCurve (curve, 100)\n\t\tll = line_length(points)\n\t\tnum_points = int(ll/resolution)+1\n\t\tpoints = rs.DivideCurve (curve, num_points)\n\n\tnum_points = len(points)\n\tt2 = e.ExtruderTurtle()\n\tif (z_inc==0):\n\t\tt2.set_position(points[0].X,points[0].Y,points[0].Z)\n\telse:\n\t\tt2.set_position(points[0].X,points[0].Y)\n\n\tdtheta = 360.0/num_points\n\ttheta = 0.0\n\tx0 = 0.0\n\ty0 = 0.0\n\n\tif (theta_offset):\n\t\ttheta0 = 180\n\telse:\n\t\ttheta_offset = 0\n\t\ttheta0 = 0\n\n\tif (extra_support):\n\t\t#non-oscillating line for support\n\t\tdelta = t.get_extrude_width()*1.25\n\t\tfor i in range (0, num_points):\n\t\t\tif (z_inc==0):\n\t\t\t\tt2.set_position(points[i].X,points[i].Y,points[i].Z)\n\t\t\telse:\n\t\t\t\tt2.set_position(points[i].X,points[i].Y)\n\t\t\t#get the new point with spare turtle\n\t\t\tt2.right(90)\n\t\t\tt2.forward(-delta)\n\t\t\tx = t2.getX()\n\t\t\ty = t2.getY()\n\t\t\tif (i==0):\n\t\t\t\tx0 = x\n\t\t\t\ty0 = y\n\t\t\tt2.forward(delta)\n\t\t\tt2.left(90)\n\t\t\t#set main turtle's position\n\t\t\tif (i!=0):\n\t\t\t\tt.set_position(x,y)\n\t\t\tif (z_inc!=0):\n\t\t\t\tt.lift(z_inc)\n\t\t\ttheta = theta + dtheta\n\n\t#weave\n\tfor i in range (0, num_points):\n\t\tif (z_inc==0):\n\t\t\tt2.set_position(points[i].X,points[i].Y,points[i].Z)\n\t\telse:\n\t\t\tt2.set_position(points[i].X,points[i].Y)\n\t\tdelta = amplitude*math.cos(num_oscillations*math.radians(theta+theta0))\n\t\t#get the oscillating point with spare turtle\n\t\tt2.right(90)\n\t\tt2.forward(delta)\n\t\tx = t2.getX()\n\t\ty = t2.getY()\n\t\tif (i==0):\n\t\t\tx0 = x\n\t\t\ty0 = y\n\t\tt2.backward(delta)\n\t\tt2.left(90)\n\t\t#set main turtle's position\n\t\tif (i!=0):\n\t\t\tt.set_position(x,y)\n\t\t\tif (t.get_pen()==False):\n\t\t\t\tt.pen_down()\n\t\tif (z_inc!=0):\n\t\t\tt.lift(z_inc)\n\t\ttheta = theta + dtheta\n\n\treturn t2\n\ndef pattern_cylinder(t, b_diameter, height, t_diameter=False, array=False, pattern_amplitude = False, pattern_spacing = 0, bottom_layers=3, oscillations = False, spiral_up = True, walls=1):\n\tbase_amplitude = 1.0\n\tevery_other_layer = True # change to false to show pattern on every layer\n\ttoggle = True # variable to select every_other_layer\n\tif (every_other_layer==True):\n\t\tprint(\"Generating pattern for every other layer\")\n\t\n\tif (pattern_amplitude == False):\n\t\tpattern_amplitude = base_amplitude+1.0\n\tif (t_diameter == False):\n\t\tt_diameter = b_diameter\n\t\n\tlayers = int(height/t.get_layer_height())\n\ttop_layers = 6 #number of layers at the top with no pattern\n\textra_bottom_layers = 0 #number of extra layers at the bottom with no pattern\n\tdiameter = b_diameter\n\tdiameter_inc = float(t_diameter - b_diameter)/layers\n\tcircumference = diameter*math.pi\n\n\tif (array):\n\t\tpattern_width = len(array)\n\t\tpattern_height = len(array[0])\n\telse:\n\t\tif (oscillations):\n\t\t\tpattern_width = oscillations+1\n\t\telse:\n\t\t\tpattern_width = circumference/4\n\n\tpattern_steps = pattern_width\n\tif (oscillations or array):\n\t\tnOscillations = int(pattern_steps)-1\n\t\tdistance_per_oscillation = circumference/nOscillations\n\t\tsteps_per_oscillation = 10 #determines resolution of curve\n\t\tc_inc = distance_per_oscillation/steps_per_oscillation\n\telse:\n\t  nOscillations = 0.0\n\t  distance_per_oscillation = circumference\n\t  c_inc = circumference/100\n\t  steps_per_oscillation = 1\n\n\tsteps = int(circumference/c_inc)\n\tdtheta = 360.0/steps\n\ttheta_per_oscillation = dtheta*steps_per_oscillation\n\ttheta_offset = theta_per_oscillation/2 #used to offset every other layer of weave\n\n\tprint(\"number of oscillations: \" +str(nOscillations))\n\tprint(\"number of steps: \" +str(steps))\n\tprint(\"degrees per step (dtheta): \" +str(dtheta))\n\tprint(\"degrees per oscillation: \" +str(steps_per_oscillation*dtheta))\n\n\n\tif (spiral_up): \n\t\tz_inc = t.get_layer_height()/steps\n\telse:\n\t\tz_inc = 0\n\n\tb = diameter/2\n\tx0 = t.getX()\n\ty0 = t.getY()\n\tz0 = t.getZ()\n\tz = z0\n\taxy = base_amplitude\n\n\t#pattern access variables\n\txp = 0\n\typ = 0\n\n\t# Rhino visualization variable\n\tvisualization = True\n\tvis_lines = []\n\n\t################################################\n\t# LAYER LOOP\n\t################################################\n\tfor l in range (layers):\n\t\taxy=base_amplitude # reset pattern amplitude for each layer\n\t\tt.write_gcode_comment(\"layer: \" +str(l))\n\n\t\t# create bottom layers if relevant\n\t\tif (l < bottom_layers):\n\t\t\tt.set_position(0,0)\n\t\t\tif (nOscillations>0):\n\t\t\t\tk = int(diameter/t.get_extrude_width()-1) # number of circles in diameter\n\t\t\telse:\n\t\t\t\tk = int(diameter/t.get_extrude_width()-1.5) # number of circles in diameter\n\t\t\tt.set_position(0,0,z)\n\t\t\tpolygon_layer(t,k*t.get_extrude_width(),return_to_center=False,offset=(l%2),rotation=(90*(l+1)))\n\t\t# if (l== bottom_layers):\n\t\t#   print(\"BOTTOM PRINT INFO\")\n\t\t#   t.volume_of_path()\n\n\t\t# reset x pattern variable for each layer\n\t\txp = 0\n\n\t\t################################################\n\t\t# MAIN PATTERN LOOP\n\t\t# generate steps around circumference\n\t\t################################################\n\t\tfor s in range(0,steps):\n\t\t\t# skip bottom most layer\n\t\t\tif (l<1):\n\t\t\t\tbreak\n\t\t\t# generate pattern\n\t\t\t# top top_layers have no pattern\n\t\t\t# bottom layers have no pattern\n\t\t\tif (l<layers-top_layers and l>=bottom_layers-1+extra_bottom_layers and s%steps_per_oscillation==0):\n\t\t\t\tif (array and xp<len(array) and yp<len(array[0]) and array[xp][yp]==1):\n\t\t\t\t\taxy = pattern_amplitude\n\t\t\t\t\t# adjust if every other layer mode is selected\n\t\t\t\t\t# turn off pattern for every other layer\n\t\t\t\t\tif (every_other_layer and toggle and l>bottom_layers+extra_bottom_layers):\n\t\t\t\t\t\taxy = base_amplitude\n\t\t\t\telse:\n\t\t\t\t\taxy = base_amplitude\n\t\t\telse:\n\t\t\t\taxy = base_amplitude\n\n\t\t\t# calculate and move to next position\n\t\t\t# offset \"weave\" for every other layer\n\t\t\tif (l%2==0):\n\t\t\t\tr= b+axy*math.cos(nOscillations*math.radians(dtheta*s+theta_offset))\n\t\t\telse:\n\t\t\t\tr= b+axy*math.cos(nOscillations*math.radians(dtheta*s))\n\n\t\t\tx = r*math.cos(math.radians(dtheta*s))\n\t\t\ty = r*math.sin(math.radians(dtheta*s))\n\n\t\t\t# spiral up only if this is not the bottom or top layer\n\t\t\tif (z_inc != 0 and l>bottom_layers and l < layers-1):\n\t\t\t\tz = z + z_inc\n\n\t\t\tt.set_position(x,y,z)\n\n\t\t\t#if the pen is up, execute a pendown command\n\t\t\tif (not(t.get_pen())): \n\t\t\t\tt.pendown() \n\n\t\t\t# if (axy == pattern_amplitude):\n\t\t\t# \tprint(\"pattern at: \" +str(xp)+\", \"+str(yp))\n\t\t\t# \tprint(\"r: \"+str(r-b))\n\n\t\t\t#generate Rhino visualization\n\t\t\tif (r-b+t.get_resolution()>=pattern_amplitude and visualization==True):\n\t\t\t\t# generate a cube at turtle's location\n\t\t\t\t# print(\"vis at: \" +str(xp)+\", \"+str(yp))\n\t\t\t\t# print(\"\")\n\t\t\t\tt2 = ExtruderTurtle()\n\t\t\t\tt2.set_position_point(t.get_position())\n\t\t\t\tt2.set_heading(dtheta*s)\n\t\t\t\tt2.pitch(90)\n\t\t\t\tpoints = []\n\t\t\t\tpoints.append(t2.get_position())\n\t\t\t\tfor i in range(2):\n\t\t\t\t\tt2.forward(t.get_layer_height()*1.25)\n\t\t\t\t\tt2.right(90)\n\t\t\t\t\tpoints.append(t2.get_position())\n\t\t\t\t\tt2.forward(distance_per_oscillation/1.15)\n\t\t\t\t\tt2.right(90)\n\t\t\t\t\tpoints.append(t2.get_position())\n\t\t\t\tsquare = rs.AddPolyline(points)\n\t\t\t\tsquare=rs.AddPlanarSrf(square)[0]\n\t\t\t\tvis_lines.append(square)\n\n\t\t\t# update x pattern variable\n\t\t\tif (s%steps_per_oscillation==0):\n\t\t\t\txp = xp+1\n\n\t\t##########################################\n\t\t# LAYER LOOP LEVEL\n\t\t##########################################\n\n\t\t# if there is no spiraling at all, step up\n\t\tif (z_inc == 0 or l<=bottom_layers):\n\t\t\tz = z + t.get_layer_height()\n\n\t\t# increment diameter if relevant\n\t\tdiameter = diameter+diameter_inc\n\t\tb = diameter/2\n\n\t\t# update pattern yp (vertical) variable\n\t\tif (l>bottom_layers-1+extra_bottom_layers):\n\t\t\typ = yp+1\n\t\t# skip every other layer if that mode is selected\n\t\tif (every_other_layer==True and l>bottom_layers+extra_bottom_layers):\n\t\t\tif (toggle==True):\n\t\t\t\typ = yp-1\n\t\t\ttoggle = not(toggle)\n\n\t\t# penup and lift to transition to next bottom layer for auger printers only\n\t\tif ((t.get_printer()==\"eazao\" or t.get_printer()==\"matrix\") and l<bottom_layers-1):\n\t\t\tt.penup()\n\t\t\tt.extrude(-1)\n\t\t\tt.lift(t.get_layer_height()*3) # prevent dragging across print during travel\n\treturn vis_lines\t\n\n\n# adjust the number of steps in a circle \n# to avoid generating too many points for small shapes\n# minimum step size = resolution\ndef adjust_circle_steps(diameter, steps, resolution, layer_height):\n\t#resolution = resolution # use smaller resolution here\n\tcircumference = diameter * math.pi\n\tc_inc = circumference/steps\n\tif (c_inc < resolution):\n\t\tc_inc = resolution\n\t\tsteps = int(circumference/c_inc)\n\n\treturn steps\n\ndef secondWallAddPointXYR(t,t2,points):\n\tt2.penup()\n\tt2.set_position_point(t.get_position())\n\tt2.right(90)\n\tt2.forward(t.get_extrude_width()*.75)\n\tx1 = t2.getX()\n\ty1 = t2.getY()\n\tz1 = t2.getZ()\n\tt2.backward(t.get_extrude_width()*.75)\n\tt2.left(90)\n\treturn rs.CreatePoint(x1,y1,z1)\n\n\ndef non_centered_poly_holes(t, diameter, steps=100, spiral_up=True):\n\tposition = t.get_position()\n\n\tz_inc = t.get_layer_height()/steps\n\t\n\tif (t.write_gcode):\n\t\tt.write_gcode_comment(\"starting polygon\")\n\t\t\n\tcircumference = diameter * math.pi\n\tc_inc = circumference/steps\n\tdtheta = 360.0/steps\n\tt.right(dtheta/2)\n\tfor i in range (steps):\n\t\tt.forward_lift(c_inc, z_inc)\n\t\tt.right(dtheta)\n\t\tif (i>=10 and i<50):\n\t\t\tt.penup()\n\t\telse:\n\t\t\tt.pendown()\n\tt.left(dtheta/2)\n\n#creates a circle or polygon with the edge begining at the turtle's location\ndef non_centered_poly(t, diameter, steps=100, walls = 1, spiral_up=False):\n\tposition = t.get_position()\n\tinitial_angle = t.get_yaw()\n\tsteps = adjust_circle_steps(diameter, steps, t.get_resolution(),t.get_layer_height())\n\t#print(\"steps: \" +str(steps))\n\n\tif (spiral_up):\n\t\tz_inc = t.get_layer_height()/steps\n\telse:\n\t\tz_inc = 0.0\n\tif (t.write_gcode):\n\t\tt.write_gcode_comment(\"starting polygon\")\n\tcircumference = diameter * math.pi\n\tc_inc = circumference/steps\n\tdtheta = 360.0/steps\n\n\tif (walls>1):\n\t\tt2 = e.ExtruderTurtle()\n\t\tpoints = []\n\n\tt.right(dtheta/2)\n\tfor i in range (steps):\n\t\tif (spiral_up):\n\t\t\tt.forward_lift(c_inc, z_inc)\n\t\telse:\n\t\t\tt.forward(c_inc)\n\t\tt.right(dtheta)\n\t\tif (walls>1):\n\t\t\tpoints.append(secondWallAddPointXYR(t,t2,points))\n\n\tt.left(dtheta/2)\n\n\tif (walls>1):\n\t\tt.penup()\n\t\tfor i in range (0,len(points)):\n\t\t\tif (i>1):\n\t\t\t\tt.pendown()\n\t\t\tt.set_position(points[i].X,points[i].Y,points[i].Z)\n\n\t#t.set_position_point(position)\n\tt.set_heading(initial_angle)\n\n\ndef circular_bottom(t,diameter,layers):\n\tt.extrude(t.get_nozzle_size()*3)\n\tfor i in range (layers-1):\n\t\tpolygon_layer(t,diameter,return_to_center=True,offset=(i%2))\n\t\tt.lift(t.get_layer_height())\n\n\tpolygon_layer(t,diameter,return_to_center=False)    \n\n\ndef circular_layer_centered(t,diameter):\n\tt.write_gcode_comment(\"starting circular layer\")\n\t# avoid generating too many points for small shapes\n\t# steps = adjust_circle_steps(diameter,360,t.get_resolution(),t.get_layer_height())\n\tsteps = 100\n\tcircumference = diameter * math.pi\n\ttheta_inc = 360/steps\n\tr = diameter/2.0\n\t\n\tfor s in range(0,steps+1):\n\t\tx = r*math.cos(math.radians(theta_inc*s))\n\t\ty = r*math.sin(math.radians(theta_inc*s))\n\t\tif (s==0):\n\t\t\tt.penup()\n\t\t\tt.set_position(x,y)\n\t\t\tt.pendown()\n\t\tt.set_position(x,y)\n\ndef circular_layer(t,diameter,spiral_up = True):\n\tt.write_gcode_comment(\"starting circular layer\")\n\t# avoid generating too many points for small shapes\n\tsteps = adjust_circle_steps(diameter,360,t.get_resolution(),t.get_layer_height())\n\tsteps = 100\n\tcircumference = diameter * math.pi\n\tc_inc = circumference/steps\n\n\tif (spiral_up): \n\t\tz_inc = t.get_layer_height()/steps\n\telse:\n\t\tz_inc = 0\n\t\n\tdtheta = 360.0/steps\n\t\n\tfor s in range(0,steps):\n\t\tif (spiral_up):\n\t\t\tt.forward_lift(c_inc,z_inc)\n\t\telse:\n\t\t\tt.forward(c_inc)\n\t\tt.left(dtheta)\n\n\n# creates a solid flat layer of polygons that spiral out from a center point\ndef polygon_layer(t, diameter, inner_diameter =False, steps=360, return_to_center = False, offset=0.0,rotation=0):\n\tt.set_heading(yaw=0)\n\tt.left(rotation)\n\tinitial_position = t.get_position()\n\tinitial_angle = t.get_yaw()\n\tif (t.write_gcode):\n\t\tt.write_gcode_comment(\"starting solid layer\")\n\t#set initial diameter d\n\td = t.get_extrude_width()*.5\n\tif (inner_diameter):\n\t\td = inner_diameter\n\tif (offset>0):\n\t\td = d + t.get_extrude_width()*.5\n\telse:\n\t\td = d + t.get_extrude_width()*1.5\n\n\tif (inner_diameter==False):\n\t\tt.extrude(2)\n\n\t#assume you start in the center of the circle\n\t#move to starting radius\n\tt.right(random.randint(0,360))\n\tt.penup()\n\tt.forward(d/2)\n\tt.right(90)\n\twhile (d < diameter-t.get_extrude_width()*2):\n\t\tt.pendown()\n\t\tnon_centered_poly(t,d)\n\t\tt.left(90)\n\t\tt.forward(t.get_extrude_width())\n\t\tt.right(90)\n\t\td = d+t.get_extrude_width()*2\n\n\tnon_centered_poly(t,d)\t\t\n\t# #move back to starting position\n\t# t.penup()\n\t# t.left(90)\n\t# t.forward((diameter-d)/2)\n\t# t.right(90)\n\t# d = d+(diameter-d)/2\n\n\tif (return_to_center):\n\t\tt.penup()\n\t\tt.lift(t.get_layer_height()*5)\n\t\tt.set_position_point(initial_position)\n\t\tt.set_heading(yaw=initial_angle)\n\t\tt.pendown()\n\n\n#creates a polygon centered around the turtle's current location\ndef centered_poly(t,diameter, steps=100):\n\t# avoid generating too many points for small shapes\n\t#steps = adjust_circle_steps(diameter, steps,t.get_resolution(),t.get_layer_height())\n\tr = diameter/2\n\tcircumference = diameter * math.pi\n\tc_inc = circumference/steps\n\n\touter_angle = 360.0/steps\n\tinner_angle = 180.0-360.0/steps\n\n\tt.penup()\n\tt.forward(r)\n\tt.left(outer_angle + inner_angle/2.0)\n\tt.pendown()\n\n\tfor i in range (steps+1):\n\t\tt.forward(c_inc)\n\t\tt.left(outer_angle)\n\n\tt.penup()\n\tt.left(outer_angle + inner_angle/2)\n\tt.forward(r)\n\tt.pendown()\n\n# generates a polygon with edges that are side_length long\ndef polygon(side_length, steps, t):\n\tr = side_length/(2*math.sin(math.radians(180/steps)))\n\touter_angle = 360/steps\n\tinner_angle = 180-360/steps\n\tt.penup()\n\tt.forward(r)\n\tt.left(outer_angle + inner_angle/2)\n\tt.pendown()\n\tfor j in range(steps):\n\t\tt.forward(side_length)\n\t\tt.left(outer_angle)\n\tt.penup()\n\tt.right(outer_angle + inner_angle/2)\n\tt.backward(r)\n\tt.pendown()\n\ndef filled_oscillating_circle_xy(diameter, a, nOscillations, t, steps=360):\n\tsteps = adjust_circle_steps(diameter, steps,t.get_resolution(),t.get_layer_height())\n\td = t.get_extrude_width()*2\n\tnumber_cycles = diameter/(t.get_extrude_width()*2)\n\tda = float(a)/number_cycles\n\ta2=da\n\twhile(d<diameter):\n\t\toscillating_circle_xy(d, a2, nOscillations, t, steps)\n\t\tt.left(90)\n\t\tt.forward(t.get_extrude_width())\n\t\tt.right(90)\n\t\td = d+t.get_extrude_width()*2 \n\t\ta2 = a2+da\n\toscillating_circle_xy(diameter, a2, nOscillations, t, steps)\n\ndef oscillating_circle(t, diameter, nOscillationsxy, axy, nOscillationsz=0, az=0, spiral_out=0, theta_offset=0, spiral_up = True, z_inc=0):\n\t# avoid generating too many points for small shapes\n\tsteps = adjust_circle_steps(diameter,360,t.get_resolution(),t.get_layer_height())\n\tsteps = 100\n\tcircumference = diameter * math.pi\n\tc_inc = circumference/steps\n\tif (spiral_up): \n\t\tz_inc = t.get_layer_height()/steps\n\telse:\n\t\tz_inc = 0\n\t#print(\"z_inc x steps: \" +str(round(z_inc,5)*steps))\n\n\tdtheta = 360.0/steps\n\t# to get 180 degrees out of phase add: theta_one_oscillation/2\n\tb = diameter/2\n\tx0 = t.getX()\n\ty0 = t.getY()\n\tz0 = t.getZ()\n\tz = z0\n\t# this is a problematic if statement. Will cause problems later!\n\tif (x0==0):\n\t\ttheta0 = 0\n\t\t# could also be theta0 = 90 or theta0 = 270\n\telif (x0 < 0):\n\t\ttheta0 = math.degrees(math.atan(y0/x0))+180\n\telse:\n\t\ttheta0 = math.degrees(math.atan(y0/x0))\n\n\tfor s in range(0,steps+1):\n\t\ttheta = theta0+dtheta*s\n\t\tif (theta_offset==0):\n\t\t\tr= b+axy*math.cos(nOscillationsxy*math.radians(theta))\n\t\telse:\n\t\t\tr= b+axy*math.cos(nOscillationsxy*math.radians(theta+theta_offset))\n\t\tif (nOscillations==0):\n\t\t\tr=diameter/2.0\n\t\tx = r*math.cos(math.radians(theta))\n\t\ty = r*math.sin(math.radians(theta))\n\t\tz = z + az*math.sin(math.radians(nOscillationsz*theta))\n\t\tif (z_inc != 0):\n\t\t\tz = z + z_inc\n\t\tt.set_position(x,y,z)\n\ndef square_oscillating_circle(t,inner_diameter, outer_diameter, nOscillations):\n\t# avoid generating too many points for small shapes\n\tsteps = adjust_circle_steps(diameter,360,t.get_resolution(),t.get_layer_height())\n\tinner_radius = inner_diameter/2\n\touter_radius = outer_diameter/2\n\tr_dif = outer_radius-inner_radius\n\tinner_circumference = math.pi*inner_diameter\n\touter_circumference = math.pi*outer_diameter\n\tinner_c_step = inner_circumference/steps\n\touter_c_step = outer_circumference/steps\n\ttheta_step = 360.0/steps\n\tfor i in range(0,nOscillations):\n\t\tfor j in range (0,int(steps/(nOscillations*2))):\n\t\t\tt.forward(inner_c_step)\n\t\t\tt.left(theta_step)\n\t\tt.right(90)\n\t\tt.forward(r_dif)\n\t\tt.left(90)\n\t\tfor j in range (0,int(steps/(nOscillations*2))):\n\t\t\tt.forward(outer_c_step)\n\t\t\tt.left(theta_step)\n\t\tt.left(90)\n\t\tt.forward(r_dif)\n\t\tt.right(90)\n\ndef polar_rose_old(t, a, n, x0=False, y0=False):\n\tif (x0==False):\n\t\tx0 = t.getX()\n\t\tprint(\"no x0\")\n\tif (y0==False):\n\t\ty0 = t.getY()\n\tsteps = 50\n\n\tdtheta = 360.0/steps\n\ttotal_steps = int(steps*1.5/(n)+1)\n\n\tfor s in range(0,total_steps):\n\t\ttheta = dtheta*s\n\t\tr= a*math.cos(n*math.radians(theta))\n\t\tx = r*math.cos(math.radians(theta))\n\t\ty = r*math.sin(math.radians(theta))\n\n\t\tt.set_position(x0+x,y0+y)\n\ndef polar_rose(t,d,p,q):\n\tin_r = d/2.0\n\tif ((p*q)%2==0):\n\t\tm = 2\n\telse:\n\t\tm = 1\n\n\tif (p % 2==1 or q%2==1):\n\t\tangle = 90\n\telse:\n\t\tangle = 45\n\n\titerations = int(2*angle*q*m)\n\tprint (\"total turning: \" +str(iterations))\n\tresolution = 4.0 #higher number, lower resolution\n\tfor i in range(0,int((iterations+resolution*1.99)/resolution)):\n\t\tr = in_r*math.cos(p/q*math.radians(i*resolution))\n\t\tx = r*math.cos(math.radians(i*resolution))\n\t\ty = r*math.sin(math.radians(i*resolution))\n\t\tt.set_position(x,y)\n\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}