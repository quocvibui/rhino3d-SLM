{
  "source_url": "https://github.com/McMuff86/rh_caminterface/blob/20a285ccf1ce1850b5a4ae296b07d8d04b1740c7/RH_caminterface_v007.py",
  "repo": "McMuff86/rh_caminterface",
  "repo_stars": 1,
  "repo_description": null,
  "license": "unknown",
  "filepath": "RH_caminterface_v007.py",
  "instruction": "Rhino → Maestro XCS-Generator (Selektion → XCS) Features: WK_PIECE                                         -> Außenkontur (DX/DY) CUT_E010[_Z20][_S5][_D9.5]                       -> Konturfräsen POCKET_E010[_Z12][_S3][_D8][_O5]                 -> Pocket (konzentrische Offsets) DRILL_D4.5[_Z17][_C P|L]                         -> Einzelbohrungen (Kreis/Punkt) DRILLROW_D5_Z17_P32[_N10]                        -> Lochreihe entlang Kurve RBNUT_CH_X_W6[_Z8][_S2][_E015]_[M|P]             -> Rückwandnut (Channel), Linie→Rechteck RBNUT_CH_Y_W6[_Z8][_S2][_E015]_[M|P] RBNUT_RNT_X_W6[_Z8]_C066_[M|P]                   -> Rückwandnut via RNT-Makro (X/Y, Mitte/Positiv) RBNUT_RNT_Y_W6[_Z8]_C066_[M|P]",
  "code": "#! python 3\n# Rhino → Maestro XCS-Generator (Selektion → XCS)\n# Features:\n#   WK_PIECE                                         -> Außenkontur (DX/DY)\n#   CUT_E010[_Z20][_S5][_D9.5]                       -> Konturfräsen\n#   POCKET_E010[_Z12][_S3][_D8][_O5]                 -> Pocket (konzentrische Offsets)\n#   DRILL_D4.5[_Z17][_C P|L]                         -> Einzelbohrungen (Kreis/Punkt)\n#   DRILLROW_D5_Z17_P32[_N10]                        -> Lochreihe entlang Kurve\n#   RBNUT_CH_X_W6[_Z8][_S2][_E015]_[M|P]             -> Rückwandnut (Channel), Linie→Rechteck\n#   RBNUT_CH_Y_W6[_Z8][_S2][_E015]_[M|P]\n#   RBNUT_RNT_X_W6[_Z8]_C066_[M|P]                   -> Rückwandnut via RNT-Makro (X/Y, Mitte/Positiv)\n#   RBNUT_RNT_Y_W6[_Z8]_C066_[M|P]\n\nimport rhinoscriptsyntax as rs\nimport Rhino\nimport System\nimport re, math\nfrom math import isclose\n\n# ---------------- Einstellungen ----------------\nDZ = 19.0                               # Werkstückdicke fix\nSETUP_OFFSET = (2.5, 2.5, 0.0, 0.0)     # x, y, z, rot\nLAYER_PIECE = \"WK_PIECE\"\nDEFAULT_TOOL_DIA = 9.5                  # mm (Fallback)\nDEFAULT_POCKET_STEPOVER = 0.7           # *ToolØ (für Pocket-Offsetschritt)\nGROOVE_OVERTRAVEL = 5.0                 # mm Überlauf an Nutenden\nPOLY_TOL = 0.05                         # mm – Kurve→Polyline\nDOC = Rhino.RhinoDoc.ActiveDoc\nTOL = DOC.ModelAbsoluteTolerance if DOC else 0.01\nUSE_CORNER_ROUNDING = False             # False = CreateIso gar nicht ausgeben\n\n# --- RNT Makro Steuerung ---\n\nUSE_RNT_MACRO = True\n\nRNT_TEMPLATE_X = (\n    'CreateMacro(\"{name}\",\"RNT\",'\n    '{x_start:.3f},{y_center:.3f},{width:.3f},-1,-1,-1,{x_len:.3f},{depth:.3f},true,'\n    '\"{code}\",\"-1\",false,false,true,{y_center:.3f},null,null,null,null,true);'\n)\n\nRNT_TEMPLATE_Y = (\n    'CreateMacro(\"{name}\",\"RNT\",'\n    '{x_center:.3f},{y_start:.3f},{width:.3f},-1,-1,-1,{y_len:.3f},{depth:.3f},true,'\n    '\"{code}\",\"-1\",false,false,true,{x_center:.3f},null,null,null,null,true);'\n)\n\n\n# ---------------- Eindeutige Namen ----------------\nMAX_NAME_LEN = 31\n\nclass UniqueNames:\n    def __init__(self, max_len=MAX_NAME_LEN):\n        self.used = set()\n        self.counts = {}\n        self.max_len = max_len\n    def sanitize(self, s):\n        s = re.sub(r'[^A-Za-z0-9_]', '_', s)\n        return s[:self.max_len] if len(s) > self.max_len else s\n    def get(self, base):\n        base = self.sanitize(base)\n        if base not in self.used and self.counts.get(base, 0) == 0:\n            self.used.add(base); self.counts[base] = 1\n            return base\n        n = self.counts.get(base, 1) + 1\n        while True:\n            cand = self.sanitize(f\"{base}_{n}\")\n            if cand not in self.used:\n                self.used.add(cand); self.counts[base] = n\n                return cand\n            n += 1\n\nNAME = UniqueNames()\ndef UNIQ(base): return NAME.get(base)\n\n# ---------------- Regex für Layer ----------------\nCUT_RX    = re.compile(r\"^CUT_(?P<tech>E(?P<num>\\d{2,3}))(?:_Z(?P<depth>\\d+(?:\\.\\d+)?))?(?:_S(?P<sd>\\d+(?:\\.\\d+)?))?(?:_D(?P<dia>\\d+(?:\\.\\d+)?))?$\", re.I)\nDRILL_RX  = re.compile(r\"^DRILL_D(?P<dia>\\d+(?:\\.\\d+)?)(?:_Z(?P<depth>\\d+(?:\\.\\d+)?))?(?:_C(?P<code>[PL]))?$\", re.I)\nROW_RX    = re.compile(r\"^DRILLROW_D(?P<dia>\\d+(?:\\.\\d+)?)(?:_Z(?P<depth>\\d+(?:\\.\\d+)?))?_P(?P<pitch>\\d+(?:\\.\\d+)?)(?:_N(?P<count>\\d+))?$\", re.I)\nPOCKET_RX = re.compile(r\"^POCKET_(?P<tech>E(?P<num>\\d{2,3}))(?:_Z(?P<depth>\\d+(?:\\.\\d+)?))?(?:_S(?P<sd>\\d+(?:\\.\\d+)?))?(?:_D(?P<dia>\\d+(?:\\.\\d+)?))?(?:_O(?P<ostep>\\d+(?:\\.\\d+)?))?$\", re.I)\nRBNUT_CH_RX = re.compile(\n    r\"^RBNUT_CH_(?P<axis>[XY])_W(?P<w>\\d+(?:\\.\\d+)?)\"\n    r\"(?:_Z(?P<depth>\\d+(?:\\.\\d+)?))?\"\n    r\"(?:_S(?P<sd>\\d+(?:\\.\\d+)?))?\"\n    r\"(?:_E(?P<technum>\\d{2,3}))?\"\n    r\"(?:_(?P<place>[MP]))?$\",\n    re.IGNORECASE\n)\n# RNT-Makro-Layer\nRBNUT_RNT_RX = re.compile(\n    r\"^RBNUT_RNT_(?P<axis>[XY])_W(?P<w>\\d+(?:\\.\\d+)?)\"\n    r\"(?:_Z(?P<depth>\\d+(?:\\.\\d+)?))?_C(?P<code>\\d{3})\"\n    r\"(?:_(?P<place>[MP]))?$\",\n    re.IGNORECASE\n)\n\ndef normalize_tech(tech, num_str):\n    try: return \"E{:03d}\".format(int(num_str))\n    except: return tech.upper()\n\n# ---------------- Geometrie-Helfer ----------------\ndef curve_is_closed(crv):\n    try: return crv.IsClosed\n    except: return False\n\ndef curve_area(crv):\n    amp = Rhino.Geometry.AreaMassProperties.Compute(crv)\n    return amp.Area if amp else 0.0\n\ndef to_poly_points(crv, tol=0.1):\n    plc = crv.ToPolyline(tol, tol, 0, 0)\n    if not plc:\n        plc = crv.ToPolyline(tol*0.5, tol*0.5, 0, 0)\n        if not plc: return None\n    pts = [(pt.X, pt.Y) for pt in plc.ToPolyline()]\n    if pts and (not isclose(pts[0][0], pts[-1][0]) or not isclose(pts[0][1], pts[-1][1])):\n        pts.append(pts[0])\n    return pts if len(pts) >= 4 else None\n\ndef bbox_xy(crv):\n    bb = crv.GetBoundingBox(True)\n    return (bb.Max.X - bb.Min.X), (bb.Max.Y - bb.Min.Y)\n\ndef orientation_sign(crv):\n    ori = Rhino.Geometry.Curve.ClosedCurveOrientation(crv, Rhino.Geometry.Plane.WorldXY)\n    return -1 if ori == Rhino.Geometry.CurveOrientation.CounterClockwise else +1\n\ndef inside_offsets(curv, step_dist):\n    res, current = [], curv\n    sign = orientation_sign(current)\n    dist = -sign * step_dist  # innen\n    while True:\n        arr = current.Offset(Rhino.Geometry.Plane.WorldXY, dist, TOL, Rhino.Geometry.CurveOffsetCornerStyle.Sharp)\n        if not arr or arr.Count == 0: break\n        best = max(arr, key=lambda c: curve_area(c))\n        if curve_area(best) <= 1e-6: break\n        res.append(best); current = best\n    return res\n\n# Rückwandnut: Linie → Rechteckpunkte (geschlossen)\ndef build_groove_rect_from_line(line_crv, axis, w, place, overtravel):\n    p0 = line_crv.PointAtStart\n    p1 = line_crv.PointAtEnd\n    x0, y0, x1, y1 = p0.X, p0.Y, p1.X, p1.Y\n\n    if axis == 'X':\n        y = 0.5*(y0 + y1)\n        x_start = min(x0, x1) - overtravel\n        x_end   = max(x0, x1) + overtravel\n        if place == 'M':\n            y_lo, y_hi = y - 0.5*w, y + 0.5*w\n        else:  # P → Y+\n            y_lo, y_hi = y, y + w\n        return [(x_start, y_lo), (x_end, y_lo), (x_end, y_hi), (x_start, y_hi), (x_start, y_lo)]\n\n    else:  # axis == 'Y'\n        x = 0.5*(x0 + x1)\n        y_start = min(y0, y1) - overtravel\n        y_end   = max(y0, y1) + overtravel\n        if place == 'M':\n            x_lo, x_hi = x - 0.5*w, x + 0.5*w\n        else:  # P → X+\n            x_lo, x_hi = x, x + w\n        return [(x_lo, y_start), (x_hi, y_start), (x_hi, y_end), (x_lo, y_end), (x_lo, y_start)]\n\n# Für RNT: Start/Ende/Mitte bestimmen\ndef groove_endpoints_from_line(line_crv, axis, place, width, overtravel):\n    p0 = line_crv.PointAtStart; p1 = line_crv.PointAtEnd\n    x0,y0,x1,y1 = p0.X, p0.Y, p1.X, p1.Y\n    if axis == 'X':\n        y_center = 0.5*(y0+y1)\n        x_start  = min(x0,x1) - overtravel\n        x_end    = max(x0,x1) + overtravel\n        if place == 'M':\n            return dict(x_start=x_start,x_end=x_end,\n                        y_center=y_center, y_start=y_center-width*0.5, y_end=y_center+width*0.5)\n        else:  # P → Y+\n            return dict(x_start=x_start,x_end=x_end,\n                        y_center=y_center, y_start=y_center, y_end=y_center+width)\n    else:  # 'Y'\n        x_center = 0.5*(x0+x1)\n        y_start  = min(y0,y1) - overtravel\n        y_end    = max(y0,y1) + overtravel\n        if place == 'M':\n            return dict(y_start=y_start,y_end=y_end,\n                        x_center=x_center, x_start=x_center-width*0.5, x_end=x_center+width*0.5)\n        else:  # P → X+\n            return dict(y_start=y_start,y_end=y_end,\n                        x_center=x_center, x_start=x_center, x_end=x_center+width)\n\n# ---------------- XCS-Ausgabe ----------------\ndef xcs_header(name, dx, dy, dz):\n    return \"\\n\".join([\n        '// *** Programm created by Rhino→Maestro Generator ***',\n        'SetMachiningParameters(\"IJ\",1,10,196608,false);',\n        f'CreateFinishedWorkpieceBox(\"{name}\", {dx:.3f}, {dy:.3f}, {dz:.3f});',\n        f'double DZ = {dz:.3f};',\n        f'SetWorkpieceSetupPosition({SETUP_OFFSET[0]},{SETUP_OFFSET[1]},{SETUP_OFFSET[2]},{SETUP_OFFSET[3]});',\n        ''\n    ])\n\ndef xcs_polyline_pass(poly_name, op_name, pts, tech, depth, tool_dia, plane=\"Top\"):\n    lines = [f'SelectWorkplane(\"{plane}\");']\n    x0, y0 = pts[0]\n    lines.append(f'CreatePolyline(\"{poly_name}\", {x0:.3f},{y0:.3f});')\n    for x, y in pts[1:]:\n        lines.append(f'AddSegmentToPolyline({x:.3f},{y:.3f});')\n\n    if USE_CORNER_ROUNDING:\n        iso_name = UNIQ(f\"ISO_AEA_{op_name}\")  # eindeutig\n        lines.append(f'CreateIso(\"{iso_name}\",\"CUTOCOK=0\",\"\",false);')\n\n    lines += [\n        'SetCompensationMode(false);',\n        'SetApproachStrategy(false,true,2);',\n        'SetRetractStrategy(false,true,2.0,2);',\n        'SetPneumaticHoodPosition(null);',\n        f'CreateRoughFinish(\"{op_name}\",{depth:.3f},\"\", TypeOfProcess.GeneralRouting ,\"{tech}\",\"-1\",2,-1,-1,-1,0);',\n        'ResetApproachStrategy();',\n        'ResetRetractStrategy();',\n        ''\n    ]\n    return \"\\n\".join(lines)\n\ndef xcs_drill(name, x, y, depth, dia, plane=\"Top\", side=\"P\"):\n    return \"\\n\".join([\n        f'SelectWorkplane(\"{plane}\");',\n        f'CreateDrill(\"{name}\",{x:.3f},{y:.3f},{depth:.3f},{dia:.3f},\"\",TypeOfProcess.Drilling,\"-1\",\"-1\",1,-1,-1,\"{side}\");',\n        'ResetPattern();',\n        ''\n    ])\n\n# ---------------- Layer-Parser ----------------\ndef parse_cut_layer(layer_name, dz_default=DZ):\n    m = CUT_RX.match(layer_name or \"\")\n    if not m: return None\n    tech = normalize_tech(m.group(\"tech\"), m.group(\"num\"))\n    depth = float(m.group(\"depth\")) if m.group(\"depth\") else dz_default\n    sd = float(m.group(\"sd\")) if m.group(\"sd\") else None\n    dia = float(m.group(\"dia\")) if m.group(\"dia\") else DEFAULT_TOOL_DIA\n    return tech, depth, sd, dia\n\ndef parse_drill_layer(layer_name, dz_default=DZ):\n    m = DRILL_RX.match(layer_name or \"\")\n    if not m: return None\n    dia = float(m.group(\"dia\"))\n    depth = float(m.group(\"depth\")) if m.group(\"depth\") else dz_default\n    code = (m.group(\"code\") or \"P\").upper()\n    return dia, depth, code\n\ndef parse_row_layer(layer_name, dz_default=DZ):\n    m = ROW_RX.match(layer_name or \"\")\n    if not m: return None\n    dia = float(m.group(\"dia\"))\n    depth = float(m.group(\"depth\")) if m.group(\"depth\") else dz_default\n    pitch = float(m.group(\"pitch\"))\n    count = int(m.group(\"count\")) if m.group(\"count\") else None\n    return dia, depth, pitch, count\n\ndef parse_pocket_layer(layer_name, dz_default=DZ):\n    m = POCKET_RX.match(layer_name or \"\")\n    if not m: return None\n    tech = normalize_tech(m.group(\"tech\"), m.group(\"num\"))\n    depth = float(m.group(\"depth\")) if m.group(\"depth\") else dz_default\n    sd = float(m.group(\"sd\")) if m.group(\"sd\") else None\n    dia = float(m.group(\"dia\")) if m.group(\"dia\") else DEFAULT_TOOL_DIA\n    ostep = float(m.group(\"ostep\")) if m.group(\"ostep\") else dia * DEFAULT_POCKET_STEPOVER\n    return tech, depth, sd, dia, ostep\n\ndef parse_rbnut_ch_layer(layer_name, dz_default=DZ):\n    m = RBNUT_CH_RX.match(layer_name or \"\")\n    if not m: return None\n    axis = m.group(\"axis\").upper()\n    w = float(m.group(\"w\"))\n    depth = float(m.group(\"depth\")) if m.group(\"depth\") else dz_default\n    sd = float(m.group(\"sd\")) if m.group(\"sd\") else None\n    tech = \"E{:03d}\".format(int(m.group(\"technum\"))) if m.group(\"technum\") else \"E010\"\n    place = (m.group(\"place\") or \"M\").upper()   # M = mittig, P = positiv (Y+ bei X-Nut, X+ bei Y-Nut)\n    return axis, w, depth, sd, tech, place\n\ndef parse_rbnut_rnt_layer(layer_name, dz_default=DZ):\n    m = RBNUT_RNT_RX.match(layer_name or \"\")\n    if not m: return None\n    axis  = m.group(\"axis\").upper()\n    w     = float(m.group(\"w\"))\n    depth = float(m.group(\"depth\")) if m.group(\"depth\") else dz_default\n    code  = m.group(\"code\")\n    place = (m.group(\"place\") or \"M\").upper()  # M=center, P=positive side\n    tech  = \"E010\"  # irrelevant für Makro; halten für Konsistenz\n    return axis, w, depth, code, place, tech\n\n# ---------------- Emitter ----------------\ndef emit_cut_operation(parts, base_name, pts, layer_name, mode_layer_stepdown):\n    parsed = parse_cut_layer(layer_name, DZ)\n    if not parsed: return\n    tech, depth_total, stepdown, tool_dia = parsed\n    if mode_layer_stepdown and stepdown is not None:\n        n = int(math.ceil(depth_total / stepdown))\n        for i in range(1, n+1):\n            z_i = min(i*stepdown, depth_total)\n            poly_name = UNIQ(f\"{base_name}_Z{z_i:.1f}\")\n            op_name   = UNIQ(f\"{base_name}_Z{z_i:.1f}_OP\")\n            parts.append(xcs_polyline_pass(poly_name, op_name, pts, tech, z_i, tool_dia))\n    else:\n        poly_name = UNIQ(f\"{base_name}\")\n        op_name   = UNIQ(f\"{base_name}_OP\")\n        parts.append(xcs_polyline_pass(poly_name, op_name, pts, tech, depth_total, tool_dia))\n\ndef emit_drill(parts, base_name, x, y, layer_name):\n    parsed = parse_drill_layer(layer_name, DZ)\n    if not parsed: return\n    dia, depth, code = parsed\n    unique = UNIQ(base_name)\n    parts.append(xcs_drill(unique, x, y, depth, dia, \"Top\", code))\n\ndef emit_drill_row(parts, base_name, crv, layer_name):\n    parsed = parse_row_layer(layer_name, DZ)\n    if not parsed: return\n    dia, depth, pitch, count = parsed\n    length = crv.GetLength()\n    if count is None:\n        count = int(math.floor(length / pitch)) + 1\n    for i in range(count):\n        s = min(i * pitch, length)\n        ok, t = crv.LengthParameter(s)\n        if not ok: continue\n        pt = crv.PointAt(t)\n        unique = UNIQ(f\"{base_name}_{i+1}\")\n        parts.append(xcs_drill(unique, pt.X, pt.Y, depth, dia, \"Top\", \"P\"))\n\ndef emit_pocket(parts, base_name, crv, layer_name, mode_layer_stepdown):\n    parsed = parse_pocket_layer(layer_name, DZ)\n    if not parsed: return\n    tech, depth_total, stepdown, tool_dia, ostep = parsed\n    pts_outer = to_poly_points(crv, POLY_TOL)\n    if not pts_outer: return\n\n    def passes_at_depth(label, depth_val, curve):\n        loops = [curve] + inside_offsets(curve, ostep)\n        for j, loop in enumerate(loops):\n            pts = to_poly_points(loop, POLY_TOL)\n            if not pts: continue\n            poly_name = UNIQ(f\"{label}_ring{j+1}\")\n            op_name   = UNIQ(f\"{label}_ring{j+1}_OP\")\n            parts.append(xcs_polyline_pass(poly_name, op_name, pts, tech, depth_val, tool_dia))\n\n    if mode_layer_stepdown and stepdown is not None:\n        n = int(math.ceil(depth_total / stepdown))\n        for i in range(1, n+1):\n            z_i = min(i*stepdown, depth_total)\n            passes_at_depth(f\"{base_name}_Z{z_i:.1f}\", z_i, crv)\n    else:\n        passes_at_depth(f\"{base_name}\", depth_total, crv)\n\ndef emit_rbnut_channel(parts, base_name, crv, layer_name, mode_layer_stepdown):\n    parsed = parse_rbnut_ch_layer(layer_name, DZ)\n    if not parsed: return\n    axis, w, depth_total, stepdown, tech, place = parsed\n\n    rect_pts = build_groove_rect_from_line(crv, axis, w, place, GROOVE_OVERTRAVEL)\n    if not rect_pts: return\n\n    if mode_layer_stepdown and stepdown is not None:\n        n = int(math.ceil(depth_total / stepdown))\n        for i in range(1, n+1):\n            z_i = min(i*stepdown, depth_total)\n            poly_name = UNIQ(f\"{base_name}_Z{z_i:.1f}\")\n            op_name   = UNIQ(f\"{base_name}_Z{z_i:.1f}_OP\")\n            parts.append(xcs_polyline_pass(poly_name, op_name, rect_pts, tech, z_i, DEFAULT_TOOL_DIA))\n    else:\n        poly_name = UNIQ(f\"{base_name}\")\n        op_name   = UNIQ(f\"{base_name}_OP\")\n        parts.append(xcs_polyline_pass(poly_name, op_name, rect_pts, tech, depth_total, DEFAULT_TOOL_DIA))\n\ndef emit_rbnut_rnt(parts, base_name, crv, layer_name):\n    if not USE_RNT_MACRO: return\n    parsed = parse_rbnut_rnt_layer(layer_name, DZ)\n    if not parsed: return\n    axis, w, depth, code, place, _tech = parsed\n\n    ends = groove_endpoints_from_line(crv, axis, place, w, GROOVE_OVERTRAVEL)\n\n    # Name – gern sprechend wie bei CAD+T:\n    nice = \"Nut in X-Richtung\" if axis == 'X' else \"Nut in Y-Richtung\"\n    macro_name = UNIQ(nice)\n\n    data = {\n        'name': macro_name,\n        'width': w,\n        'depth': depth,\n        'code': code,\n        'x_start':  ends.get('x_start',  0.0),\n        'x_end':    ends.get('x_end',    0.0),\n        'y_start':  ends.get('y_start',  0.0),\n        'y_end':    ends.get('y_end',    0.0),\n        'x_center': ends.get('x_center', 0.0),\n        'y_center': ends.get('y_center', 0.0),\n        'x_len':    abs(ends.get('x_end',0.0) - ends.get('x_start',0.0)),\n        'y_len':    abs(ends.get('y_end',0.0) - ends.get('y_start',0.0)),\n    }\n    parts.append('SelectWorkplane(\"Top\");')\n    if axis == 'X':\n        parts.append(RNT_TEMPLATE_X.format(**data))\n    else:\n        parts.append(RNT_TEMPLATE_Y.format(**data))\n    parts.append('')\n\n# ---------------- Hauptprogramm ----------------\ndef main():\n    ids = rs.GetObjects(\"Wähle Objekte (WK_PIECE, CUT_*, POCKET_*, DRILL_*, DRILLROW_*, RBNUT_CH_*, RBNUT_RNT_*)\",\n                        preselect=True, select=False, filter=rs.filter.allobjects)\n    if not ids:\n        rs.MessageBox(\"Keine Objekte ausgewählt.\", 48, \"Abbruch\"); return\n\n    choice = rs.ListBox(\n        items=[\"A: Technologie-Stepdown (Standard)\", \"B: Layer-Stepdown (_Sxx)\"],\n        message=\"Wie sollen Z-Schritte erzeugt werden?\",\n        title=\"Zustellstrategie wählen\"\n    )\n    if not choice: return\n    mode_layer_stepdown = choice.startswith(\"B\")\n\n    piece_curves = []\n    cuts, drills, rows, pockets, grooves, grooves_rnt = [], [], [], [], [], []\n\n    for obj_id in ids:\n        layer = rs.ObjectLayer(obj_id) or \"\"\n        obj = rs.coercerhinoobject(obj_id)\n        if not obj: continue\n        crv = rs.coercecurve(obj_id)\n\n        if crv and layer == LAYER_PIECE and curve_is_closed(crv):\n            piece_curves.append(crv); continue\n        if crv and CUT_RX.match(layer) and curve_is_closed(crv):\n            cuts.append((crv, layer)); continue\n        if crv and POCKET_RX.match(layer) and curve_is_closed(crv):\n            pockets.append((crv, layer)); continue\n        if crv and ROW_RX.match(layer) and not curve_is_closed(crv):\n            rows.append((crv, layer)); continue\n        if DRILL_RX.match(layer):\n            if obj.Geometry.ObjectType == Rhino.DocObjects.ObjectType.Circle:\n                c = obj.Geometry; center = c.Center\n                drills.append((center.X, center.Y, layer)); continue\n            if obj.Geometry.ObjectType == Rhino.DocObjects.ObjectType.Point:\n                p = obj.Geometry.Location\n                drills.append((p.X, p.Y, layer)); continue\n            if crv and isinstance(crv, Rhino.Geometry.ArcCurve) and crv.IsCircle():\n                circ = crv.Circle; center = circ.Center\n                drills.append((center.X, center.Y, layer)); continue\n        if crv and RBNUT_CH_RX.match(layer):\n            grooves.append((crv, layer)); continue\n        if crv and RBNUT_RNT_RX.match(layer):\n            grooves_rnt.append((crv, layer)); continue\n\n    if not piece_curves:\n        rs.MessageBox(\"Keine geschlossene Außenkontur auf Layer 'WK_PIECE' gefunden.\", 48, \"Abbruch\")\n        return\n\n    outer = max(piece_curves, key=curve_area)\n    dx, dy = bbox_xy(outer)\n\n    filt = \"Xilog Script (*.xcs)|*.xcs||\"\n    xcs_path = rs.SaveFileName(\"Speichere XCS\", filt)\n    if not xcs_path: return\n    if not xcs_path.lower().endswith(\".xcs\"): xcs_path += \".xcs\"\n    name = System.IO.Path.GetFileNameWithoutExtension(xcs_path)\n\n    parts = [xcs_header(name, dx, dy, DZ)]\n\n    # Fallback: wenn gar nichts außer WK_PIECE da ist → Außenkontur fräsen\n    if not cuts and not pockets and not drills and not rows and not grooves and not grooves_rnt:\n        pts = to_poly_points(outer, POLY_TOL)\n        if pts:\n            poly_name = UNIQ(\"Aussenkontur\")\n            op_name   = UNIQ(\"Aussenkontur_OP\")\n            parts.append(xcs_polyline_pass(poly_name, op_name, pts, \"E010\", DZ, DEFAULT_TOOL_DIA))\n\n    # CUT\n    for idx, (crv, layer_name) in enumerate(cuts, 1):\n        pts = to_poly_points(crv, POLY_TOL)\n        if pts:\n            emit_cut_operation(parts, f\"CUT_{idx}\", pts, layer_name, mode_layer_stepdown)\n\n    # POCKET\n    for idx, (crv, layer_name) in enumerate(pockets, 1):\n        emit_pocket(parts, f\"POCKET_{idx}\", crv, layer_name, mode_layer_stepdown)\n\n    # DRILL\n    for idx, (x, y, layer_name) in enumerate(drills, 1):\n        emit_drill(parts, f\"DRILL_{idx}\", x, y, layer_name)\n\n    # DRILLROW\n    for idx, (crv, layer_name) in enumerate(rows, 1):\n        emit_drill_row(parts, f\"DRILLROW_{idx}\", crv, layer_name)\n\n    # RBNUT per RNT-Makro\n    for idx, (crv, layer_name) in enumerate(grooves_rnt, 1):\n        emit_rbnut_rnt(parts, f\"RBNUT_RNT_{idx}\", crv, layer_name)\n\n    # RBNUT (Channel)\n    for idx, (crv, layer_name) in enumerate(grooves, 1):\n        emit_rbnut_channel(parts, f\"RBNUT_{idx}\", crv, layer_name, mode_layer_stepdown)\n\n    parts.append('CreateMacro(\"Wegfahrschritt\",\"XPARK\");\\n')\n\n    try:\n        with open(xcs_path, \"w\", encoding=\"utf-8\") as f:\n            f.write(\"\\n\".join(parts))\n        rs.MessageBox(\"XCS erstellt:\\n{}\".format(xcs_path), 64, \"Fertig\")\n    except Exception as ex:\n        rs.MessageBox(\"Fehler beim Schreiben:\\n{}\".format(ex), 16, \"Fehler\")\n\nif __name__ == \"__main__\":\n    main()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}