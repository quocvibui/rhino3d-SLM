{
  "source_url": "https://github.com/kellertobias/rhino-scripts/blob/1b965725c49d5e0f82ebb80006ce6300219ecbae/assemble_layouts.py",
  "repo": "kellertobias/rhino-scripts",
  "repo_stars": 0,
  "repo_description": null,
  "license": "unknown",
  "filepath": "assemble_layouts.py",
  "instruction": "Rhino 8 for macOS — Assemble layouts from exported DWGs and export vector PDF Behavior: - Discovers DWG files (by default: ~/Desktop/*-Export.dwg) or accepts explicit paths. - Optionally duplicates a master layout (if present) as the base for each page. - Creates one page layout per DWG and inserts a single detail viewport. - Sets the detail scale so that 1 mm on paper equals 0.2 m in the imported DWG by default. - Attempts to export a vector PDF of all layouts. Notes: - This script is designed to run in a mostly empty Rhino file. If a master layout exists, its page contents will be copied to every generated page by duplicating the master layout as a template. - Scaling can be adjusted via arguments to main().",
  "code": "# -*- coding: utf-8 -*-\n# Rhino 8 for macOS — Assemble layouts from exported DWGs and export vector PDF\n#\n# Behavior:\n# - Discovers DWG files (by default: ~/Desktop/*-Export.dwg) or accepts explicit paths.\n# - Optionally duplicates a master layout (if present) as the base for each page.\n# - Creates one page layout per DWG and inserts a single detail viewport.\n# - Sets the detail scale so that 1 mm on paper equals 0.2 m in the imported DWG by default.\n# - Attempts to export a vector PDF of all layouts.\n#\n# Notes:\n# - This script is designed to run in a mostly empty Rhino file. If a master\n#   layout exists, its page contents will be copied to every generated page\n#   by duplicating the master layout as a template.\n# - Scaling can be adjusted via arguments to main().\n\nimport rhinoscriptsyntax as rs\nimport Rhino\nimport os\nimport glob\nimport time\nimport logging\nimport tempfile\n\n# ---------- logging ----------\nlogger = logging.getLogger(\"assemble_layouts\")\n\n__version__ = \"0.3.2\"\n\n\ndef _default_log_path():\n    \"\"\"\n    Determine a writable log file path.\n    Preference order:\n      1) ~/Desktop/LayoutAssembly.log\n      2) current working directory ./LayoutAssembly.log\n      3) system temporary directory\n    \"\"\"\n    try:\n        desktop = os.path.join(os.path.expanduser('~'), 'Desktop')\n        if os.path.isdir(desktop):\n            return os.path.join(desktop, \"LayoutAssembly.log\")\n    except Exception:\n        pass\n    try:\n        return os.path.join(os.getcwd(), \"LayoutAssembly.log\")\n    except Exception:\n        pass\n    return os.path.join(tempfile.gettempdir(), \"LayoutAssembly.log\")\n\n\ndef _setup_logging():\n    \"\"\"\n    Configure logging only once per interpreter session.\n    - FileHandler captures DEBUG and above (full fidelity)\n    - StreamHandler captures INFO and above (human friendly)\n    \"\"\"\n    if getattr(_setup_logging, \"_configured\", False):\n        return\n    log_path = _default_log_path()\n    logger.setLevel(logging.DEBUG)\n    formatter = logging.Formatter(\n        fmt=\"%(asctime)s %(levelname)s [%(name)s] %(message)s\",\n        datefmt=\"%Y-%m-%d %H:%M:%S\"\n    )\n    try:\n        fh = logging.FileHandler(log_path, encoding=\"utf-8\")\n        fh.setLevel(logging.DEBUG)\n        fh.setFormatter(formatter)\n        logger.addHandler(fh)\n    except Exception:\n        logger.debug(\n            \"FileHandler init failed; continuing with console-only.\", exc_info=True)\n    ch = logging.StreamHandler()\n    ch.setLevel(logging.INFO)\n    ch.setFormatter(formatter)\n    logger.addHandler(ch)\n    _setup_logging._configured = True\n    logger.debug(\"Logging initialized. Log file: %s\", log_path)\n\n\n_setup_logging()\n\n# ---------- user input helpers ----------\n\n\ndef _get_page_format_dimensions(format_name, landscape=False):\n    \"\"\"\n    Get page width and height in millimeters for a given format name.\n\n    Args:\n        format_name: Page format name (A5, A4, A3, A2, A1) - case insensitive\n        landscape: If True, swap width and height for landscape orientation\n\n    Returns:\n        tuple: (width_mm, height_mm) or None if format not recognized\n    \"\"\"\n    formats = {\n        'A5': (148.0, 210.0),\n        'A4': (210.0, 297.0),\n        'A3': (297.0, 420.0),\n        'A2': (420.0, 594.0),\n        'A1': (594.0, 841.0),\n    }\n    dimensions = formats.get(format_name.upper().strip())\n    if dimensions and landscape:\n        # Swap width and height for landscape\n        return (dimensions[1], dimensions[0])\n    return dimensions\n\n\ndef _prompt_orientation():\n    \"\"\"\n    Prompt user to select page orientation (Portrait or Landscape).\n\n    Returns:\n        bool: True for landscape, False for portrait, or None if cancelled\n    \"\"\"\n    prompt = \"Select orientation (Portrait/Landscape) [Portrait]: \"\n    default = \"Portrait\"\n    result = rs.GetString(prompt, default)\n\n    if result is None:\n        return None\n\n    result = result.strip()\n    if not result:\n        result = default\n\n    result_lower = result.lower()\n    if result_lower.startswith('l'):\n        logger.info(\"Selected orientation: Landscape\")\n        return True\n    elif result_lower.startswith('p'):\n        logger.info(\"Selected orientation: Portrait\")\n        return False\n    else:\n        logger.warning(\n            \"Invalid orientation '%s', using default Portrait\", result)\n        return False\n\n\ndef _prompt_page_format():\n    \"\"\"\n    Prompt user to select a page format (A5, A4, A3, A2, A1) and orientation.\n\n    Returns:\n        tuple: (width_mm, height_mm) or None if cancelled\n    \"\"\"\n    prompt = \"Select page format (A5, A4, A3, A2, A1) [A3]: \"\n    default = \"A3\"\n    result = rs.GetString(prompt, default)\n\n    if result is None:\n        return None\n\n    result = result.strip()\n    if not result:\n        result = default\n\n    dimensions = _get_page_format_dimensions(result)\n    if dimensions is None:\n        logger.warning(\"Invalid format '%s', using default A3\", result)\n        dimensions = _get_page_format_dimensions(\"A3\")\n        result = \"A3\"\n\n    # Prompt for orientation\n    logger.info(\"Prompting for page orientation...\")\n    landscape = _prompt_orientation()\n    if landscape is None:\n        logger.warning(\n            \"Orientation selection cancelled, using default Portrait\")\n        landscape = False\n\n    # Apply orientation\n    if landscape:\n        dimensions = (dimensions[1], dimensions[0])  # Swap width and height\n\n    orientation_str = \"Landscape\" if landscape else \"Portrait\"\n    logger.info(\"Selected page format: %s %s (%.1f x %.1f mm)\",\n                result.upper(), orientation_str, dimensions[0], dimensions[1])\n    return dimensions\n\n\ndef _prompt_scale():\n    \"\"\"\n    Prompt user for the drawing scale.\n    Format: 1mm page = XX mm drawing\n\n    Returns:\n        tuple: (scale_paper_mm, scale_model_mm) where scale_model_mm is the drawing scale\n               or None if cancelled\n    \"\"\"\n    prompt = \"Enter scale: 1mm page = XX mm drawing [200]: \"\n    default = \"200\"\n    result = rs.GetString(prompt, default)\n\n    if result is None:\n        return None\n\n    result = result.strip()\n    if not result:\n        result = default\n\n    try:\n        scale_model_mm = float(result)\n        if scale_model_mm <= 0:\n            raise ValueError(\"Scale must be positive\")\n        scale_paper_mm = 1.0\n        logger.info(\"Scale set: 1 mm page = %.1f mm drawing\", scale_model_mm)\n        return (scale_paper_mm, scale_model_mm)\n    except (ValueError, TypeError) as e:\n        logger.warning(\"Invalid scale '%s', using default 200\", result)\n        return (1.0, 200.0)\n\n\ndef _prompt_folder():\n    \"\"\"\n    Prompt user to select a folder containing DWG files.\n\n    Returns:\n        str: Folder path or None if cancelled\n    \"\"\"\n    # Try to get folder using Rhino's file dialog\n    try:\n        folder = rs.BrowseForFolder(\n            message=\"Select folder containing DWG files\")\n        if folder and os.path.isdir(folder):\n            logger.info(\"Selected folder: %s\", folder)\n            return folder\n    except Exception:\n        logger.debug(\"BrowseForFolder failed, trying GetString\", exc_info=True)\n\n    # Fallback: prompt for folder path as string\n    desktop = os.path.join(os.path.expanduser('~'), 'Desktop')\n    prompt = \"Enter folder path containing DWG files [{}]: \".format(desktop)\n    result = rs.GetString(prompt, desktop)\n\n    if result is None:\n        return None\n\n    result = result.strip()\n    if not result:\n        result = desktop\n\n    # Expand user home directory if needed\n    result = os.path.expanduser(result)\n\n    if not os.path.isdir(result):\n        logger.error(\"Invalid folder path: %s\", result)\n        return None\n\n    logger.info(\"Selected folder: %s\", result)\n    return result\n\n\n# ---------- helpers ----------\n\n\ndef _get_page_view_names():\n    \"\"\"\n    Retrieve the names of all layout page views in the active document.\n\n    This prefers RhinoCommon (reliable across Rhino versions). If the legacy\n    rhinoscriptsyntax API `PageViewNames` exists in the current runtime, it is\n    used as a soft fallback for compatibility with certain environments.\n\n    Returns:\n        list[str]: A list of layout page names (strings). May be empty.\n    \"\"\"\n    try:\n        # Primary path: RhinoCommon is stable and available in headless-safe contexts\n        page_views = Rhino.RhinoDoc.ActiveDoc.Views.GetPageViews()\n        return [pv.PageName for pv in page_views] if page_views else []\n    except Exception:\n        logger.debug(\n            \"RhinoCommon page view discovery failed; trying rs.PageViewNames if present.\", exc_info=True)\n    # Soft fallback: only call if attribute exists to avoid AttributeError on some builds\n    try:\n        page_view_names_func = getattr(rs, \"PageViewNames\", None)\n        if callable(page_view_names_func):\n            names = page_view_names_func() or []\n            return list(names)\n    except Exception:\n        logger.debug(\"rs.PageViewNames fallback failed.\", exc_info=True)\n    return []\n\n\ndef _activate_layout_or_create(name, width_mm=420.0, height_mm=297.0):\n    \"\"\"\n    Activate an existing layout by name or create it if missing.\n\n    Args:\n        name: Layout page name\n        width_mm: Page width in millimeters (default: 420.0)\n        height_mm: Page height in millimeters (default: 297.0)\n\n    Returns:\n        tuple: (page_view, page_id) where page_view is the PageView object\n               and page_id is the viewport GUID\n    \"\"\"\n    logger.debug(\"Activating or creating layout: %s\", name)\n    # Try existing\n    for pv in Rhino.RhinoDoc.ActiveDoc.Views.GetPageViews():\n        if pv.PageName == name:\n            Rhino.RhinoDoc.ActiveDoc.Views.ActiveView = pv\n            try:\n                rs.CurrentView(pv.PageName)\n            except Exception:\n                logger.debug(\"Failed to switch to page view: %s\",\n                             pv.PageName, exc_info=True)\n            return pv, pv.ActiveViewportID\n    # Create new layout using RhinoCommon (more reliable than rs.AddLayout)\n    try:\n        # Use RhinoCommon's AddPageView which accepts name, width, height\n        page_view = Rhino.RhinoDoc.ActiveDoc.Views.AddPageView(\n            name, width_mm, height_mm)\n        if page_view is None:\n            raise Exception(\"Failed to create layout: {}\".format(name))\n        page_id = page_view.ActiveViewportID\n        # Activate the newly created page view\n        Rhino.RhinoDoc.ActiveDoc.Views.ActiveView = page_view\n        try:\n            rs.CurrentView(page_view.PageName)\n        except Exception:\n            logger.debug(\"Failed to set CurrentView to layout %s\",\n                         page_view.PageName, exc_info=True)\n        # Ensure page size and name are correct\n        try:\n            page_view.PageWidth = width_mm\n            page_view.PageHeight = height_mm\n        except Exception:\n            logger.debug(\n                \"Failed to enforce page dimensions after creation.\", exc_info=True)\n        try:\n            # Ensure page is named correctly (prefer RhinoCommon setter)\n            page_view.PageName = name\n        except Exception:\n            logger.debug(\"Direct PageName set failed.\", exc_info=True)\n            try:\n                # Fallback to rename by id\n                rs.RenameLayout(page_id, name)\n            except Exception:\n                logger.debug(\n                    \"Rename after creation failed (may already be correct).\", exc_info=True)\n        logger.debug(\"Created layout '%s' with size %.1f x %.1f mm\",\n                     name, width_mm, height_mm)\n        return page_view, page_id\n    except Exception as e:\n        # Fallback: try rs.AddLayout with just the name, then set dimensions\n        logger.debug(\n            \"RhinoCommon AddPageView failed, trying rs.AddLayout fallback\", exc_info=True)\n        try:\n            page_id = rs.AddLayout(name)\n            if not page_id:\n                raise Exception(\"Failed to create layout: {}\".format(name))\n            # Resolve page view\n            page_view = None\n            for pv in Rhino.RhinoDoc.ActiveDoc.Views.GetPageViews():\n                if pv.ActiveViewportID == page_id:\n                    page_view = pv\n                    break\n            if page_view is None:\n                # fallback by name match\n                for pv in Rhino.RhinoDoc.ActiveDoc.Views.GetPageViews():\n                    if pv.PageName == name:\n                        page_view = pv\n                        break\n            if page_view is None:\n                raise Exception(\n                    \"Created layout but could not resolve page view for: {}\".format(name))\n            # Set page dimensions\n            try:\n                page_view.PageWidth = width_mm\n                page_view.PageHeight = height_mm\n            except Exception:\n                logger.debug(\n                    \"Failed to set page dimensions, using defaults\", exc_info=True)\n            Rhino.RhinoDoc.ActiveDoc.Views.ActiveView = page_view\n            try:\n                rs.CurrentView(page_view.PageName)\n            except Exception:\n                logger.debug(\"Failed to set CurrentView to layout %s\",\n                             page_view.PageName, exc_info=True)\n            return page_view, page_id\n        except Exception:\n            raise Exception(\"Failed to create layout '{}': {}\".format(name, e))\n\n\ndef _duplicate_master_layout(master_name):\n    \"\"\"\n    Duplicate master layout by name.\n    Returns the new page view id (GUID) or None on failure.\n    \"\"\"\n    logger.debug(\"Duplicating master layout: %s\", master_name)\n    try:\n        return rs.DuplicateLayout(master_name)\n    except Exception:\n        logger.debug(\"Failed to duplicate master layout.\", exc_info=True)\n        return None\n\n\ndef _find_master_layout(explicit_name=None):\n    \"\"\"\n    Decide on a master layout to use as a template.\n    Priority:\n      1) explicit_name (if provided and exists)\n      2) layout named 'MASTER' (case-insensitive)\n      3) first existing layout\n      4) None (no master)\n    Returns layout name or None.\n    \"\"\"\n    # Use robust page view discovery that works across Rhino versions\n    names = _get_page_view_names()\n    if not names:\n        logger.info(\n            \"No existing layouts found; proceeding without a master layout.\")\n        return None\n    if explicit_name and explicit_name in names:\n        logger.info(\"Using explicit master layout: %s\", explicit_name)\n        return explicit_name\n    for n in names:\n        if n.strip().lower() == \"master\":\n            logger.info(\"Using 'MASTER' as master layout.\")\n            return n\n    logger.info(\"Using first layout as master: %s\", names[0])\n    return names[0]\n\n\ndef _detail_rect_with_margin(page_view, margin_mm=10.0):\n    \"\"\"\n    Compute a detail rectangle (left,bottom,right,top) within the page bounds in mm.\n    \"\"\"\n    w = page_view.PageWidth\n    h = page_view.PageHeight\n    l = margin_mm\n    b = margin_mm\n    r = max(margin_mm, w - margin_mm)\n    t = max(margin_mm, h - margin_mm)\n    return l, b, r, t\n\n\ndef _resolve_layout_guid(page_view):\n    \"\"\"\n    Best-effort resolution of the layout (page view) GUID required by rs.AddDetail.\n    Tries multiple strategies to obtain a GUID for the provided page_view.\n    Returns GUID or None if not found.\n    \"\"\"\n    # Try rhinoscriptsyntax ViewId by page name (works for page views in many builds)\n    try:\n        vid = rs.ViewId(page_view.PageName)\n        if vid:\n            return vid\n    except Exception:\n        logger.debug(\"rs.ViewId failed for page '%s'\", getattr(\n            page_view, \"PageName\", \"?\"), exc_info=True)\n    # Try RhinoCommon: some builds expose MainViewport.Id which is a Guid we can reuse\n    try:\n        for pv in Rhino.RhinoDoc.ActiveDoc.Views.GetPageViews():\n            if pv.PageName == page_view.PageName:\n                try:\n                    mv = pv.MainViewport\n                    if mv and getattr(mv, \"Id\", None):\n                        return mv.Id\n                except Exception:\n                    pass\n    except Exception:\n        logger.debug(\n            \"Failed to resolve layout GUID via RhinoCommon.\", exc_info=True)\n    return None\n\n\ndef _rename_layout(page_view, target_name):\n    \"\"\"\n    Robustly rename a layout (page view) to target_name.\n    Tries RhinoCommon first, falls back to RhinoScriptSyntax by GUID.\n    Logs before/after state for debugging.\n    Returns True on success.\n    \"\"\"\n    try:\n        before_names = [\n            pv.PageName for pv in Rhino.RhinoDoc.ActiveDoc.Views.GetPageViews()]\n        logger.debug(\"Renaming layout. Before names: %s\", before_names)\n        # Try direct set on provided page_view\n        try:\n            old = page_view.PageName\n            page_view.PageName = target_name\n            logger.debug(\n                \"Set PageName via RhinoCommon: '%s' -> '%s'\", old, target_name)\n        except Exception:\n            logger.debug(\n                \"Direct PageName set on page_view failed.\", exc_info=True)\n        # Verify\n        after_names = [\n            pv.PageName for pv in Rhino.RhinoDoc.ActiveDoc.Views.GetPageViews()]\n        if target_name in after_names:\n            logger.info(\"Layout renamed to '%s' (verified)\", target_name)\n            return True\n        # Fallback to GUID-based rename\n        guid = _resolve_layout_guid(page_view)\n        logger.debug(\"Fallback rename: resolved guid=%s for '%s'\",\n                     str(guid), getattr(page_view, \"PageName\", \"?\"))\n        if guid:\n            try:\n                rs.RenameLayout(guid, target_name)\n            except Exception:\n                logger.debug(\"rs.RenameLayout by guid failed.\", exc_info=True)\n        # Re-verify\n        final_names = [\n            pv.PageName for pv in Rhino.RhinoDoc.ActiveDoc.Views.GetPageViews()]\n        logger.debug(\"Renaming layout. After names: %s\", final_names)\n        ok = target_name in final_names\n        if ok:\n            logger.info(\n                \"Layout renamed to '%s' (post-fallback verified)\", target_name)\n        else:\n            logger.warning(\n                \"Layout rename to '%s' did not reflect in views list.\", target_name)\n        return ok\n    except Exception:\n        logger.debug(\"Rename layout helper failed.\", exc_info=True)\n        return False\n\n\ndef _add_or_replace_single_detail(page_view, margin_mm=10.0):\n    \"\"\"\n    Ensure the layout has exactly one unlocked detail covering the page with a margin.\n    Returns the detail object id (GUID).\n    \"\"\"\n    logger.debug(\"Preparing single detail on page: %s\", page_view.PageName)\n    # Delete existing details\n    try:\n        detail_ids = rs.ObjectsByType(32768, select=False) or [\n        ]  # 32768 = detail objects\n        # Filter by current page\n        current_page_id = page_view.ActiveViewportID\n        to_delete = []\n        for did in detail_ids:\n            try:\n                obj = Rhino.RhinoDoc.ActiveDoc.Objects.Find(did)\n                if obj and obj.Attributes and obj.Attributes.Space == Rhino.DocObjects.ActiveSpace.PageSpace:\n                    if obj.Attributes.LayoutIndex == page_view.PageNumber:\n                        to_delete.append(did)\n            except Exception:\n                logger.debug(\n                    \"Error inspecting detail object; skipping.\", exc_info=True)\n        if to_delete:\n            rs.DeleteObjects(to_delete)\n    except Exception:\n        logger.debug(\"Failed to clean prior details.\", exc_info=True)\n    # Add new detail\n    l, b, r, t = _detail_rect_with_margin(page_view, margin_mm=margin_mm)\n    logger.debug(\n        \"Detail rectangle: left=%.1f, bottom=%.1f, right=%.1f, top=%.1f\", l, b, r, t)\n\n    # Ensure we're on the correct page view\n    try:\n        Rhino.RhinoDoc.ActiveDoc.Views.ActiveView = page_view\n        rs.CurrentView(page_view.PageName)\n        time.sleep(0.1)  # Give Rhino time to switch views\n    except Exception as e:\n        logger.debug(\n            \"Failed to activate page view before adding detail: %s\", e, exc_info=True)\n\n    # Try rs.AddDetail first (most reliable)\n    detail_id = None\n    try:\n        # Ensure page view is active before adding detail\n        Rhino.RhinoDoc.ActiveDoc.Views.ActiveView = page_view\n        rs.CurrentView(page_view.PageName)\n        time.sleep(0.15)  # Give Rhino time to fully activate the view\n\n        # rs.AddDetail expects the layout GUID. Resolve best-effort.\n        layout_guid = _resolve_layout_guid(page_view)\n        if not layout_guid:\n            raise Exception(\n                \"Could not resolve layout GUID for page '{}'\".format(page_view.PageName))\n        logger.debug(\"Calling rs.AddDetail with: layout_id=%s, corner1=(%.1f, %.1f), corner2=(%.1f, %.1f)\",\n                     str(layout_guid), l, b, r, t)\n        # rs.AddDetail expects two 2D points (corner1, corner2)\n        corner1 = (float(l), float(b))\n        corner2 = (float(r), float(t))\n        # Use positional parameters only for compatibility across builds\n        detail_id = rs.AddDetail(layout_guid, corner1, corner2)\n        if detail_id:\n            logger.debug(\"Created detail using rs.AddDetail: %s\", detail_id)\n            # Unlock to allow zoom and scale\n            try:\n                rs.DetailLock(detail_id, False)\n            except Exception:\n                pass\n            # Try to set the detail view to Top (World) for consistent orientation\n            try:\n                try:\n                    rs.CurrentDetail(detail_id, True)\n                except Exception:\n                    logger.debug(\n                        \"rs.CurrentDetail activation failed.\", exc_info=True)\n                rs.Command(u'_-SetView _World _Top _Enter', echo=False)\n            except Exception:\n                logger.debug(\n                    \"Failed to set detail view to World Top.\", exc_info=True)\n            return detail_id\n        else:\n            logger.warning(\n                \"rs.AddDetail returned None for page: %s (this usually means the call failed silently)\", page_view.PageName)\n    except Exception as e:\n        logger.error(\"rs.AddDetail failed with exception for page '%s': %s\",\n                     page_view.PageName, e, exc_info=True)\n\n    # Fallback: Try using command-based approach (less reliable, but worth trying)\n    if not detail_id:\n        try:\n            logger.debug(\"Trying command-based detail creation as last resort\")\n            # Note: Command-based detail creation is unreliable and may not work\n            # We'll try it but don't expect it to succeed in all cases\n            # The Detail command typically requires interactive input for coordinates\n            pass  # Skip command-based approach as it's causing parsing errors\n        except Exception as e:\n            logger.debug(\n                \"Command-based detail creation skipped: %s\", e)\n\n    # Last resort: Try RhinoCommon\n    if not detail_id:\n        try:\n            logger.debug(\"Trying RhinoCommon AddDetail\")\n            # Create detail using RhinoCommon - need to convert to proper coordinate system\n            # Details on page space use page coordinates (mm from bottom-left)\n            plane = Rhino.Geometry.Plane(\n                Rhino.Geometry.Point3d(l, b, 0),\n                Rhino.Geometry.Vector3d.XAxis,\n                Rhino.Geometry.Vector3d.YAxis\n            )\n            detail = Rhino.RhinoDoc.ActiveDoc.Views.AddDetail(\n                page_view.Id,\n                Rhino.Geometry.Rectangle3d(\n                    plane,\n                    Rhino.Geometry.Interval(0, r - l),\n                    Rhino.Geometry.Interval(0, t - b)\n                ),\n                \"Top\"\n            )\n            if detail:\n                detail_id = detail.Id\n                logger.debug(\"Created detail using RhinoCommon: %s\", detail_id)\n                try:\n                    rs.DetailLock(detail_id, False)\n                except Exception:\n                    pass\n                return detail_id\n        except Exception as e:\n            logger.debug(\"RhinoCommon AddDetail failed: %s\", e, exc_info=True)\n\n    logger.error(\"All methods failed to add detail to page: %s\",\n                 page_view.PageName)\n    return None\n\n\ndef _set_detail_scale(detail_id, paper_mm_per_model_unit=1.0/0.2, model_unit=\"Meters\"):\n    \"\"\"\n    Configure detail scale using rs.DetailScale:\n      paper_length(mm) : model_length(model_unit)\n    (Deprecated: prefer _apply_detail_scale_mm)\n    \"\"\"\n    try:\n        # Calculate model_length from the ratio\n        # paper_mm_per_model_unit = paper_mm / model_length\n        # So: model_length = paper_mm / paper_mm_per_model_unit\n        # We use paper_length = 1.0 mm as the reference\n        paper_length = 1.0\n        model_length = paper_length / paper_mm_per_model_unit\n\n        # Explicitly set the scale with units; rs.DetailScale expects model_length, paper_length, and optional units\n        rs.DetailScale(detail_id, model_length, paper_length,\n                       model_unit, \"Millimeters\")\n        logger.debug(\"Detail scale set: %.3f mm paper = %.3f %s model\",\n                     paper_length, model_length, model_unit)\n        return True\n    except Exception:\n        logger.debug(\"Failed to set detail scale.\", exc_info=True)\n        return False\n\n\ndef _apply_detail_scale_mm(detail_id, scale_model_mm):\n    \"\"\"\n    Set detail scale using millimeters for both model and paper units.\n    Interprets the user input as: 1 mm paper = scale_model_mm mm drawing/model.\n\n    Args:\n        detail_id: GUID of the detail viewport\n        scale_model_mm: Number of millimeters in model that correspond to 1 mm on paper\n    \"\"\"\n    try:\n        # Convert requested model length (mm) to current document model units\n        doc_units = Rhino.RhinoDoc.ActiveDoc.ModelUnitSystem\n        factor = Rhino.RhinoMath.UnitScale(\n            Rhino.UnitSystem.Millimeters, doc_units)\n        model_length_in_doc = float(scale_model_mm) * factor\n        paper_length_mm = 1.0  # page units are millimeters\n        # Determine model unit system name string for rs.DetailScale\n        unit_map = {\n            Rhino.UnitSystem.Millimeters: \"Millimeters\",\n            Rhino.UnitSystem.Centimeters: \"Centimeters\",\n            Rhino.UnitSystem.Meters: \"Meters\",\n            Rhino.UnitSystem.Inches: \"Inches\",\n            Rhino.UnitSystem.Feet: \"Feet\",\n        }\n        model_unit_name = unit_map.get(doc_units, None)\n        # Use explicit units so paper length is interpreted in mm\n        if model_unit_name:\n            rs.DetailScale(detail_id, model_length_in_doc,\n                           paper_length_mm, model_unit_name, \"Millimeters\")\n        else:\n            rs.DetailScale(detail_id, model_length_in_doc, paper_length_mm)\n        logger.debug(\"Applied detail scale: 1 mm paper = %.3f %s (from %.3f mm model)\",\n                     model_length_in_doc, model_unit_name or \"doc-units\", float(scale_model_mm))\n        return True\n    except Exception:\n        logger.debug(\"Failed to apply millimeter detail scale.\", exc_info=True)\n        return False\n\n\ndef _center_detail_on_bbox(detail_id, bbox_points):\n    \"\"\"\n    Center the active detail view on the provided bounding box center without changing scale.\n    Assumes the detail is currently showing the model in Top projection.\n    \"\"\"\n    try:\n        if not bbox_points:\n            return False\n        # Compute center of bounding box\n        xs = [p.X if hasattr(p, \"X\") else p[0] for p in bbox_points]\n        ys = [p.Y if hasattr(p, \"Y\") else p[1] for p in bbox_points]\n        zs = [p.Z if hasattr(p, \"Z\") else (\n            p[2] if len(p) > 2 else 0.0) for p in bbox_points]\n        cx, cy, cz = sum(xs)/len(xs), sum(ys)/len(ys), sum(zs)/len(zs)\n        center = (cx, cy, cz)\n        # Activate the detail\n        try:\n            rs.CurrentDetail(detail_id, True)\n        except Exception:\n            logger.debug(\n                \"Failed to activate detail for centering.\", exc_info=True)\n        # Read current camera/target and preserve relative offset\n        try:\n            cam, tgt = rs.ViewCameraTarget()\n            if cam and tgt:\n                dx = cam[0] - tgt[0]\n                dy = cam[1] - tgt[1]\n                dz = cam[2] - tgt[2]\n                new_target = center\n                new_camera = (new_target[0] + dx,\n                              new_target[1] + dy, new_target[2] + dz)\n                rs.ViewCameraTarget(camera_point=new_camera,\n                                    target_point=new_target)\n                logger.debug(\n                    \"Centered detail on bbox center at (%.3f, %.3f, %.3f)\", cx, cy, cz)\n                return True\n        except Exception:\n            logger.debug(\n                \"Failed to center detail via camera/target.\", exc_info=True)\n        return False\n    except Exception:\n        logger.debug(\"Centering detail failed.\", exc_info=True)\n        return False\n\n\ndef _import_dwg_capture_new_objects(path):\n    \"\"\"\n    Import a DWG and return the list of newly added object ids.\n    \"\"\"\n    logger.info(\"Importing DWG: %s\", path)\n    before = set(rs.AllObjects() or [])\n    # Use robust command variants to avoid UI prompts\n    cmds = [\n        u'-_Import \"{}\" _Enter'.format(path),\n        u'-_Import {} _Enter'.format(path),\n    ]\n    for cmd in cmds:\n        rs.Command(cmd, echo=False)\n        time.sleep(0.15)\n        after = set(rs.AllObjects() or [])\n        diff = list(after - before)\n        if diff:\n            logger.info(\"Imported %d new objects from %s\",\n                        len(diff), os.path.basename(path))\n            return diff\n    logger.error(\"DWG import produced no new geometry: %s\", path)\n    return []\n\n\ndef _derive_layout_name_from_objects(object_ids, fallback_name):\n    \"\"\"\n    Derive a layout name from imported objects by inspecting their layers.\n    Strategy:\n      - Count occurrences of the top-level layer name among the provided objects\n      - Choose the most frequent top-level layer\n      - Sanitize and return that as the layout name\n      - Fallback to the provided fallback_name if nothing useful can be derived\n    \"\"\"\n    try:\n        if not object_ids:\n            return fallback_name\n        layer_counts = {}\n        for oid in object_ids:\n            try:\n                layer_full = rs.ObjectLayer(oid)\n                if not layer_full:\n                    continue\n                top = layer_full.split(\"::\", 1)[0]\n                if not top:\n                    continue\n                layer_counts[top] = layer_counts.get(top, 0) + 1\n            except Exception:\n                continue\n        if not layer_counts:\n            return fallback_name\n        # Pick highest count; tie-break by name\n        best = sorted(layer_counts.items(),\n                      key=lambda kv: (-kv[1], kv[0]))[0][0]\n        # Sanitize for layout names\n        safe = best.replace(\"/\", \"-\").replace(\"\\\\\", \"-\").strip()\n        return safe if safe else fallback_name\n    except Exception:\n        logger.debug(\n            \"Failed to derive layout name from objects; using fallback.\", exc_info=True)\n        return fallback_name\n\n\ndef _zoom_selected_in_detail(detail_id, object_ids):\n    \"\"\"\n    Activate the detail, select the given objects, perform a Zoom Selected, then unselect.\n    \"\"\"\n    if not object_ids:\n        return\n    try:\n        # Activate layout view first\n        parent_layout = rs.coercerhinoobject(detail_id).Attributes.LayoutIndex\n    except Exception:\n        parent_layout = None\n    try:\n        rs.SelectObjects(object_ids)\n    except Exception:\n        pass\n    # Attempt to activate the detail and zoom to selection\n    try:\n        # Use API to activate the detail if available\n        try:\n            rs.CurrentDetail(detail_id, True)\n        except Exception:\n            # Fallback: try without the activate flag\n            try:\n                rs.CurrentDetail(detail_id)\n            except Exception:\n                pass\n        rs.Command('_-Zoom _Selected _Enter', echo=False)\n    except Exception:\n        logger.debug(\"Failed to zoom selected within detail.\", exc_info=True)\n    try:\n        rs.UnselectAllObjects()\n    except Exception:\n        pass\n\n\ndef _move_model_to_paperspace_and_center(detail_id, model_object_ids, page_view):\n    \"\"\"\n    Move selected model objects to paperspace through the active detail (ChangeSpace),\n    then center them on the page and delete the detail viewport.\n    Returns the moved object ids (paperspace) or empty list on failure.\n    \"\"\"\n    try:\n        if not model_object_ids:\n            return []\n        # Activate the detail\n        try:\n            rs.CurrentDetail(detail_id, True)\n        except Exception:\n            logger.debug(\n                \"Detail activation before ChangeSpace failed.\", exc_info=True)\n        # Select and move to paperspace via command\n        try:\n            rs.SelectObjects(model_object_ids)\n        except Exception:\n            pass\n        try:\n            # ChangeSpace moves objects from model to page space using current detail scale\n            rs.Command(u'_-ChangeSpace _Enter', echo=False)\n            time.sleep(0.2)\n        except Exception:\n            logger.debug(\"ChangeSpace command failed.\", exc_info=True)\n        # Collect selected objects now in paperspace\n        try:\n            page_objs = rs.SelectedObjects() or []\n        except Exception:\n            page_objs = []\n        try:\n            rs.UnselectAllObjects()\n        except Exception:\n            pass\n        # If nothing selected, try to find objects on this page\n        if not page_objs:\n            try:\n                all_ids = rs.AllObjects() or []\n                page_objs = []\n                for oid in all_ids:\n                    obj = Rhino.RhinoDoc.ActiveDoc.Objects.Find(oid)\n                    if obj and obj.Attributes and obj.Attributes.Space == Rhino.DocObjects.ActiveSpace.PageSpace:\n                        if obj.Attributes.LayoutIndex == page_view.PageNumber:\n                            page_objs.append(oid)\n            except Exception:\n                logger.debug(\n                    \"Fallback page objects discovery failed.\", exc_info=True)\n        if not page_objs:\n            return []\n        # Center on page\n        try:\n            bbox = rs.BoundingBox(page_objs)\n            if bbox:\n                # bbox returns 8 points; compute center\n                xs = [p.X for p in bbox]\n                ys = [p.Y for p in bbox]\n                cx, cy = sum(xs)/len(xs), sum(ys)/len(ys)\n                page_cx, page_cy = page_view.PageWidth/2.0, page_view.PageHeight/2.0\n                dx, dy = page_cx - cx, page_cy - cy\n                if abs(dx) > 1e-6 or abs(dy) > 1e-6:\n                    rs.MoveObjects(page_objs, (dx, dy, 0.0))\n        except Exception:\n            logger.debug(\"Centering page objects failed.\", exc_info=True)\n        # Delete the detail viewport\n        try:\n            rs.DeleteObject(detail_id)\n        except Exception:\n            logger.debug(\"Failed to delete detail viewport.\", exc_info=True)\n        return page_objs\n    except Exception:\n        logger.debug(\"Move to paperspace and center failed.\", exc_info=True)\n        return []\n\n\ndef _export_pdf_all_layouts(out_pdf_path):\n    \"\"\"\n    Attempt a vector PDF export of all layouts to the specified file path.\n    Tries multiple command variants for macOS builds.\n    Returns True on success.\n    \"\"\"\n    logger.info(\n        \"Attempting vector PDF export of all layouts -> %s\", out_pdf_path)\n    # Remove stale file\n    try:\n        if os.path.exists(out_pdf_path):\n            os.remove(out_pdf_path)\n    except Exception:\n        logger.debug(\"Failed to remove stale PDF file (continuing): %s\",\n                     out_pdf_path, exc_info=True)\n    cmds = [\n        # RhinoPDF (preferred)\n        u'-_Print _Setup _Destination=_PDF _OutputColor=_Display _OutputType=_Vector _Enter _View=_AllLayouts _Enter _Enter',\n        # Sometimes requiring extra _Enter on mac\n        u'-_Print _Destination=_PDF _OutputType=_Vector _Enter _View=_AllLayouts _Enter _Enter',\n    ]\n    for cmd in cmds:\n        rs.Command(cmd, echo=False)\n        time.sleep(0.5)\n        # Try to force output path (some builds honor this, some ignore)\n        try:\n            rs.Command(\n                u'-_Print _OutputFile \"{}\" _Enter _Go'.format(out_pdf_path), echo=False)\n        except Exception:\n            pass\n        time.sleep(0.5)\n        try:\n            if os.path.exists(out_pdf_path) and os.path.getsize(out_pdf_path) > 0:\n                logger.info(\"PDF export succeeded: %s\", out_pdf_path)\n                return True\n        except Exception:\n            logger.debug(\"PDF file check failed.\", exc_info=True)\n    logger.warning(\"Bulk PDF export failed; will try per-layout export.\")\n    return False\n\n\ndef _export_pdf_per_layout(output_dir, basename_prefix=\"Sheet\"):\n    \"\"\"\n    Export each layout as an individual PDF to output_dir.\n    Returns list of generated file paths.\n    \"\"\"\n    logger.info(\"Exporting per-layout PDFs to: %s\", output_dir)\n    paths = []\n    page_views = Rhino.RhinoDoc.ActiveDoc.Views.GetPageViews()\n    idx = 1\n    for pv in page_views:\n        try:\n            Rhino.RhinoDoc.ActiveDoc.Views.ActiveView = pv\n            rs.CurrentView(pv.PageName)\n        except Exception:\n            logger.debug(\"Failed to activate page before export: %s\",\n                         pv.PageName, exc_info=True)\n        outpath = os.path.join(\n            output_dir, \"{}-{:02d}-{}.pdf\".format(basename_prefix, idx, pv.PageName))\n        # Try export using Print command with PDF destination\n        try:\n            if os.path.exists(outpath):\n                os.remove(outpath)\n        except Exception:\n            pass\n\n        # Use Print command with PDF output for individual layouts\n        # Try multiple sequences for compatibility on macOS\n        export_success = False\n        safe_path = outpath.replace('\\\\', '\\\\\\\\').replace('\"', '\\\\\"')\n        try_sequences = [\n            [\n                u'-_Print _Setup _Destination=_RhinoPDF _OutputType=_Vector _Enter',\n                u'-_Print _View=_Current _OutputFile=\"{}\" _Go'.format(\n                    safe_path)\n            ],\n            [\n                u'-_Print _Destination=_RhinoPDF _OutputType=_Vector _View=_Current _Enter',\n                u'-_Print _OutputFile=\"{}\" _Go'.format(safe_path)\n            ],\n            [\n                u'-_Print _Destination=_PDF _OutputType=_Vector _View=_Current _Enter',\n                u'-_Print _OutputFile=\"{}\" _Go'.format(safe_path)\n            ],\n            [\n                u'-_Print _Destination=_PDF _View=_Current _OutputFile=\"{}\" _Go'.format(\n                    safe_path)\n            ],\n        ]\n        for seq in try_sequences:\n            try:\n                logger.debug(\"Trying print sequence for view '%s': %s\",\n                             pv.PageName, \" | \".join(seq))\n                for c in seq:\n                    rs.Command(c, echo=False)\n                    time.sleep(0.4)\n                time.sleep(0.8)\n                if os.path.exists(outpath) and os.path.getsize(outpath) > 0:\n                    logger.info(\"Exported layout PDF: %s\", outpath)\n                    paths.append(outpath)\n                    export_success = True\n                    break\n            except Exception as e:\n                logger.debug(\"Print sequence failed: %s\", e, exc_info=True)\n\n        # Variant 3: Try using RhinoCommon Print functionality if available\n        if not export_success:\n            try:\n                logger.debug(\"Trying RhinoCommon print functionality\")\n                # Note: Direct PDF export via RhinoCommon may require additional setup\n                # For now, we rely on the Print command variants above\n                pass\n            except Exception as e:\n                logger.debug(\"RhinoCommon print approach not available: %s\", e)\n\n        if not export_success:\n            logger.warning(\n                \"Failed to export PDF for layout: %s (path: %s)\", pv.PageName, outpath)\n        idx += 1\n    return paths\n\n# ---------- main orchestration ----------\n\n\ndef assemble_from_dwgs(\n    dwg_paths=None,\n    dwg_folder=None,\n    scale_paper_mm=1.0,\n    scale_model_mm=200.0,\n    master_layout_name=None,\n    page_width_mm=420.0,\n    page_height_mm=297.0,\n    margin_mm=10.0,\n    output_pdf_path=None\n):\n    \"\"\"\n    Assemble one layout per DWG:\n    - dwg_paths: list of file paths. If None, discovers DWG files from dwg_folder\n    - dwg_folder: folder path to search for DWG files. If None and dwg_paths is None,\n                  defaults to '~/Desktop' searching for '*-Export.dwg'\n    - scale_paper_mm: paper length (mm) in the scale definition (default 1.0)\n    - scale_model_mm: model/drawing length (mm) corresponding to scale_paper_mm (default 200.0)\n                      This represents \"1mm page = XX mm drawing\"\n    - master_layout_name: optional explicit master layout to duplicate\n    - page_width_mm, page_height_mm: page size for created layouts\n    - margin_mm: detail margin from edges\n    - output_pdf_path: if provided, attempts to export combined vector PDF here;\n      otherwise exports individual PDFs to the Desktop.\n    Returns a dict with keys: 'layouts', 'pdf' or 'pdfs'\n    \"\"\"\n    # Discover DWG files if not provided\n    if dwg_paths is None:\n        if dwg_folder is None:\n            desktop = os.path.join(os.path.expanduser('~'), 'Desktop')\n            dwg_folder = desktop\n        if not os.path.isdir(dwg_folder):\n            raise Exception(\"Invalid folder path: {}\".format(dwg_folder))\n        # Search for all .dwg files in the folder\n        dwg_paths = sorted(glob.glob(os.path.join(dwg_folder, \"*.dwg\")))\n        if not dwg_paths:\n            # Fallback to old pattern if no DWGs found\n            dwg_paths = sorted(\n                glob.glob(os.path.join(dwg_folder, \"*-Export.dwg\")))\n\n    if not dwg_paths:\n        raise Exception(\"No DWG files provided or discovered in folder: {}\".format(\n            dwg_folder or \"specified\"))\n    logger.info(\"Found %d DWGs to assemble.\", len(dwg_paths))\n\n    # Determine master layout (if any)\n    master = _find_master_layout(explicit_name=master_layout_name)\n\n    created_layouts = []\n    for path in dwg_paths:\n        name_base = os.path.splitext(os.path.basename(path))[0]\n        # Build page: either duplicate master or create fresh\n        if master:\n            dup_id = _duplicate_master_layout(master)\n            if dup_id:\n                # Rename the duplicated page to match DWG base\n                try:\n                    # Try RhinoCommon setter if we can resolve the page view now\n                    for v in Rhino.RhinoDoc.ActiveDoc.Views.GetPageViews():\n                        if getattr(v, \"ActiveViewportID\", None) == dup_id or v.PageName == master:\n                            try:\n                                v.PageName = name_base\n                                break\n                            except Exception:\n                                pass\n                    # Fallback to RhinoScriptSyntax by GUID\n                    rs.RenameLayout(dup_id, name_base)\n                except Exception:\n                    logger.debug(\n                        \"Failed to rename duplicated layout; will set active and proceed.\", exc_info=True)\n                # Resolve page view by duplicated layout's viewport id first\n                pv = None\n                try:\n                    for v in Rhino.RhinoDoc.ActiveDoc.Views.GetPageViews():\n                        # Match by ActiveViewportID if available\n                        try:\n                            if getattr(v, \"ActiveViewportID\", None) == dup_id:\n                                pv = v\n                                break\n                        except Exception:\n                            pass\n                    # Fallback to name match after rename\n                    if pv is None:\n                        for v in Rhino.RhinoDoc.ActiveDoc.Views.GetPageViews():\n                            if v.PageName == name_base:\n                                pv = v\n                                break\n                except Exception:\n                    logger.debug(\n                        \"Error resolving page view after duplication.\", exc_info=True)\n                if pv is None:\n                    # fallback: try to find by active viewport ID or create new\n                    try:\n                        active_view = Rhino.RhinoDoc.ActiveDoc.Views.ActiveView\n                        # Only use if it's actually a page view\n                        if isinstance(active_view, Rhino.Display.RhinoPageView):\n                            pv = active_view\n                        else:\n                            # Create new layout if we can't find the duplicated one\n                            logger.warning(\n                                \"Could not resolve duplicated layout, creating new one\")\n                            pv, _ = _activate_layout_or_create(\n                                name_base, width_mm=page_width_mm, height_mm=page_height_mm)\n                    except Exception:\n                        # Create new layout as last resort\n                        logger.warning(\n                            \"Failed to resolve duplicated layout, creating new one\")\n                        pv, _ = _activate_layout_or_create(\n                            name_base, width_mm=page_width_mm, height_mm=page_height_mm)\n                page_view = pv\n            else:\n                page_view, _ = _activate_layout_or_create(\n                    name_base, width_mm=page_width_mm, height_mm=page_height_mm)\n        else:\n            page_view, _ = _activate_layout_or_create(\n                name_base, width_mm=page_width_mm, height_mm=page_height_mm)\n\n        # Capture layout GUID early for later rename reliability\n        try:\n            layout_guid_for_rename = _resolve_layout_guid(page_view)\n        except Exception:\n            layout_guid_for_rename = None\n\n        # Ensure a single detail\n        # Validate that we have a valid page view\n        if not isinstance(page_view, Rhino.Display.RhinoPageView):\n            logger.error(\n                \"Invalid page view type for layout creation. Expected RhinoPageView, got: %s\", type(page_view))\n            # Try to recreate the layout\n            try:\n                page_view, _ = _activate_layout_or_create(\n                    name_base, width_mm=page_width_mm, height_mm=page_height_mm)\n            except Exception as e:\n                logger.error(\"Failed to recreate layout %s: %s\", name_base, e)\n                continue\n\n        detail_id = _add_or_replace_single_detail(\n            page_view, margin_mm=margin_mm)\n        if not detail_id:\n            logger.error(\"Could not create a detail on layout: %s\",\n                         page_view.PageName)\n            continue\n\n        # Import DWG and capture new objects\n        new_ids = _import_dwg_capture_new_objects(path)\n        if not new_ids:\n            logger.error(\"Skipping layout due to empty import: %s\", path)\n            continue\n\n        # Set requested scale using millimeters (1 mm paper = scale_model_mm mm model)\n        try:\n            _apply_detail_scale_mm(detail_id, scale_model_mm)\n        except Exception:\n            logger.debug(\n                \"Detail scale application failed, continuing.\", exc_info=True)\n\n        # Zoom selected objects inside the detail\n        _zoom_selected_in_detail(detail_id, new_ids)\n        # Move geometry into paperspace, center on page, and remove the detail viewport\n        try:\n            _move_model_to_paperspace_and_center(detail_id, new_ids, page_view)\n        except Exception:\n            logger.debug(\n                \"Move to paperspace or centering failed.\", exc_info=True)\n\n        # Lock the detail to prevent accidental changes\n        try:\n            rs.DetailLock(detail_id, True)\n        except Exception:\n            pass\n\n        # Enforce final layout name strictly as DWG base; add diagnostic logs\n        final_name = name_base\n        try:\n            ok_rename_final = _rename_layout(page_view, final_name)\n            logger.info(\"Final rename to DWG base '%s': %s\",\n                        final_name, \"ok\" if ok_rename_final else \"failed\")\n            # Show current list to aid debugging\n            current_names = [\n                pv.PageName for pv in Rhino.RhinoDoc.ActiveDoc.Views.GetPageViews()]\n            logger.debug(\"Current layouts after rename: %s\", current_names)\n        except Exception:\n            logger.debug(\"Final rename helper raised.\", exc_info=True)\n        # Report final prepared layout name\n        created_layouts.append(final_name)\n        logger.info(\"Prepared layout: %s\", final_name)\n\n    # Export PDF(s)\n    desktop = os.path.join(os.path.expanduser('~'), 'Desktop')\n    if output_pdf_path is None:\n        output_pdf_path = os.path.join(desktop, \"AssembledLayouts.pdf\")\n\n    pdf_ok = _export_pdf_all_layouts(output_pdf_path)\n    result = {\"layouts\": created_layouts}\n    if pdf_ok:\n        result[\"pdf\"] = output_pdf_path\n    else:\n        # Fallback to per-layout exports\n        pdfs = _export_pdf_per_layout(desktop, basename_prefix=\"Assembled\")\n        result[\"pdfs\"] = pdfs\n    return result\n\n\ndef main():\n    \"\"\"\n    Entry point for interactive runs inside Rhino.\n    Prompts user for:\n      - Page format (A5, A4, A3, A2, A1)\n      - Drawing scale (1mm page = XX mm drawing)\n      - Folder containing DWG files\n    Exports combined PDF to Desktop/AssembledLayouts.pdf (or per-layout on fallback)\n    \"\"\"\n    try:\n        rs.EnableRedraw(False)\n    except Exception:\n        pass\n\n    try:\n        # Announce in command history with spacing and version\n        try:\n            Rhino.RhinoApp.WriteLine(\"\")\n            Rhino.RhinoApp.WriteLine(\"\")\n            Rhino.RhinoApp.WriteLine(\n                \"=== assemble_layouts.py v{} starting ===\".format(__version__))\n        except Exception:\n            logger.debug(\n                \"Failed to write start banner to Rhino command history.\", exc_info=True)\n        # Prompt for page format\n        logger.info(\"Prompting for page format...\")\n        page_dims = _prompt_page_format()\n        if page_dims is None:\n            logger.warning(\"Page format selection cancelled, using default A3\")\n            page_dims = _get_page_format_dimensions(\"A3\")\n        page_width_mm, page_height_mm = page_dims\n\n        # Prompt for scale\n        logger.info(\"Prompting for drawing scale...\")\n        scale_params = _prompt_scale()\n        if scale_params is None:\n            logger.warning(\"Scale input cancelled, using default 200\")\n            scale_params = (1.0, 200.0)\n        scale_paper_mm, scale_model_mm = scale_params\n\n        # Prompt for folder\n        logger.info(\"Prompting for DWG folder...\")\n        dwg_folder = _prompt_folder()\n        if dwg_folder is None:\n            logger.error(\"Folder selection cancelled. Aborting.\")\n            return\n\n        # Run assembly with user-provided parameters\n        result = assemble_from_dwgs(\n            dwg_paths=None,\n            dwg_folder=dwg_folder,\n            scale_paper_mm=scale_paper_mm,\n            scale_model_mm=scale_model_mm,\n            master_layout_name=None,\n            page_width_mm=page_width_mm,\n            page_height_mm=page_height_mm,\n            margin_mm=10.0,\n            output_pdf_path=None\n        )\n        logger.info(\"Assembly complete: %s\", result)\n    except Exception as e:\n        logger.exception(\"Assembly failed: %s\", e)\n    finally:\n        try:\n            rs.EnableRedraw(True)\n        except Exception:\n            pass\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}