{
  "source_url": "https://github.com/GiLuSSa/N-ICP/blob/caf3829e984728f551131872b90f230b182ccd32/N-ICP.py",
  "repo": "GiLuSSa/N-ICP",
  "repo_stars": 0,
  "repo_description": "N-ICP for Rhino 8",
  "license": "unknown",
  "filepath": "N-ICP.py",
  "instruction": "_   __                     _         _      __        ____ ______ ____ \n   / | / /____   ____   _____ (_)____ _ (_)____/ /       /  _// ____// __ \\\n  /  |/ // __ \\ / __ \\ / ___// // __ `// // __ ...",
  "code": "\"\"\" _   __                     _         _      __        ____ ______ ____ \n   / | / /____   ____   _____ (_)____ _ (_)____/ /       /  _// ____// __ \\\n  /  |/ // __ \\ / __ \\ / ___// // __ `// // __  /______  / / / /    / /_/ /\n / /|  // /_/ // / / // /   / // /_/ // // /_/ //_____/_/ / / /___ / ____/ \n/_/ |_/ \\____//_/ /_//_/   /_/ \\__, //_/ \\__,_/       /___/ \\____//_/      \n                              /____/                                             \n\nThis is an implementation of the famous N-ICP algorithm by Amberg et al. (2007).\nThanks to Yiyan Liu who provided me his Python implementation which allowed me to make this port for Rhino\nand I used as a starting point for the development of my own algorithm.\n\nThis cose is a rough and messy implementation I (Giulio L.S. Sacco) made in September 2024 in an hurry. Sorry and have fun.\n\"\"\"\n#sys.exit(0)\n#import rhinoscriptsyntax as rs\nimport Rhino as rn\nimport numpy as np\nfrom scipy import sparse\nfrom scipy import linalg\nimport math\nimport ghpythonlib.treehelpers as th\n\n#debug\nimport sys\nimport time\n\n\"\"\" DEBUG \"\"\"\n#GET START TIME\ntime_start = time.time()\ntime_start_string = time.strftime(\"%y-%m-%d %H:%M:%S\", time.gmtime(time_start))\n\n###################################################################################################\ndbg = []\n\n#PLOT Status info - Initialization\nprint(f\"{time_start_string} UTC\\n \")\nwith open(\"StatusDebug.txt\", \"w+\") as stf:\n    stf.write(f\"Started at {time_start_string} UTC\\n\\n\")\n\n#--- --- --- ! --- --- --- SETUP --- --- --- ! --- --- --- #\n\n#The values of alpha are assigned with an exponential decay scheme, as Yiyan Liu did and as suggested by Hasler et al., 2009\nalphaValues = [maxAlpha * np.exp(-(1 / iterations * np.log(maxAlpha / minAlpha)) * i) for i in range(iterations)]\nalphaValues[-1] = minAlpha #Ensure the last alpha value is exactly the minimum specified\n\n###-### Stifness Term ###-###\n\n# Calculate all unique edges from the source mesh triangles to aid in deformation regularisation\nedges = set(tuple(sorted((face[i], face[j]))) for face in sourceMesh.Faces for i, j in [(0, 1), (0, 2), (1, 2)])\nnumSourceEdges = len(edges)\n\n# M\nnumSourceVertexes = len(sourceMesh.Vertices)\nrow = []\ncol = []\ndata = []\nfor i, vertIndex in enumerate(edges):\n    row.extend([i, i])\n    col.extend([vertIndex[0], vertIndex[1]])\n    data.extend([-1, 1])\nmatrixM = sparse.csc_matrix((data, (row, col)), shape=(numSourceEdges, numSourceVertexes))\n\n# G exp - This is just a larger version of G. It works in the same way but it's a 12x12 bevause now X is an assembly of 12x1 instead of 4x3. \nG_exp = sparse.diags([1,1,1,gamma,1,1,1,gamma,1,1,1,gamma], shape=(12,12))\n\n# MoxG\nsparseKronMG = sparse.kron(matrixM, G_exp)\n\n# Vector of Zeros\nvecZero = np.zeros((12*numSourceEdges))\n\n###-###  Distance Term  ###-###\n\n# D - This D is similar to the original one, but each vertex is repeted diagonally in there lines\nrow = []\ncol = []\ndata = []\nfor i, vert in enumerate(sourceMesh.Vertices):\n    for j in range(3):\n        for k in range(4):\n            row.append(i*3 + j)\n            col.append(12*i + 4*j + k)\n        data.extend([sourceMesh.Vertices[i].X, sourceMesh.Vertices[i].Y, sourceMesh.Vertices[i].Z, 1.0])\nsparseD = sparse.csc_matrix((data, (row, col)), shape=(3*numSourceVertexes, 12*numSourceVertexes))\n\n#matrixU is not here because is computed each subiterations \n\n###-###  Landmarks Term ###-###\nif sourceLandmarks != []:\n    print(\"Yay! You are using landmarks!\\n \")\n\n    # D_L\n    numLandmark = len(sourceLandmarks)\n    row = []\n    col = []\n    data = []\n    for i, souLandInd in enumerate(sourceLandmarks):\n        for j in range(3):\n            for k in range(4):\n                row.append(i*3 + j)\n                col.append(12*souLandInd + 4*j + k)\n            data.append(sourceMesh.Vertices[souLandInd].X)\n            data.append(sourceMesh.Vertices[souLandInd].Y)\n            data.append(sourceMesh.Vertices[souLandInd].Z)\n            data.append(1.0)\n    sparseDL = sparse.csc_matrix((data, (row, col)), shape=(3*numLandmark, 12*numSourceVertexes))\n\n    #U_L\n    vecU_L = []\n    for vertex in targetLandmarks: \n        vecU_L.append(vertex.X)\n        vecU_L.append(vertex.Y)\n        vecU_L.append(vertex.Z)\n    vecU_L = np.array(vecU_L)\n\n#--- --- --- ! --- --- --- LOOP --- --- --- ! --- --- --- #\n\n#initialize X and other stuff\nX = np.tile(np.array([1,0,0,0,0,1,0,0,0,0,1,0]), numSourceVertexes)\ntransformedTemplate = sourceMesh.Vertices\nfirstLoop = True\n\nfor step, alpha in enumerate(alphaValues, 1): #OUTER LOOP\n    print(f\"Step {step}, alpha: {alpha}, substep:\", end=\" \")\n    with open(\"StatusDebug.txt\", \"a\") as stf:\n        stf.write(f\"Step {step}, alpha: {alpha}, substep:\")\n\n    # Cumpute Beta \n    if sourceLandmarks != [] and firstLoop == False:\n        distanceResidual = 0\n        for source, transformed in zip(transformedTemplate, sourceMesh.Vertices):\n            distanceResidual += source.DistanceTo(transformed)\n        \n        landmarksResiduals = 0\n        for i, trgLand in zip(sourceLandmarks, targetLandmarks):\n            landmarksResiduals += transformedTemplate[i].DistanceTo(trgLand)\n\n        btmp = 1.5 * (distanceResidual / landmarksResiduals)\n        beta = 0 if btmp < 0 else 100 if btmp > 100 else btmp\n        #print(\"distanceResidual\", distanceResidual, \"landmarksResiduals\", landmarksResiduals,\"Beta\", beta)\n \n    else: \n        firstLoop = False\n        beta = 1.5        \n\n    #Initialize the while\n    oldX, subIterations = 10*X, 1\n    \n    while np.linalg.norm(X - oldX) >= epsilon and subIterations <= maxSubIterations: #INNER LOOP\n        #print(\"WHILE! step\", step, \",\", subIterations, \" - \", np.linalg.norm(X - oldX), \">=\", epsilon)\n        print(subIterations, end=\" \")\n        with open(\"StatusDebug.txt\", \"a\") as stf:\n            stf.write(f\"{subIterations} \")\n\n        oldX = X\n\n        # Finding U\n        target_vertices = []\n        target_distances = []\n        dbg = []\n        if type(target) == rn.Geometry.Mesh:\n            for point in transformedTemplate:\n                new_target_vertices_temp = rn.Geometry.Mesh.ClosestPoint(target, point)\n                dbg.append(new_target_vertices_temp)\n                target_vertices.append([new_target_vertices_temp.X, new_target_vertices_temp.Y, new_target_vertices_temp.Z])\n                target_distances.append(point.DistanceTo(new_target_vertices_temp))\n        \n        elif type(target) == rn.Geometry.PointCloud:\n            for point in transformedTemplate:\n                new_target_vertices_index_temp = rn.Geometry.PointCloud.ClosestPoint(target, point)\n                new_target_vertices_temp = target[new_target_vertices_index_temp]\n                dbg.append(new_target_vertices_temp)\n                target_vertices.append([new_target_vertices_temp.X, new_target_vertices_temp.Y, new_target_vertices_temp.Z])\n                target_distances.append(point.DistanceTo(new_target_vertices_temp))\n\n        elif type(target) == rn.Geometry.Brep:\n            for point in transformedTemplate:\n                new_target_vertices_temp = rn.Geometry.Brep.ClosestPoint(target, point)\n                dbg.append(new_target_vertices_temp)\n                target_vertices.append([new_target_vertices_temp.X, new_target_vertices_temp.Y, new_target_vertices_temp.Z])\n                target_distances.append(point.DistanceTo(new_target_vertices_temp))\n\n        else:\n            sys.exit(\"Give me proper data! I need a mesh, a proper point cloud or a brep.\") # /!\\ Type Hint must be on No Type Hint, otherwise it doesn't work even passing the right data!\n        \n        target_vertices = np.asarray(target_vertices)\n        target_distances = np.asanyarray(target_distances)\n        vecU = target_vertices.flatten()\n\n        # W weights\n        Wd = (target_distances <= distanceThresholdToReject).astype(int) #This is just a boolean mask, but something more refined could be theoretically by inplemented\n\n        # W\n        if Wp == []:\n            W = Wd\n        else:\n            W = np.multiply(Wp, Wd)\n        W = W.repeat(3)\n\n        # UW vector\n        vecUW = np.multiply(vecU, W)\n\n        # W matrix multiplied W\n        Wexp = sparse.kron(sparse.diags(W, shape=(3*numSourceVertexes, 3*numSourceVertexes)), np.array([1,1,1,1]), format=\"csc\")\n        sparseDW = sparseD.multiply(Wexp)\n\n        # Assemblage of A and B matrix\n        if sourceLandmarks == []:\n            A = sparse.vstack([alpha*sparseKronMG, sparseDW])\n            B = np.concatenate((vecZero, vecUW))\n        else:\n            A = sparse.vstack([alpha*sparseKronMG, sparseDW, beta*sparseDL]) #In equation 12 (Amberg et al.2007) beta is only on D_L but according to equation 5 i assumes it was intended to be also on U_L.  \n            B = np.concatenate((vecZero, vecUW, beta*vecU_L))\n\n        # Solve\n        X, istop, itn, normt = sparse.linalg.lsqr(A, B, atol=0, btol=0, conlim=0, iter_lim=10000)[:4]\n        if itn > 9999:\n            print(\"Ok, i've been lazy here and I skipped the study of sparse.linalg.lsqr leveraging the power of my pc and my usecase. If you are reading this message you should probably take a look here.\")\n        #print(\"Solution\", istop, itn, normt)\n\n        # Transform template (some post projects at subiteration level)\n        transformedTemplateTemp = sparseD @ X\n        transformedTemplateTemp = transformedTemplateTemp.reshape(-1, 3)\n        transformedTemplate = []\n        for point in transformedTemplateTemp:\n            transformedTemplate.append(rn.Geometry.Point3d(point[0], point[1], point[2]))\n\n        subIterations += 1\n    \n    print(\"\")\n    with open(\"StatusDebug.txt\", \"a\") as stf:\n        stf.write(f\"\\n\")\n\n#--- --- --- ! --- --- --- POST PROCESSING --- --- --- ! --- --- --- #\n\n#Creation of the registeredMesh in Rhino format\nregisteredMesh = rn.Geometry.Mesh()#Initialization\nfor vrt in transformedTemplate: \n    registeredMesh.Vertices.Add(vrt)\nfor fc in sourceMesh.Faces:   \n    registeredMesh.Faces.AddFace(fc)\n\n# displacement field in Rhino format\ndisplacementField = []\nfor start, finish in zip(sourceMesh.Vertices, registeredMesh.Vertices):\n    displacementField.append(rn.Geometry.Vector3d(finish - start))\ndisplacementField = th.list_to_tree(displacementField, source=[0,0]) #this th.list_to_tree is black magic to me.\n\n#--- --- --- ! --- --- --- END --- --- --- ! --- --- --- #\n\n#FINAL TIME TAG\ntime_end = time.time()\ntime_end_string = time.strftime(\"%y-%m-%d %H:%M:%S\", time.gmtime(time_end))\ntime_elapsed = time_end - time_start \ntime_elapsed_minutes = time_elapsed // 60 \ntime_elapsed_seconds = round(time_elapsed % 60, 2)\nprint(f\" \\nDONE AT {time_end_string} UTC!!!\\n \\nElapsed time: {time_elapsed_minutes} minutes and {time_elapsed_seconds} seconds\")\nwith open(\"StatusDebug.txt\", \"a\") as stf:\n    stf.write(f\"\\nDONE AT {time_end_string} UTC!!!\\n \\nElapsed time: {time_elapsed_minutes} minutes and {time_elapsed_seconds} seconds\") \n\nprint(\" \\n \\n \\n \\n \\n \\n \\n \\n \\nฅ^•ﻌ•^ฅ\")\n",
  "language": "python",
  "imports": [
    "Rhino",
    "ghpythonlib",
    "rhinoscriptsyntax"
  ],
  "has_docstring": true
}