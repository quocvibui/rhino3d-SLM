{
  "source_url": "https://discourse.mcneel.com/t/problem-with-implementing-multithreading-parallel-foreach-in-ghpython/79994",
  "topic_id": 79994,
  "title": "Problem with implementing multithreading (Parallel.ForEach) in GHPython!",
  "question": "Hello everybody,\n\n\nI’m trying to implement \nmultithreading (parallel computing)\n, for a demanding for loop-portion of a Python script, I’m currently working on.\n\n\nI’ve read \n@stevebaer\n’s \npost\n on the subject from a while back and tried to accomplish a similar thing with \nSystem.Threading.Tasks.Parallel.ForEach()\n.\n\n\nI get the following error:\n\n\n\n\nRuntime error (ArgumentTypeException): The type arguments for method ‘ForEach’ cannot be inferred from the usage. Try specifying the type arguments explicitly.\n\n\nTraceback:\n\nline 28, in update\n\n\n\n\nI understand that \nParallel.ForEach\n takes 2 parameters: a list of objects of type x, and a method that takes in one object of the same type x and returns nothing.\n\nHere may reside one problem, since in Python (at least I think so), you don’t declare the type of the items in your list, and the type of the list itself would be, well, ‘list’ and not type x.\n\n\nHere’s how I call \nParallel.ForEach\n:\n\n\nimport System.Threading.Tasks as tasks\n\ntasks.Parallel.ForEach(self.agents, self._compute_agent_velocity)\n\n\n\nI pass it a list of class instances \nself.agents\n, of the same class \nAgent\n, as an iterable, and the method \nself._compute_agent_velocity()\n. The method takes in one agent instance and returns nothing. The list of agent instances, as well the method, are both parts of the class \nParticleSystem\n.\n\n\nimport Rhino.Geometry as rg\nimport System.Threading.Tasks as tasks\nimport random\n\n\nclass ParticleSystem:\n    def __init__(self, agent_count=100, use_parallel=True):\n        self.agent_count = agent_count\n        self.use_parallel = use_parallel\n        self.agents = [] # gets passed to Parallel.ForEach()\n        \n        for i in range(self.agent_count):\n            agent = Agent(\n                self._get_random_point(0.0, 30.0, 0.0, 30.0, 0.0, 30.0),\n                self._get_random_unit_vector() * 4.0)\n            agent.flock_system = self\n            self.agents.append(agent)\n\n\n    def update(self):\n        \"\"\"Method that calls Par...",
  "code_blocks": [
    {
      "code": "import Rhino.Geometry as rg\nimport System.Threading.Tasks as tasks\nimport random\n\n\nclass ParticleSystem:\n    def __init__(self, agent_count=100, use_parallel=True):\n        self.agent_count = agent_count\n        self.use_parallel = use_parallel\n        self.agents = [] # gets passed to Parallel.ForEach()\n        \n        for i in range(self.agent_count):\n            agent = Agent(\n                self._get_random_point(0.0, 30.0, 0.0, 30.0, 0.0, 30.0),\n                self._get_random_unit_vector() * 4.0)\n            agent.flock_system = self\n            self.agents.append(agent)\n\n\n    def update(self):\n        \"\"\"Method that calls Parallel.ForEach().\"\"\"\n        # Regular for loop\n        if not self.use_parallel:\n            for agent in self.agents:\n                neighbours = self._find_neighbours(agent)\n                agent._compute_desired_velocity(neighbours)\n        # Multithreaded for loop\n        else:\n            tasks.Parallel.ForEach(self.agents, self._compute_agent_desired_velocity)\n            \n        for agent in self.agents:\n            agent.update_veloctiy_and_position()\n    \n    \n    def _compute_agent_desired_velocity(self, agent):\n        \"\"\"Method that gets passed to Parallel.ForEach().\"\"\"\n        neighbours = self._find_neighbours(agent)\n        agent._compute_desired_velocity(neighbours)\n    \n    \n    def _find_neighbours(self, agent):\n        neighbours = []\n        for neighbour in self.agents:\n            dist = neighbour.position.DistanceTo(agent.position)\n            if neighbour != agent and dist < 1.500:\n                neighbours.append(neighbour)\n        return neighbours\n    \n    \n    def _get_random_point(self, min_x, max_x, min_y, max_y, min_z, max_z):\n        x = min_x + (max_x - min_x) * random.random()\n        y = min_y + (max_y - min_y) * random.random()\n        z = min_z + (max_z - min_z) * random.random()\n        return rg.Point3d(x, y, z)\n    \n    \n    def _get_random_unit_vector(self, three=True):\n        phi = 2.0 * math.pi * random.random()\n        theta = math.acos(2.0 * random.random() - 1.0)\n        x = math.sin(theta) * math.cos(phi)\n        y = math.sin(theta) * math.sin(phi)\n        z = math.cos(theta)\n        return rg.Vector3d(x, y, z)\n    \n\n\nclass Agent:\n    def __init__(self, position, velocity):\n        self.position = position\n        self.velocity = velocity\n        self.desired_velocity = rg.Vector3d.Zero\n        self.particle_system = None\n        \n    \n    def update_veloctiy_and_position(self):\n        self.velocity = 0.97 * self.velocity + 0.03 * self.desired_velocity\n        if self.velocity.Length > 8.0:\n            self.velocity *= 8.0 / self.velocity.Length\n        elif self.velocity.Length < 4.0:\n            self.velocity *= 4.0 / self.velocity.Length\n        self.position += self.velocity * self.particle_system.time_step\n        \n        \n    def _compute_desired_velocity(self, neighbours):\n        self.desired_velocity = rg.Vector3d.Zero\n        bounding_box_size = 30.0\n        # Control boundary\n        if self.position.X < 0.0:\n            self.desired_velocity += rg.Vector3d(-self.position.X, 0.0, 0.0)\n        elif self.position.X > bounding_box_size:\n            self.desired_velocity += rg.Vector3d(bounding_box_size - self.position.X, 0.0, 0.0)\n        \n        if self.position.Y < 0.0:\n            self.desired_velocity += rg.Vector3d(0.0, -self.position.Y, 0.0)\n        elif self.position.Y > bounding_box_size:\n            self.desired_velocity += rg.Vector3d(0.0, bounding_box_size - self.position.Y, 0.0)\n            \n        if self.position.Z < 0.0:\n            self.desired_velocity += rg.Vector3d(0.0, 0.0, -self.position.Z)\n        elif self.position.Z > bounding_box_size:\n            self.desired_velocity += rg.Vector3d(0.0, 0.0, bounding_box_size - self.position.Z)",
      "language": "python",
      "author": "diff-arch",
      "post_number": 1,
      "is_solution": false
    }
  ],
  "tags": [
    "file-io",
    "geometry",
    "grasshopper",
    "python",
    "rhinocommon"
  ],
  "has_accepted_answer": false,
  "category_id": 11,
  "posts_count": 12,
  "views": 2277
}