{
  "source_url": "https://github.com/fesmcr/Grafit/blob/0b80fd011af1d84bb50d5cafb684feb331ec3435/examples/rhino/Python%20F14%20Dual%20Graph%20Cognitive%20Distance.py",
  "repo": "fesmcr/Grafit",
  "repo_stars": 1,
  "repo_description": null,
  "license": "MIT",
  "filepath": "examples/rhino/Python F14 Dual Graph Cognitive Distance.py",
  "instruction": "Python f14 dual graph cognitive distance",
  "code": "ï»¿import rhinoscriptsyntax as rs\nimport Rhino.Geometry as rg\nimport sys\nimport clr\n\nclr.AddReference(\"System.IO\")\n\nfrom System import Environment\nfrom System.IO import *\n\nif CustomLibPath is not None: \n\t# Check if the assembly is loaded\n\tif \"Grafit\" not in sys.modules: \n\t\tsearchResult = Directory.GetFiles(CustomLibPath, \"Grafit.dll\", SearchOption.AllDirectories)\n\n\t\tif len(searchResult) == 0:\n\t\t\traise Exception(\"Grafit.dll is not found in folder.\")\n\t\t\t\n\t\tLibPathGrafit = searchResult[0] \n\t\tLibPathGrafitRhino = Path.GetDirectoryName(LibPathGrafit) + \"\\\\\"  + \"GrafitRhino.dll\"   \n\t\n\t\tclr.AddReferenceToFileAndPath(LibPathGrafit)\n\t\tclr.AddReferenceToFileAndPath(LibPathGrafitRhino) \nelse:\n\tclr.AddReference(\"Grafit\") \n\tclr.AddReference(\"GrafitRhino\")\n \n\nfrom Grafit import *\nfrom GrafitRhino import *\nfrom System import Array\n\nprimalGraph = {}\ndualGraph = {}\n\n# Positive infinity (similar to double.PositiveInfinity in C#)\ndouble_PositiveInfinity = float('inf')\n\n# Maximum finite positive value (similar to double.MaxValue in C#)\ndouble_MaxValue = sys.float_info.max\n\n\n#Create Primal Graph from which Dual Graph will be created\nif True: \n    lineGeometry = Array[CWLine](map(lambda s: CWLine(s), LineGeometry))\n\n    graphElements, edgeLengths = GeometryToGraphElements.GetNodesAndEdgesFromLines(lineGeometry)\n\n    primalGraph = CPrimalDirectedGraph(graphElements)\n    primalGraph.AddWeightMatrix(edgeLengths)            # index 0\n    primalGraph.AddEmptyWeightMatrix(0)                  # index 1 - angles\n    primalGraph.AddEmptyWeightMatrix(double_MaxValue);  # index 2 - steps\n    primalGraph.AddEmptyWeightMatrix(double_MaxValue);  # index 3 - time\n    \n    for i in range(len(primalGraph.UndirectedEdges)):\n        n1 = primalGraph.UndirectedEdges[i][0]  # start node of edge #i\n        n2 = primalGraph.UndirectedEdges[i][1]  # end node of edge #i\n    \n        weight_1 = 0.0  # angle of a single edge is 0.0 deg \n        weight_2 = 0.0  # step of a single edge is 0 \n    \n        primalGraph.SetWeightMatrixAndEdgeValue(weight_1, n1, n2, 1)  # forward direction angles\n        primalGraph.SetWeightMatrixAndEdgeValue(weight_1, n2, n1, 1)  # backward direction angles\n        \n        primalGraph.SetWeightMatrixAndEdgeValue(weight_2, n1, n2, 2)  # forward direction steps\n        primalGraph.SetWeightMatrixAndEdgeValue(weight_2, n2, n1, 2)  # backward direction steps\n        \n        primalGraph.SetWeightMatrixAndEdgeValue(TimeWeightsIn[i], n1, n2, 3)  # forward direction time\n        primalGraph.SetWeightMatrixAndEdgeValue(TimeWeightsOut[i], n2, n1, 3)  # backward direction time\n\n# Create Dual Graph\nif True:    \n    # Get dual nodes and edges from primal graph\n    graphElements, edgeLengths, edgeAngles = GeometryToGraphElements.GetDualNodesAndEdgesFromPrimalGraph(primalGraph)\n    \n    # Create the dual graph using the primal graph and dual graph elements\n    dualGraph = CDualDirectedGraph[float](primalGraph, graphElements)\n\n    # The order of dual graph weight matrices must be the same as in the primal graph\n    # Dual lengths\n    dualGraph.AddWeightMatrix(edgeLengths)  # index 0\n    # Dual angles\n    dualGraph.AddWeightMatrix(edgeAngles)  # index 1\n    \n    dualGraph.AddEmptyWeightMatrix(double_MaxValue);      #index 2 - steps\n    dualGraph.AddEmptyWeightMatrix(double_MaxValue);      #index 3 - time \n    \n    # Calculate dual edge values for weight matrices #2 and #3\n    for i in range(dualGraph.UndirectedEdges.Count):\n        edge = dualGraph.UndirectedEdges[i]\n        primDirEdgeId_0 = edge[0]\n        primDirEdgeId_1 = edge[1]\n    \n        e0n1 = dualGraph.Nodes[primDirEdgeId_0].PrimId1  # primal node from of edge 0\n        e0n2 = dualGraph.Nodes[primDirEdgeId_0].PrimId2  # primal node to of edge 0\n    \n        e1n1 = dualGraph.Nodes[primDirEdgeId_1].PrimId1   # primal node from of edge 1\n        e1n2 = dualGraph.Nodes[primDirEdgeId_1].PrimId2   # primal node to of edge 1\n\n        # Edge to opposite itself\n        if e0n1 == e1n2:\n            oppositePrimDirEdgeId_0 = primalGraph.GetOppositeEdgeId(primDirEdgeId_0)\n            oppositePrimDirEdgeId_1 = primalGraph.GetOppositeEdgeId(primDirEdgeId_1)\n            \n            # index 2 - steps\n            dualGraph.SetWeightMatrixAndEdgeValue(double_MaxValue, primDirEdgeId_0, primDirEdgeId_1, 2)\n            dualGraph.SetWeightMatrixAndEdgeValue(double_MaxValue, oppositePrimDirEdgeId_1, oppositePrimDirEdgeId_0, 2)\n    \n            # index 3 - time \n            dualGraph.SetWeightMatrixAndEdgeValue(double_MaxValue, primDirEdgeId_0, primDirEdgeId_1, 3)\n            dualGraph.SetWeightMatrixAndEdgeValue(double_MaxValue, oppositePrimDirEdgeId_1, oppositePrimDirEdgeId_0, 3)\n            continue\n    \n        undirPrimDirEdgeId_0 = primalGraph.GetUndirectedEdgeId(primDirEdgeId_0)\n        undirPrimDirEdgeId_1 = primalGraph.GetUndirectedEdgeId(primDirEdgeId_1)\n        \n        isEdgeLink_0 = EdgeIsLinkUndir[undirPrimDirEdgeId_0]\n        isEdgeLink_1 = EdgeIsLinkUndir[undirPrimDirEdgeId_1]\n    \n        iEdgeIsActivityNodeLink_0 = EdgesIsActivityNodeLinkUndir[undirPrimDirEdgeId_0]\n        iEdgeIsActivityNodeLink_1 = EdgesIsActivityNodeLinkUndir[undirPrimDirEdgeId_1]\n\n        # 0 = normal segment\n        # 1 = modal link\n        # 2 = activity node link\n    \n        # start\n        LinkType_0 = 0\n    \n        if isEdgeLink_0:\n            LinkType_0 = 1\n    \n        if iEdgeIsActivityNodeLink_0:\n            LinkType_0 = 2\n    \n        # end\n        LinkType_1 = 0\n    \n        if isEdgeLink_1:\n            LinkType_1 = 1\n    \n        if iEdgeIsActivityNodeLink_1:\n            LinkType_1 = 2\n     \n        dualStepWeight = 0.00000001\n    \n        # step between two default segments\n        # penalty based on the angular deviation between the segments and presence of crossings\n        # if there is no crossing the penalty is 0. if there is a crossing and we have to turn more than 30 degrees from the original direction, the penalty is 1\n        \n        if LinkType_0 == 0 and LinkType_1 == 0:  \n            angle = dualGraph.GetEdgeValue(i, 1)\n            if angle > 30.0 and len(primalGraph.Nodes[e0n2].OutNeighbourEdges) > 2:\n                dualStepWeight = 1.0\n    \n        # step between default segment and activity node link\n        # penalty is 1000 (a link penalty to avoid internal shortcuts) + 1 (to count for one decision)\n        if (LinkType_0 == 2 and LinkType_1 == 0) or (LinkType_1 == 2 and LinkType_0 == 0):\n            dualStepWeight = 1 + 1000\n    \n        # step between activity node and modal link\n        # penalty is 0.5 (modal penalty is always in entry-exit pairs, we use 0.5 so that the full modal change takes 1 decision) + 1000 (activity node penalty)\n        if (LinkType_0 == 2 and LinkType_1 == 1) or (LinkType_1 == 2 and LinkType_0 == 1):\n            dualStepWeight = 0.5 + 1000\n    \n        # step between activity node link and activity node link\n        # penalty is 1000 (activity node penalty)\n        if (LinkType_0 == 2 and LinkType_1 == 2):\n            dualStepWeight = 1000 + 1000\n    \n        # step between modal link and modal link\n        # penalty is 1, this is used when traveling through the internal network\n        if (LinkType_0 == 1 and LinkType_1 == 1):\n            dualStepWeight = 1\n    \n        # step between modal link and default segment\n        # penalty is 0.5 (modal penalty is always in entry-exit pairs, we use 0.5 so that the full modal change takes 1 decision)\n        if (LinkType_0 == 1 and LinkType_1 == 0) or (LinkType_1 == 1 and LinkType_0 == 0):\n            dualStepWeight = 0.5\n    \n        dualGraph.SetWeightMatrixAndEdgeValue(dualStepWeight, primDirEdgeId_0, primDirEdgeId_1, 2)  # index 2 - steps\n        dualGraph.SetWeightMatrixAndEdgeValue(dualStepWeight, primalGraph.GetOppositeEdgeId(primDirEdgeId_1), primalGraph.GetOppositeEdgeId(primDirEdgeId_0), 2)\n    \n        dualEdgeTimeWeight1 = (primalGraph.GetEdgeValue(primDirEdgeId_0, 3) + primalGraph.GetEdgeValue(primDirEdgeId_1, 3)) / 2.0\n        dualEdgeTimeWeight2 = (primalGraph.GetEdgeValue(primalGraph.GetOppositeEdgeId(primDirEdgeId_1), 3) + primalGraph.GetEdgeValue(primalGraph.GetOppositeEdgeId(primDirEdgeId_0), 3)) / 2.0\n    \n        dualGraph.SetWeightMatrixAndEdgeValue(dualEdgeTimeWeight1, primDirEdgeId_0, primDirEdgeId_1, 3)  # index 3 - time\n        dualGraph.SetWeightMatrixAndEdgeValue(dualEdgeTimeWeight2, primalGraph.GetOppositeEdgeId(primDirEdgeId_1), primalGraph.GetOppositeEdgeId(primDirEdgeId_0), 3)\n    \n    \n# Calculate shortest paths\ndualGraph.APShortestPathsByManyWeights(WeightMatrixIndexMain, WeightMatrixIndexFilter, GPU, 0.0000000001)\n#dualGraph.APShortestPathsByOneWeight(WeightMatrixIndexMain, GPU, 0.0000000001) \n\n \n# Calculate all other Weight Matrices, which are not WeightMatrixIndexMain\nallIds = list(range(len(dualGraph.weightMatrices)))\notherMatricesIds = [i for i in allIds if i != WeightMatrixIndexMain]\ndualGraph.FillWeightMatrixBySPRestore(Array[int](otherMatricesIds), GPU)\n    \nDualGraph = dualGraph   \n \n\n\n",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax"
  ],
  "has_docstring": false
}