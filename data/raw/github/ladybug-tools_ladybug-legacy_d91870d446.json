{
  "source_url": "https://github.com/ladybug-tools/ladybug-legacy/blob/d90db02f2776febbb38100dea26ec0c93e77aa53/src/Ladybug_Kmz%20Generator.py",
  "repo": "ladybug-tools/ladybug-legacy",
  "repo_stars": 202,
  "repo_description": ":beetle: Ladybug is an environmental plugin for Grasshopper.",
  "license": "NOASSERTION",
  "filepath": "src/Ladybug_Kmz Generator.py",
  "instruction": "Use this component to export geometries into an Google Earth file.\nIt requires Google Earth. You can download it at this link: https://www.google.it/earth/download/ge/agree.html\nOnce you open kmz...",
  "code": "# Kmz Generator\n#\n# Ladybug: A Plugin for Environmental Analysis (GPL) started by Mostapha Sadeghipour Roudsari\n# \n# This file is part of Ladybug.\n# \n# Copyright (c) 2013-2020, Antonello Di Nunzio <antonellodinunzio@gmail.com> \n# Ladybug is free software; you can redistribute it and/or modify \n# it under the terms of the GNU General Public License as published \n# by the Free Software Foundation; either version 3 of the License, \n# or (at your option) any later version. \n# \n# Ladybug is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with Ladybug; If not, see <http://www.gnu.org/licenses/>.\n# \n# @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>\n\n\n\"\"\"\nUse this component to export geometries into an Google Earth file.\nIt requires Google Earth. You can download it at this link: https://www.google.it/earth/download/ge/agree.html\nOnce you open kmz file you can continue to update it. This is useful when you change geometries or you want to compare different scenarios.\n.\nUpdating: Just setting again to \"True\" _writeKmz, after that right click and select \"update\" on Google Earth.\n-\nSpecial thanks goes to Google and the authors of gHowl.\n-\nProvided by Ladybug 0.0.69\n    \n    Args:\n        _geometry: A list of Breps, Meshes and Surfaces to export.\n        _basePoint_: Input a point here to georeference the model. Default value is origin point.\n        _location: It accepts two type of inputs. \n        a) latitude, longitude and elevation that represent WSG84 coordinates of the base point. You can achieve these type of coordinates from Google Maps or similar.\n        e.g. 40.821796, 14.426439, 990\n        -\n        b) location, you can obtain this type of input from \"Ladybug_Construct Location\", \"Ladybug_Location Finder\", \"Ladybug_Import epw\", \"Ladybug_Import Location\".\n        _terrain: Connect the terrain output of \"Ladybug_Terrain Generator\" to move the geometries in the right altitude automatically.\n        ---------------: ---------------\n        _folder_: The folder into which you would like to write the kmz file.  This should be a complete file path to the folder.  If no folder is provided, the images will be written to Ladybug default folder.\n        name_: Name of kmz file.\n        material_: Connect Create Material component of Grasshopper, it is part of Display tab. If not supplied it will be default material.\n        _bakeIt: Connect a Grasshopper button. Set to \"True\" to bake the geometries for Google Earth.\n        _writeKmz: Connect a Boolean Toggle. After the baking, set it to \"True\" to export from Rhino Model to KMZ format.\n    Returns:\n        readMe!: ...\n        kmzPath: Complete path of kmz file.\n        pointOnTerrain: basePoint projected on terrain.\n        geometry : Geometries on the ground.\n\"\"\"\n\nghenv.Component.Name = \"Ladybug_Kmz Generator\"\nghenv.Component.NickName = 'KmzGenerator'\nghenv.Component.Message = 'VER 0.0.69\\nJUL_07_2020'\nghenv.Component.IconDisplayMode = ghenv.Component.IconDisplayMode.application\nghenv.Component.Category = \"LB-Legacy\"\nghenv.Component.SubCategory = \"7 | WIP\"\n#compatibleLBVersion = VER 0.0.62\\nJUN_07_2016\ntry: ghenv.Component.AdditionalHelpFromDocStrings = \"0\"\nexcept: pass\n\nimport Rhino as rc\nimport scriptcontext as sc\nimport Grasshopper.Kernel as gh\nimport rhinoscriptsyntax as rs\nimport System\nimport os\n\ndef checkInputs(location, geometry,  bakeIt, writeKmz, terrain):\n    if location == None or geometry == [] or bakeIt == None or writeKmz == None or terrain == None:\n        return False\n    elif location and geometry and terrain:\n        return True\n\n\ndef findEarthPoint(terrain, basePoint):\n    vector = rc.Geometry.Vector3d.ZAxis\n    try:\n        pointOnTerrain = rc.Geometry.Intersect.Intersection.ProjectPointsToMeshes([terrain], [basePoint], vector, sc.doc.ModelAbsoluteTolerance)\n    except:\n        pointOnTerrain = rc.Geometry.Intersect.Intersection.ProjectPointsToBreps([terrain], [basePoint], vector, sc.doc.ModelAbsoluteTolerance)\n    return pointOnTerrain\n\n\ndef moveGeometry(geometry, terrain, basePoint):\n    centroid = rc.Geometry.AreaMassProperties.Compute(geometry).Centroid\n    pointOnPlane = rc.Geometry.Point3d(centroid.X, centroid.Y, basePoint.Z)\n    \n    try:\n        pointOnTerrain_geometry = findEarthPoint(terrain, pointOnPlane)[0]\n    except IndexError:\n        pointOnTerrain_geometry = rc.Geometry.Point3d(centroid.X, centroid.Y, basePoint.Z)\n        warning = \"Some geometries are outside the terrain area.\\n\" + \\\n        \"You should move them manually after the baking.\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n    \n    vec1 = rc.Geometry.Vector3d(pointOnTerrain_geometry)\n    vec2 = rc.Geometry.Vector3d(pointOnPlane)\n    vec3 = rc.Geometry.Vector3d.Add(vec1, -vec2)\n    \n    geometry.Translate(vec3)\n    \n    return geometry\n\n\ndef setReferencePoint(pointOnTerrain, latitude, longitude, elevation):\n    p = rc.DocObjects.EarthAnchorPoint()\n    p.EarthBasepointLatitude = latitude\n    p.EarthBasepointLongitude = longitude\n    p.EarthBasepointElevation = elevation\n    p.ModelBasePoint = pointOnTerrain\n    p.ModelEast = rc.Geometry.Vector3d.XAxis\n    p.ModelNorth = rc.Geometry.Vector3d.YAxis\n    \n    rc.RhinoDoc.ActiveDoc.EarthAnchorPoint = p\n\n\ndef bakeGeometry(geometries, materialFromUser):\n    layerName = 'buildings'\n    layerIndex, l = lb_visualization.setupLayers(layerName, \"LADYBUG\", projectName = \"GEOMETRY\", studyLayerName = \"LB_TERRAIN\") # here I have to understand how to enable all sublayers\n    for i, obj in enumerate(geometries):\n        attr = rc.DocObjects.ObjectAttributes()\n        attr.LayerIndex = layerIndex\n        attr.ColorSource = rc.DocObjects.ObjectColorSource.ColorFromObject\n        attr.ObjectColor = System.Drawing.Color.GreenYellow\n        \n        # user's material\n        if materialFromUser != None:\n            materialIndex = sc.doc.Materials.Add()\n            material = sc.doc.Materials[materialIndex]\n            \n            material.AmbientColor = materialFromUser.Ambient\n            material.DiffuseColor = materialFromUser.Diffuse\n            material.EmissionColor = materialFromUser.Emission\n            material.SpecularColor = materialFromUser.Specular\n            material.Transparency = materialFromUser.Transparency\n            material.Shine = materialFromUser.Shine\n            \n            material.CommitChanges()\n            attr.MaterialSource = rc.DocObjects.ObjectMaterialSource.MaterialFromObject\n            attr.MaterialIndex = materialIndex\n        \n        id = rc.RhinoDoc.ActiveDoc.Objects.Add(obj, attr)\n\n\ndef mdPath(folder):\n    # make a folder for the images\n    if folder != None:\n        directory = folder + '\\\\' # it work also with Desktop as folder\n        if not os.path.exists(folder):\n            try:\n                os.mkdir(directory)\n            except Exception:\n                appdata = os.getenv(\"APPDATA\")\n                directory = os.path.join(appdata, \"Ladybug\\LB_Kmz\\\\\")\n                w = gh.GH_RuntimeMessageLevel.Warning\n                ghenv.Component.AddRuntimeMessage(w, \"Invalid Folder, you can find images here: {}\".format(directory))\n    else:\n        appdata = os.getenv(\"APPDATA\")\n        directory = os.path.join(appdata, \"Ladybug\\LB_Kmz\\\\\")\n        if not os.path.exists(directory): os.makedirs(directory)\n    \n    return directory\n\n\ndef main():\n    \n    # default values\n    if _basePoint_ == None:\n        basePoint = rc.Geometry.Point3d.Origin\n    else:\n        basePoint = _basePoint_\n    \n    if _folder_ == None:\n        path = mdPath(_folder_)\n    else:\n        path = _folder_\n    \n    if name_ == None:\n        name = \"Ladybug_GoogleEarth.kmz\"\n    else:\n        name = name_\n    \n    fullPath = os.path.join(path, name)\n    \n    \n    # file!\n    fileName = '!-Save \"{}\"'.format(fullPath)\n    \n    if material_ == None: materialFromUser = None\n    else: materialFromUser = material_\n    sc.doc = rc.RhinoDoc.ActiveDoc\n    \n    \n    # location or point3d\n    try:\n        latitude, longitude, elevation = eval(_location)\n        location = rc.Geometry.Point3d(latitude, longitude, elevation)\n    except:\n        locationName, latitude, longitude, timeZone, elevation = lb_preparation.decomposeLocation(_location)\n        location = rc.Geometry.Point3d(latitude, longitude, elevation)\n    \n    \n    pointOnTerrain = findEarthPoint(_terrain, basePoint)\n    setReferencePoint(pointOnTerrain[0], latitude, longitude, 0)\n    geometryOnTerrain = [moveGeometry(geo, _terrain, basePoint) for geo in _geometry]\n    \n    # avoid bakeIt\n    if _writeKmz == True and _bakeIt == True: bakeIt = None\n    else: bakeIt = _bakeIt\n    \n    if bakeIt:\n        bakeGeometry(geometryOnTerrain, materialFromUser)\n    if _writeKmz:\n        # remark for users\n        w = gh.GH_RuntimeMessageLevel.Remark\n        ghenv.Component.AddRuntimeMessage(w, \"if you want to bake again you have to switch '_writeKmz' to False\")\n        rs.Command(fileName)\n        \n        return geometryOnTerrain, pointOnTerrain, fullPath\n    \n    return geometryOnTerrain, pointOnTerrain, None\n\n\ninitCheck = False\nif sc.sticky.has_key('ladybug_release'):\n    initCheck = True\n    try:\n        if not sc.sticky['ladybug_release'].isCompatible(ghenv.Component): initCheck = True\n    except:\n        initCheck = False\n        warning = \"You need a newer version of Ladybug to use this compoent.\" + \\\n        \"Use updateLadybug component to update userObjects.\\n\" + \\\n        \"If you have already updated userObjects drag Ladybug_Ladybug component \" + \\\n        \"into canvas and try again.\"\n        w = gh.GH_RuntimeMessageLevel.Warning\n        ghenv.Component.AddRuntimeMessage(w, warning)\n    lb_preparation = sc.sticky[\"ladybug_Preparation\"]()\n    lb_visualization = sc.sticky[\"ladybug_ResultVisualization\"]()\nelse:\n    initCheck = False\n    print \"You should first let the Ladybug fly...\"\n    w = gh.GH_RuntimeMessageLevel.Warning\n    ghenv.Component.AddRuntimeMessage(w, \"You should first let the Ladybug fly...\")\n\ncheck = checkInputs(_location, _geometry, _bakeIt, _writeKmz, _terrain)\nif check and initCheck:\n    buttonTest = ghenv.Component.Params.Input[8].Sources[0]\n    if buttonTest.Name == 'Button':\n        result = main()\n        if result != -1:\n            geometry, pointOnTerrain, kmzPath = result\n            if _writeKmz: print(\"kmz done! Check on your Desktop.\")\n    else:\n        warning = \"_bakeIt should be a Button. You can find it in Params/Input.\"\n        ghenv.Component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, warning)\nelse:\n    pass\n    w = gh.GH_RuntimeMessageLevel.Warning\n    ghenv.Component.AddRuntimeMessage(w, \"Please provide all inputs.\")\n    #print(\"Please provide all inputs.\")",
  "language": "python",
  "imports": [
    "Rhino",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}