{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Brep_contiguousFilletFaces.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Brep_contiguousFilletFaces.py",
  "instruction": "160412-16: Created.\r\n160601: Modularizations.\r\n160611: Bug fixes.\r\n160823: Various minor changes.\r\n161022: Commented out alias maker.\r\n170701: Script name changed from ActOnChainFilletFaces to...",
  "code": "\"\"\"\r\n160412-16: Created.\r\n160601: Modularizations.\r\n160611: Bug fixes.\r\n160823: Various minor changes.\r\n161022: Commented out alias maker.\r\n170701: Script name changed from ActOnChainFilletFaces to extractChainFilletFaces.\r\n        Removed code that allowed deletion and duplication of faces.\r\n        Added command option for destination layer of extracted faces.  All attributes, not just the layer, are actually applied.\r\n180305: Now, extracted faces are joined instead of being monoface breps.\r\n        Name changed from extractChainFilletFaces.py to extractContiguousFilletFaces.py\r\n181118: Added Opts and more options.\r\n181204: Updated an import name.\r\n190128: Refactored and added option for fillet concavity matching.\r\n        Renamed from extractContiguousFilletFaces.py to Brep_ContiguousFilletFaces.py.\r\n190129: Updated an import name.\r\n190130: Added SetCommandPrompt.\r\n190207, ..., 0605: Updated an import name.\r\n190620: Added Opts and changed getInput accordingly.  Changed the display name of an option for clarity.\r\n190810: Changed an option default.\r\n191010,1101: Import-related update.\r\n191118: Moved a function from another module to this script.\r\n191205: Bug fix.\r\n210612, 221108: Import-related update.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.Input as ri\r\nimport rhinoscriptsyntax as rs\r\nimport scriptcontext as sc\r\n\r\nfrom System import Guid\r\nfrom System.Collections.Generic import List\r\n\r\nimport xBrepObject\r\nimport spb_Srf_radius\r\n\r\n\r\nsOpts = (\r\n        'bSameConcavityType',\r\n        'bSameRad',\r\n        'fRadTol',\r\n        'bTanContinuity',\r\n        'fAngleTol',\r\n        'bRetainLayer',\r\n        'bRetainColor',\r\n        'bCopy',\r\n        'bEcho',\r\n        'bDebug',\r\n)\r\n\r\nclass Opts:\r\n    \r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    stickyKeys = {}\r\n    \r\n    for key in sOpts:\r\n        keys.append(key)\r\n        names[key] = key[1:] # Overwrite as wanted in the following.\r\n    \r\n    key = 'bSameConcavityType'\r\n    values[key] = True\r\n    names[key] = 'ConcavityType'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'Either', 'Same')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bSameRad'\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'fRadTol'\r\n    values[key] = 10.0 * sc.doc.ModelAbsoluteTolerance\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n    \r\n    key = 'bTanContinuity'\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'fAngleTol'\r\n    values[key] = 50.0 * sc.doc.ModelAngleToleranceDegrees\r\n    riOpts[key] = ri.Custom.OptionDouble(initialValue=values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n    \r\n    key = 'bRetainLayer'\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bRetainColor'\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bCopy'\r\n    values[key] = False\r\n    names[key] = 'Copy'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bEcho'\r\n    values[key] = True\r\n    names[key] = 'Echo'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    key = 'bDebug'\r\n    values[key] = False\r\n    names[key] = 'Debug'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n    \r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if sc.sticky.has_key(stickyKeys[key]):\r\n            if riOpts[key]:\r\n                values[key] = riOpts[key].CurrentValue = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n    \r\n    \r\n    @classmethod\r\n    def setValues(cls):\r\n        for key in cls.stickyKeys:\r\n            if cls.riOpts[key]:\r\n                cls.values[key] = cls.riOpts[key].CurrentValue\r\n            else:\r\n                # For OptionList.\r\n                pass\r\n    \r\n    \r\n    @classmethod\r\n    def saveSticky(cls):\r\n        for key in cls.stickyKeys:\r\n            if cls.riOpts[key]:\r\n                sc.sticky[cls.stickyKeys[key]] = cls.riOpts[key].CurrentValue\r\n            else:\r\n                # For OptionList.\r\n                sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef getInput(bDebug=False):\r\n    \"\"\"\r\n    \"\"\"\r\n    \r\n    # Get constant radius (rolling ball) fillet face of brep.\r\n    \r\n    go = ri.Custom.GetObject()\r\n    go.SetCommandPrompt(\"Select starting face\")\r\n    go.GeometryFilter = Rhino.DocObjects.ObjectType.Surface\r\n    go.GeometryAttributeFilter = (\r\n            ri.Custom.GeometryAttributeFilter.SubSurface) # Doesn't allow single surfaces to be selected.\r\n    \r\n    go.AcceptNumber(enable=True, acceptZero=True)\r\n    go.EnableClearObjectsOnEntry(False) # If not set to False, faces will be unselected when result == ri.GetResult.Object \r\n    \r\n    while True:\r\n        go.AddOptionToggle(Opts.names['bSameConcavityType'], Opts.riOpts['bSameConcavityType'])\r\n        go.AddOptionToggle(Opts.names['bSameRad'], Opts.riOpts['bSameRad'])\r\n        go.AddOptionDouble(Opts.names['fRadTol'], Opts.riOpts['fRadTol'])\r\n        go.AddOptionToggle(Opts.names['bTanContinuity'], Opts.riOpts['bTanContinuity'])\r\n        if Opts.values['bTanContinuity']:\r\n            go.AddOptionDouble(Opts.names['fAngleTol'], Opts.riOpts['fAngleTol'])\r\n        go.AddOptionToggle(Opts.names['bRetainLayer'], Opts.riOpts['bRetainLayer'])\r\n        go.AddOptionToggle(Opts.names['bRetainColor'], Opts.riOpts['bRetainColor'])\r\n        go.AddOptionToggle(Opts.names['bCopy'], Opts.riOpts['bCopy'])\r\n        go.AddOptionToggle(Opts.names['bEcho'], Opts.riOpts['bEcho'])\r\n        go.AddOptionToggle(Opts.names['bDebug'], Opts.riOpts['bDebug'])\r\n        \r\n        res = go.Get()\r\n        \r\n        if res == ri.GetResult.Object:\r\n            break\r\n        elif res == ri.GetResult.Cancel:\r\n            return\r\n        \r\n        # An option was selected or a number was entered.\r\n        \r\n        if res == ri.GetResult.Number:\r\n            Opts.riOpts['fRadTol'].CurrentValue = go.Number()\r\n        \r\n        if Opts.riOpts['fRadTol'].CurrentValue < 0.0:\r\n            Opts.riOpts['fRadTol'].CurrentValue = Opts.riOpts['fRadTol'].InitialValue\r\n        elif Opts.riOpts['fAngleTol'].CurrentValue < 0.0:\r\n            Opts.riOpts['fAngleTol'].CurrentValue = Opts.riOpts['fAngleTol'].InitialValue\r\n        \r\n        Opts.setValues()\r\n        Opts.saveSticky()\r\n        go.ClearCommandOptions()\r\n    \r\n    bDebug = Opts.values['bDebug']\r\n    \r\n    objref = go.Object(0)\r\n    \r\n    rgFace = objref.Face()\r\n    \r\n    fPlanarTol = sc.doc.ModelAbsoluteTolerance\r\n    if rgFace.IsPlanar(fPlanarTol):\r\n        print \"Planar face selected.\"\r\n        return\r\n    \r\n    fFaceRad0 = spb_Srf_radius.constantRadiusOfSurface(\r\n        rgFace,\r\n        Opts.values['fRadTol'],\r\n        bDebug=bDebug)\r\n    if bDebug: sPrint = 'fFaceRad0'; print sPrint + ':', eval(sPrint)\r\n    if fFaceRad0 is None:\r\n        print \"Non-fillet face selected.\"\r\n        return\r\n    \r\n    rdBrep0 = objref.Object() # Parent\r\n    \r\n    idxFace_Sel = objref.GeometryComponentIndex.Index\r\n    \r\n    gBrep0 = objref.ObjectId\r\n    \r\n    return (\r\n            gBrep0,\r\n            idxFace_Sel,\r\n            Opts.values['bSameConcavityType'],\r\n            Opts.values['bSameRad'],\r\n            Opts.values['fRadTol'],\r\n            Opts.values['bTanContinuity'],\r\n            Opts.values['fAngleTol'],\r\n            Opts.values['bRetainLayer'],\r\n            Opts.values['bRetainColor'],\r\n            Opts.values['bCopy'],\r\n            Opts.values['bEcho'],\r\n            Opts.values['bDebug'],\r\n    )\r\n\r\n\r\ndef curvatures(rgFace):\r\n    \"\"\"\r\n    Returns: MajorCurvature, MinorCurvature as floats.\r\n    Sign of curvature is per face, which may not be the same as the underlying surface.\r\n    \"\"\"\r\n    areaMassProp = Rhino.Geometry.AreaMassProperties.Compute(rgFace)\r\n    if areaMassProp is None:\r\n        print \"Face {} is skipped because\" \\\r\n              \" its centroid cannot be calculated.\".format(\r\n              rgFace.FaceIndex)\r\n        return\r\n    \r\n    ptCentrdW = areaMassProp.Centroid\r\n    \r\n    getrc, u, v = rgFace.ClosestPoint(ptCentrdW)\r\n    \r\n    c = rgFace.CurvatureAt(u, v)\r\n    if c is None: return\r\n    \r\n    if rgFace.OrientationIsReversed:\r\n        return -c.Kappa(0), -c.Kappa(1)\r\n    else:\r\n        return c.Kappa(0), c.Kappa(1)\r\n\r\n\r\ndef indicesOfContiguousFilletFaces(rgBrep0, idxFace0, bSameConcavityType=True, bSameRad=False, fRadTol=1e-6, bTanContinuity=False, fAngleTol=5.0):\r\n    \r\n    fPlanarTol = 0.1 * sc.doc.ModelAbsoluteTolerance\r\n    \r\n    fAngleTol_Rad = Rhino.RhinoMath.ToRadians(fAngleTol)\r\n    \r\n    rgFace0 = rgBrep0.Faces[idxFace0]\r\n    \r\n    fFaceRad0 = spb_Srf_radius.constantRadiusOfSurface(rgFace0, fRadTol)\r\n    if fFaceRad0 is None: return\r\n    \r\n    if bSameConcavityType:\r\n        rc = curvatures(rgFace0)\r\n        if not rc: return\r\n        kappa_ToMatch = rc[0]\r\n    \r\n    idxFaces_Pass = [idxFace0]\r\n    idxFaces_Fail = []\r\n    idxFace_LastAdded = [idxFace0]\r\n    \r\n    for i in idxFace_LastAdded:\r\n        sc.escape_test()\r\n        \r\n        for j in rgBrep0.Faces[i].AdjacentFaces():\r\n            #print 'j:', j\r\n            if not j in idxFaces_Pass and not j in idxFaces_Fail:\r\n                rgFaceX = rgBrep0.Faces[j]\r\n                \r\n                if rgFaceX.IsPlanar(fPlanarTol):\r\n                    idxFaces_Fail.append(j)\r\n                    continue\r\n                \r\n                fRadFace = spb_Srf_radius.constantRadiusOfSurface(rgFaceX, fRadTol)\r\n                if fRadFace is None:\r\n                    idxFaces_Fail.append(j)\r\n                    continue\r\n                \r\n                if bSameConcavityType:\r\n                    rc = curvatures(rgFaceX)\r\n                    if not rc:\r\n                        idxFaces_Fail.append(j)\r\n                        continue\r\n                    kappa_Max, kappa_Min = rc\r\n                    if kappa_Max == 0.0 and kappa_Min == 0.0:\r\n                        idxFaces_Fail.append(j)\r\n                        continue\r\n                    elif kappa_Max == 0.0:\r\n                        if (\r\n                                (abs(1.0/kappa_Min - 1.0/kappa_ToMatch) > fRadTol)\r\n                        ):\r\n                            idxFaces_Fail.append(j)\r\n                            continue\r\n                    elif kappa_Min == 0.0:\r\n                        if (\r\n                                (abs(1.0/kappa_Max - 1.0/kappa_ToMatch) > fRadTol)\r\n                        ):\r\n                            idxFaces_Fail.append(j)\r\n                            continue\r\n                    else:\r\n                        if (\r\n                                (abs(1.0/kappa_Max - 1.0/kappa_ToMatch) > fRadTol)\r\n                                and\r\n                                (abs(1.0/kappa_Min - 1.0/kappa_ToMatch) > fRadTol)\r\n                        ):\r\n                            idxFaces_Fail.append(j)\r\n                            continue\r\n                \r\n                if bSameRad and not abs(fRadFace - fFaceRad0) <= fRadTol:\r\n                    idxFaces_Fail.append(j)\r\n                    continue\r\n                \r\n                if bTanContinuity:\r\n                    idxEdgesA = list(rgBrep0.Faces[i].AdjacentEdges())\r\n                    idxEdgesB = list(rgFaceX.AdjacentEdges())\r\n                    edges_Shared = list(set(idxEdgesA) & set(idxEdgesB))\r\n                    bTanFound = False\r\n                    for edge_Shared in edges_Shared:\r\n                        if rgBrep0.Edges[edge_Shared].IsSmoothManifoldEdge(\r\n                                fAngleTol_Rad\r\n                        ):\r\n                            bTanFound = True\r\n                    if not bTanFound:\r\n                        idxFaces_Fail.append(j)\r\n                        continue\r\n                \r\n                idxFaces_Pass.append(j)\r\n                idxFace_LastAdded.append(j)\r\n    return idxFaces_Pass\r\n\r\n\r\ndef main(bEcho=True, bDebug=False):\r\n    \r\n    rc = getInput()\r\n    if rc is None: return\r\n    (\r\n            gBrep0,\r\n            idxFace_Sel,\r\n            bSameConcavityType,\r\n            bSameRad,\r\n            fRadTol,\r\n            bTanContinuity,\r\n            fAngleTol,\r\n            bRetainLayer,\r\n            bRetainColor,\r\n            bCopy,\r\n            bEcho,\r\n            bDebug,\r\n    ) = rc\r\n    if idxFace_Sel is None: return\r\n    \r\n    Rhino.RhinoApp.SetCommandPrompt(prompt=\"Working ...\")\r\n    \r\n    rdBrep0 = sc.doc.Objects.FindId(gBrep0) if Rhino.RhinoApp.ExeVersion >= 6 else sc.doc.Objects.Find(gBrep0)\r\n    rgBrep0 = rdBrep0.BrepGeometry\r\n    \r\n    idxFaces_Pass = indicesOfContiguousFilletFaces(\r\n            rgBrep0,\r\n            idxFace_Sel,\r\n            Opts.values['bSameConcavityType'],\r\n            Opts.values['bSameRad'],\r\n            Opts.values['fRadTol'],\r\n            Opts.values['bTanContinuity'],\r\n            Opts.values['fAngleTol'],\r\n    )\r\n    \r\n    rc = xBrepObject.extractFaces(\r\n            gBrep0,\r\n            idxFaces_Pass,\r\n            bAddOnlyMonofaces=False,\r\n            bRetainLayer=bRetainLayer,\r\n            bRetainColor=bRetainColor,\r\n   )\r\n    if rc is None:\r\n        print \"Faces could not be extracted.\"\r\n        return\r\n    else:\r\n        gExtracted = rc[0]\r\n    \r\n    #    # Add brep(s) of faces to be extracted.\r\n    #    \r\n    #    gExtracted = xBrepObject.addFromSubsetOfFaces(\r\n    #            gBrep0, idxFaces_Pass, bRetainLayer,\r\n    #            bEcho=True, bDebug=False,\r\n    #            )\r\n    #    if gExtracted is None:\r\n    #        print \"Faces could not be extracted.\"\r\n    #        return\r\n    #    \r\n    #    # Remove faces from brep.\r\n    #    \r\n    #    rc = xBrepObject.removeFaces(rdBrep0, idxFaces_Pass)\r\n    #    \r\n    #    if rc is None:\r\n    #        print \"xBrepObject.removeFaces returned None!\"\r\n    #        return\r\n    \r\n    if not gExtracted:\r\n        print \"No face of target radius found.\"\r\n        return\r\n    \r\n    ct_Face = 0\r\n    for gBrep1 in gExtracted:\r\n        rgBrep1 = rs.coercebrep(gBrep1)\r\n        ct_Face += rgBrep1.Faces.Count\r\n    \r\n    if not bDebug: sc.doc.Views.RedrawEnabled = False\r\n    \r\n    ct_Breps_Selected = rs.SelectObjects(gExtracted)\r\n    \r\n    print \"{} brep{} selected with {} face{}.\".format(\r\n            ct_Breps_Selected,\r\n            \" is\" if ct_Breps_Selected == 1 else \"s are\",\r\n            ct_Face,\r\n            \"\" if ct_Face == 1 else \"s\",\r\n    )\r\n    \r\n    sc.doc.Views.RedrawEnabled = True\r\n\r\n\r\nif __name__ == '__main__': main(bEcho=bool(1), bDebug=bool(0))",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}