{
  "source_url": "https://github.com/JonasWard/ClayAdventures/blob/70e453eab058ddb92ad4ee34f3148155e4c1cf31/src/ghPython/PatternBrickLibrary/pinLinkingBis.py",
  "repo": "JonasWard/ClayAdventures",
  "repo_stars": 3,
  "repo_description": "A width range of different tests and experiments for fdm clay printing",
  "license": "MIT",
  "filepath": "src/ghPython/PatternBrickLibrary/pinLinkingBis.py",
  "instruction": "pin linking",
  "code": "# pin linking\nimport Rhino.Geometry as rg\nfrom copy import deepcopy as dc\nfrom generalFunctions import *\nfrom brickSlicer import Pin\nfrom layerFunctions import LineSet\n\ndef lineInterpolate(pt_0, pt_2, count):\n\n    delta_pt = (pt_2 - pt_0) / float(count + 1.0)\n\n    return [pt_0 + delta_pt * i for i in range(1, count + 1, 1)]\n\n\ndef linkGen(pt_a, pt_b):\n\n    distance = pt_a.DistanceTo(pt_b)\n    \n    end_pt = rg.Point3d((pt_b - pt_a) / distance + pt_a)\n    \n    return rg.Line(pt_a, end_pt), end_pt\n\n\ndef copyTransformSet(geo_set, trans_matrix):\n\n    new_set = []\n\n    for geo in geo_set:\n\n        tmp_geo = dc(geo)\n        tmp_geo.Transform(trans_matrix)\n\n        new_set.append(tmp_geo)\n\n    return new_set\n\n\ndef startEnd(pt, pt_bis, count, alfa):\n\n    pt_set = []\n    link_lines = []\n\n    if count > 1:\n\n        alfa_delta = ( 6.2831853072 - 2 * alfa ) / (count - 1)\n\n        for i in range(count):\n\n            loc_angle = alfa + alfa_delta * i\n            rot_m = rg.Transform.Rotation(loc_angle, pt)\n\n            loc_pt = dc(pt_bis)\n            loc_pt.Transform(rot_m)\n\n            pt_set.append(loc_pt)\n            link_lines.append(rg.Line(pt, loc_pt))\n\n    elif count == 0:\n\n        pass\n\n    else:\n\n        # case will consider count == 1\n\n        loc_angle = 3.1415927\n        rot_m = rg.Transform.Rotation(loc_angle, pt)\n\n        loc_pt = dc(pt_bis)\n        loc_pt.Transform(rot_m)\n\n        pt_set.append(loc_pt)\n        link_lines.append(rg.Line(pt, loc_pt))\n\n    return link_lines, pt_set\n    \n\ndef start(pt, pt_1, count, alfa = .5):\n\n    # _, pt_a = linkGen(pt, pt_0)\n    main_link, pt_b = linkGen(pt, pt_1)\n    # main_link = rg.Line(pt, pt_1)\n\n    link_lines, pt_set = startEnd(pt, pt_b, count, alfa)\n    pt_set = [pt_b] + pt_set\n\n    return main_link, link_lines, pt_set\n\n\ndef end(pt_0, pt, count, alfa = .5):\n\n    _, pt_a = linkGen(pt, pt_0)\n    # main_link, pt_b = linkGen(pt, pt_1)\n\n    link_lines, pt_set = startEnd(pt, pt_a, count, alfa)\n    pt_set = [pt_a] + pt_set\n\n    main_link = None\n\n    return main_link, link_lines, pt_set\n\n\ndef mid(pt_0, pt, pt_1, count, min_alfa = .25):\n\n    _, pt_a = linkGen(pt, pt_0)\n    main_link, pt_b = linkGen(pt, pt_1)\n    # main_link = rg.Line(pt, pt_1)\n\n    link_lines, pt_set = midDivide(pt_a, pt, pt_b, items=count, cutoff=min_alfa)\n\n    pt_set = [pt_a, pt_b] + pt_set\n\n    return main_link, link_lines, pt_set\n\n\ndef midDivide(pt_0, pt, pt_1, items = 1, cutoff = .25):\n\n    _, pt_0 = linkGen(pt, pt_0)\n    _, pt_1 = linkGen(pt, pt_1)\n\n    circle = rg.Circle(pt, 1.0).ToNurbsCurve()\n\n    crvs, _ = layer2ptIntersect(circle, [pt_0, pt_1])\n    crv_0 = crvs[0]\n    crv_1 = crvs[1]\n\n    crv_0_l = crv_0.GetLength()\n    crv_1_l = crv_1.GetLength()\n\n    if crv_0_l < crv_1_l:\n\n        double_split_crv = crv_1\n        double_crv_l = crv_1_l\n        single_split_crv = crv_0\n    \n    else:\n\n        double_split_crv = crv_0\n        double_crv_l = crv_0_l\n        single_split_crv = crv_1\n\n    if items < 2:\n\n        double_split_crv.Domain = rg.Interval(0.0, 1.0)\n        pt_2 = double_split_crv.PointAt(.5)\n\n        line_set = [rg.Line(pt, pt_2)]\n\n        pt_set = [pt_2]\n\n    elif items == 2:\n\n        single_split_crv.Domain = rg.Interval(0,1)\n        pt_2 = single_split_crv.PointAt(.5)\n\n        double_split_crv.Domain = rg.Interval(0,1)\n        pt_3 = double_split_crv.PointAt(.5)\n\n        line_set = [rg.Line(pt, pt_2), rg.Line(pt, pt_3)]\n\n        pt_set = [pt_2, pt_3]\n\n    else:\n\n        if double_crv_l < 3.1415927 + cutoff:\n            \n            line_set, pt_set = midDivide(pt_0, pt, pt_1, items = 2)\n\n        else:\n\n            double_split_crv.Domain = rg.Interval(0,double_crv_l)\n            single_split_crv.Domain = rg.Interval(0,1.0)\n            \n            pt_2 = single_split_crv.PointAt(.5)\n            \n            pt_3 = double_split_crv.PointAt(.5 * 3.1415927)\n            pt_4 = double_split_crv.PointAt(double_crv_l - .5 * 3.1415927)\n\n            line_set = [rg.Line(pt, pt_2), rg.Line(pt, pt_3), rg.Line(pt, pt_4)]\n\n            pt_set = [pt_2, pt_3, pt_4]\n\n    return line_set, pt_set\n\n\ndef longestSegment(pin_point, pin_pt_set, second_one = False):\n\n    c = rg.Circle(pin_point, 1.0).ToNurbsCurve()\n\n    crvs, pts = layer2ptIntersect(c, pin_pt_set)\n\n    crv_lengths = [crv.GetLength() for crv in crvs]\n\n    crv_lengths, crvs = zip(*sorted(zip(crv_lengths, crvs)))\n\n    print(\"this is the list of crv lengths\")\n    print(crv_lengths)\n\n    longest_crv = crvs[-1]\n    second_longest_crv = crvs[-2]\n\n    longest_crv.Domain = rg.Interval(0, 1.0)\n    longest_mid_pt = longest_crv.PointAt(.5)\n\n    if second_one:\n\n        second_longest_crv.Domain = rg.Interval(0, 1.0)\n        second_longest_mid_pt = longest_crv.PointAt(.5)\n\n        split_lines = [\n            rg.Line(pin_point, second_longest_mid_pt),\n            rg.Line(pin_point, longest_mid_pt)    \n        ]\n\n        return split_lines\n\n    else:\n\n        split_line = rg.Line(pin_point, longest_mid_pt)\n\n        return split_line\n\n\ndef createLinks(pin_pts, connection_count = 2, max_main_line = 100.0, start_end_alfa = .5, mid_alfa = .25):\n\n    pin_pts = [rg.Point3d(pt.X, pt.Y, 0.0) for pt in pin_pts]\n\n    main_links, link_lines, pin_pt_sets = [], [], []\n    split_lines = []\n\n    pin_count = len(pin_pts)\n\n    for pt_i, pt in enumerate(pin_pts):\n\n        if pt_i == 0:\n\n            main_link, link_line_set, pt_set = start(pt, pin_pts[pt_i + 1], connection_count, start_end_alfa)\n\n            main_links.append(main_link)\n            link_lines.extend(link_line_set)\n            pin_pt_sets.append(pt_set)\n\n        elif pt_i == pin_count - 1:\n\n            _, link_line_set, pt_set = end(pin_pts[pt_i - 1], pt, connection_count, start_end_alfa)\n\n            # main_links.append(main_link)\n            link_lines.extend(link_line_set)\n            pin_pt_sets.append(pt_set)\n\n        else:\n\n            main_link, link_line_set, pt_set = mid(pin_pts[pt_i - 1], pt, pin_pts[pt_i + 1], connection_count, mid_alfa)\n\n            main_links.append(main_link)\n            link_lines.extend(link_line_set)\n            pin_pt_sets.append(pt_set)\n\n    # generating extra line division in case the main lines are too long\n\n    b_mid_pts = []\n    mid_links = []\n\n    for i in range(pin_count - 1):\n\n        pt_0 = pin_pts[i]\n        pt_1 = pin_pts[i + 1]\n\n        distance = pt_0.DistanceTo(pt_1)\n\n        if distance > max_main_line:\n\n            _, loc_link_set, _ = start(pt_0, pt_1, 2, alfa = 1.570796)\n\n            split_count = int(round(distance / max_main_line))\n\n            b_pts = lineInterpolate(pt_0, pt_1, split_count)\n\n            loc_mid_pts = []\n\n            if len(b_pts) > 1:\n\n                # generating mid points between the base points if necessary\n\n                for i in range(len(b_pts) - 1):\n\n                    loc_mid_pts.append(rg.Point3d( (b_pts[i] + b_pts[i+1]) * .5) )\n\n            for b_pt in b_pts:\n\n                trans_m = rg.Transform.Translation(rg.Vector3d(b_pt - pt_0))\n\n                mid_links.extend(copyTransformSet(loc_link_set, trans_m))\n\n        b_mid_pts.append(loc_mid_pts)\n\n    # generating the split lines\n\n    for i, pin_pt_set in enumerate(pin_pt_sets):\n\n        split_lines.append(longestSegment(pin_pts[i], pin_pt_set))\n\n    return main_links, link_lines, split_lines, pin_pt_sets, mid_links, b_mid_pts\n\n\ndef pinMaker(pin_pts, pin_height, bot_rad, top_rad, resolution = 16):\n\n    return [Pin(pt, pin_height, bot_rad, top_rad, resolution) for pt in pin_pts]\n\ndef extendTrim(inner_crv, outer_crv, line_set):\n\n    line_set.trimLines(outer_crv, True)\n    line_set.trimLines(inner_crv, False)\n\ndef linkClosestPoints(link, pts):\n\n    extra_pt_set = []\n\n    lines = link.createLines()\n\n    for line in lines:\n\n        for pt in pts:\n\n            extra_pt_set.append( line.ClosestPoint(pt, False) )\n\n    return extra_pt_set\n\ndef joinShape(prev_crv, next_crv, line_set, extend_trim = True, crossing = False):\n\n    if extend_trim:\n\n        extendTrim(prev_crv, next_crv, line_set)\n    \n    result_crvs_0, _ = layer2ptIntersect(prev_crv, line_set.Start)\n    main_crv = curveToPolyline(longestCurve(result_crvs_0))\n\n    result_crvs_1, _ = layer2ptIntersect(next_crv, line_set.End)\n    next_crv = curveToPolyline(longestCurve(result_crvs_1))\n\n    main_crv, next_crv = list(main_crv), list(next_crv)\n\n    \n    if not(crossing):\n\n        pt_set = main_crv + next_crv\n\n    else:\n\n        crossing_distance = 4.0\n\n        start0, start1 = main_crv[0], main_crv[-1]\n        end0, end1 = next_crv[-1], next_crv[0]\n\n        distance0 = start0.DistanceTo(end0)\n        distance1 = start1.DistanceTo(end1)\n\n        exPt0_0 = crossing_distance\n        exPt0_1 = distance0 - crossing_distance\n\n        exPt1_0 = crossing_distance\n        exPt1_1 = distance1 - crossing_distance\n\n        # swapping & reversing set 1\n\n        pt0_0 = interpolatePts(start0, end0, exPt0_0)\n        pt0_1 = interpolatePts(start0, end0, exPt0_1)\n\n        pt1_1 = interpolatePts(start1, end1, exPt1_0)\n        pt1_0 = interpolatePts(start1, end1, exPt1_1)\n\n        pt_set = main_crv + [pt0_0, pt0_1] + next_crv + [pt1_0, pt1_1]\n\n    return pt_set + [pt_set[0]]\n        \n\ndef linkSetGeneration(lines, spacing, amount = 2):\n\n    link_set = []\n\n    for line in lines:\n\n        loc_line_set = LineSet(line, spacing, amount)\n        loc_line_set.createLines()\n\n        link_set.append(loc_line_set)\n\n    return link_set\n\n\ndef makeMainShape(pins, main_link_set, height, bottom_shift = None):\n\n    main_crv = pins[0].createSlice(height).ToPolylineCurve()\n\n    if not(bottom_shift == None):\n\n        print(\"I am offsetting the bottom layer with %s\" % bottom_shift)\n        \n        main_crv = offsetCurveSet(main_crv, bottom_shift, \"outside\", count = 2)[1].ToNurbsCurve()\n\n    inner_crvs = [dc(main_crv)]\n\n    mv_m = rg.Transform.Translation(rg.Vector3d(0,0,height))\n\n    main_links = []\n\n    for i, main_link in enumerate(main_link_set):\n\n        con_line_set = dc(main_link)\n        con_line_set.Transform(mv_m)\n\n        next_crv = pins[i + 1].createSlice(height).ToPolylineCurve()\n\n        if not(bottom_shift == None):\n\n            print(\"I am offsetting the bottom layer with %s\" % bottom_shift)\n            \n            next_crv = offsetCurveSet(next_crv, bottom_shift, \"outside\", count = 2)[1].ToNurbsCurve()\n\n        inner_crvs.append(dc(next_crv))\n\n        current_pt_set = joinShape(main_crv, next_crv, con_line_set)\n\n        main_crv = rg.Polyline(current_pt_set).ToPolylineCurve()\n\n        main_links.append(con_line_set)\n\n    return main_crv, current_pt_set, main_links, inner_crvs\n\n\ndef addLink(polycrv, side_link, open_end = True, start_pts = False, safety_dis = True, start_dis = (20.0, 15.0)):\n\n    result_crvs, _ = layer2ptIntersect(polycrv, side_link.Start)\n    pt_set = list(curveToPolyline(longestCurve(result_crvs)).ToArray())\n\n    if pt_set[0].DistanceTo(side_link.Start[1]) < .001:\n\n        # start_pts = list(side_link.Start).reverse()\n        end_pts = list(side_link.End)\n        end_pts.reverse()\n\n    else:\n\n        # start_pts = list(side_link.Start)\n        end_pts = list(side_link.End)\n\n\n    if open_end:\n\n        pt_set = [end_pts[1]] + pt_set + [end_pts[0]]\n\n    elif start_pts:\n\n        if safety_dis:\n\n            start_dis = [start_dis[0], start_dis[1], start_dis[1], start_dis[0]]\n\n            vecs = [\n                rg.Vector3d(pt_set[-2] - pt_set[-1]),\n                rg.Vector3d(end_pts[0] - pt_set[-1]),\n                rg.Vector3d(end_pts[1] - pt_set[0]),\n                rg.Vector3d(pt_set[1] - pt_set[0])\n            ]\n\n            [vec.Unitize() for vec in vecs]\n\n            vecs = [vec * start_dis[vec_i] for vec_i, vec in enumerate(vecs)]\n\n            b_pts = [pt_set[-1], pt_set[-1], pt_set[0], pt_set[0]]\n\n            ex_pts = [rg.Point3d(b_pt + vecs[i]) for i, b_pt in enumerate(b_pts)]\n            ex_pts = ex_pts[:2] + end_pts + ex_pts[2:]\n\n            print(len(ex_pts))\n\n            pt_set = pt_set[1:-1] + ex_pts # + [pt_set[1]]\n\n        else:\n\n            pt_set = pt_set[1:-1] + end_pts + [pt_set[1]]\n    \n    else:\n\n        # pt_set = pt_set + side_link.joinLines(False) + [pt_set[0]]\n        \n        pt_set = pt_set + end_pts + [pt_set[0]]\n\n    return pt_set\n\n\ndef makeSideLinks(main_crv, exterior_crv, link_set, height):\n\n    mv_m = rg.Transform.Translation(rg.Vector3d(0,0,height))\n\n    side_link_set = []\n    main_crv_pt_set = []\n\n    for side_link in link_set:\n\n        loc_side_link = dc(side_link)\n        loc_side_link.Transform(mv_m)\n\n        extendTrim(main_crv, exterior_crv, loc_side_link)\n\n        side_link_set.append(loc_side_link)\n\n        main_crv_pt_set = addLink(main_crv, loc_side_link, False)\n        main_crv = rg.Polyline(main_crv_pt_set).ToPolylineCurve()\n\n    return main_crv_pt_set, side_link_set\n\n\ndef makeInnerCurve(inner_crvs, main_links, side_links, end_link = None, loc_extra_pts = None, mid_links = None, diamond_settings = (False, False, (15.0, 10.0))):\n\n    inner_crv_count = len(inner_crvs)\n\n    main_crv = dc(inner_crvs[0])\n\n    # reading in the diamond settings\n    start_mid_pts, safety_dis, start_dis = diamond_settings\n\n    if inner_crv_count > 1:\n\n        print(\"I have to do more!\")\n\n        for i in range(inner_crv_count - 1):\n\n            current_pt_set = joinShape(main_crv, inner_crvs[i + 1], main_links[i], False, True)\n\n            main_crv = rg.Polyline(current_pt_set).ToPolylineCurve()\n\n    if not(loc_extra_pts == None):\n\n        for pt in loc_extra_pts:\n\n            _, t_val = main_crv.ClosestPoint(pt)\n\n            main_crv.ChangeClosedCurveSeam(t_val)\n\n    for side_link in side_links:\n\n        print(\"I am adding a side_link!\")\n\n        pt_set = addLink(main_crv, side_link, open_end = False)\n\n        main_crv = rg.Polyline(pt_set + [pt_set[0]]).ToPolylineCurve()\n\n    for mid_link in mid_links:\n        \n        print(\"I am here?\")\n\n        pt_set = addLink(main_crv, mid_link, open_end = False, start_pts = start_mid_pts, safety_dis = safety_dis, start_dis = start_dis)\n\n        main_crv = rg.Polyline(pt_set + [pt_set[0]]).ToPolylineCurve()\n\n    if not(end_link == None):\n\n        print(\"I am adding the end_link!\")\n\n        pt_set = addLink(main_crv, end_link, True)\n\n        main_crv = rg.Polyline(pt_set).ToPolylineCurve()\n\n    return main_crv\n\n\n\n\n# def createLinkChain(pins, height, main_links, link_lines, split_lines, outer_part, ):",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry"
  ],
  "has_docstring": true
}