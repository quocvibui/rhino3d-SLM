{
  "source_url": "https://github.com/ibois-epfl/catalogue-exporter/blob/c7bea3508e7dcdb08ef71184efde207e37a4c5c1/MinimumBoundingBox.py",
  "repo": "ibois-epfl/catalogue-exporter",
  "repo_stars": 1,
  "repo_description": "A Rhinoceros 3D plugin for exporting point cloud dataset to a web-based catalogue.",
  "license": "unknown",
  "filepath": "MinimumBoundingBox.py",
  "instruction": "Combined 2D and 3D \"fast\" minimum bounding box calculator.\nAccepts points, pointclouds, curves, surfaces, breps, extrusions, meshes.\nChecks first for single object planarity or multi-object...",
  "code": "\"\"\"Combined 2D and 3D \"fast\" minimum bounding box calculator.\nAccepts points, pointclouds, curves, surfaces, breps, extrusions, meshes.\nChecks first for single object planarity or multi-object coplanarity.\nUser options for standard/fine sampling and intermediate result reporting\n(3D BB only)\n\nIf planar/coplanar:\n- Launches 2D planar bounding rectangle routine\n- Finds a minimum bounding rectangle relative to a plane for a set of objects.\n- Finds smallest area rectangle in plane first to 1 degree, then refines by 1/90\n- continues looping with smaller increments until area no longer decreases. (tol)\n\nIf non planar/coplanar:\n- Launches 3D bounding box routine\n- Gets initial rough bounding box/plane: checks every 9 or 5 degrees in all 3 axes\n- uses plane from previous check as start point for smaller refinements\n- continues refnement stages until bounding box area no longer decreases. (tol)\n\nScript by Mitch Heynick 23.06.18  Release version 1\"\"\"\n\nimport rhinoscriptsyntax as rs\nimport scriptcontext as sc\nimport Rhino, math, time\nimport Rhino.DocObjects.ObjectType as OT\n\n#get input objects plus settings\ndef GetObjectsPlus3Boolean(prompt,b_prompts,b_opts,g_filt=None):\n    go = Rhino.Input.Custom.GetObject()\n    go.SetCommandPrompt(prompt)\n    blnOption0=Rhino.Input.Custom.OptionToggle(*b_opts[0])\n    blnOption1=Rhino.Input.Custom.OptionToggle(*b_opts[1])\n    blnOption2=Rhino.Input.Custom.OptionToggle(*b_opts[2])\n    go.AddOptionToggle(b_prompts[0],blnOption0)\n    go.AddOptionToggle(b_prompts[1],blnOption1)\n    go.AddOptionToggle(b_prompts[2],blnOption2)\n    #allow preselected object\n    go.EnablePreSelect(True,True)\n    #main object type filter\n    if g_filt: go.GeometryFilter=g_filt\n    while True:\n        get_rc = go.GetMultiple(1,0)\n        if get_rc==Rhino.Input.GetResult.Cancel: return\n        if get_rc==Rhino.Input.GetResult.Object:\n            objs=go.Objects()\n            break\n        elif get_rc==Rhino.Input.GetResult.Option:\n            continue\n    a=blnOption0.CurrentValue\n    b=blnOption1.CurrentValue\n    c=blnOption2.CurrentValue\n    return (objs,a,b,c)\n\n#multi-object planarity/coplanarity check function\ndef CheckObjCoPlanarity(objs,tol=sc.doc.ModelAbsoluteTolerance):\n    #accepts points, pointclouds, curves, surfaces, breps and meshes\n    #try to \"short-circuit\" out if any curve or brep element is not planar\n    pt_list=[]\n    for obj in objs:\n        if isinstance(obj,Rhino.Geometry.Point3d):\n            pt_list.append(obj)\n        elif isinstance(obj,Rhino.Geometry.Point):\n            pt_list.append(obj.Location)\n        elif isinstance(obj,Rhino.Geometry.PointCloud):\n            pt_list.extend(obj.GetPoints())\n        elif isinstance(obj,Rhino.Geometry.Curve):\n            rc,plane=obj.TryGetPlane(tol)\n            if not rc: return\n            nc = obj.ToNurbsCurve()\n            if nc is None: return\n            crv_pts=[nc.Points[i].Location for i in xrange(nc.Points.Count)]\n            pt_list.extend(crv_pts)\n        elif isinstance(obj,Rhino.Geometry.Brep):\n            for face in obj.Faces:\n                rc,plane=face.TryGetPlane(tol)\n                if not rc: return\n                srf=face.ToNurbsSurface()\n                if not srf: return\n                for cp in srf.Points: pt_list.append(cp.Location)\n        elif isinstance(obj,Rhino.Geometry.Surface):\n            rc,plane=obj.TryGetPlane(tol)\n            if not rc: return\n            srf=obj.ToNurbsSurface()\n            if not srf: return\n            for cp in srf.Points: pt_list.append(cp.Location)\n        elif isinstance(obj,Rhino.Geometry.Extrusion):\n            rc,plane=obj.TryGetPlane(tol)\n            if not rc: return\n            srf=face.ToNurbsSurface()\n            if not srf: return\n            for cp in srf.Points: pt_list.append(cp.Location)\n        elif isinstance(obj,Rhino.Geometry.Mesh):\n            verts=obj.Vertices\n            for vert in obj.Vertices: pt_list.append(Rhino.Geometry.Point3d(vert))\n        else:\n            return\n    if Rhino.Geometry.Point3d.ArePointsCoplanar(pt_list,tol):\n        rc, plane = Rhino.Geometry.Plane.FitPlaneToPoints(pt_list)\n        if rc==Rhino.Geometry.PlaneFitResult.Success: return plane\n\n#gets a plane-aligned bounding box\ndef BoundingBoxPlane(objs,plane,ret_pts=False,accurate=True):\n    \"\"\"returns a plane-aligned bounding box in world coordinates\n       - input geometry must be RhinoCommon geometry (not IDs)\n       - adapted from python rhinoscriptsyntax rs.BoundingBox() code.\"\"\"\n    wxy_plane=Rhino.Geometry.Plane.WorldXY\n    def __objectbbox(geom,xform):\n        if isinstance(geom,Rhino.Geometry.Point):\n            pt=geom.Location\n            if xform: pt = xform * pt\n            return Rhino.Geometry.BoundingBox(pt,pt)\n        if xform: return geom.GetBoundingBox(xform)\n        return geom.GetBoundingBox(accurate)\n    \n    xform = Rhino.Geometry.Transform.ChangeBasis(wxy_plane, plane)\n    bbox = Rhino.Geometry.BoundingBox.Empty\n    if type(objs) is list or type(objs) is tuple:\n        for obj in objs:\n            objectbbox = __objectbbox(obj, xform)\n            bbox = Rhino.Geometry.BoundingBox.Union(bbox,objectbbox)\n    else:\n        objectbbox = __objectbbox(objs, xform)\n        bbox = Rhino.Geometry.BoundingBox.Union(bbox,objectbbox)\n    if not bbox.IsValid: return\n    plane_to_world = Rhino.Geometry.Transform.ChangeBasis(plane,wxy_plane)\n    if ret_pts:\n        corners = list(bbox.GetCorners())\n        for pt in corners: pt.Transform(plane_to_world)\n        return corners\n    else:\n        box=Rhino.Geometry.Box(bbox)\n        box.Transform(plane_to_world)\n        return box\n\n#used in initial 3D bb calculation\ndef RotateCopyPlanes(tot_ang,count,init_planes,dir_vec):\n    \"\"\"takes a single plane or list of planes as input\n    rotates/copies planes through angle tot_ang\n    number of planes=count, number of angle divisions=count-1\"\"\"\n    if isinstance(init_planes,Rhino.Geometry.Plane): init_planes=[init_planes]\n    inc=tot_ang/(count-1)\n    origin=Rhino.Geometry.Point3d(0,0,0)\n    planes=[]\n    objs=[]\n    for i in range(count):\n        for init_plane in init_planes:\n            new_plane=Rhino.Geometry.Plane(init_plane)\n            new_plane.Rotate(inc*i,dir_vec,origin)\n            planes.append(new_plane)\n    return planes\n\n#used in initial 3D bb calculation\ndef GenerateOctantPlanes(count):\n    tot_ang=math.pi*0.5 #90 degrees\n    #generates an array of count^3 planes in 3 axes covering xyz positive octant\n    yz_plane=Rhino.Geometry.Plane.WorldYZ\n    dir_vec=Rhino.Geometry.Vector3d(1,0,0) #X axis\n    x_planes=RotateCopyPlanes(tot_ang,count,yz_plane,dir_vec)\n    dir_vec=Rhino.Geometry.Vector3d(0,-1,0) #-Y axis\n    xy_planes=RotateCopyPlanes(tot_ang,count,x_planes,dir_vec)\n    dir_vec=Rhino.Geometry.Vector3d(0,0,1) #Z axis\n    xyz_planes=RotateCopyPlanes(tot_ang,count,xy_planes,dir_vec)\n    return xyz_planes\n\n#used in 3D refinement calculation\ndef RotatedPlaneArray(plane,tot_ang,divs,axis):\n    \"\"\"creates an array of planes rotated in increments around an axis\n    tot_ang=total array inc. angle (rads); divided into divs number of divisions\n    included angle is interval from -tot_ang/2 to +tot_ang/2\n    number of output planes is divs; number of angle divisions is divs-1 \"\"\"\n    out_planes=[]\n    plane.Rotate(-tot_ang*0.5,axis)\n    out_planes.append(Rhino.Geometry.Plane(plane))\n    inc=tot_ang/(divs-1)\n    for i in range(divs-1):\n        plane.Rotate(inc,axis)\n        out_planes.append(Rhino.Geometry.Plane(plane))\n    return out_planes\n\n#used in 3D refinement calculation \ndef RotatePlaneArray3D(view_plane,tot_ang,divs):\n    #generate a 3D array of refinement planes (works with narrow angles)\n    out_planes=[]\n    #use RotatedPlaneArray to generate 'horizontal' left-right array (yaw)\n    yaw_planes=RotatedPlaneArray(view_plane,tot_ang,divs,view_plane.ZAxis)\n    for y_plane in yaw_planes:\n        #use RotatedPlaneArray to generate side-to-side 'tilt' array (roll)\n        roll_planes=RotatedPlaneArray(y_plane,tot_ang,divs,y_plane.YAxis)\n        for r_plane in roll_planes:\n            #use RotatedPlaneArray to generate up-down 'tilt' array (pitch)\n            pitch_planes=RotatedPlaneArray(r_plane,tot_ang,divs,r_plane.XAxis)\n            for p_plane in pitch_planes:\n                out_planes.append(p_plane)\n    return out_planes\n\n#this is the main 3D bb calculation search function\ndef MinBBPlane(objs,best_plane,planes,curr_box,curr_vol):\n    \"\"\"returns plane with smallest aligned bounding box volume\n    from list of input objects, planes to test and initial compare volume\n    best plane, volume, and bbox pass through if no better solution found\"\"\"\n    for plane in planes:\n        bb=BoundingBoxPlane(objs,plane,ret_pts=False)\n        if bb.Volume<curr_vol:\n            curr_vol=bb.Volume\n            best_plane=plane\n            curr_box=bb\n    return best_plane,curr_box,curr_vol\n\n#3D (non-planar) bounding box routine\ndef Min3DBoundingBox(objs,init_plane,count,rel_stop,im_rep):\n    #for non-planar or non-coplanar object(s)\n    #get initial fast bb in init plane (World XY), plus volume to compare\n    curr_bb=BoundingBoxPlane(objs,init_plane,False)\n    curr_vol=curr_bb.Volume\n    \n    tot_ang=math.pi*0.5 #90 degrees for intial octant\n    factor=0.1 #angle reduction factor for each successive refinement pass\n    max_passes=20 #safety factor\n    prec=sc.doc.ModelDistanceDisplayPrecision\n    us=rs.UnitSystemName(abbreviate=True)\n    \n    #run intitial bb calculation\n    xyz_planes=GenerateOctantPlanes(count)\n    best_plane,curr_bb,curr_vol=MinBBPlane(objs,init_plane,xyz_planes,curr_bb,curr_vol)\n    #report results of intial rough calculation\n#    if im_rep:\n#        print \"Initial pass 0, volume: {} {}3\".format(round(curr_vol,prec),us)\n    #refine with smaller angles around best fit plane, loop until...\n    for i in range(max_passes):\n        prev_vol=curr_vol\n        #reduce angle by factor, use refinement planes to generate array\n        tot_ang*=factor\n        ref_planes=RotatePlaneArray3D(best_plane,tot_ang,count)\n        best_plane,curr_bb,curr_vol=MinBBPlane(objs,best_plane,ref_planes,curr_bb,curr_vol)\n        vol_diff=prev_vol-curr_vol #vol. diff. over last pass, should be positive or 0\n        #print \"Volume difference from last pass: {}\".format(vol_diff) #debug\n        #check if difference is less than minimum \"significant\"\n        #rel_stop==True: relative stop value <.01% difference from previous\n        if rel_stop:\n            if vol_diff<0.0001*prev_vol: break\n        else:\n            if vol_diff<sc.doc.ModelAbsoluteTolerance: break\n#        Rhino.RhinoApp.Wait()\n#        if im_rep:\n#            print \"Refine pass {}, volume: {} {}3\".format(i+1,round(curr_vol,prec),us)\n        #get out of loop if escape is pressed\n        if sc.escape_test(False):\n#            print \"Refinement aborted after {} passes.\".format(i+1)\n            break\n            \n    return curr_bb,curr_vol,i+1\n\n#this is the main 2D bb calculation search function\ndef PlanarMinBB(objs,plane,tot_ang,divs):\n    inc=tot_ang/divs\n    #rotate plane half total angle minus direction\n    plane.Rotate(-tot_ang*0.5,plane.ZAxis,plane.Origin)\n    bb = BoundingBoxPlane(objs,plane)\n    curr_plane=Rhino.Geometry.Plane(plane)\n    curr_area=BoxArea(bb)\n    #loop through angle increments\n    for i in range(divs):\n        plane.Rotate(inc,plane.ZAxis,plane.Origin)\n        bb = BoundingBoxPlane(objs,plane)\n        new_area=BoxArea(bb)\n        if new_area<curr_area:\n            #print curr_area #debug\n            #print new_area #debug\n            curr_area=new_area\n            curr_plane=Rhino.Geometry.Plane(plane)\n    return curr_plane, curr_area\n\n#2D planar bounding rectangle routine\ndef MinBoundingRectanglePlane(objs,curr_plane,im_rep=False):\n    #pass True argument above if you want to print intermediate results\n    #initialize\n    factor=0.01 #0.01 (1/100 of model abs tolerance)\n    angle=math.pi*0.5 #start angle 90 degrees\n    divs=90  #initial division 1 degree intervals\n    tol = sc.doc.ModelAbsoluteTolerance\n    err_msg=\"Unable to calculate bounding box area\"\n    st=time.time()\n    \n    #get initial rough bounding box\n    init_bb=BoundingBoxPlane(objs,curr_plane,ret_pts=False)\n    curr_area=BoxArea(init_bb)\n#    if im_rep: \n#        print \"Initial area: {}\".format(curr_area)\n    \n    #main calculation loop\n    safe=10 #set safety limit at 10\n    for i in range(safe):\n        curr_plane,new_area = PlanarMinBB(objs,curr_plane,angle,divs)\n        #abort if area is 0 or extremely small\n#        if new_area<tol*0.1:\n#            print err_msg ; return\n        #break out of loop if new area is the same as prev. area within limit\n        if abs(curr_area-new_area)<factor*tol: break\n        #otherwise, decrease increments and loop\n        curr_area=new_area\n        angle*=(1/divs)\n#        if im_rep:\n#            print \"Refine stage {} Area: {}\".format(i+1,curr_area)\n#            Rhino.RhinoApp.Wait() #wait for command line to print...\n#        if i==10:\n#            print \"Max loop limit reached\" #debug\n        \n    f_bb=BoundingBoxPlane(objs,curr_plane,ret_pts=True)\n    return f_bb,curr_area,i\n\n#used for planar bounding rectangle calculation\ndef BoxArea(box):\n    return (box.X[1]-box.X[0])*(box.Y[1]-box.Y[0])\n\ndef CombinedMinBB(objIDs, fine_sample = False, rel_stop = False, im_rep = False):\n    #user input\n    #get prev settings\n    if \"MinBBSample\" in sc.sticky: u_samp = sc.sticky[\"MinBBSample\"]\n    else: u_samp = False #standard sampling\n    if \"MinBBStop\" in sc.sticky: u_stop = sc.sticky[\"MinBBStop\"]\n    else: u_stop = True #relative volume stop value\n    if \"MinBBReports\" in sc.sticky: u_rep = sc.sticky[\"MinBBReports\"]\n    else: u_rep = True #intermediate reports shown\n    \n    prec=sc.doc.ModelDistanceDisplayPrecision\n    us=rs.UnitSystemName(abbreviate=True)\n    \n    # prompt=\"Select objects for minimum bounding box\"\n    # gf=OT.Point|OT.PointSet|OT.Curve|OT.Surface|OT.Extrusion|OT.Brep|OT.Mesh\n    # bool_prompts=[\"Sampling\",\"StopVal\",\"ReportIntermedResults\"]\n    # bool_ini=[[u_samp,\"Standard\",\"Fine\"],[u_stop,\"Absolute\",\"Relative\"],[u_rep,\"No\",\"Yes\"]]\n    # result=GetObjectsPlus3Boolean(prompt,bool_prompts,bool_ini,gf)\n    # if result is None: return\n    # objIDs,fine_sample,rel_stop,im_rep=result\n\n\n    \n    #objIDs=rs.GetObjects(preselect=True)\n    #if not objIDs: return\n    objs=[rs.coercegeometry(objID) for objID in objIDs]\n#    print \"Checking object planarity/coplanarity...\"\n    st=time.time()\n    plane=CheckObjCoPlanarity(objs,tol=sc.doc.ModelAbsoluteTolerance)\n    \n    if plane:\n        if len(objs)==1: msg=\"Selected object is planar - \"\n        else: msg=\"All selected objects are coplanar - \"\n        msg+=\"launching 2D planar bounding rectangle calculation.\"\n#        print msg\n        #launch planar bounding box routine\n        f_bb,curr_area,passes=MinBoundingRectanglePlane(objs,plane,im_rep)\n        #add polyline, report message\n        bbID=rs.AddPolyline([f_bb[0],f_bb[1],f_bb[2],f_bb[3],f_bb[0]])\n        fa=round(curr_area,prec)\n        msg=\"{} refinement stages. \".format(passes)\n        msg+=\"Minimum bounding box area = {} sq. {}\".format(fa,us)\n        msg+=\" Elapsed time: {:.2f} sec.\".format(time.time()-st)\n        \n    else:\n        #standard sample count=10 --> 1000 boxes per pass\n        #fine sample count=18 --> 5832 boxes per pass\n        if fine_sample: count=18\n        else: count=10\n        wxy_plane=Rhino.Geometry.Plane.WorldXY\n        if len(objs)==1: cp_msg=\"Selected object is not planar - \"\n        else: cp_msg=\"Selected objects are not coplanar - \"\n        cp_msg+=\"launching 3D bounding box calculation.\"\n#        print cp_msg\n        rs.Prompt(\"Calculating... please wait.\")\n        #launch 3D bounding box routine\n        curr_bb,curr_vol,passes=Min3DBoundingBox(objs,wxy_plane,count,rel_stop,im_rep)\n        \n        #add box, report message\n        if Rhino.RhinoApp.ExeVersion<6:\n            sc.doc.Objects.AddBrep(curr_bb.ToBrep()) #legacy\n        else:\n            sc.doc.Objects.AddBox(curr_bb)\n        fv=round(curr_vol,prec)\n        msg=\"Final volume after {} passes is {} {}3\".format(passes,fv,us)\n        msg+=\" | Elapsed time: {:.2f} sec.\".format(time.time()-st)\n        \n    #final result reporting\n#    print msg\n    sc.doc.Views.Redraw()\n    #save user settings\n    sc.sticky[\"MinBBSample\"] = fine_sample\n    sc.sticky[\"MinBBReports\"] = im_rep\n    sc.sticky[\"MinBBStop\"] = rel_stop\n    return curr_vol",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "RhinoCommon",
    "rhinoscriptsyntax",
    "scriptcontext"
  ],
  "has_docstring": true
}