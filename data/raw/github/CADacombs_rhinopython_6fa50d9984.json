{
  "source_url": "https://github.com/CADacombs/rhinopython/blob/541b4ade49f1dda6a3861d12b9e2613405182082/spb_Pipe_tangentToCrvOnSrf.py",
  "repo": "CADacombs/rhinopython",
  "repo_stars": 37,
  "repo_description": "Python scripts for Rhinoceros (Rhino, Rhino3D).",
  "license": "LGPL-3.0",
  "filepath": "spb_Pipe_tangentToCrvOnSrf.py",
  "instruction": "This script will create a pipe with its center spine an offset from a curve on a surface.\r\n\r\nSend any questions, comments, or script development service needs to @spb on the McNeel...",
  "code": "\"\"\"\r\nThis script will create a pipe with its center spine an offset from a curve on a surface.\r\n\r\nSend any questions, comments, or script development service needs to @spb on the McNeel Forums:\r\nhttps://discourse.mcneel.com/\r\n\"\"\"\r\n\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\n\"\"\"\r\n240105: Created.\r\n\"\"\"\r\n\r\nimport Rhino\r\nimport Rhino.DocObjects as rd\r\nimport Rhino.Geometry as rg\r\nimport Rhino.Input as ri\r\nimport scriptcontext as sc\r\n\r\nimport spb_OffsetNormal\r\n\r\n\r\nclass Opts:\r\n\r\n    keys = []\r\n    values = {}\r\n    names = {}\r\n    riOpts = {}\r\n    listValues = {}\r\n    stickyKeys = {}\r\n\r\n\r\n    key = 'fRadius'; keys.append(key)\r\n    values[key] = 1.0\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bUseFaceOfSelNakedEdge'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bRebuildInCrv'; keys.append(key)\r\n    values[key] = True\r\n    names[key] = 'RebuildEdgeCrv'\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Try')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'fTol'; keys.append(key)\r\n    values[key] = max((1.0*sc.doc.ModelAbsoluteTolerance, 1e-6))\r\n    names[key] = 'TargetTol'\r\n    riOpts[key] = ri.Custom.OptionDouble(values[key])\r\n    stickyKeys[key] = '{}({})({})'.format(key, __file__, sc.doc.Name)\r\n\r\n    key = 'bOutputCenterCrv'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bEcho'; keys.append(key)\r\n    values[key] = True\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n    key = 'bDebug'; keys.append(key)\r\n    values[key] = False\r\n    riOpts[key] = ri.Custom.OptionToggle(values[key], 'No', 'Yes')\r\n    stickyKeys[key] = '{}({})'.format(key, __file__)\r\n\r\n\r\n    for key in keys:\r\n        if key not in names:\r\n            names[key] = key[1:]\r\n\r\n\r\n    # Load sticky.\r\n    for key in stickyKeys:\r\n        if stickyKeys[key] in sc.sticky:\r\n            if key in riOpts:\r\n                riOpts[key].CurrentValue = values[key] = sc.sticky[stickyKeys[key]]\r\n            else:\r\n                # For OptionList.\r\n                values[key] = sc.sticky[stickyKeys[key]]\r\n\r\n\r\n    @classmethod\r\n    def addOption(cls, go, key):\r\n\r\n        idxOpt = None\r\n\r\n        if key in cls.riOpts:\r\n            if key[0] == 'b':\r\n                idxOpt = go.AddOptionToggle(\r\n                        cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'f':\r\n                idxOpt = go.AddOptionDouble(\r\n                    cls.names[key], cls.riOpts[key])[0]\r\n            elif key[0] == 'i':\r\n                idxOpt = go.AddOptionInteger(\r\n                    englishName=cls.names[key], intValue=cls.riOpts[key])[0]\r\n        elif key in cls.listValues:\r\n            idxOpt = go.AddOptionList(\r\n                englishOptionName=cls.names[key],\r\n                listValues=cls.listValues[key],\r\n                listCurrentIndex=cls.values[key])\r\n        else:\r\n            print(\"{} is not a valid key in Opts.\".format(key))\r\n\r\n        return idxOpt\r\n\r\n\r\n    @classmethod\r\n    def setValue(cls, key, idxList=None):\r\n\r\n        if key == 'fRadius':\r\n            if abs(cls.riOpts[key].CurrentValue) < 1e-3:\r\n                print(\"Radius input value is too small.\")\r\n                cls.riOpts[key].CurrentValue = cls.values[key]\r\n                return\r\n\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key == 'fTol':\r\n            if cls.riOpts[key].CurrentValue < 0:\r\n                cls.riOpts[key].CurrentValue = cls.riOpts[key].InitialValue\r\n            elif cls.riOpts[key].CurrentValue < 1e-6:\r\n                cls.riOpts[key].CurrentValue = 1e-6\r\n\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n            sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n            return\r\n\r\n        if key in cls.riOpts:\r\n            cls.values[key] = cls.riOpts[key].CurrentValue\r\n        elif key in cls.listValues:\r\n            cls.values[key] = idxList\r\n        else:\r\n            print(\"Why is key, {}, here?  Value was not set or sticky-saved.\".format(key))\r\n            return\r\n\r\n        sc.sticky[cls.stickyKeys[key]] = cls.values[key]\r\n\r\n\r\ndef _addCommonOptions(go):\r\n    idxs_Opt = {}\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    addOption('fRadius')\r\n    addOption('bRebuildInCrv')\r\n    addOption('fTol')\r\n    addOption('bOutputCenterCrv')\r\n    addOption('bEcho')\r\n    addOption('bDebug')\r\n\r\n    return idxs_Opt\r\n\r\n\r\ndef _getInput_Curve():\r\n    \"\"\"\r\n    Get objects with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select curve on face\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Curve\r\n\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Do not clear objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False) # Do not unselect object when an option selected, a number is entered, etc.\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n\r\n    idxs_Opt = {}\r\n\r\n    #bPreselectedObjsChecked = False\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n        addOption('bUseFaceOfSelNakedEdge')\r\n        idxs_Opt.update(_addCommonOptions(go))\r\n\r\n        res = go.Get()\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objref_CrvOnFace = go.Object(0)\r\n            go.Dispose()\r\n\r\n            return objref_CrvOnFace\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fRadius'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef _getInput_Face():\r\n    \"\"\"\r\n    Get objects with optional input.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Select base face\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Surface\r\n\r\n    go.DeselectAllBeforePostSelect = False # So objects won't be deselected on repeats of While loop.\r\n    go.EnableClearObjectsOnEntry(False) # Do not clear objects in go on repeats of While loop.\r\n    go.EnableUnselectObjectsOnExit(False) # Do not unselect object when an option selected, a number is entered, etc.\r\n    \r\n    go.AcceptNumber(True, acceptZero=True)\r\n    \r\n    idxs_Opt = {}\r\n\r\n    bPreselectedObjsChecked = False\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n        idxs_Opt.update(_addCommonOptions(go))\r\n\r\n        res = go.Get()\r\n\r\n        # Use bPreselectedObjsChecked so that only objects before the\r\n        # first call to go.GetMultiple is considered.\r\n        if not bPreselectedObjsChecked and go.ObjectsWerePreselected:\r\n            bPreselectedObjsChecked = True\r\n            go.EnablePreSelect(False, ignoreUnacceptablePreselectedObjects=True)\r\n            continue\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objref_Face = go.Object(0)\r\n\r\n            go.Dispose()\r\n    \r\n            return objref_Face\r\n\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'fRadius'\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                break\r\n\r\n\r\ndef _getInput_Click():\r\n    \"\"\"\r\n    Click to toggle angle and/or direction with optional input.\r\n\r\n    Returns:\r\n        True: To recalculate and reloop\r\n        False: To not recalculate and break out of loop with current output.\r\n        None: To not recalculate and return without output.\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetPoint()\r\n\r\n    go.SetCommandPrompt(\"Left click to flip direction\")\r\n\r\n    go.SetCommandPromptDefault(\"Accept result\")\r\n\r\n    go.AcceptNumber(True, acceptZero=True)\r\n    go.AcceptNothing(True)\r\n\r\n    idxs_Opt = {}\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    key = 'FlipDir'; idxs_Opt[key] = go.AddOption(key)\r\n\r\n    idxs_Opt.update(_addCommonOptions(go))\r\n\r\n    res = go.Get()\r\n\r\n    if res == ri.GetResult.Cancel:\r\n        go.Dispose()\r\n        return\r\n\r\n    if res == ri.GetResult.Nothing:\r\n        go.Dispose()\r\n        return False\r\n\r\n    if res == ri.GetResult.Point:\r\n        Opts.riOpts['fRadius'].CurrentValue = -Opts.riOpts['fRadius'].CurrentValue\r\n        Opts.setValue('fRadius')\r\n        go.Dispose()\r\n        return True\r\n\r\n    if res == ri.GetResult.Number:\r\n        key = 'fRadius'\r\n        Opts.riOpts[key].CurrentValue = go.Number()\r\n        Opts.setValue(key)\r\n        go.Dispose()\r\n        return True\r\n\r\n    # An option was selected.\r\n\r\n    if go.OptionIndex() == idxs_Opt['FlipDir']:\r\n        Opts.riOpts['fRadius'].CurrentValue = -Opts.riOpts['fRadius'].CurrentValue\r\n        Opts.setValue('fRadius')\r\n        go.Dispose()\r\n        return True\r\n\r\n    for key in idxs_Opt:\r\n        if go.Option().Index == idxs_Opt[key]:\r\n            Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n            break\r\n\r\n    go.Dispose()\r\n    return True\r\n\r\n\r\ndef getInput():\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    go = ri.Custom.GetObject()\r\n\r\n    go.SetCommandPrompt(\"Pick edge near its end for start of extension\")\r\n\r\n    go.GeometryFilter = rd.ObjectType.Curve\r\n\r\n\r\n    def geomFilter_Curve(rdObj, geom, compIdx):\r\n        #print(rdObj, geom, compIdx.ComponentIndexType, compIdx.Index\r\n\r\n        if isinstance(geom, rg.BrepEdge):\r\n            # DuplicateCurve gets the edge as a curve, which may be a subset of the EdgeCurve.\r\n            rgC = geom.DuplicateCurve()\r\n        elif isinstance(geom, rg.Curve):\r\n            rgC = geom\r\n        else:\r\n            return False\r\n\r\n        if rgC.IsPeriodic:\r\n            print(\"Periodic curves are not supported.\")\r\n            return False\r\n\r\n        return True\r\n\r\n\r\n    go.SetCustomGeometryFilter(geomFilter_Curve)\r\n\r\n    go.DisablePreSelect()\r\n\r\n    idxs_Opt = {}\r\n\r\n    def addOption(key): idxs_Opt[key] = Opts.addOption(go, key)\r\n\r\n    while True:\r\n        go.ClearCommandOptions()\r\n\r\n        idxs_Opt.clear()\r\n\r\n        addOption('bSameDegree')\r\n        if not Opts.values['bSameDegree']:\r\n            addOption('iDegree')\r\n        addOption('bEcho')\r\n        addOption('bDebug')\r\n\r\n\r\n        res = go.Get()\r\n\r\n\r\n        if res == ri.GetResult.Cancel:\r\n            go.Dispose()\r\n            return\r\n\r\n        if res == ri.GetResult.Object:\r\n            objref = go.Object(0)\r\n            go.Dispose()\r\n            return objref\r\n\r\n        if res == ri.GetResult.Number:\r\n            key = 'iDegree'\r\n            if go.Number() == Opts.riOpts[key].CurrentValue:\r\n                continue\r\n            Opts.riOpts[key].CurrentValue = go.Number()\r\n            if Opts.riOpts[key].CurrentValue < 1:\r\n                Opts.riOpts[key].CurrentValue = Opts.riOpts[key].InitialValue\r\n            Opts.setValue(key)\r\n            continue\r\n\r\n        # An option was selected.\r\n        for key in idxs_Opt:\r\n            if go.Option().Index == idxs_Opt[key]:\r\n                Opts.setValue(key, go.Option().CurrentListOptionIndex)\r\n                go.ClearCommandOptions()\r\n                break\r\n\r\n\r\ndef _createCenterSpineWithCorrectedEndPts(ns_Loft, nc_TanEdge, bDebug=False):\r\n    \"\"\"\r\n    This method corrects the end points of the center spine so that the ends\r\n    of the pipe match the end points of the tangent curve.\r\n\r\n    Returns: NurbsCurve\r\n    \"\"\"\r\n\r\n\r\n    ns = ns_Loft\r\n\r\n    # When the input curve is not used verbatim, the tangent curve spine is\r\n    # the west isocurve of the loft.\r\n    if nc_TanEdge is None:\r\n        nc_TanEdge = ns.IsoCurve(1, ns.Domain(0).T0)\r\n\r\n    # Center spine is the east isocurve of the loft.\r\n    nc_CenterSpine = ns.IsoCurve(1, ns.Domain(0).T1)\r\n\r\n    nc_CenterSpine_WIP = nc_CenterSpine.DuplicateCurve()\r\n\r\n    #sc.doc.Objects.AddCurve(nc_CenterSpine_WIP)\r\n    #sc.doc.Views.Redraw()\r\n    #return\r\n\r\n    # Extend as necessary, the start end of the center spine to be beyond\r\n    # the closest point projection from the start of the tangent curve.\r\n\r\n    while True:\r\n        sc.escape_test()\r\n        bSuccess, t_C_Start = nc_CenterSpine_WIP.ClosestPoint(nc_TanEdge.PointAtStart)\r\n        if not bSuccess:\r\n            raise Exception(\"ClosestPoint failed.\")\r\n\r\n        pt_C_Start = nc_CenterSpine_WIP.PointAt(t_C_Start)\r\n        dist = pt_C_Start.DistanceTo(nc_CenterSpine_WIP.PointAtStart)\r\n        if bDebug: sEval = \"dist\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        if dist > 1e-6:\r\n            break\r\n\r\n        nc_tmp = nc_CenterSpine_WIP.Extend(-0.001, 1.0)\r\n        nc_CenterSpine_WIP.Dispose()\r\n        nc_CenterSpine_WIP = nc_tmp\r\n\r\n\r\n    # Do the same at the ends (T1) of the curves.\r\n\r\n    while True:\r\n        sc.escape_test()\r\n        bSuccess, t_C_End = nc_CenterSpine_WIP.ClosestPoint(nc_TanEdge.PointAtEnd)\r\n        if not bSuccess:\r\n            raise Exception(\"ClosestPoint failed.\")\r\n\r\n        pt_C_End = nc_CenterSpine_WIP.PointAt(t_C_End)\r\n        dist = pt_C_End.DistanceTo(nc_CenterSpine_WIP.PointAtEnd)\r\n        if bDebug: sEval = \"dist\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        if dist > 1e-6:\r\n            break\r\n\r\n        nc_tmp = nc_CenterSpine_WIP.Extend(0, 1.001)\r\n        nc_CenterSpine_WIP.Dispose()\r\n        nc_CenterSpine_WIP = nc_tmp\r\n\r\n\r\n    nc_tmp = nc_CenterSpine_WIP.Trim(t_C_Start, t_C_End)\r\n    nc_CenterSpine_WIP.Dispose()\r\n\r\n    return nc_tmp\r\n\r\n\r\nclass DrawConduit(Rhino.Display.DisplayConduit):\r\n\r\n    def __init__(self):\r\n        self.crvs = []\r\n        self.breps = []\r\n        displayMode = Rhino.RhinoDoc.ActiveDoc.Views.ActiveView.ActiveViewport.DisplayMode\r\n        self.crv_thk = displayMode.DisplayAttributes.CurveThickness + 1\r\n\r\n    def CalculateBoundingBox(self, calculateBoundingBoxEventArgs):\r\n        for crv in self.crvs:\r\n            bbox = crv.GetBoundingBox(accurate=False)\r\n            calculateBoundingBoxEventArgs.IncludeBoundingBox(bbox)\r\n        for brep in self.breps:\r\n            bbox = brep.GetBoundingBox(accurate=False)\r\n            calculateBoundingBoxEventArgs.IncludeBoundingBox(bbox)\r\n\r\n    def PreDrawObjects(self, drawEventArgs):\r\n\r\n        color = sc.doc.Layers.CurrentLayer.Color\r\n\r\n        for crv in self.crvs:\r\n            drawEventArgs.Display.DrawCurve(\r\n                curve=crv,\r\n                color=color,\r\n                thickness=self.crv_thk)\r\n\r\n        for brep in self.breps:\r\n\r\n            displayMode = Rhino.RhinoDoc.ActiveDoc.Views.ActiveView.ActiveViewport.DisplayMode\r\n            da = displayMode.DisplayAttributes\r\n            if da.ShadingEnabled:\r\n                drawEventArgs.Display.DrawBrepShaded(\r\n                    brep=brep,\r\n                    material=Rhino.Display.DisplayMaterial(diffuse=color))\r\n            drawEventArgs.Display.DrawBrepWires(\r\n                brep=brep,\r\n                color=color,\r\n                wireDensity=1)\r\n\r\n\r\ndef _createGeometryInteractively():\r\n    \"\"\"\r\n    \"\"\"\r\n\r\n    objref_CrvToOffset = _getInput_Curve()\r\n    if objref_CrvToOffset is None: return\r\n\r\n    bUseFaceOfSelNakedEdge = Opts.values['bUseFaceOfSelNakedEdge']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n    rgC_In, t_atPickedPt = objref_CrvToOffset.CurveParameter()\r\n    if bDebug: sEval = \"rgC_In\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n    if not rgC_In: return\r\n\r\n\r\n    if isinstance(rgC_In, rg.BrepEdge) and bUseFaceOfSelNakedEdge:\r\n        rgE_In = rgC_In\r\n        if rgE_In.Valence == rg.EdgeAdjacency.Naked:\r\n            idxF = objref_CrvToOffset.Edge().AdjacentFaces()[0]\r\n            rgF_In = rgE_In.Brep.Faces[idxF]\r\n        else:\r\n            rgT_In = objref_CrvToOffset.Trim()\r\n            if bDebug: sEval = \"rgT_In.TrimIndex\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            rgF_In = rgT_In.Face\r\n    else:\r\n        sc.doc.Objects.UnselectAll()\r\n        objref_Face = _getInput_Face()\r\n        if objref_Face is None: return\r\n\r\n        rgF_In = objref_Face.Face()\r\n\r\n    gBrep = objref_CrvToOffset.ObjectId\r\n    sc.doc.Objects.UnselectAll()\r\n\r\n\r\n    Rhino.RhinoApp.SetCommandPrompt(\"Working ...\")\r\n\r\n    fRadius = Opts.values['fRadius']\r\n    bRebuildInCrv = Opts.values['bRebuildInCrv']\r\n    fTol = Opts.values['fTol']\r\n    bEcho = Opts.values['bEcho']\r\n    bDebug = Opts.values['bDebug']\r\n\r\n\r\n    if isinstance(rgC_In, rg.PolyCurve):\r\n        sEval = \"rgC_In.RemoveNesting()\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n        #rgC_In.RemoveNesting()\r\n\r\n    rgC_In_TrimmedToFace = spb_OffsetNormal.crvWithSpansCompletelyOnFace(\r\n        rgC_In,\r\n        rgF_In,\r\n        t_atPickedPt,\r\n        fTol=1.0*fTol,\r\n        bDebug=bDebug)\r\n    if rgC_In_TrimmedToFace is None: return\r\n\r\n    if (\r\n        bDebug and\r\n        isinstance(rgC_In, rg.NurbsCurve) and\r\n        isinstance(rgC_In_TrimmedToFace, rg.NurbsCurve)\r\n    ):\r\n        sEval = \"rgC_In.EpsilonEquals(rgC_In_TrimmedToFace, 1e-6)\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n    if rgC_In_TrimmedToFace.IsClosed and fAngle_End_Deg:\r\n        fAngle_End_Deg = Opts.values['fAngle_End_Deg'] = sc.sticky[Opts.stickyKeys['fAngle_End_Deg']] = None\r\n        bVariableAngle = Opts.values['bVariableAngle'] = sc.sticky[Opts.stickyKeys['bVariableAngle']] = False\r\n\r\n\r\n    sk_conduit = 'conduit({})'.format(__file__) # StickyKey\r\n    if (sk_conduit in sc.sticky) and sc.sticky[sk_conduit]:\r\n        conduit = sc.sticky[sk_conduit]\r\n        conduit.Enabled = False\r\n    else:\r\n        conduit = DrawConduit()\r\n        sc.sticky[sk_conduit] = conduit\r\n\r\n    # For debugging.  Erase me.\r\n    conduit = None\r\n    conduit = DrawConduit()\r\n    sc.sticky[sk_conduit] = conduit\r\n\r\n\r\n\r\n    fSamplingDist = 100.0*sc.doc.ModelAbsoluteTolerance\r\n    while True:\r\n        ncs_toOffset, fDev_fromRebuilds = spb_OffsetNormal.prepareCrvToOffset(\r\n            rgC_In_TrimmedToFace,\r\n            bExplodePolyCrv=True,\r\n            bRebuild=bRebuildInCrv,\r\n            bSplitAtNonG2Knots=True,\r\n            bMakeDeformable=False,\r\n            fTol=0.1*fTol,\r\n            bDebug=bDebug)\r\n\r\n        if bDebug:\r\n            sEval = \"fDev_fromRebuilds\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n\r\n        def areCurvesDifferent(cA, ncsB):\r\n            if len(ncsB) > 1:\r\n                True\r\n\r\n            ncA = cA.ToNurbsCurve()\r\n            ncB = ncsB[0]\r\n\r\n            epsEquals = ncA.EpsilonEquals(ncB, epsilon=1e-6)\r\n\r\n            ncA.Dispose()\r\n\r\n            return not epsEquals\r\n\r\n\r\n        if areCurvesDifferent(rgC_In_TrimmedToFace, ncs_toOffset):\r\n            print(\"Due to preprocessing, curve to offset is different than the input curve.\")\r\n        else:\r\n            print(\"Curve on surface will be used verbatim as the curve to offset to make the center spine.\")\r\n\r\n\r\n\r\n        ncs_CenterSpines = []\r\n        rgBs_Pipes = []\r\n        ncs_Centers = []\r\n\r\n\r\n        bFaceNormalIsReversedToSrf = rgF_In.OrientationIsReversed\r\n\r\n        if bDebug:\r\n            sEval = \"fRadius>0.0\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            sEval = \"bFaceNormalIsReversedToSrf\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n\r\n        for nc_toOffset in ncs_toOffset:\r\n\r\n            nc_toOffset.Domain = rg.Interval(0.0, 1.0)\r\n\r\n            if bDebug:\r\n                sEval = \"nc_toOffset.Degree\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n                sEval = \"nc_toOffset.SpanCount\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n                sEval = \"nc_toOffset.Domain\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n            rc = spb_OffsetNormal.createOffsetCurve(\r\n                rgCrv_In=nc_toOffset,\r\n                rgSrf=rgF_In,\r\n                bLoose=False,\r\n                bAlignEndDirs=False,\r\n                fDistance=fRadius,\r\n                fTol=fTol-fDev_fromRebuilds,\r\n                fSamplingDist=fSamplingDist,\r\n                bDebug=bDebug)\r\n            if rc is None:\r\n                if bEcho: print(\"No solution found.\")\r\n                return\r\n\r\n            nc_Offset, dev_Offset = rc\r\n\r\n            if bDebug: sEval = \"fTol-fDev_fromRebuilds-dev_Offset\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n            if fTol-fDev_fromRebuilds-dev_Offset < 0.0:\r\n                raise ValueError(\"Curve(s) deviate more than the allotted tolerance.\")\r\n\r\n            #sc.doc.Objects.AddCurve(nc_Offset); sc.doc.Views.Redraw(); return\r\n\r\n            if bDebug:\r\n                sEval = \"nc_Offset.Degree\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n                sEval = \"nc_Offset.SpanCount\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n                sEval = \"nc_Offset.Domain\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n            nc_Offset.Domain = rg.Interval(0.0, 1.0)\r\n\r\n            ncs_CenterSpines.append(nc_Offset)\r\n\r\n            rgBs_Loft = rg.Brep.CreateFromLoft(\r\n                [nc_toOffset, nc_Offset],\r\n                start=rg.Point3d.Unset,\r\n                end=rg.Point3d.Unset,\r\n                loftType=rg.LoftType.Straight,\r\n                closed=nc_Offset.IsClosed)\r\n            if not rgBs_Loft:\r\n                continue\r\n            if len(rgBs_Loft) > 1:\r\n                raise ValueError(\"{} breps in loft.  Should only be 1.\".format(len(rgB_Loft)))\r\n\r\n            rgB_Loft = rgBs_Loft[0]\r\n\r\n            #sc.doc.Objects.AddBrep(rgB_Loft)\r\n            #conduit.Enabled = False\r\n            #sc.doc.Views.Redraw()\r\n            #return\r\n\r\n            def refreshBrepForNormalizedDomains(brep_In):\r\n                ns = brep_In.Surfaces[0]\r\n                ns.SetDomain(0, rg.Interval(0.0, 1.0))\r\n                ns.SetDomain(1, rg.Interval(0.0, 1.0))\r\n                brep_Out = ns.ToBrep()\r\n                brep_In.Dispose()\r\n                return brep_Out\r\n\r\n            rgB_Loft = refreshBrepForNormalizedDomains(rgB_Loft)\r\n            # 2 Curves3D and their BrepEdges will have domains of [-1, 0].  Don't know why yet.\r\n\r\n            def reportBrepDomains(brep):\r\n                ns = brep.Surfaces[0]\r\n                ns.SetDomain(0, rg.Interval(0.0, 1.0))\r\n                ns.SetDomain(1, rg.Interval(0.0, 1.0))\r\n                brep_Out = ns.ToBrep()\r\n                for ss in \"brep.Curves2D\", \"brep.Curves3D\", \"brep.Trims\", \"brep.Edges\":\r\n                    print(\"{} domains:\".format(ss))\r\n                    cs = eval(ss)\r\n                    for i in range(eval(\"{}.Count\".format(ss))):\r\n                        sEval = \"cs[{}].Domain\".format(i); print(\"{}: {}\".format(i, eval(sEval)))\r\n\r\n            #reportBrepDomains(rgB_Loft)\r\n\r\n            #sc.doc.Objects.AddCurve(nc_toOffset)\r\n            #sc.doc.Objects.AddCurve(nc_Offset)\r\n            #sc.doc.Objects.AddBrep(rgB_Loft)\r\n            #conduit.Enabled = False\r\n            #1/0\r\n\r\n            ns_Loft = rgB_Loft.Surfaces[0]\r\n            if bDebug:\r\n                sEval = \"ns_Loft.Domain(0)\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n                sEval = \"ns_Loft.Domain(1)\"; print(\"{}: {}\".format(sEval, eval(sEval)))\r\n\r\n            nc_Center = _createCenterSpineWithCorrectedEndPts(\r\n                ns_Loft=ns_Loft,\r\n                nc_TanEdge=None if bRebuildInCrv else nc_toOffset,\r\n                bDebug=bDebug)\r\n            if not nc_Center: return\r\n            ncs_Centers.append(nc_Center)\r\n\r\n            rgB_Loft.Dispose()\r\n\r\n            rgBs_Pipes_Res = rg.Brep.CreatePipe(\r\n                rail=nc_Center,\r\n                radius=abs(fRadius),\r\n                localBlending=False,\r\n                cap=rg.PipeCapMode.None,\r\n                fitRail=False,\r\n                absoluteTolerance=fTol-fDev_fromRebuilds-dev_Offset,\r\n                angleToleranceRadians=sc.doc.ModelAngleToleranceRadians)\r\n            if len(rgBs_Pipes_Res) == 0:\r\n                raise Exception(\"CreatePipe returned None.\")\r\n            if len(rgBs_Pipes_Res) > 1:\r\n                raise Exception(\"CreatePipe returned {} breps.\".format(len(rgBs_Pipes_Res)))\r\n\r\n            rgBs_Pipes.append(rgBs_Pipes_Res[0])\r\n\r\n        conduit.curves = ncs_Centers\r\n        conduit.breps = rgBs_Pipes\r\n\r\n        if bDebug:\r\n            conduit.crvs = ncs_CenterSpines\r\n\r\n        conduit.Enabled = True\r\n\r\n        sc.doc.Views.Redraw()\r\n\r\n        if bEcho:\r\n            sOut = []\r\n            if len(ncs_CenterSpines) > 1: sOut.append(\"{} curves\".format(len(ncs_CenterSpines)))\r\n            if sOut:\r\n                print(\"Calculated {}.\".format(\", \".join(sOut)))\r\n\r\n\r\n        rc = _getInput_Click()\r\n\r\n        conduit.Enabled = False\r\n\r\n        if rc is None:\r\n            for _ in ncs_CenterSpines: _.Dispose()\r\n            for _ in rgBs_Pipes: _.Dispose()\r\n            return\r\n\r\n        if not rc:\r\n\r\n            if bDebug:\r\n                gs = [sc.doc.Objects.AddCurve(nc) for nc in ncs_toOffset]\r\n                [sc.doc.Objects.AddCurve(nc) for nc in ncs_CenterSpines]\r\n                [sc.doc.Objects.AddBrep(brep) for brep in rgBs_Pipes]\r\n                [sc.doc.Objects.AddCurve(nc) for ncs in ncs_Centers for nc in ncs]\r\n            else:\r\n                #for _ in ncs_toOffset: _.Dispose()\r\n                for _ in ncs_CenterSpines: _.Dispose()\r\n\r\n            return rgBs_Pipes, ncs_Centers\r\n\r\n        for _ in ncs_CenterSpines: _.Dispose()\r\n\r\n\r\n        for _ in rgBs_Pipes: _.Dispose()\r\n\r\n\r\n        fRadius = Opts.values['fRadius']\r\n        bRebuildInCrv = Opts.values['bRebuildInCrv']\r\n        fTol = Opts.values['fTol']\r\n        bEcho = Opts.values['bEcho']\r\n        bDebug = Opts.values['bDebug']\r\n\r\n\r\ndef main():\r\n\r\n    while True:\r\n        rc = _createGeometryInteractively()\r\n        if rc is None: return\r\n\r\n        (\r\n            rgBs_Pipes,\r\n            ncs_CenterSpines,\r\n            ) = rc\r\n\r\n        bOutputCenterCrv = Opts.values['bOutputCenterCrv']\r\n        bEcho = Opts.values['bEcho']\r\n        bDebug = Opts.values['bDebug']\r\n\r\n        for rgB in rgBs_Pipes:\r\n            sc.doc.Objects.AddBrep(rgB)\r\n\r\n        if bOutputCenterCrv:\r\n            for nc in ncs_CenterSpines:\r\n                sc.doc.Objects.AddCurve(nc)\r\n        else:\r\n            for nc in ncs_CenterSpines: nc.Dispose()\r\n\r\n        sc.doc.Objects.UnselectAll()\r\n\r\n        sc.doc.Views.Redraw()\r\n\r\n\r\nif __name__ == '__main__': main()",
  "language": "python",
  "imports": [
    "Rhino",
    "Rhino.Geometry",
    "scriptcontext"
  ],
  "has_docstring": true
}