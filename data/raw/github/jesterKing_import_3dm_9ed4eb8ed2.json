{
  "source_url": "https://github.com/jesterKing/import_3dm/blob/b3c680c3fe049bae8e421fac9da7f13c6c9cd927/import_3dm/converters/instances.py",
  "repo": "jesterKing/import_3dm",
  "repo_stars": 372,
  "repo_description": "Blender importer script for Rhinoceros 3D files",
  "license": "MIT",
  "filepath": "import_3dm/converters/instances.py",
  "instruction": "MIT License",
  "code": "# MIT License\n\n# Copyright (c) 2018-2024 Nathan Letwory, Joel Putnam, Tom Svilans, Lukas Fertig\n\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\nimport bpy\nimport rhino3dm as r3d\nfrom mathutils import Matrix, Vector\nfrom math import sqrt\nfrom . import utils\n\n\n#TODO\n#tag collections and references with guids\n#test w/ more complex blocks and empty blocks\n#proper exception handling\n\n\ndef handle_instance_definitions(context, model, toplayer, layername):\n    \"\"\"\n    Import instance definitions from rhino model as empty collections. These\n    will later be populated to contain actual geometry.\n    \"\"\"\n\n    # TODO: here we need to get instance name and material used by this instance\n    # meaning we need to also extrapolate either layer material or by parent\n    # material.\n\n    #\n\n    if not layername in context.blend_data.collections:\n            instance_col = context.blend_data.collections.new(name=layername)\n            instance_col.hide_render = True\n            instance_col.hide_viewport = True\n            toplayer.children.link(instance_col)\n\n    for idef in model.InstanceDefinitions:\n        tags = utils.create_tag_dict(idef.Id, idef.Name, None, None, True)\n        idef_col=utils.get_or_create_iddata(context.blend_data.collections, tags, None )\n\n        try:\n            instance_col.children.link(idef_col)\n        except Exception:\n            pass\n\ndef _duplicate_collection(context : bpy.context, collection : bpy.types.Collection, newname : str):\n    new_collection = bpy.context.blend_data.collections.new(name=newname)\n    def _recurse_duplicate_collection(collection : bpy.types.Collection):\n        for obj in collection.children:\n            if type(obj.type) == bpy.types.Collection:\n                pass\n            else:\n                new_obj = context.blend_data.objects.new(name=obj.name, object_data=obj.data)\n                new_collection.objects.link(new_obj)\n        for child in collection.children:\n            new_child = bpy.context.blend_data.collections.new(name=child.name)\n            new_collection.children.link(new_child)\n            _recurse_duplicate_collection(child,new_child)\n\ndef import_instance_reference(context : bpy.context, ob : r3d.File3dmObject, iref : bpy.types.Object, name : str, scale : float, options):\n    # To be able to support ByParent material we need to add actual objects\n    # instead of collection instances. That will allow us to add material slots\n    # to instances and set them to 'OBJECT', which allows us to essentially\n    # 'override' the material for the original mesh data\n    tags = utils.create_tag_dict(ob.Geometry.ParentIdefId, \"\")\n    iref.instance_type='COLLECTION'\n    iref.instance_collection = utils.get_or_create_iddata(context.blend_data.collections, tags, None)\n    #instance_definition = utils.get_or_create_iddata(context.blend_data.collections, tags, None)\n    #iref.data = instance_definition.data\n    xform=list(ob.Geometry.Xform.ToFloatArray(1))\n    xform=[xform[0:4],xform[4:8], xform[8:12], xform[12:16]]\n    xform[0][3]*=scale\n    xform[1][3]*=scale\n    xform[2][3]*=scale\n    iref.matrix_world = Matrix(xform)\n\n\ndef populate_instance_definitions(context, model, toplayer, layername, options, scale):\n    import_as_grid = options.get(\"import_instances_grid_layout\",False)\n\n    if import_as_grid:\n        count = 0\n        columns = int(sqrt(len(model.InstanceDefinitions)))\n        grid = options.get(\"import_instances_grid\",False) *scale\n\n    #for every instance definition fish out the instance definition objects and link them to their parent\n    for idef in model.InstanceDefinitions:\n        tags = utils.create_tag_dict(idef.Id, idef.Name, None, None, True)\n        parent=utils.get_or_create_iddata(context.blend_data.collections, tags, None)\n        objectids=idef.GetObjectIds()\n\n        if import_as_grid:\n            #calculate position offset to lay out block definitions in xy plane\n            offset = Vector((count%columns * grid, (count-count%columns)/columns * grid, 0 ))\n            parent.instance_offset = offset #this sets the offset for the collection instances (read: resets the origin)\n            count +=1\n\n        for ob in context.blend_data.objects:\n            for guid in objectids:\n                if ob.get('rhid',None) == str(guid):\n                    try:\n                        parent.objects.link(ob)\n                        if import_as_grid:\n                            ob.location += offset #apply the previously calculated offset to all instance definition objects\n                    except Exception:\n                        pass\n",
  "language": "python",
  "imports": [
    "rhino3dm"
  ],
  "has_docstring": true
}